<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤独狂饮</title>
  <subtitle>只要有百分之一的梦想，就要付出百分之百的努力。努力不一定成功，但是不努力就一定不会成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gdky005.com/"/>
  <updated>2016-06-20T10:17:59.000Z</updated>
  <id>http://gdky005.com/</id>
  
  <author>
    <name>gdky005</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 volley 切换到 OkHttp 遇到的坑</title>
    <link href="http://gdky005.com/2016/06/20/%E4%BB%8E-volley-%E5%88%87%E6%8D%A2%E5%88%B0-OkHttp-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://gdky005.com/2016/06/20/从-volley-切换到-OkHttp-遇到的坑/</id>
    <published>2016-06-20T10:17:30.000Z</published>
    <updated>2016-06-20T10:17:59.000Z</updated>
    
    <content type="html">&lt;p&gt;这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。&lt;/p&gt;
&lt;p&gt;之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.&lt;/p&gt;
&lt;h3 id=&quot;代理异常？&quot;&gt;&lt;a href=&quot;#代理异常？&quot; class=&quot;headerlink&quot; title=&quot;代理异常？&quot;&gt;&lt;/a&gt;代理异常？&lt;/h3&gt;&lt;p&gt;切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。&lt;/p&gt;
&lt;p&gt;根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 &lt;/p&gt;
&lt;p&gt;之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？&lt;/p&gt;
&lt;p&gt;经过对比后发现：原来是 之前写 volley 的时候是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HttpURLConnection connection;
    if (&amp;quot;https&amp;quot;.equals(url.getProtocol())) {
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                InetSocketAddress
                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));
        connection = (HttpURLConnection) url
                .openConnection(proxy);
        connection.addRequestProperty(&amp;quot;Proxy-Authorization&amp;quot;,
                &amp;quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&amp;quot;);
    } else {
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                InetSocketAddress
                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));
        connection = (HttpURLConnection) url
                .openConnection(proxy);
        connection.addRequestProperty(&amp;quot;Authorization&amp;quot;,
                &amp;quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&amp;quot;);
    }
    connection.addRequestProperty(&amp;quot;Proxy-Connection&amp;quot;, &amp;quot;Keep-Alive&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。&lt;/p&gt;
&lt;p&gt;但是在 okhttp 里面貌似是不需要区分的。只需要这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
     * 设置联通流量 代理功能
     * @param builder
     */
    private void setUnicomProxy(OkHttpClient.Builder builder) {
        //添加联通代理功能
        if (TrafficUtil.getUnicomProxyAvailable()) {
            Authenticator proxyAuthenticator = new Authenticator() {
                @Override
                public okhttp3.Request authenticate(Route route, Response response) throws IOException {
                    return response.request().newBuilder().header(&amp;quot;Proxy-Authorization&amp;quot;, &amp;quot;Basic &amp;quot; +
                            &amp;quot;MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&amp;quot;).header(&amp;quot;Proxy-Connection&amp;quot;,
                            &amp;quot;Keep-Alive&amp;quot;).build();
                }
            };

            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,
                    FLOWPACKAGETCPPORT)));
            builder.proxyAuthenticator(proxyAuthenticator);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以了。&lt;br&gt;&lt;code&gt;FLOWPACKAGEHOST -&amp;gt; test.proxy.1111.com (这是域名)&lt;/code&gt;&lt;br&gt;&lt;code&gt;FLOWPACKAGETCPPORT -&amp;gt; 8143&lt;/code&gt;&lt;br&gt;这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;SSL-STL证书-出错？&quot;&gt;&lt;a href=&quot;#SSL-STL证书-出错？&quot; class=&quot;headerlink&quot; title=&quot;SSL/STL证书 出错？&quot;&gt;&lt;/a&gt;SSL/STL证书 出错？&lt;/h3&gt;&lt;p&gt;这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：&lt;br&gt;     @NonNull&lt;br&gt;        private SSLContext getSslContext(InputStream… certificates) {&lt;br&gt;            SSLContext sslContext = null;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        try {
            CertificateFactory certificateFactory = CertificateFactory.getInstance(&amp;quot;X.509&amp;quot;);
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null);
            int index = 0;
            for (InputStream certificate : certificates) {
                String certificateAlias = Integer.toString(index++);
                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate
                        (certificate));
                try {
                    if (certificate != null)
                        certificate.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            sslContext = SSLContext.getInstance(&amp;quot;TLS&amp;quot;);

            TrustManagerFactory trustManagerFactory =
                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

            trustManagerFactory.init(keyStore);
            sslContext.init(null, trustManagerFactory.getTrustManagers(),
                    new SecureRandom());

        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        } catch (Exception e){
            e.printStackTrace();
        }   finally {
        }

        return sslContext;
    }

/**
     * 启用 OkHttps 域名校验功能
     * @param builder
     */
    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {
        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R
                .raw.kl_magic));

        if (sslContext != null) {
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
                    return hostnameVerifier.verify(&amp;quot;xxx.com&amp;quot;, session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)
                }
            });
            builder.sslSocketFactory(sslContext.getSocketFactory());
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这句是非常重要的：&lt;br&gt;&lt;code&gt;hostnameVerifier.verify(&amp;quot;xxx.com&amp;quot;, session);&lt;/code&gt;主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。&lt;/p&gt;
&lt;p&gt;之前尝试过使用 使用&lt;br&gt;    builder.hostnameVerifier(new AllowAllHostnameVerifier());&lt;/p&gt;
&lt;p&gt;这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。&lt;/p&gt;
&lt;h3 id=&quot;post-参数不能为空？&quot;&gt;&lt;a href=&quot;#post-参数不能为空？&quot; class=&quot;headerlink&quot; title=&quot;post 参数不能为空？&quot;&gt;&lt;/a&gt;post 参数不能为空？&lt;/h3&gt;&lt;p&gt;这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).&lt;/p&gt;
&lt;p&gt;但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 &lt;a href=&quot;https://github.com/square/okhttp/issues/751&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;okhttp issue&lt;/a&gt; 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。&lt;/p&gt;
&lt;p&gt;具体参考这个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void addRequest(int method, final Map&amp;lt;String, String&amp;gt; params, final String baseUrl,
                           final TypeReference&amp;lt;? extends BaseResponse&amp;gt; type, final JsonResultCallback callback) {
            ......
          if (params.size() == 0 &amp;amp;&amp;amp; method == Request.Method.POST)
            params.put(&amp;quot;temp&amp;quot;, &amp;quot;temp&amp;quot;); //解决 method POST must have a request body.;
            ......
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个问题解决后，基本就可以放心使用了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。&lt;/p&gt;
&lt;p&gt;之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案：
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>分享Java Collection 的一张图</title>
    <link href="http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/"/>
    <id>http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/</id>
    <published>2016-06-20T09:09:48.000Z</published>
    <updated>2016-06-20T10:18:56.000Z</updated>
    
    <content type="html">&lt;p&gt;在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等&lt;/p&gt;
&lt;p&gt;我们可以看出他们之间的关系以及差别。&lt;/p&gt;
&lt;p&gt;例如：HashMap, HastTable,  Vector 和 LinkedList等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png&quot; alt=&quot;Java Collection Cheat Sheet&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等&lt;/p&gt;
&lt;p&gt;我们可以看出他们之间的关系以及差别。&lt;/p&gt;
&lt;p&gt;例如：HashMap,
    
    </summary>
    
      <category term="Java" scheme="http://gdky005.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://gdky005.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Okio 简单处理I/O操作</title>
    <link href="http://gdky005.com/2016/06/20/Okio-%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86I-O%E6%93%8D%E4%BD%9C/"/>
    <id>http://gdky005.com/2016/06/20/Okio-简单处理I-O操作/</id>
    <published>2016-06-20T08:59:24.000Z</published>
    <updated>2016-06-20T10:18:47.000Z</updated>
    
    <content type="html">&lt;p&gt;Android 善用Okio简化处理I/O操作&lt;br&gt;Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile &amp;apos;com.squareup.okio:okio:1.6.0&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ohio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。&lt;/p&gt;
&lt;p&gt;而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BufferedSink writeLong(long v) throws IOException {
    if (this.closed) {
        throw new IllegalStateException(&amp;quot;closed&amp;quot;);
    } else {
        this.buffer.writeLong(v);
        return this.emitCompleteSegments();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BufferedSink emitCompleteSegments() throws IOException {
        if(this.closed) {
            throw new IllegalStateException(&amp;quot;closed&amp;quot;);
        } else {
            long byteCount = this.buffer.completeSegmentByteCount();
            if(byteCount &amp;gt; 0L) {
                this.sink.write(this.buffer, byteCount);
            }
            return this;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两个实现类的内部的所有方法都是类似的，这里不一一展开。&lt;br&gt;而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final class SegmentPool {
    static final long MAX_SIZE = 65536L;
    static Segment next;
    static long byteCount;

    private SegmentPool() {
    }

    static Segment take() {
        Class var0 = SegmentPool.class;

        synchronized(SegmentPool.class) {
            if(next != null) {
                Segment result = next;
                next = result.next;
                result.next = null;
                byteCount -= 2048L;
                return result;
            }
        }
        return new Segment();
    }

    static void recycle(Segment segment) {
        if(segment.next == null &amp;amp;&amp;amp; segment.prev == null) {
            if(!segment.shared) {
                Class var1 = SegmentPool.class;

                synchronized(SegmentPool.class) {
                    if(byteCount + 2048L &amp;lt;= 65536L) {
                        byteCount += 2048L;
                        segment.next = next;
                        segment.pos = segment.limit = 0;
                        next = segment;
                    }
                }
            }
        } else {
            throw new IllegalArgumentException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。&lt;/p&gt;
&lt;p&gt;而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Okio.buffer(sink)
Okio.buffer(source)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Okio.sink(new File(&amp;quot;***&amp;quot;));
Okio.sink(new FileOutputStream(new File(&amp;quot;***&amp;quot;)));
Okio.sink(new Socket(&amp;quot;***&amp;quot;,8888));

Okio.source(new File(&amp;quot;***&amp;quot;));
Okio.source(new FileInputStream(new File(&amp;quot;***&amp;quot;)));
Okio.source(new Socket(&amp;quot;****&amp;quot;,8888));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Source source = null;
        BufferedSource bufferedSource = null;

        try {
            File file = new File(&amp;quot;resources/test.txt&amp;quot;);
            source = Okio.source(file);
            bufferedSource = Okio.buffer(source);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }

        Sink sink = null;
        BufferedSink bufferedSink = null;
        try {
            File dest = new File(&amp;quot;resources/dest.txt&amp;quot;);
            sink = Okio.sink(dest);
            bufferedSink = Okio.buffer(sink);
            bufferedSink.writeUtf8(&amp;quot;11111111111&amp;quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Sink sink = null;
        BufferedSink bufferedSink = null;
        GzipSink gzipSink=null;

        try {
            File dest = new File(&amp;quot;resources/gzip.txt&amp;quot;);
            sink = Okio.sink(dest);
            gzipSink=new GzipSink(sink);
            bufferedSink = Okio.buffer(gzipSink);
            bufferedSink.writeUtf8(&amp;quot;android vs ios&amp;quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }

        Source source = null;
        BufferedSource bufferedSource = null;
        GzipSource gzipSource=null;

        try {
            File file = new File(&amp;quot;resources/gzip.txt&amp;quot;);
            source = Okio.source(file);
            gzipSource=new GzipSource(source);
            bufferedSource = Okio.buffer(gzipSource);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。&lt;br&gt;对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class GzipUtil {
        /**
         * GZIP压缩
         *
         * @param data
         * @return
         * @throws Exception
         */
        public static byte[] gzip(byte[] data) throws Exception {
            if (data == null || data.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            GZIPOutputStream zos;
            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));
            byte[] buf = new byte[512];
            int len;

            try {
                zos = new GZIPOutputStream(out);
                while ((len = bis.read(buf)) != -1) {
                    zos.write(buf, 0, len);
                    zos.flush();
                }
                bis.close();
                zos.close();
                return out.toByteArray();
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e2) {
                    }
                }
            }
        }

        /**
         * Gzip解压缩
         *
         * @param b
         * @return
         */
        public static byte[] unGzip(byte[] b) {
            if (b == null || b.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(b);

            try {
                GZIPInputStream gunzip = new GZIPInputStream(in);
                byte[] buffer = new byte[256];
                int n;
                while ((n = gunzip.read(buffer)) &amp;gt;= 0) {
                    out.write(buffer, 0, n);
                }
                return out.toByteArray();
            } catch (IOException e) {
                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), &amp;quot;uncompress error&amp;quot;, e);
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                } catch (Exception e2) {
                }
            }
            return null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。&lt;/p&gt;
&lt;p&gt;在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android 善用Okio简化处理I/O操作&lt;br&gt;Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便
    
    </summary>
    
      <category term="okio" scheme="http://gdky005.com/categories/okio/"/>
    
    
      <category term="okio" scheme="http://gdky005.com/tags/okio/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp3 源码分析【缓存策略】</title>
    <link href="http://gdky005.com/2016/06/20/OkHttp3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/OkHttp3-源码分析【缓存策略】/</id>
    <published>2016-06-20T08:35:10.000Z</published>
    <updated>2016-06-20T09:06:02.000Z</updated>
    
    <content type="html">&lt;p&gt;本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇&lt;/p&gt;
&lt;h3 id=&quot;Http-缓存基础知识&quot;&gt;&lt;a href=&quot;#Http-缓存基础知识&quot; class=&quot;headerlink&quot; title=&quot;Http 缓存基础知识&quot;&gt;&lt;/a&gt;Http 缓存基础知识&lt;/h3&gt;&lt;p&gt;分析源目前，我们先回顾一下 Http 的缓存 Header 的含义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Expires&lt;br&gt;表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存&lt;br&gt; Expires: Thu, 12 Jan 2017 11:01:33 GMT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cache-Control&lt;br&gt;相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。&lt;/p&gt;
&lt;p&gt; Cache-Control: max-age=31536000, public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修订文件名（Reving Filenames）&lt;br&gt;如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery&lt;br&gt; upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;条件 get 请求 （Conditional GET Requests） 与 304&lt;br&gt;如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请求的方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified-Date:&lt;br&gt;  Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端再次发送时，通过发送&lt;br&gt;    If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT&lt;/p&gt;
&lt;p&gt;交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETag&lt;br&gt;ETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了&lt;br&gt;  ETag: “5694c7ef-24dc”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端再次请求时，通过发送&lt;br&gt;    If-None-Match:”5694c7ef-24dc”&lt;/p&gt;
&lt;p&gt;交给服务器进行判断，如果还能使用缓存，服务器就返回 304&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;其他标签&lt;ul&gt;
&lt;li&gt;no-cache/no-store: 不使用缓存&lt;ul&gt;
&lt;li&gt;only-if-cached: 只使用缓存&lt;/li&gt;
&lt;li&gt;Date:The date and time that the message was sent&lt;/li&gt;
&lt;li&gt;Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;“only-if-cached”标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。&lt;br&gt;全部的标签，可以到&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_header_fields&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里看&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h3&gt;&lt;p&gt;OkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总体请求流程分析&lt;br&gt;CacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出&lt;br&gt;Input（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Request:&lt;br&gt;开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。&lt;/p&gt;
&lt;p&gt;cacheCandildate:&lt;br&gt;也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.&lt;/p&gt;
&lt;p&gt;当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;CacheStrategy 的加工过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CacheStrategy 使用 Factory模式进行构造，参数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InternalCache responseCache = Internal.instance.internalCache(client);
//cacheCandidate从disklurcache中获取
//request的url被md5序列化为key,进行缓存查询
Response cacheCandidate = responseCache != null ? responseCache.get(request) : null;
//请求与缓存
factory = new CacheStrategy.Factory(now, request, cacheCandidate);
cacheStrategy = factory.get();
//输出结果
networkRequest = cacheStrategy.networkRequest;
cacheResponse = cacheStrategy.cacheResponse;
//进行一大堆的if判断，内容同上表格
.....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private CacheStrategy getCandidate() {
  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了
  if (cacheResponse == null) {
    //`没有缓存的网络请求,查上文的表可知是直接访问
    return new CacheStrategy(request, null);
  }

  // 如果缓存的TLS握手信息丢失,返回进行直接连接
  if (request.isHttps() &amp;amp;&amp;amp; cacheResponse.handshake() == null) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  //检测response的状态码,Expired时间,是否有no-cache标签
  if (!isCacheable(cacheResponse, request)) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  CacheControl requestCaching = request.cacheControl();
  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)
  //或者有ETag/Since标签(也就是条件GET请求)
  if (requestCaching.noCache() || hasConditions(request)) {
    //直接连接,把缓存判断交给服务器
    return new CacheStrategy(request, null);
  }
  //根据RFC协议计算
  //计算当前age的时间戳
  //now - sent + age (s)
  long ageMillis = cacheResponseAge();
  //大部分情况服务器设置为max-age
  long freshMillis = computeFreshnessLifetime();

  if (requestCaching.maxAgeSeconds() != -1) {
    //大部分情况下是取max-age
    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
  }

  long minFreshMillis = 0;
  if (requestCaching.minFreshSeconds() != -1) {
    //大部分情况下设置是0
    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
  }

  long maxStaleMillis = 0;
  //ParseHeader中的缓存控制信息
  CacheControl responseCaching = cacheResponse.cacheControl();
  if (!responseCaching.mustRevalidate() &amp;amp;&amp;amp; requestCaching.maxStaleSeconds() != -1) {
    //设置最大过期时间,一般设置为0
    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
  }

  //缓存在过期时间内,可以使用
  //大部分情况下是进行如下判断
  //now - sent + age + 0 &amp;lt; max-age + 0
  if (!responseCaching.noCache() &amp;amp;&amp;amp; ageMillis + minFreshMillis &amp;lt; freshMillis + maxStaleMillis) {
    //返回上次的缓存
    Response.Builder builder = cacheResponse.newBuilder();
    return new CacheStrategy(null, builder.build());
  }

  //缓存失效, 如果有etag等信息
  //进行发送`conditional`请求,交给服务器处理
  Request.Builder conditionalRequestBuilder = request.newBuilder();

  if (etag != null) {
    conditionalRequestBuilder.header(&amp;quot;If-None-Match&amp;quot;, etag);
  } else if (lastModified != null) {
    conditionalRequestBuilder.header(&amp;quot;If-Modified-Since&amp;quot;, lastModifiedString);
  } else if (servedDate != null) {
    conditionalRequestBuilder.header(&amp;quot;If-Modified-Since&amp;quot;, servedDateString);
  }
  //下面请求实质还说网络请求
  Request conditionalRequest = conditionalRequestBuilder.build();
  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,
      cacheResponse) : new CacheStrategy(conditionalRequest, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;太长不看的话，大多数常见的情况可以用这个估算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;now - sent + age &amp;lt; max-age
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。&lt;/li&gt;
&lt;li&gt;OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 &lt;strong&gt;没有必要&lt;/strong&gt; 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 &lt;a href=&quot;https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;注释中&lt;/a&gt;。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.&lt;/li&gt;
&lt;li&gt;充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成&lt;/li&gt;
&lt;li&gt;可以使用 alt + space  快速预览某个函数&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/9cebbbd0eeab&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/9cebbbd0eeab&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇&lt;/p&gt;
&lt;h3 id=&quot;Http-缓存基础知识&quot;&gt;&lt;a href=&quot;#Http-缓存基础知识&quot; class=&quot;headerlink&quot; title=&quot;Http 缓存基础知识&quot;&gt;&lt;/a&gt;Http 缓存基础
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp3源码分析【任务队列】</title>
    <link href="http://gdky005.com/2016/06/20/OkHttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/OkHttp3源码分析【任务队列】/</id>
    <published>2016-06-20T08:34:26.000Z</published>
    <updated>2016-06-20T09:05:36.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池基础&lt;/li&gt;
&lt;li&gt;反向代理模块&lt;/li&gt;
&lt;li&gt;OkHttp 的任务调度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。&lt;/p&gt;
&lt;h1 id=&quot;线程池基础&quot;&gt;&lt;a href=&quot;#线程池基础&quot; class=&quot;headerlink&quot; title=&quot;线程池基础&quot;&gt;&lt;/a&gt;线程池基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程池好处有哪些&lt;br&gt;线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：&lt;br&gt;如果一台服务完成一项任务的时间为 T&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T1 创建线程的时间
T2 在线程中执行任务的时间，包括线程间同步所需时间
T3 线程销毁的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。&lt;/p&gt;
&lt;p&gt;可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。&lt;/p&gt;
&lt;p&gt;线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过对线程缓存，减少创建和销毁的时间损失&lt;ul&gt;
&lt;li&gt;通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OkHttp 配置的线程池&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 OkHttp 中，使用如下构造了单例线程池&lt;br&gt;    public synchronized ExecutorService executorService() {&lt;br&gt;      if (executorService == null) {&lt;br&gt;        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,&lt;br&gt;            new SynchronousQueue&lt;runnable&gt;(), Util.threadFactory(“OkHttp Dispatcher”, false));&lt;br&gt;      }&lt;br&gt;      return executorService;&lt;br&gt;    }&lt;/runnable&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。&lt;/li&gt;
&lt;li&gt;int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃&lt;em&gt;处理机制&lt;/em&gt;来处理&lt;/li&gt;
&lt;li&gt;long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive&lt;/li&gt;
&lt;li&gt;TimeUnit unit: 时间单位，一般用秒&lt;/li&gt;
&lt;li&gt;BlockingQueue\&lt;runnable\&gt; workQueue:  工作队列&lt;/runnable\&gt;&lt;/li&gt;
&lt;li&gt;ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 “OkHttp Dispatcher” 的线程工厂。&lt;/p&gt;
&lt;p&gt;也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反向代理模型&quot;&gt;&lt;a href=&quot;#反向代理模型&quot; class=&quot;headerlink&quot; title=&quot;反向代理模型&quot;&gt;&lt;/a&gt;反向代理模型&lt;/h3&gt;&lt;p&gt;在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。&lt;/p&gt;
&lt;p&gt;我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现&lt;strong&gt;非阻塞、高并发连接&lt;/strong&gt;，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\&lt;readyasynccalls\&gt;对应 Nginx 的内部缓存&lt;/readyasynccalls\&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体成员如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maxRequests = 64：最大并发请求数为64&lt;/li&gt;
&lt;li&gt;maxRequestsPerHost = 5：每个主机最大请求数为5&lt;/li&gt;
&lt;li&gt;Dispatcher：分发者，也就是生产者（默认在主线程）&lt;/li&gt;
&lt;li&gt;AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）&lt;/li&gt;
&lt;li&gt;ExecutorService：消费者池（也就是线程池）&lt;/li&gt;
&lt;li&gt;Deque\&lt;readyasynccalls\&gt;：缓存（用数组实现，可自动扩容，无大小限制）&lt;/readyasynccalls\&gt;&lt;/li&gt;
&lt;li&gt;Deque\&lt;runningasynccalls\&gt;：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存&lt;/runningasynccalls\&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间&lt;/p&gt;
&lt;h3 id=&quot;OkHttp-的任务调度&quot;&gt;&lt;a href=&quot;#OkHttp-的任务调度&quot; class=&quot;headerlink&quot; title=&quot;OkHttp 的任务调度&quot;&gt;&lt;/a&gt;OkHttp 的任务调度&lt;/h3&gt;&lt;p&gt;当我们使用 OkHttp 的异步请求时，一般进行如下构造：&lt;br&gt;    OkHttpClient client = new OkHttpClient.Builder().build();&lt;br&gt;    Request request = new Request.Builder()&lt;br&gt;        .url(“&lt;a href=&quot;http://qq.com&amp;quot;).get().build(&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://qq.com&amp;quot;).get().build(&lt;/a&gt;);&lt;br&gt;    client.newCall(request).enqueue(new Callback() {&lt;br&gt;      @Override public void onFailure(Call call, IOException e) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  }

  @Override public void onResponse(Call call, Response response) throws IOException {

  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() &amp;lt; maxRequests &amp;amp;&amp;amp; runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {
      //添加正在运行的请求
    runningAsyncCalls.add(call);
       //线程池执行请求
    executorService().execute(call);
  } else {
      //添加到缓存队列
    readyAsyncCalls.add(call);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现请求是否进入缓存的条件如下：&lt;br&gt;    (runningRequests&amp;lt;64 &amp;amp;&amp;amp; runningRequestsPerHost&amp;lt;5)&lt;/p&gt;
&lt;p&gt;如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。&lt;/p&gt;
&lt;p&gt;我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：&lt;br&gt;    @Override protected void execute() {&lt;br&gt;      boolean signalledCallback = false;&lt;br&gt;      try {&lt;br&gt;          //执行耗时IO任务&lt;br&gt;        Response response = getResponseWithInterceptorChain(forWebSocket);&lt;br&gt;        if (canceled) {&lt;br&gt;          signalledCallback = true;&lt;br&gt;          //回调，注意这里回调是在线程池中，而不是想当然的主线程回调&lt;br&gt;          responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));&lt;br&gt;        } else {&lt;br&gt;          signalledCallback = true;&lt;br&gt;          //回调，同上&lt;br&gt;          responseCallback.onResponse(RealCall.this, response);&lt;br&gt;        }&lt;br&gt;      } catch (IOException e) {&lt;br&gt;        if (signalledCallback) {&lt;br&gt;          // Do not signal the callback twice!&lt;br&gt;          logger.log(Level.INFO, “Callback failure for “ + toLoggableString(), e);&lt;br&gt;        } else {&lt;br&gt;          responseCallback.onFailure(RealCall.this, e);&lt;br&gt;        }&lt;br&gt;      } finally {&lt;br&gt;          //最关键的代码&lt;br&gt;        client.dispatcher().finished(this);&lt;br&gt;      }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数&lt;br&gt;    private void promoteCalls() {&lt;br&gt;        //如果目前是最大负荷运转，接着等&lt;br&gt;      if (runningAsyncCalls.size() &amp;gt;= maxRequests) return; // Already running max capacity.&lt;br&gt;      //如果缓存等待区是空的，接着等&lt;br&gt;      if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  for (Iterator&amp;lt;AsyncCall&amp;gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
    AsyncCall call = i.next();

    if (runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {
        //将缓存等待区最后一个移动到运行区中，并执行
      i.remove();
      runningAsyncCalls.add(call);
      executorService().execute(call);
    }

    if (runningAsyncCalls.size() &amp;gt;= maxRequests) return; // Reached max capacity.
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码&lt;/p&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;p&gt;通过上述的分析，我们知道了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行&lt;/li&gt;
&lt;li&gt;OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出&lt;/li&gt;
&lt;li&gt;OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/6637369d02e7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/6637369d02e7&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池基础&lt;/li&gt;
&lt;li&gt;反向代理模块&lt;/li&gt;
&lt;li&gt;OkHttp 的任务调度&lt;/li&gt;
&lt;/ol&gt;
&lt;
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
</feed>
