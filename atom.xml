<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤独狂饮</title>
  <subtitle>只要有百分之一的梦想，就要付出百分之百的努力。努力不一定成功，但是不努力就一定不会成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gdky005.com/"/>
  <updated>2016-06-20T08:39:17.000Z</updated>
  <id>http://gdky005.com/</id>
  
  <author>
    <name>gdky005</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OkHttp3 源码分析【缓存策略】</title>
    <link href="http://gdky005.com/2016/06/20/OkHttp3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/OkHttp3-源码分析【缓存策略】/</id>
    <published>2016-06-20T08:35:10.000Z</published>
    <updated>2016-06-20T08:39:17.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;OkHttp3-源码分析【缓存策略】&quot;&gt;&lt;a href=&quot;#OkHttp3-源码分析【缓存策略】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3 源码分析【缓存策略】&quot;&gt;&lt;/a&gt;OkHttp3 源码分析【缓存策略】&lt;/h1&gt;&lt;p&gt;本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇&lt;/p&gt;
&lt;h3 id=&quot;Http-缓存基础知识&quot;&gt;&lt;a href=&quot;#Http-缓存基础知识&quot; class=&quot;headerlink&quot; title=&quot;Http 缓存基础知识&quot;&gt;&lt;/a&gt;Http 缓存基础知识&lt;/h3&gt;&lt;p&gt;分析源目前，我们先回顾一下 Http 的缓存 Header 的含义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Expires&lt;br&gt;表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存&lt;br&gt; Expires: Thu, 12 Jan 2017 11:01:33 GMT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cache-Control&lt;br&gt;相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。&lt;/p&gt;
&lt;p&gt; Cache-Control: max-age=31536000, public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修订文件名（Reving Filenames）&lt;br&gt;如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery&lt;br&gt; upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;条件 get 请求 （Conditional GET Requests） 与 304&lt;br&gt;如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请求的方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified-Date:&lt;br&gt;  Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端再次发送时，通过发送&lt;br&gt;    If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT&lt;/p&gt;
&lt;p&gt;交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETag&lt;br&gt;ETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了&lt;br&gt;  ETag: “5694c7ef-24dc”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端再次请求时，通过发送&lt;br&gt;    If-None-Match:”5694c7ef-24dc”&lt;/p&gt;
&lt;p&gt;交给服务器进行判断，如果还能使用缓存，服务器就返回 304&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;其他标签&lt;ul&gt;
&lt;li&gt;no-cache/no-store: 不使用缓存&lt;ul&gt;
&lt;li&gt;only-if-cached: 只使用缓存&lt;/li&gt;
&lt;li&gt;Date:The date and time that the message was sent&lt;/li&gt;
&lt;li&gt;Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;“only-if-cached”标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。&lt;br&gt;全部的标签，可以到&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_header_fields&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里看&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h3&gt;&lt;p&gt;OkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总体请求流程分析&lt;br&gt;CacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出&lt;br&gt;Input（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Request:&lt;br&gt;开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。&lt;/p&gt;
&lt;p&gt;cacheCandildate:&lt;br&gt;也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.&lt;/p&gt;
&lt;p&gt;当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;CacheStrategy 的加工过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CacheStrategy 使用 Factory模式进行构造，参数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InternalCache responseCache = Internal.instance.internalCache(client);
//cacheCandidate从disklurcache中获取
//request的url被md5序列化为key,进行缓存查询
Response cacheCandidate = responseCache != null ? responseCache.get(request) : null;
//请求与缓存
factory = new CacheStrategy.Factory(now, request, cacheCandidate);
cacheStrategy = factory.get();
//输出结果
networkRequest = cacheStrategy.networkRequest;
cacheResponse = cacheStrategy.cacheResponse;
//进行一大堆的if判断，内容同上表格
.....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private CacheStrategy getCandidate() {
  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了
  if (cacheResponse == null) {
    //`没有缓存的网络请求,查上文的表可知是直接访问
    return new CacheStrategy(request, null);
  }

  // 如果缓存的TLS握手信息丢失,返回进行直接连接
  if (request.isHttps() &amp;amp;&amp;amp; cacheResponse.handshake() == null) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  //检测response的状态码,Expired时间,是否有no-cache标签
  if (!isCacheable(cacheResponse, request)) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  CacheControl requestCaching = request.cacheControl();
  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)
  //或者有ETag/Since标签(也就是条件GET请求)
  if (requestCaching.noCache() || hasConditions(request)) {
    //直接连接,把缓存判断交给服务器
    return new CacheStrategy(request, null);
  }
  //根据RFC协议计算
  //计算当前age的时间戳
  //now - sent + age (s)
  long ageMillis = cacheResponseAge();
  //大部分情况服务器设置为max-age
  long freshMillis = computeFreshnessLifetime();

  if (requestCaching.maxAgeSeconds() != -1) {
    //大部分情况下是取max-age
    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
  }

  long minFreshMillis = 0;
  if (requestCaching.minFreshSeconds() != -1) {
    //大部分情况下设置是0
    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
  }

  long maxStaleMillis = 0;
  //ParseHeader中的缓存控制信息
  CacheControl responseCaching = cacheResponse.cacheControl();
  if (!responseCaching.mustRevalidate() &amp;amp;&amp;amp; requestCaching.maxStaleSeconds() != -1) {
    //设置最大过期时间,一般设置为0
    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
  }

  //缓存在过期时间内,可以使用
  //大部分情况下是进行如下判断
  //now - sent + age + 0 &amp;lt; max-age + 0
  if (!responseCaching.noCache() &amp;amp;&amp;amp; ageMillis + minFreshMillis &amp;lt; freshMillis + maxStaleMillis) {
    //返回上次的缓存
    Response.Builder builder = cacheResponse.newBuilder();
    return new CacheStrategy(null, builder.build());
  }

  //缓存失效, 如果有etag等信息
  //进行发送`conditional`请求,交给服务器处理
  Request.Builder conditionalRequestBuilder = request.newBuilder();

  if (etag != null) {
    conditionalRequestBuilder.header(&amp;quot;If-None-Match&amp;quot;, etag);
  } else if (lastModified != null) {
    conditionalRequestBuilder.header(&amp;quot;If-Modified-Since&amp;quot;, lastModifiedString);
  } else if (servedDate != null) {
    conditionalRequestBuilder.header(&amp;quot;If-Modified-Since&amp;quot;, servedDateString);
  }
  //下面请求实质还说网络请求
  Request conditionalRequest = conditionalRequestBuilder.build();
  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,
      cacheResponse) : new CacheStrategy(conditionalRequest, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;太长不看的话，大多数常见的情况可以用这个估算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;now - sent + age &amp;lt; max-age
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。&lt;/li&gt;
&lt;li&gt;OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 &lt;strong&gt;没有必要&lt;/strong&gt; 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 &lt;a href=&quot;https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;注释中&lt;/a&gt;。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.&lt;/li&gt;
&lt;li&gt;充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成&lt;/li&gt;
&lt;li&gt;可以使用 alt + space  快速预览某个函数&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/9cebbbd0eeab&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/9cebbbd0eeab&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OkHttp3-源码分析【缓存策略】&quot;&gt;&lt;a href=&quot;#OkHttp3-源码分析【缓存策略】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3 源码分析【缓存策略】&quot;&gt;&lt;/a&gt;OkHttp3 源码分析【缓存策略】&lt;/h1&gt;&lt;p&gt;本文专门分析
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OkHttp3源码分析【任务队列】</title>
    <link href="http://gdky005.com/2016/06/20/OkHttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/OkHttp3源码分析【任务队列】/</id>
    <published>2016-06-20T08:34:26.000Z</published>
    <updated>2016-06-20T08:42:06.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;a href=&quot;#OkHttp3源码分析【任务队列】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;/a&gt;OkHttp3源码分析【任务队列】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池基础&lt;/li&gt;
&lt;li&gt;反向代理模块&lt;/li&gt;
&lt;li&gt;OkHttp 的任务调度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。&lt;/p&gt;
&lt;h1 id=&quot;线程池基础&quot;&gt;&lt;a href=&quot;#线程池基础&quot; class=&quot;headerlink&quot; title=&quot;线程池基础&quot;&gt;&lt;/a&gt;线程池基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程池好处有哪些&lt;br&gt;线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：&lt;br&gt;如果一台服务完成一项任务的时间为 T&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T1 创建线程的时间
T2 在线程中执行任务的时间，包括线程间同步所需时间
T3 线程销毁的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。&lt;/p&gt;
&lt;p&gt;可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。&lt;/p&gt;
&lt;p&gt;线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过对线程缓存，减少创建和销毁的时间损失&lt;ul&gt;
&lt;li&gt;通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OkHttp 配置的线程池&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 OkHttp 中，使用如下构造了单例线程池&lt;br&gt;    public synchronized ExecutorService executorService() {&lt;br&gt;      if (executorService == null) {&lt;br&gt;        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,&lt;br&gt;            new SynchronousQueue&lt;runnable&gt;(), Util.threadFactory(“OkHttp Dispatcher”, false));&lt;br&gt;      }&lt;br&gt;      return executorService;&lt;br&gt;    }&lt;/runnable&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。&lt;/li&gt;
&lt;li&gt;int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃&lt;em&gt;处理机制&lt;/em&gt;来处理&lt;/li&gt;
&lt;li&gt;long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive&lt;/li&gt;
&lt;li&gt;TimeUnit unit: 时间单位，一般用秒&lt;/li&gt;
&lt;li&gt;BlockingQueue\&lt;runnable\&gt; workQueue:  工作队列&lt;/runnable\&gt;&lt;/li&gt;
&lt;li&gt;ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 “OkHttp Dispatcher” 的线程工厂。&lt;/p&gt;
&lt;p&gt;也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反向代理模型&quot;&gt;&lt;a href=&quot;#反向代理模型&quot; class=&quot;headerlink&quot; title=&quot;反向代理模型&quot;&gt;&lt;/a&gt;反向代理模型&lt;/h3&gt;&lt;p&gt;在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。&lt;/p&gt;
&lt;p&gt;我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现&lt;strong&gt;非阻塞、高并发连接&lt;/strong&gt;，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\&lt;readyasynccalls\&gt;对应 Nginx 的内部缓存&lt;/readyasynccalls\&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体成员如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maxRequests = 64：最大并发请求数为64&lt;/li&gt;
&lt;li&gt;maxRequestsPerHost = 5：每个主机最大请求数为5&lt;/li&gt;
&lt;li&gt;Dispatcher：分发者，也就是生产者（默认在主线程）&lt;/li&gt;
&lt;li&gt;AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）&lt;/li&gt;
&lt;li&gt;ExecutorService：消费者池（也就是线程池）&lt;/li&gt;
&lt;li&gt;Deque\&lt;readyasynccalls\&gt;：缓存（用数组实现，可自动扩容，无大小限制）&lt;/readyasynccalls\&gt;&lt;/li&gt;
&lt;li&gt;Deque\&lt;runningasynccalls\&gt;：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存&lt;/runningasynccalls\&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间&lt;/p&gt;
&lt;h3 id=&quot;OkHttp-的任务调度&quot;&gt;&lt;a href=&quot;#OkHttp-的任务调度&quot; class=&quot;headerlink&quot; title=&quot;OkHttp 的任务调度&quot;&gt;&lt;/a&gt;OkHttp 的任务调度&lt;/h3&gt;&lt;p&gt;当我们使用 OkHttp 的异步请求时，一般进行如下构造：&lt;br&gt;    OkHttpClient client = new OkHttpClient.Builder().build();&lt;br&gt;    Request request = new Request.Builder()&lt;br&gt;        .url(“&lt;a href=&quot;http://qq.com&amp;quot;).get().build(&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://qq.com&amp;quot;).get().build(&lt;/a&gt;);&lt;br&gt;    client.newCall(request).enqueue(new Callback() {&lt;br&gt;      @Override public void onFailure(Call call, IOException e) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  }

  @Override public void onResponse(Call call, Response response) throws IOException {

  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() &amp;lt; maxRequests &amp;amp;&amp;amp; runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {
      //添加正在运行的请求
    runningAsyncCalls.add(call);
       //线程池执行请求
    executorService().execute(call);
  } else {
      //添加到缓存队列
    readyAsyncCalls.add(call);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现请求是否进入缓存的条件如下：&lt;br&gt;    (runningRequests&amp;lt;64 &amp;amp;&amp;amp; runningRequestsPerHost&amp;lt;5)&lt;/p&gt;
&lt;p&gt;如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。&lt;/p&gt;
&lt;p&gt;我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：&lt;br&gt;    @Override protected void execute() {&lt;br&gt;      boolean signalledCallback = false;&lt;br&gt;      try {&lt;br&gt;          //执行耗时IO任务&lt;br&gt;        Response response = getResponseWithInterceptorChain(forWebSocket);&lt;br&gt;        if (canceled) {&lt;br&gt;          signalledCallback = true;&lt;br&gt;          //回调，注意这里回调是在线程池中，而不是想当然的主线程回调&lt;br&gt;          responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));&lt;br&gt;        } else {&lt;br&gt;          signalledCallback = true;&lt;br&gt;          //回调，同上&lt;br&gt;          responseCallback.onResponse(RealCall.this, response);&lt;br&gt;        }&lt;br&gt;      } catch (IOException e) {&lt;br&gt;        if (signalledCallback) {&lt;br&gt;          // Do not signal the callback twice!&lt;br&gt;          logger.log(Level.INFO, “Callback failure for “ + toLoggableString(), e);&lt;br&gt;        } else {&lt;br&gt;          responseCallback.onFailure(RealCall.this, e);&lt;br&gt;        }&lt;br&gt;      } finally {&lt;br&gt;          //最关键的代码&lt;br&gt;        client.dispatcher().finished(this);&lt;br&gt;      }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数&lt;br&gt;    private void promoteCalls() {&lt;br&gt;        //如果目前是最大负荷运转，接着等&lt;br&gt;      if (runningAsyncCalls.size() &amp;gt;= maxRequests) return; // Already running max capacity.&lt;br&gt;      //如果缓存等待区是空的，接着等&lt;br&gt;      if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  for (Iterator&amp;lt;AsyncCall&amp;gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
    AsyncCall call = i.next();

    if (runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {
        //将缓存等待区最后一个移动到运行区中，并执行
      i.remove();
      runningAsyncCalls.add(call);
      executorService().execute(call);
    }

    if (runningAsyncCalls.size() &amp;gt;= maxRequests) return; // Reached max capacity.
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码&lt;/p&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;p&gt;通过上述的分析，我们知道了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行&lt;/li&gt;
&lt;li&gt;OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出&lt;/li&gt;
&lt;li&gt;OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/6637369d02e7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/6637369d02e7&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;a href=&quot;#OkHttp3源码分析【任务队列】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;/a&gt;OkHttp3源码分析【任务队列】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Collection Cheat Sheet</title>
    <link href="http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/"/>
    <id>http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/</id>
    <published>2016-06-20T08:21:47.000Z</published>
    <updated>2016-06-20T08:31:11.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;分享Java-Collection-的一张图&quot;&gt;&lt;a href=&quot;#分享Java-Collection-的一张图&quot; class=&quot;headerlink&quot; title=&quot;分享Java Collection 的一张图&quot;&gt;&lt;/a&gt;分享Java Collection 的一张图&lt;/h3&gt;&lt;p&gt;在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等&lt;/p&gt;
&lt;p&gt;我们可以看出他们之间的关系以及差别。&lt;/p&gt;
&lt;p&gt;例如：HashMap, HastTable,  Vector 和 LinkedList等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png&quot; alt=&quot;Java Collection Cheat Sheet&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分享Java-Collection-的一张图&quot;&gt;&lt;a href=&quot;#分享Java-Collection-的一张图&quot; class=&quot;headerlink&quot; title=&quot;分享Java Collection 的一张图&quot;&gt;&lt;/a&gt;分享Java Collection 的一
    
    </summary>
    
      <category term="Java" scheme="http://gdky005.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://gdky005.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Okhttp3源码分析【DiskLruCache】</title>
    <link href="http://gdky005.com/2016/06/20/Okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90DiskLruCache%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/Okhttp3源码分析【DiskLruCache】/</id>
    <published>2016-06-20T07:57:46.000Z</published>
    <updated>2016-06-20T08:40:20.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;a href=&quot;#Okhttp3源码分析【DiskLruCache】&quot; class=&quot;headerlink&quot; title=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;/a&gt;Okhttp3源码分析【DiskLruCache】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Cache 的简介&lt;/li&gt;
&lt;li&gt;LinkedHashMap 原理&lt;/li&gt;
&lt;li&gt;OkHttp 的文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 &lt;strong&gt;缓存策略&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-Cache-的简介&quot;&gt;&lt;a href=&quot;#1-Cache-的简介&quot; class=&quot;headerlink&quot; title=&quot;1.Cache 的简介&quot;&gt;&lt;/a&gt;1.Cache 的简介&lt;/h3&gt;&lt;p&gt;缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。&lt;/li&gt;
&lt;li&gt;需要实现 &lt;em&gt;排序依据&lt;/em&gt;， 子啊 java 中，可以使用 Comparable\&lt;t\&gt;作为排序的接口。&lt;/t\&gt;&lt;/li&gt;
&lt;li&gt;需要一种 &lt;em&gt;页面置换算法&lt;/em&gt; 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等&lt;/li&gt;
&lt;li&gt;如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Comparable\&lt;t\&gt;是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》&lt;br&gt;2.页面置换算法可以参考阅读《现代操作系统》的中译本&lt;/t\&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-LinkedHashMap-原理&quot;&gt;&lt;a href=&quot;#2-LinkedHashMap-原理&quot; class=&quot;headerlink&quot; title=&quot;2.LinkedHashMap 原理&quot;&gt;&lt;/a&gt;2.LinkedHashMap 原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;源码概述分析&lt;br&gt;在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 HashMap 中，维护了一个 Node\&lt;k,v\&gt;[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。&lt;/k,v\&gt;&lt;/p&gt;
&lt;p&gt;而在 LinkedHashMap 中，除了 Node\&lt;k,v\&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; table， 还维护着 Entry\&lt;k,v\&gt; head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素&lt;br&gt;    // move node to last&lt;br&gt;    void afterNodeAccess(Node&lt;k,v&gt; e)&lt;br&gt;    // possibly remove eldest&lt;br&gt;    void afterNodeInsertion(boolean evict)&lt;/k,v&gt;&lt;/k,v\&gt;&lt;/k,v\&gt;&lt;/p&gt;
&lt;p&gt;当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建&lt;br&gt;    // move node to last&lt;br&gt;    void afterNodeAccess(Node&lt;k,v&gt; e)&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head&lt;/p&gt;
&lt;p&gt;最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现&lt;br&gt;    head &amp;lt;–&amp;gt; …. &amp;lt;–&amp;gt; tail&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;旧元素 &amp;lt;-----------&amp;gt; 反复使用的新元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化&lt;br&gt;    //按照访问顺序排序的Map，设置accessOrder为true&lt;br&gt;    map = new LinkedHashMap&amp;lt;&amp;gt;(0, 0.75f, true);&lt;/p&gt;
&lt;h3 id=&quot;3-OkHttp-的文件系统&quot;&gt;&lt;a href=&quot;#3-OkHttp-的文件系统&quot; class=&quot;headerlink&quot; title=&quot;3.OkHttp 的文件系统&quot;&gt;&lt;/a&gt;3.OkHttp 的文件系统&lt;/h3&gt;&lt;p&gt;OkHttp 中的关键对象如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作&lt;/li&gt;
&lt;li&gt;DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装&lt;/li&gt;
&lt;li&gt;DiskLruCache.Entry: 维护着 key 对应的多个文件&lt;/li&gt;
&lt;li&gt;Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类&lt;/li&gt;
&lt;li&gt;DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）&lt;/li&gt;
&lt;li&gt;Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理&lt;/li&gt;
&lt;li&gt;Response/Request: OkHttp 的请求与回应&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;文件初级封装（FileSystem）&lt;br&gt;众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。&lt;br&gt; File(低级操作，步骤繁琐) -&amp;gt; Okio(封装) －&amp;gt; FileSystem(友好工具类)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Okio 很不错，可以去&lt;a href=&quot;https://github.com/square/okio&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件高级封装（DiskLruCache.Entry/Editor/Snapshot）&lt;br&gt;本部分进行了如下操作，进行了实际的 put/get 操作&lt;br&gt; FileSystem &amp;lt;– DiskLruCache.Entry/Editor –&amp;gt; source/sink(更少参数)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY_METADATA 与 ENTRY_BODY。&lt;/p&gt;
&lt;p&gt;比如在缓存的路径下执行 ls,结果如下：&lt;br&gt;    $ ls&lt;br&gt;    5716ab0f06c49bc7cf602397c51d5677.0&lt;br&gt;    5716ab0f06c49bc7cf602397c51d5677.1&lt;br&gt;    5b2f52377611dc6201a1871bdb997466.0&lt;br&gt;    5b2f52377611dc6201a1871bdb997466.1&lt;br&gt;    journal&lt;br&gt;    …..&lt;/p&gt;
&lt;p&gt;DiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;读取场景：读取时，需要获取快照，通过调用链分析&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;序列化与反序列化（Cache.Entry）&lt;br&gt;文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变&lt;blockquote&gt;
&lt;p&gt;Resonse(java对象) \&amp;lt;— Cache.Entry —&gt; source/sink(文件io)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以通过 find usage 位置相同，概括如下：&lt;br&gt;如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。&lt;br&gt;    至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;缓存的自动清理&lt;br&gt;在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。&lt;/p&gt;
&lt;p&gt; new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), Util.threadFactory(&amp;quot;OkHttp DiskLruCache&amp;quot;, true))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当需要清理时，执行清理任务，它将在每次 get/set 后调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Runnable cleanupRunnable = new Runnable() {
  public void run() {
    synchronized (DiskLruCache.this) {
      if (!initialized | closed) {
        return; // Nothing to do
      }
      try {
        //遍历LRU缓存(从旧到新进行遍历map),并删除文件
        //直到小于MaxSize为止
        trimToSize();
        if (journalRebuildRequired()) {
          rebuildJournal();
          redundantOpCount = 0;
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作&lt;/li&gt;
&lt;li&gt;OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作&lt;/li&gt;
&lt;li&gt;OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/23b8aa490a6b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/23b8aa490a6b&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;a href=&quot;#Okhttp3源码分析【DiskLruCache】&quot; class=&quot;headerlink&quot; title=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;/a&gt;Okhttp3源码分析
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>代码面试最常用的10大算法</title>
    <link href="http://gdky005.com/2016/03/12/%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95/"/>
    <id>http://gdky005.com/2016/03/12/代码面试最常用的10大算法/</id>
    <published>2016-03-12T00:32:44.000Z</published>
    <updated>2016-04-19T13:17:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;代码面试最常用的10大算法&quot;&gt;&lt;a href=&quot;#代码面试最常用的10大算法&quot; class=&quot;headerlink&quot; title=&quot;代码面试最常用的10大算法&quot;&gt;&lt;/a&gt;代码面试最常用的10大算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。&lt;br&gt;本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。&lt;/p&gt;
&lt;h3 id=&quot;1-String-Array-Matrix&quot;&gt;&lt;a href=&quot;#1-String-Array-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1. String/Array/Matrix&quot;&gt;&lt;/a&gt;1. String/Array/Matrix&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;toCharArray() //get char array of a String
Arrays.sort()  //sort an array
Arrays.toString(char[] a) //convert to string
charAt(int x) //get a char at the specific index
length() //string length
length //array size 
substring(int beginIndex) 
substring(int beginIndex, int endIndex)
Integer.valueOf()//string to integer
String.valueOf()/integer to string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。&lt;br&gt;下面列出一些需要高级算法才能解决的经典问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Evaluate Reverse Polish Notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-solution-word-break/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;单词分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;字梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Median of Two Sorted Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;正则表达式匹配￼Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://merge%20intervals/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;合并间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-insert-interval/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插入间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Two Sum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3Sum&lt;/li&gt;
&lt;li&gt;4Sum&lt;/li&gt;
&lt;li&gt;3Sum Closest&lt;/li&gt;
&lt;li&gt;String to Integer&lt;/li&gt;
&lt;li&gt;合并排序数组&lt;/li&gt;
&lt;li&gt;Valid Parentheses&lt;/li&gt;
&lt;li&gt;实现strStr()&lt;/li&gt;
&lt;li&gt;Set Matrix Zeroes&lt;/li&gt;
&lt;li&gt;搜索插入位置&lt;/li&gt;
&lt;li&gt;Longest Consecutive Sequence&lt;/li&gt;
&lt;li&gt;Valid Palindrome&lt;/li&gt;
&lt;li&gt;螺旋矩阵&lt;/li&gt;
&lt;li&gt;搜索一个二维矩阵&lt;/li&gt;
&lt;li&gt;旋转图像&lt;/li&gt;
&lt;li&gt;三角形&lt;/li&gt;
&lt;li&gt;Distinct Subsequences Total&lt;/li&gt;
&lt;li&gt;Maximum Subarray&lt;/li&gt;
&lt;li&gt;删除重复的排序数组&lt;/li&gt;
&lt;li&gt;删除重复的排序数组2&lt;/li&gt;
&lt;li&gt;查找没有重复的最长子串&lt;/li&gt;
&lt;li&gt;包含两个独特字符的最长子串&lt;/li&gt;
&lt;li&gt;Palindrome Partitioning&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-链表&quot;&gt;&lt;a href=&quot;#2-链表&quot; class=&quot;headerlink&quot; title=&quot;2. 链表&quot;&gt;&lt;/a&gt;2. 链表&lt;/h3&gt;&lt;p&gt;在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Node {
    int val;
    Node next;

    Node(int x) {
        val = x;
        next = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比较流行的两个链表例子就是栈和队列。&lt;/p&gt;
&lt;h4 id=&quot;栈（Stack）&quot;&gt;&lt;a href=&quot;#栈（Stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（Stack）&quot;&gt;&lt;/a&gt;栈（Stack）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Stack{
    Node top; 

    public Node peek(){
        if(top != null){
            return top;
        }

        return null;
    }

    public Node pop(){
        if(top == null){
            return null;
        }else{
            Node temp = new Node(top.val);
            top = top.next;
            return temp;    
        }
    }

    public void push(Node n){
        if(n != null){
            n.next = top;
            top = n;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;队列（Queue）&quot;&gt;&lt;a href=&quot;#队列（Queue）&quot; class=&quot;headerlink&quot; title=&quot;队列（Queue）&quot;&gt;&lt;/a&gt;队列（Queue）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Queue{
    Node first, last;
&amp;amp;nbsp;
    public void enqueue(Node n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }
&amp;amp;nbsp;
    public Node dequeue(){
        if(first == null){
            return null;
        }else{
            Node temp = new Node(first.val);
            first = first.next;
            return temp;
        }   
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。&lt;br&gt;在实际中，需要用到链表的算法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入两个数字&lt;/li&gt;
&lt;li&gt;重新排序列表&lt;/li&gt;
&lt;li&gt;链表周期&lt;/li&gt;
&lt;li&gt;Copy List with Random Pointer&lt;/li&gt;
&lt;li&gt;合并两个有序列表&lt;/li&gt;
&lt;li&gt;合并多个排序列表&lt;/li&gt;
&lt;li&gt;从排序列表中删除重复的&lt;/li&gt;
&lt;li&gt;分区列表&lt;/li&gt;
&lt;li&gt;LRU缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-树-amp-堆&quot;&gt;&lt;a href=&quot;#3-树-amp-堆&quot; class=&quot;headerlink&quot; title=&quot;3. 树&amp;amp;堆&quot;&gt;&lt;/a&gt;3. 树&amp;amp;堆&lt;/h3&gt;&lt;p&gt;这里的树通常是指二叉树。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TreeNode{
    int value;
    TreeNode left;
    TreeNode right;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是一些与二叉树有关的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树搜索：对于所有节点，顺序是：left children \&amp;lt;= current node \&amp;lt;= right children；&lt;/li&gt;
&lt;li&gt;平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；&lt;/li&gt;
&lt;li&gt;满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；&lt;/li&gt;
&lt;li&gt;完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；&lt;/li&gt;
&lt;li&gt;完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。&lt;/p&gt;
&lt;p&gt;下面列出一些基于二叉树和堆的算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树前序遍历&lt;/li&gt;
&lt;li&gt;二叉树中序遍历&lt;/li&gt;
&lt;li&gt;二叉树后序遍历&lt;/li&gt;
&lt;li&gt;字梯&lt;/li&gt;
&lt;li&gt;验证二叉查找树&lt;/li&gt;
&lt;li&gt;把二叉树变平放到链表里&lt;/li&gt;
&lt;li&gt;二叉树路径和&lt;/li&gt;
&lt;li&gt;从前序和后序构建二叉树&lt;/li&gt;
&lt;li&gt;把有序数组转换为二叉查找树&lt;/li&gt;
&lt;li&gt;把有序列表转为二叉查找树&lt;/li&gt;
&lt;li&gt;最小深度二叉树&lt;/li&gt;
&lt;li&gt;二叉树最大路径和&lt;/li&gt;
&lt;li&gt;平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-Graph&quot;&gt;&lt;a href=&quot;#4-Graph&quot; class=&quot;headerlink&quot; title=&quot;4. Graph&quot;&gt;&lt;/a&gt;4. Graph&lt;/h3&gt;&lt;p&gt;与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一步，定义一个GraphNode&quot;&gt;&lt;a href=&quot;#第一步，定义一个GraphNode&quot; class=&quot;headerlink&quot; title=&quot;第一步，定义一个GraphNode&quot;&gt;&lt;/a&gt;第一步，定义一个GraphNode&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class GraphNode{ 
    int val;
    GraphNode next;
    GraphNode[] neighbors;
    boolean visited;

    GraphNode(int x) {
        val = x;
    }

    GraphNode(int x, GraphNode[] n){
        val = x;
        neighbors = n;
    }

    public String toString(){
        return &amp;quot;value: &amp;quot;+ this.val; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第二步，定义一个队列&quot;&gt;&lt;a href=&quot;#第二步，定义一个队列&quot; class=&quot;headerlink&quot; title=&quot;第二步，定义一个队列&quot;&gt;&lt;/a&gt;第二步，定义一个队列&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Queue{
    GraphNode first, last;

    public void enqueue(GraphNode n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }

    public GraphNode dequeue(){
        if(first == null){
            return null;
        }else{
            GraphNode temp = new GraphNode(first.val, first.neighbors);
            first = first.next;
            return temp;
        }   
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第三步，使用队列进行宽度优先搜索&quot;&gt;&lt;a href=&quot;#第三步，使用队列进行宽度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;第三步，使用队列进行宽度优先搜索&quot;&gt;&lt;/a&gt;第三步，使用队列进行宽度优先搜索&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class GraphTest {

    public static void main(String[] args) {
        GraphNode n1 = new GraphNode(1); 
        GraphNode n2 = new GraphNode(2); 
        GraphNode n3 = new GraphNode(3); 
        GraphNode n4 = new GraphNode(4); 
        GraphNode n5 = new GraphNode(5); 

        n1.neighbors = new GraphNode[]{n2,n3,n5};
        n2.neighbors = new GraphNode[]{n1,n4};
        n3.neighbors = new GraphNode[]{n1,n4,n5};
        n4.neighbors = new GraphNode[]{n2,n3,n5};
        n5.neighbors = new GraphNode[]{n1,n3,n4};

        breathFirstSearch(n1, 5);
    }

    public static void breathFirstSearch(GraphNode root, int x){
        if(root.val == x)
            System.out.println(&amp;quot;find in root&amp;quot;);

        Queue queue = new Queue();
        root.visited = true;
        queue.enqueue(root);

        while(queue.first != null){
            GraphNode c = (GraphNode) queue.dequeue();
            for(GraphNode n: c.neighbors){

                if(!n.visited){
                    System.out.print(n + &amp;quot; &amp;quot;);
                    n.visited = true;
                    if(n.val == x)
                        System.out.println(&amp;quot;Find &amp;quot;+n);
                    queue.enqueue(n);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;输出结果：&quot;&gt;&lt;a href=&quot;#输出结果：&quot; class=&quot;headerlink&quot; title=&quot;输出结果：&quot;&gt;&lt;/a&gt;输出结果：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;value: 2 value: 3 value: 5 Find value: 5 
value: 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际中，基于Graph需要经常用到的算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克隆Graph&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;5-排序&quot;&gt;&lt;a href=&quot;#5-排序&quot; class=&quot;headerlink&quot; title=&quot;5. 排序&quot;&gt;&lt;/a&gt;5. 排序&lt;/h3&gt;&lt;p&gt;不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   &lt;/p&gt;
&lt;p&gt;下面是这些算法的具体实例，另外，你还可以阅读： &lt;a href=&quot;http://www.programcreek.com/2014/03/how-developers-sort-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java开发者在实际操作中是如何排序的&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;6-递归和迭代&quot;&gt;&lt;a href=&quot;#6-递归和迭代&quot; class=&quot;headerlink&quot; title=&quot;6. 递归和迭代&quot;&gt;&lt;/a&gt;6. 递归和迭代&lt;/h3&gt;&lt;p&gt;下面通过一个例子来说明什么是递归。&lt;/p&gt;
&lt;h4 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这里有n个台阶，每次能爬1或2节，请问有多少种爬法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;步骤1：查找n和n-1之间的关系&quot;&gt;&lt;a href=&quot;#步骤1：查找n和n-1之间的关系&quot; class=&quot;headerlink&quot; title=&quot;步骤1：查找n和n-1之间的关系&quot;&gt;&lt;/a&gt;步骤1：查找n和n-1之间的关系&lt;/h4&gt;&lt;p&gt;为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   &lt;/p&gt;
&lt;h4 id=&quot;步骤2：确保开始条件是正确的&quot;&gt;&lt;a href=&quot;#步骤2：确保开始条件是正确的&quot; class=&quot;headerlink&quot; title=&quot;步骤2：确保开始条件是正确的&quot;&gt;&lt;/a&gt;步骤2：确保开始条件是正确的&lt;/h4&gt;&lt;p&gt;f(0) = 0;&lt;br&gt;f(1) = 1; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static int f(int n){
    if(n &amp;lt;= 2) return n;
    int x = f(n-1) + f(n-2);
    return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;递归方法的时间复杂度指数为n，这里会有很多冗余计算。&lt;br&gt;    f(5)&lt;br&gt;    f(4) + f(3)&lt;br&gt;    f(3) + f(2) + f(2) + f(1)&lt;br&gt;    f(2) + f(1) + f(2) + f(2) + f(1)&lt;/p&gt;
&lt;p&gt;该递归可以很简单地转换为迭代。&lt;br&gt;    public static int f(int n) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if (n &amp;lt;= 2){
        return n;
    }

    int first = 1, second = 2;
    int third = 0;

    for (int i = 3; i &amp;lt;= n; i++) {
        third = first + second;
        first = second;
        second = third;
    }

    return third;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 &lt;a href=&quot;http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;看看。&lt;/p&gt;
&lt;h3 id=&quot;7-动态规划&quot;&gt;&lt;a href=&quot;#7-动态规划&quot; class=&quot;headerlink&quot; title=&quot;7. 动态规划&quot;&gt;&lt;/a&gt;7. 动态规划&lt;/h3&gt;&lt;p&gt;动态规划主要用来解决如下技术问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过较小的子例来解决一个实例；&lt;/li&gt;
&lt;li&gt;对于一个较小的实例，可能需要许多个解决方案；&lt;/li&gt;
&lt;li&gt;把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;附加空间用来节省时间。&lt;br&gt;上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：&lt;br&gt;  public static int[] A = new int[100];&lt;/p&gt;
&lt;p&gt;  public static int f3(int n) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (n &amp;lt;= 2)
    A[n]= n;

if(A[n] &amp;gt; 0)
    return A[n];
else
    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!
return A[n];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些基于动态规划的算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编辑距离&lt;/li&gt;
&lt;li&gt;最长回文子串&lt;/li&gt;
&lt;li&gt;单词分割&lt;/li&gt;
&lt;li&gt;最大的子数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;8-位操作&quot;&gt;&lt;a href=&quot;#8-位操作&quot; class=&quot;headerlink&quot; title=&quot;8. 位操作&quot;&gt;&lt;/a&gt;8. 位操作&lt;/h3&gt;&lt;p&gt;位操作符：&lt;br&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从一个给定的数n中找位i（i从0开始，然后向右开始）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static boolean getBit(int num, int i){
    int result = num &amp;amp; (1&amp;lt;&amp;lt;i);

    if(result == 0){
        return false;
    }else{
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，获取10的第二位：&lt;br&gt;    i=1, n=10&lt;br&gt;    1&amp;lt;&amp;lt;1= 10&lt;br&gt;    1010&amp;amp;10=10&lt;br&gt;    10 is not 0, so return true;&lt;/p&gt;
&lt;p&gt;典型的位算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find Single Number&lt;/li&gt;
&lt;li&gt;Maximum Binary Gap&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9-概率&quot;&gt;&lt;a href=&quot;#9-概率&quot; class=&quot;headerlink&quot; title=&quot;9. 概率&quot;&gt;&lt;/a&gt;9. 概率&lt;/h3&gt;&lt;p&gt;通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public static double caculateProbability(int n){
    double x = 1; 

    for(int i=0; i&amp;lt;n; i++){
        x *=  (365.0-i)/365.0;
    }

    double pro = Math.round((1-x) * 100);
    return pro/100;
}I
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;calculateProbability(50) = 0.97&lt;/p&gt;
&lt;h3 id=&quot;10-组合和排列&quot;&gt;&lt;a href=&quot;#10-组合和排列&quot; class=&quot;headerlink&quot; title=&quot;10. 组合和排列&quot;&gt;&lt;/a&gt;10. 组合和排列&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;组合和排列的主要差别在于顺序是否重要。&lt;br&gt;例1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？&lt;br&gt;例2：&lt;br&gt;有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于它们的一些常见算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排列&lt;/li&gt;
&lt;li&gt;排列2&lt;/li&gt;
&lt;li&gt;排列顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来自：&lt;a href=&quot;http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代码面试最常用的10大算法&quot;&gt;&lt;a href=&quot;#代码面试最常用的10大算法&quot; class=&quot;headerlink&quot; title=&quot;代码面试最常用的10大算法&quot;&gt;&lt;/a&gt;代码面试最常用的10大算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面试也是一门学问，在面试之
    
    </summary>
    
    
      <category term="算法" scheme="http://gdky005.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
