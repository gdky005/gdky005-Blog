<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤独狂饮</title>
  <subtitle>只要有百分之一的梦想，就要付出百分之百的努力。努力不一定成功，但是不努力就一定不会成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gdky005.com/"/>
  <updated>2016-06-20T08:14:57.000Z</updated>
  <id>http://gdky005.com/</id>
  
  <author>
    <name>gdky005</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Okhttp3源码分析【DiskLruCache】</title>
    <link href="http://gdky005.com/2016/06/20/Okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90DiskLruCache%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/Okhttp3源码分析【DiskLruCache】/</id>
    <published>2016-06-20T07:57:46.000Z</published>
    <updated>2016-06-20T08:14:57.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;a href=&quot;#Okhttp3源码分析【DiskLruCache】&quot; class=&quot;headerlink&quot; title=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;/a&gt;Okhttp3源码分析【DiskLruCache】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Cache 的简介&lt;/li&gt;
&lt;li&gt;LinkedHashMap 原理&lt;/li&gt;
&lt;li&gt;OkHttp 的文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 &lt;strong&gt;缓存策略&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-Cache-的简介&quot;&gt;&lt;a href=&quot;#1-Cache-的简介&quot; class=&quot;headerlink&quot; title=&quot;1.Cache 的简介&quot;&gt;&lt;/a&gt;1.Cache 的简介&lt;/h3&gt;&lt;p&gt;缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。&lt;/li&gt;
&lt;li&gt;需要实现 &lt;em&gt;排序依据&lt;/em&gt;， 子啊 java 中，可以使用 Comparable\&lt;t\&gt;作为排序的接口。&lt;/t\&gt;&lt;/li&gt;
&lt;li&gt;需要一种 &lt;em&gt;页面置换算法&lt;/em&gt; 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等&lt;/li&gt;
&lt;li&gt;如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Comparable\&lt;t\&gt;是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》&lt;br&gt;2.页面置换算法可以参考阅读《现代操作系统》的中译本&lt;/t\&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-LinkedHashMap-原理&quot;&gt;&lt;a href=&quot;#2-LinkedHashMap-原理&quot; class=&quot;headerlink&quot; title=&quot;2.LinkedHashMap 原理&quot;&gt;&lt;/a&gt;2.LinkedHashMap 原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;源码概述分析&lt;br&gt;在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 HashMap 中，维护了一个 Node\&lt;k,v\&gt;[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。&lt;/k,v\&gt;&lt;/p&gt;
&lt;p&gt;而在 LinkedHashMap 中，除了 Node\&lt;k,v\&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; table， 还维护着 Entry\&lt;k,v\&gt; head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素&lt;br&gt;    // move node to last&lt;br&gt;    void afterNodeAccess(Node&lt;k,v&gt; e)&lt;br&gt;    // possibly remove eldest&lt;br&gt;    void afterNodeInsertion(boolean evict)&lt;/k,v&gt;&lt;/k,v\&gt;&lt;/k,v\&gt;&lt;/p&gt;
&lt;p&gt;当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建&lt;br&gt;    // move node to last&lt;br&gt;    void afterNodeAccess(Node&lt;k,v&gt; e)&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head&lt;/p&gt;
&lt;p&gt;最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现&lt;br&gt;    head &amp;lt;–&amp;gt; …. &amp;lt;–&amp;gt; tail&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;旧元素 &amp;lt;-----------&amp;gt; 反复使用的新元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化&lt;br&gt;    //按照访问顺序排序的Map，设置accessOrder为true&lt;br&gt;    map = new LinkedHashMap&amp;lt;&amp;gt;(0, 0.75f, true);&lt;/p&gt;
&lt;h3 id=&quot;3-OkHttp-的文件系统&quot;&gt;&lt;a href=&quot;#3-OkHttp-的文件系统&quot; class=&quot;headerlink&quot; title=&quot;3.OkHttp 的文件系统&quot;&gt;&lt;/a&gt;3.OkHttp 的文件系统&lt;/h3&gt;&lt;p&gt;OkHttp 中的关键对象如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作&lt;/li&gt;
&lt;li&gt;DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装&lt;/li&gt;
&lt;li&gt;DiskLruCache.Entry: 维护着 key 对应的多个文件&lt;/li&gt;
&lt;li&gt;Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类&lt;/li&gt;
&lt;li&gt;DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）&lt;/li&gt;
&lt;li&gt;Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理&lt;/li&gt;
&lt;li&gt;Response/Request: OkHttp 的请求与回应&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;文件初级封装（FileSystem）&lt;br&gt;众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。&lt;br&gt; File(低级操作，步骤繁琐) -&amp;gt; Okio(封装) －&amp;gt; FileSystem(友好工具类)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Okio 很不错，可以去&lt;a href=&quot;https://github.com/square/okio&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件高级封装（DiskLruCache.Entry/Editor/Snapshot）&lt;br&gt;本部分进行了如下操作，进行了实际的 put/get 操作&lt;br&gt; FileSystem &amp;lt;– DiskLruCache.Entry/Editor –&amp;gt; source/sink(更少参数)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY_METADATA 与 ENTRY_BODY。&lt;/p&gt;
&lt;p&gt;比如在缓存的路径下执行 ls,结果如下：&lt;br&gt;    $ ls&lt;br&gt;    5716ab0f06c49bc7cf602397c51d5677.0&lt;br&gt;    5716ab0f06c49bc7cf602397c51d5677.1&lt;br&gt;    5b2f52377611dc6201a1871bdb997466.0&lt;br&gt;    5b2f52377611dc6201a1871bdb997466.1&lt;br&gt;    journal&lt;br&gt;    …..&lt;/p&gt;
&lt;p&gt;DiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;读取场景：读取时，需要获取快照，通过调用链分析&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;序列化与反序列化（Cache.Entry）&lt;br&gt;文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变&lt;blockquote&gt;
&lt;p&gt;Resonse(java对象) \&amp;lt;— Cache.Entry —&gt; source/sink(文件io)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以通过 find usage 位置相同，概括如下：&lt;br&gt;如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。&lt;br&gt;    至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;缓存的自动清理&lt;br&gt;在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。&lt;/p&gt;
&lt;p&gt; new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), Util.threadFactory(&amp;quot;OkHttp DiskLruCache&amp;quot;, true))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当需要清理时，执行清理任务，它将在每次 get/set 后调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Runnable cleanupRunnable = new Runnable() {
  public void run() {
    synchronized (DiskLruCache.this) {
      if (!initialized | closed) {
        return; // Nothing to do
      }
      try {
        //遍历LRU缓存(从旧到新进行遍历map),并删除文件
        //直到小于MaxSize为止
        trimToSize();
        if (journalRebuildRequired()) {
          rebuildJournal();
          redundantOpCount = 0;
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作&lt;/li&gt;
&lt;li&gt;OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作&lt;/li&gt;
&lt;li&gt;OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;a href=&quot;#Okhttp3源码分析【DiskLruCache】&quot; class=&quot;headerlink&quot; title=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;/a&gt;Okhttp3源码分析
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>代码面试最常用的10大算法</title>
    <link href="http://gdky005.com/2016/03/12/%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95/"/>
    <id>http://gdky005.com/2016/03/12/代码面试最常用的10大算法/</id>
    <published>2016-03-12T00:32:44.000Z</published>
    <updated>2016-04-19T13:17:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;代码面试最常用的10大算法&quot;&gt;&lt;a href=&quot;#代码面试最常用的10大算法&quot; class=&quot;headerlink&quot; title=&quot;代码面试最常用的10大算法&quot;&gt;&lt;/a&gt;代码面试最常用的10大算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。&lt;br&gt;本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。&lt;/p&gt;
&lt;h3 id=&quot;1-String-Array-Matrix&quot;&gt;&lt;a href=&quot;#1-String-Array-Matrix&quot; class=&quot;headerlink&quot; title=&quot;1. String/Array/Matrix&quot;&gt;&lt;/a&gt;1. String/Array/Matrix&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;toCharArray() //get char array of a String
Arrays.sort()  //sort an array
Arrays.toString(char[] a) //convert to string
charAt(int x) //get a char at the specific index
length() //string length
length //array size 
substring(int beginIndex) 
substring(int beginIndex, int endIndex)
Integer.valueOf()//string to integer
String.valueOf()/integer to string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。&lt;br&gt;下面列出一些需要高级算法才能解决的经典问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Evaluate Reverse Polish Notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-solution-word-break/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;单词分割&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;字梯&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Median of Two Sorted Arrays&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;正则表达式匹配￼Java&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://merge%20intervals/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;合并间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-insert-interval/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插入间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Two Sum&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3Sum&lt;/li&gt;
&lt;li&gt;4Sum&lt;/li&gt;
&lt;li&gt;3Sum Closest&lt;/li&gt;
&lt;li&gt;String to Integer&lt;/li&gt;
&lt;li&gt;合并排序数组&lt;/li&gt;
&lt;li&gt;Valid Parentheses&lt;/li&gt;
&lt;li&gt;实现strStr()&lt;/li&gt;
&lt;li&gt;Set Matrix Zeroes&lt;/li&gt;
&lt;li&gt;搜索插入位置&lt;/li&gt;
&lt;li&gt;Longest Consecutive Sequence&lt;/li&gt;
&lt;li&gt;Valid Palindrome&lt;/li&gt;
&lt;li&gt;螺旋矩阵&lt;/li&gt;
&lt;li&gt;搜索一个二维矩阵&lt;/li&gt;
&lt;li&gt;旋转图像&lt;/li&gt;
&lt;li&gt;三角形&lt;/li&gt;
&lt;li&gt;Distinct Subsequences Total&lt;/li&gt;
&lt;li&gt;Maximum Subarray&lt;/li&gt;
&lt;li&gt;删除重复的排序数组&lt;/li&gt;
&lt;li&gt;删除重复的排序数组2&lt;/li&gt;
&lt;li&gt;查找没有重复的最长子串&lt;/li&gt;
&lt;li&gt;包含两个独特字符的最长子串&lt;/li&gt;
&lt;li&gt;Palindrome Partitioning&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-链表&quot;&gt;&lt;a href=&quot;#2-链表&quot; class=&quot;headerlink&quot; title=&quot;2. 链表&quot;&gt;&lt;/a&gt;2. 链表&lt;/h3&gt;&lt;p&gt;在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Node {
    int val;
    Node next;

    Node(int x) {
        val = x;
        next = null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比较流行的两个链表例子就是栈和队列。&lt;/p&gt;
&lt;h4 id=&quot;栈（Stack）&quot;&gt;&lt;a href=&quot;#栈（Stack）&quot; class=&quot;headerlink&quot; title=&quot;栈（Stack）&quot;&gt;&lt;/a&gt;栈（Stack）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Stack{
    Node top; 

    public Node peek(){
        if(top != null){
            return top;
        }

        return null;
    }

    public Node pop(){
        if(top == null){
            return null;
        }else{
            Node temp = new Node(top.val);
            top = top.next;
            return temp;    
        }
    }

    public void push(Node n){
        if(n != null){
            n.next = top;
            top = n;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;队列（Queue）&quot;&gt;&lt;a href=&quot;#队列（Queue）&quot; class=&quot;headerlink&quot; title=&quot;队列（Queue）&quot;&gt;&lt;/a&gt;队列（Queue）&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Queue{
    Node first, last;
&amp;amp;nbsp;
    public void enqueue(Node n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }
&amp;amp;nbsp;
    public Node dequeue(){
        if(first == null){
            return null;
        }else{
            Node temp = new Node(first.val);
            first = first.next;
            return temp;
        }   
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。&lt;br&gt;在实际中，需要用到链表的算法有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入两个数字&lt;/li&gt;
&lt;li&gt;重新排序列表&lt;/li&gt;
&lt;li&gt;链表周期&lt;/li&gt;
&lt;li&gt;Copy List with Random Pointer&lt;/li&gt;
&lt;li&gt;合并两个有序列表&lt;/li&gt;
&lt;li&gt;合并多个排序列表&lt;/li&gt;
&lt;li&gt;从排序列表中删除重复的&lt;/li&gt;
&lt;li&gt;分区列表&lt;/li&gt;
&lt;li&gt;LRU缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-树-amp-堆&quot;&gt;&lt;a href=&quot;#3-树-amp-堆&quot; class=&quot;headerlink&quot; title=&quot;3. 树&amp;amp;堆&quot;&gt;&lt;/a&gt;3. 树&amp;amp;堆&lt;/h3&gt;&lt;p&gt;这里的树通常是指二叉树。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class TreeNode{
    int value;
    TreeNode left;
    TreeNode right;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是一些与二叉树有关的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树搜索：对于所有节点，顺序是：left children \&amp;lt;= current node \&amp;lt;= right children；&lt;/li&gt;
&lt;li&gt;平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；&lt;/li&gt;
&lt;li&gt;满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；&lt;/li&gt;
&lt;li&gt;完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；&lt;/li&gt;
&lt;li&gt;完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。&lt;/p&gt;
&lt;p&gt;下面列出一些基于二叉树和堆的算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉树前序遍历&lt;/li&gt;
&lt;li&gt;二叉树中序遍历&lt;/li&gt;
&lt;li&gt;二叉树后序遍历&lt;/li&gt;
&lt;li&gt;字梯&lt;/li&gt;
&lt;li&gt;验证二叉查找树&lt;/li&gt;
&lt;li&gt;把二叉树变平放到链表里&lt;/li&gt;
&lt;li&gt;二叉树路径和&lt;/li&gt;
&lt;li&gt;从前序和后序构建二叉树&lt;/li&gt;
&lt;li&gt;把有序数组转换为二叉查找树&lt;/li&gt;
&lt;li&gt;把有序列表转为二叉查找树&lt;/li&gt;
&lt;li&gt;最小深度二叉树&lt;/li&gt;
&lt;li&gt;二叉树最大路径和&lt;/li&gt;
&lt;li&gt;平衡二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-Graph&quot;&gt;&lt;a href=&quot;#4-Graph&quot; class=&quot;headerlink&quot; title=&quot;4. Graph&quot;&gt;&lt;/a&gt;4. Graph&lt;/h3&gt;&lt;p&gt;与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一步，定义一个GraphNode&quot;&gt;&lt;a href=&quot;#第一步，定义一个GraphNode&quot; class=&quot;headerlink&quot; title=&quot;第一步，定义一个GraphNode&quot;&gt;&lt;/a&gt;第一步，定义一个GraphNode&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class GraphNode{ 
    int val;
    GraphNode next;
    GraphNode[] neighbors;
    boolean visited;

    GraphNode(int x) {
        val = x;
    }

    GraphNode(int x, GraphNode[] n){
        val = x;
        neighbors = n;
    }

    public String toString(){
        return &amp;quot;value: &amp;quot;+ this.val; 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第二步，定义一个队列&quot;&gt;&lt;a href=&quot;#第二步，定义一个队列&quot; class=&quot;headerlink&quot; title=&quot;第二步，定义一个队列&quot;&gt;&lt;/a&gt;第二步，定义一个队列&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;class Queue{
    GraphNode first, last;

    public void enqueue(GraphNode n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }

    public GraphNode dequeue(){
        if(first == null){
            return null;
        }else{
            GraphNode temp = new GraphNode(first.val, first.neighbors);
            first = first.next;
            return temp;
        }   
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;第三步，使用队列进行宽度优先搜索&quot;&gt;&lt;a href=&quot;#第三步，使用队列进行宽度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;第三步，使用队列进行宽度优先搜索&quot;&gt;&lt;/a&gt;第三步，使用队列进行宽度优先搜索&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;public class GraphTest {

    public static void main(String[] args) {
        GraphNode n1 = new GraphNode(1); 
        GraphNode n2 = new GraphNode(2); 
        GraphNode n3 = new GraphNode(3); 
        GraphNode n4 = new GraphNode(4); 
        GraphNode n5 = new GraphNode(5); 

        n1.neighbors = new GraphNode[]{n2,n3,n5};
        n2.neighbors = new GraphNode[]{n1,n4};
        n3.neighbors = new GraphNode[]{n1,n4,n5};
        n4.neighbors = new GraphNode[]{n2,n3,n5};
        n5.neighbors = new GraphNode[]{n1,n3,n4};

        breathFirstSearch(n1, 5);
    }

    public static void breathFirstSearch(GraphNode root, int x){
        if(root.val == x)
            System.out.println(&amp;quot;find in root&amp;quot;);

        Queue queue = new Queue();
        root.visited = true;
        queue.enqueue(root);

        while(queue.first != null){
            GraphNode c = (GraphNode) queue.dequeue();
            for(GraphNode n: c.neighbors){

                if(!n.visited){
                    System.out.print(n + &amp;quot; &amp;quot;);
                    n.visited = true;
                    if(n.val == x)
                        System.out.println(&amp;quot;Find &amp;quot;+n);
                    queue.enqueue(n);
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;输出结果：&quot;&gt;&lt;a href=&quot;#输出结果：&quot; class=&quot;headerlink&quot; title=&quot;输出结果：&quot;&gt;&lt;/a&gt;输出结果：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;value: 2 value: 3 value: 5 Find value: 5 
value: 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际中，基于Graph需要经常用到的算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克隆Graph&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;5-排序&quot;&gt;&lt;a href=&quot;#5-排序&quot; class=&quot;headerlink&quot; title=&quot;5. 排序&quot;&gt;&lt;/a&gt;5. 排序&lt;/h3&gt;&lt;p&gt;不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   &lt;/p&gt;
&lt;p&gt;下面是这些算法的具体实例，另外，你还可以阅读： &lt;a href=&quot;http://www.programcreek.com/2014/03/how-developers-sort-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java开发者在实际操作中是如何排序的&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;归并排序&lt;/li&gt;
&lt;li&gt;快速排序&lt;/li&gt;
&lt;li&gt;插入排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;6-递归和迭代&quot;&gt;&lt;a href=&quot;#6-递归和迭代&quot; class=&quot;headerlink&quot; title=&quot;6. 递归和迭代&quot;&gt;&lt;/a&gt;6. 递归和迭代&lt;/h3&gt;&lt;p&gt;下面通过一个例子来说明什么是递归。&lt;/p&gt;
&lt;h4 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;这里有n个台阶，每次能爬1或2节，请问有多少种爬法？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;步骤1：查找n和n-1之间的关系&quot;&gt;&lt;a href=&quot;#步骤1：查找n和n-1之间的关系&quot; class=&quot;headerlink&quot; title=&quot;步骤1：查找n和n-1之间的关系&quot;&gt;&lt;/a&gt;步骤1：查找n和n-1之间的关系&lt;/h4&gt;&lt;p&gt;为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   &lt;/p&gt;
&lt;h4 id=&quot;步骤2：确保开始条件是正确的&quot;&gt;&lt;a href=&quot;#步骤2：确保开始条件是正确的&quot; class=&quot;headerlink&quot; title=&quot;步骤2：确保开始条件是正确的&quot;&gt;&lt;/a&gt;步骤2：确保开始条件是正确的&lt;/h4&gt;&lt;p&gt;f(0) = 0;&lt;br&gt;f(1) = 1; &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static int f(int n){
    if(n &amp;lt;= 2) return n;
    int x = f(n-1) + f(n-2);
    return x;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;递归方法的时间复杂度指数为n，这里会有很多冗余计算。&lt;br&gt;    f(5)&lt;br&gt;    f(4) + f(3)&lt;br&gt;    f(3) + f(2) + f(2) + f(1)&lt;br&gt;    f(2) + f(1) + f(2) + f(2) + f(1)&lt;/p&gt;
&lt;p&gt;该递归可以很简单地转换为迭代。&lt;br&gt;    public static int f(int n) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    if (n &amp;lt;= 2){
        return n;
    }

    int first = 1, second = 2;
    int third = 0;

    for (int i = 3; i &amp;lt;= n; i++) {
        third = first + second;
        first = second;
        second = third;
    }

    return third;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 &lt;a href=&quot;http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;看看。&lt;/p&gt;
&lt;h3 id=&quot;7-动态规划&quot;&gt;&lt;a href=&quot;#7-动态规划&quot; class=&quot;headerlink&quot; title=&quot;7. 动态规划&quot;&gt;&lt;/a&gt;7. 动态规划&lt;/h3&gt;&lt;p&gt;动态规划主要用来解决如下技术问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过较小的子例来解决一个实例；&lt;/li&gt;
&lt;li&gt;对于一个较小的实例，可能需要许多个解决方案；&lt;/li&gt;
&lt;li&gt;把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;附加空间用来节省时间。&lt;br&gt;上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：&lt;br&gt;  public static int[] A = new int[100];&lt;/p&gt;
&lt;p&gt;  public static int f3(int n) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (n &amp;lt;= 2)
    A[n]= n;

if(A[n] &amp;gt; 0)
    return A[n];
else
    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!
return A[n];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些基于动态规划的算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编辑距离&lt;/li&gt;
&lt;li&gt;最长回文子串&lt;/li&gt;
&lt;li&gt;单词分割&lt;/li&gt;
&lt;li&gt;最大的子数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;8-位操作&quot;&gt;&lt;a href=&quot;#8-位操作&quot; class=&quot;headerlink&quot; title=&quot;8. 位操作&quot;&gt;&lt;/a&gt;8. 位操作&lt;/h3&gt;&lt;p&gt;位操作符：&lt;br&gt;&lt;img src=&quot;http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从一个给定的数n中找位i（i从0开始，然后向右开始）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static boolean getBit(int num, int i){
    int result = num &amp;amp; (1&amp;lt;&amp;lt;i);

    if(result == 0){
        return false;
    }else{
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，获取10的第二位：&lt;br&gt;    i=1, n=10&lt;br&gt;    1&amp;lt;&amp;lt;1= 10&lt;br&gt;    1010&amp;amp;10=10&lt;br&gt;    10 is not 0, so return true;&lt;/p&gt;
&lt;p&gt;典型的位算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find Single Number&lt;/li&gt;
&lt;li&gt;Maximum Binary Gap&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;9-概率&quot;&gt;&lt;a href=&quot;#9-概率&quot; class=&quot;headerlink&quot; title=&quot;9. 概率&quot;&gt;&lt;/a&gt;9. 概率&lt;/h3&gt;&lt;p&gt;通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;public static double caculateProbability(int n){
    double x = 1; 

    for(int i=0; i&amp;lt;n; i++){
        x *=  (365.0-i)/365.0;
    }

    double pro = Math.round((1-x) * 100);
    return pro/100;
}I
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;calculateProbability(50) = 0.97&lt;/p&gt;
&lt;h3 id=&quot;10-组合和排列&quot;&gt;&lt;a href=&quot;#10-组合和排列&quot; class=&quot;headerlink&quot; title=&quot;10. 组合和排列&quot;&gt;&lt;/a&gt;10. 组合和排列&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;组合和排列的主要差别在于顺序是否重要。&lt;br&gt;例1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？&lt;br&gt;例2：&lt;br&gt;有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于它们的一些常见算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排列&lt;/li&gt;
&lt;li&gt;排列2&lt;/li&gt;
&lt;li&gt;排列顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来自：&lt;a href=&quot;http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代码面试最常用的10大算法&quot;&gt;&lt;a href=&quot;#代码面试最常用的10大算法&quot; class=&quot;headerlink&quot; title=&quot;代码面试最常用的10大算法&quot;&gt;&lt;/a&gt;代码面试最常用的10大算法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;面试也是一门学问，在面试之
    
    </summary>
    
    
      <category term="算法" scheme="http://gdky005.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>推荐processon 让流程图也可以共享</title>
    <link href="http://gdky005.com/2016/02/25/%E6%8E%A8%E8%8D%90processon-%E8%AE%A9%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%85%B1%E4%BA%AB/"/>
    <id>http://gdky005.com/2016/02/25/推荐processon-让流程图也可以共享/</id>
    <published>2016-02-25T02:32:02.000Z</published>
    <updated>2016-04-19T13:17:13.000Z</updated>
    
    <content type="html">&lt;p&gt;推荐一个流程图共享的网站：&lt;br&gt;&lt;a href=&quot;https://www.processon.com/popular&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.processon.com/popular&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg&quot; alt=&quot;https://www.processon.com/view/56ca927ce4b0362f22d848b5&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://www.processon.com/view/56ca927ce4b0362f22d848b5&quot; title=&quot;原样图&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原样图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。&lt;/p&gt;
&lt;h3 id=&quot;例如：&quot;&gt;&lt;a href=&quot;#例如：&quot; class=&quot;headerlink&quot; title=&quot;例如：&quot;&gt;&lt;/a&gt;例如：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/557051bee4b0d6a77d619124&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;IOS开发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/55783184e4b0d6a77d9f9560&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前端技能树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/555097e7e4b09739f4652bf3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Service总结1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/5550a05ee4b09739f46585b0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Service总结2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android测试工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/55f69023e4b0a8c6fae84984&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中主要类的关系图 Activity Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/55110a6ee4b00af64b0c3cba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;APP开发人员技能树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/568bc9eae4b002e52c0fb427&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EventBus源码分析简要图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/561ccd9de4b07efc017ca19b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android小说阅读器部分计划及流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/562847b4e4b04931dccccbfe&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;View绘制流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/view/550cf083e4b0b74dae7c2c7d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Drawable分类汇总&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;推荐一个流程图共享的网站：&lt;br&gt;&lt;a href=&quot;https://www.processon.com/popular&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.processon.com/popular&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JADX反编译源码更easy</title>
    <link href="http://gdky005.com/2016/02/24/APK%E5%8F%8D%E7%BC%96%E8%AF%91Jadx/"/>
    <id>http://gdky005.com/2016/02/24/APK反编译Jadx/</id>
    <published>2016-02-24T03:54:09.000Z</published>
    <updated>2016-04-19T13:17:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;JADX反编译源码更easy&quot;&gt;&lt;a href=&quot;#JADX反编译源码更easy&quot; class=&quot;headerlink&quot; title=&quot;JADX反编译源码更easy&quot;&gt;&lt;/a&gt;JADX反编译源码更easy&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Command line and GUI tools for produce Java source code from Android Dex and Apk files&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Downloads&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://drone.io/github.com/skylot/jadx/files&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unstable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;from &lt;a href=&quot;https://github.com/skylot/jadx/releases&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;from &lt;a href=&quot;http://sourceforge.net/projects/jadx/files/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;sourceforge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考地址：&lt;a href=&quot;#&quot;&gt; https://github.com/skylot/jadx &lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JADX反编译源码更easy&quot;&gt;&lt;a href=&quot;#JADX反编译源码更easy&quot; class=&quot;headerlink&quot; title=&quot;JADX反编译源码更easy&quot;&gt;&lt;/a&gt;JADX反编译源码更easy&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一个Android
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android开发者提升技能水平的大招</title>
    <link href="http://gdky005.com/2016/02/19/Android%E5%BC%80%E5%8F%91%E8%80%85%E6%8F%90%E5%8D%87%E6%8A%80%E8%83%BD%E6%B0%B4%E5%B9%B3%E7%9A%84%E5%A4%A7%E6%8B%9B/"/>
    <id>http://gdky005.com/2016/02/19/Android开发者提升技能水平的大招/</id>
    <published>2016-02-19T09:40:14.000Z</published>
    <updated>2016-04-19T13:17:13.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;br&gt;&lt;br&gt;国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;参加活动，沙龙，技术聚会：&quot;&gt;&lt;a href=&quot;#参加活动，沙龙，技术聚会：&quot; class=&quot;headerlink&quot; title=&quot;参加活动，沙龙，技术聚会：&quot;&gt;&lt;/a&gt;参加活动，沙龙，技术聚会：&lt;/h3&gt;&lt;p&gt;参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。&lt;/p&gt;
&lt;h3 id=&quot;参加培训：&quot;&gt;&lt;a href=&quot;#参加培训：&quot; class=&quot;headerlink&quot; title=&quot;参加培训：&quot;&gt;&lt;/a&gt;参加培训：&lt;/h3&gt;&lt;p&gt;公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。&lt;/p&gt;
&lt;h3 id=&quot;参加讨论会：&quot;&gt;&lt;a href=&quot;#参加讨论会：&quot; class=&quot;headerlink&quot; title=&quot;参加讨论会：&quot;&gt;&lt;/a&gt;参加讨论会：&lt;/h3&gt;&lt;p&gt;参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。&lt;/p&gt;
&lt;h3 id=&quot;回答问题：&quot;&gt;&lt;a href=&quot;#回答问题：&quot; class=&quot;headerlink&quot; title=&quot;回答问题：&quot;&gt;&lt;/a&gt;回答问题：&lt;/h3&gt;&lt;p&gt;个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。&lt;/p&gt;
&lt;h3 id=&quot;边吃边学：&quot;&gt;&lt;a href=&quot;#边吃边学：&quot; class=&quot;headerlink&quot; title=&quot;边吃边学：&quot;&gt;&lt;/a&gt;边吃边学：&lt;/h3&gt;&lt;p&gt;如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。&lt;/p&gt;
&lt;h3 id=&quot;加入一个开源项目：&quot;&gt;&lt;a href=&quot;#加入一个开源项目：&quot; class=&quot;headerlink&quot; title=&quot;加入一个开源项目：&quot;&gt;&lt;/a&gt;加入一个开源项目：&lt;/h3&gt;&lt;p&gt;开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。&lt;/p&gt;
&lt;h3 id=&quot;读书，读代码，读博客：&quot;&gt;&lt;a href=&quot;#读书，读代码，读博客：&quot; class=&quot;headerlink&quot; title=&quot;读书，读代码，读博客：&quot;&gt;&lt;/a&gt;读书，读代码，读博客：&lt;/h3&gt;&lt;p&gt;可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。&lt;/p&gt;
&lt;h3 id=&quot;发表博客：&quot;&gt;&lt;a href=&quot;#发表博客：&quot; class=&quot;headerlink&quot; title=&quot;发表博客：&quot;&gt;&lt;/a&gt;发表博客：&lt;/h3&gt;&lt;p&gt;编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。&lt;/p&gt;
&lt;h3 id=&quot;通过做Kata来实践：&quot;&gt;&lt;a href=&quot;#通过做Kata来实践：&quot; class=&quot;headerlink&quot; title=&quot;通过做Kata来实践：&quot;&gt;&lt;/a&gt;通过做Kata来实践：&lt;/h3&gt;&lt;p&gt;Kata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。&lt;/p&gt;
&lt;h3 id=&quot;写书：&quot;&gt;&lt;a href=&quot;#写书：&quot; class=&quot;headerlink&quot; title=&quot;写书：&quot;&gt;&lt;/a&gt;写书：&lt;/h3&gt;&lt;p&gt;在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。&lt;/p&gt;
&lt;p&gt;这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。&lt;/p&gt;
&lt;h3 id=&quot;看视频教程，听播客，看在线研讨会：&quot;&gt;&lt;a href=&quot;#看视频教程，听播客，看在线研讨会：&quot; class=&quot;headerlink&quot; title=&quot;看视频教程，听播客，看在线研讨会：&quot;&gt;&lt;/a&gt;看视频教程，听播客，看在线研讨会：&lt;/h3&gt;&lt;p&gt;从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。&lt;/p&gt;
&lt;p&gt;在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来自：&lt;a href=&quot;#&quot;&gt; http://mobile.51cto.com/anews-417838.htm &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;#&quot;&gt; https://www.zhihu.com/question/20217218 &lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;br&gt;国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improv
    
    </summary>
    
    
      <category term="技能提升" scheme="http://gdky005.com/tags/%E6%8A%80%E8%83%BD%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
</feed>
