<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤独狂饮</title>
  <subtitle>只要有百分之一的梦想，就要付出百分之百的努力。努力不一定成功，但是不努力就一定不会成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gdky005.com/"/>
  <updated>2016-06-20T10:36:13.000Z</updated>
  <id>http://gdky005.com/</id>
  
  <author>
    <name>gdky005</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Android Studio 内存分析工具</title>
    <link href="http://gdky005.com/2016/06/20/%E4%BD%BF%E7%94%A8-Android-Studio-%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <id>http://gdky005.com/2016/06/20/使用-Android-Studio-内存分析工具/</id>
    <published>2016-06-20T10:33:33.000Z</published>
    <updated>2016-06-20T10:36:13.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;App的内存使用可以通过以下三个工具分析：&quot;&gt;&lt;a href=&quot;#App的内存使用可以通过以下三个工具分析：&quot; class=&quot;headerlink&quot; title=&quot;App的内存使用可以通过以下三个工具分析：&quot;&gt;&lt;/a&gt;App的内存使用可以通过以下三个工具分析：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Heap Viewer&lt;/li&gt;
&lt;li&gt;Memory Monitor&lt;/li&gt;
&lt;li&gt;Allocation Tracker&lt;br&gt;并且，这个三个是互补的可视化内存分析工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;使用 Memory Monitor 可以查找非正常的 GC 导致的性能问题。&lt;/li&gt;
&lt;li&gt;运行 Heap Viewer可以确认出 object 类型是不是 不必要的，或者分配的内存超出我们的预期估计，可能是持续增长，我们预期是在不需要的时候，可以回收内存。&lt;/li&gt;
&lt;li&gt;使用 Allocation Tracker 可以确定出你的代码中存在的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Memory-Monitor&quot;&gt;&lt;a href=&quot;#Memory-Monitor&quot; class=&quot;headerlink&quot; title=&quot;Memory Monitor&quot;&gt;&lt;/a&gt;Memory Monitor&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示你的 App 当前某一时刻的内存状态（包括可用内存，和占用内存）的曲线图，用电压跌落 的方式展示 Garbage Collection (GC) 的现象。&lt;/li&gt;
&lt;li&gt;可以方便的看出 app 的卡顿是否是由于频繁 GC（内存 频繁回收，一个 app 在手机上分配的内存是一定的，但手机厂商决定手机内存的大小，因此当我们的 app 的内存达到一定的峰值的时候，系统就会回收内存，保证 App的正常运行） 导致。&lt;/li&gt;
&lt;li&gt;提供一种快速看出App 是否是由于 运行内存不足 而导致的 crash(崩溃)的方法。&lt;/li&gt;
&lt;li&gt;当前运行的app ，每一秒更新占用内存的状况。&lt;/li&gt;
&lt;li&gt;有助于识别潜在的内存泄漏。&lt;/li&gt;
&lt;li&gt;有助于识别 App 的 GC模式,并确定它们是否正常和你所希望的样子。&lt;/li&gt;
&lt;li&gt;它很容易使用，并且很容易看明白&lt;/li&gt;
&lt;li&gt;然而，Memory Monitor 不能告诉你哪些对象是有问题的，或者给你指出代码中存在的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Heap-Viewer&quot;&gt;&lt;a href=&quot;#Heap-Viewer&quot; class=&quot;headerlink&quot; title=&quot;Heap Viewer&quot;&gt;&lt;/a&gt;Heap Viewer&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_02.png&quot; alt=&quot;Allocation Tracker&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据类型 分配许多对象 的快照图。&lt;/li&gt;
&lt;li&gt;每一次的样本数据 是自动采集或者你手动触发。&lt;/li&gt;
&lt;li&gt;帮助确定哪些对象类型可能是内存泄漏。&lt;/li&gt;
&lt;li&gt;然而，你 &lt;strong&gt;必须自己寻找&lt;/strong&gt; 在一段时间内曲线图的变化发送了什么。 （重点，需要&lt;strong&gt;采集两次以上&lt;/strong&gt;的数据进行&lt;strong&gt;对比&lt;/strong&gt;，才能明确，出问题的地方在哪里）&lt;h3 id=&quot;Allocation-Tracker&quot;&gt;&lt;a href=&quot;#Allocation-Tracker&quot; class=&quot;headerlink&quot; title=&quot;Allocation Tracker&quot;&gt;&lt;/a&gt;Allocation Tracker&lt;/h3&gt;&lt;a href=&quot;#&quot; title=&quot;Allocation Tracker&quot;&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_03.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;显示你的代码在在一定的时间内分配的 object 类型，Object 的大小，分配的线程和堆栈的大小&lt;/li&gt;
&lt;li&gt;帮助识别 内存的改变是通过 循环分配或重新分配。&lt;/li&gt;
&lt;li&gt;可以结合使用 Heap Viewer 来跟踪内存泄露，例如，如果你看到了一个 bitmap 对象 在 heap 上分配的大小。你可以使用 Allocation Tracker 找到它分配的位置。&lt;/li&gt;
&lt;li&gt;然而，它需要时间和经验来学习理解这个工具的使用。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;App的内存使用可以通过以下三个工具分析：&quot;&gt;&lt;a href=&quot;#App的内存使用可以通过以下三个工具分析：&quot; class=&quot;headerlink&quot; title=&quot;App的内存使用可以通过以下三个工具分析：&quot;&gt;&lt;/a&gt;App的内存使用可以通过以下三个工具分析：&lt;/
    
    </summary>
    
      <category term="AndroidStudio" scheme="http://gdky005.com/categories/AndroidStudio/"/>
    
    
      <category term="AndroidStudio" scheme="http://gdky005.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>网络请求的 UA</title>
    <link href="http://gdky005.com/2016/06/20/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84-UA/"/>
    <id>http://gdky005.com/2016/06/20/网络请求的-UA/</id>
    <published>2016-06-20T10:27:54.000Z</published>
    <updated>2016-06-20T10:29:18.000Z</updated>
    
    <content type="html">&lt;p&gt;一般我们的客户端请求头里面都会有一个 User Agent 的参数，默认请求下 会直接获取系统里面的一些参数信息，然后发送到服务器。服务器就知道这个设备 大体情况，也可以根据这个来处理，或者禁用某些设备。&lt;br&gt;一般定义的 UA 应该包含下面这些东西（当前也可以删减或去掉的）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appName + versionName + versonCode + 渠道号 + 设备基本信息&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里写一些大体的代码，其他可以自行封装：&lt;/p&gt;
&lt;p&gt;拼接数据：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appName: mContext.getString(R.string.appname)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;versionName:  DeviceUtil.getVersionName(mContext)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;versonCode: DeviceUtil.getVersionCode(mContext)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;渠道号：DeviceUtil.getChannelTag(mContext)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设备基本信息:&lt;br&gt;&lt;code&gt;build.MODEL         Nexus 6&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build.MANUFACTURER  motorola&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build.BRAND            google&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;build.FINGERPRINT    google/shamu/shamu:6.0.1/MMB29S/2489379:user/release-keys&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Build.VERSION.RELEASE 6.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Build.VERSION.SDKINT 23&lt;/code&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一般我们的客户端请求头里面都会有一个 User Agent 的参数，默认请求下 会直接获取系统里面的一些参数信息，然后发送到服务器。服务器就知道这个设备 大体情况，也可以根据这个来处理，或者禁用某些设备。&lt;br&gt;一般定义的 UA 应该包含下面这些东西（当前也可以删减或去掉的
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>从 volley 切换到 OkHttp 遇到的坑</title>
    <link href="http://gdky005.com/2016/06/20/%E4%BB%8E-volley-%E5%88%87%E6%8D%A2%E5%88%B0-OkHttp-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://gdky005.com/2016/06/20/从-volley-切换到-OkHttp-遇到的坑/</id>
    <published>2016-06-20T10:17:30.000Z</published>
    <updated>2016-06-20T10:17:59.000Z</updated>
    
    <content type="html">&lt;p&gt;这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。&lt;/p&gt;
&lt;p&gt;之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.&lt;/p&gt;
&lt;h3 id=&quot;代理异常？&quot;&gt;&lt;a href=&quot;#代理异常？&quot; class=&quot;headerlink&quot; title=&quot;代理异常？&quot;&gt;&lt;/a&gt;代理异常？&lt;/h3&gt;&lt;p&gt;切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。&lt;/p&gt;
&lt;p&gt;根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 &lt;/p&gt;
&lt;p&gt;之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？&lt;/p&gt;
&lt;p&gt;经过对比后发现：原来是 之前写 volley 的时候是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HttpURLConnection connection;
    if (&amp;quot;https&amp;quot;.equals(url.getProtocol())) {
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                InetSocketAddress
                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));
        connection = (HttpURLConnection) url
                .openConnection(proxy);
        connection.addRequestProperty(&amp;quot;Proxy-Authorization&amp;quot;,
                &amp;quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&amp;quot;);
    } else {
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                InetSocketAddress
                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));
        connection = (HttpURLConnection) url
                .openConnection(proxy);
        connection.addRequestProperty(&amp;quot;Authorization&amp;quot;,
                &amp;quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&amp;quot;);
    }
    connection.addRequestProperty(&amp;quot;Proxy-Connection&amp;quot;, &amp;quot;Keep-Alive&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。&lt;/p&gt;
&lt;p&gt;但是在 okhttp 里面貌似是不需要区分的。只需要这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
     * 设置联通流量 代理功能
     * @param builder
     */
    private void setUnicomProxy(OkHttpClient.Builder builder) {
        //添加联通代理功能
        if (TrafficUtil.getUnicomProxyAvailable()) {
            Authenticator proxyAuthenticator = new Authenticator() {
                @Override
                public okhttp3.Request authenticate(Route route, Response response) throws IOException {
                    return response.request().newBuilder().header(&amp;quot;Proxy-Authorization&amp;quot;, &amp;quot;Basic &amp;quot; +
                            &amp;quot;MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&amp;quot;).header(&amp;quot;Proxy-Connection&amp;quot;,
                            &amp;quot;Keep-Alive&amp;quot;).build();
                }
            };

            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,
                    FLOWPACKAGETCPPORT)));
            builder.proxyAuthenticator(proxyAuthenticator);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就可以了。&lt;br&gt;&lt;code&gt;FLOWPACKAGEHOST -&amp;gt; test.proxy.1111.com (这是域名)&lt;/code&gt;&lt;br&gt;&lt;code&gt;FLOWPACKAGETCPPORT -&amp;gt; 8143&lt;/code&gt;&lt;br&gt;这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;SSL-STL证书-出错？&quot;&gt;&lt;a href=&quot;#SSL-STL证书-出错？&quot; class=&quot;headerlink&quot; title=&quot;SSL/STL证书 出错？&quot;&gt;&lt;/a&gt;SSL/STL证书 出错？&lt;/h3&gt;&lt;p&gt;这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：&lt;br&gt;     @NonNull&lt;br&gt;        private SSLContext getSslContext(InputStream… certificates) {&lt;br&gt;            SSLContext sslContext = null;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        try {
            CertificateFactory certificateFactory = CertificateFactory.getInstance(&amp;quot;X.509&amp;quot;);
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null);
            int index = 0;
            for (InputStream certificate : certificates) {
                String certificateAlias = Integer.toString(index++);
                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate
                        (certificate));
                try {
                    if (certificate != null)
                        certificate.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            sslContext = SSLContext.getInstance(&amp;quot;TLS&amp;quot;);

            TrustManagerFactory trustManagerFactory =
                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

            trustManagerFactory.init(keyStore);
            sslContext.init(null, trustManagerFactory.getTrustManagers(),
                    new SecureRandom());

        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        } catch (Exception e){
            e.printStackTrace();
        }   finally {
        }

        return sslContext;
    }

/**
     * 启用 OkHttps 域名校验功能
     * @param builder
     */
    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {
        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R
                .raw.kl_magic));

        if (sslContext != null) {
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
                    return hostnameVerifier.verify(&amp;quot;xxx.com&amp;quot;, session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)
                }
            });
            builder.sslSocketFactory(sslContext.getSocketFactory());
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这句是非常重要的：&lt;br&gt;&lt;code&gt;hostnameVerifier.verify(&amp;quot;xxx.com&amp;quot;, session);&lt;/code&gt;主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。&lt;/p&gt;
&lt;p&gt;之前尝试过使用 使用&lt;br&gt;    builder.hostnameVerifier(new AllowAllHostnameVerifier());&lt;/p&gt;
&lt;p&gt;这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。&lt;/p&gt;
&lt;h3 id=&quot;post-参数不能为空？&quot;&gt;&lt;a href=&quot;#post-参数不能为空？&quot; class=&quot;headerlink&quot; title=&quot;post 参数不能为空？&quot;&gt;&lt;/a&gt;post 参数不能为空？&lt;/h3&gt;&lt;p&gt;这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).&lt;/p&gt;
&lt;p&gt;但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 &lt;a href=&quot;https://github.com/square/okhttp/issues/751&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;okhttp issue&lt;/a&gt; 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。&lt;/p&gt;
&lt;p&gt;具体参考这个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void addRequest(int method, final Map&amp;lt;String, String&amp;gt; params, final String baseUrl,
                           final TypeReference&amp;lt;? extends BaseResponse&amp;gt; type, final JsonResultCallback callback) {
            ......
          if (params.size() == 0 &amp;amp;&amp;amp; method == Request.Method.POST)
            params.put(&amp;quot;temp&amp;quot;, &amp;quot;temp&amp;quot;); //解决 method POST must have a request body.;
            ......
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个问题解决后，基本就可以放心使用了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。&lt;/p&gt;
&lt;p&gt;之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案：
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
  <entry>
    <title>分享Java Collection 的一张图</title>
    <link href="http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/"/>
    <id>http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/</id>
    <published>2016-06-20T09:09:48.000Z</published>
    <updated>2016-06-20T10:18:56.000Z</updated>
    
    <content type="html">&lt;p&gt;在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等&lt;/p&gt;
&lt;p&gt;我们可以看出他们之间的关系以及差别。&lt;/p&gt;
&lt;p&gt;例如：HashMap, HastTable,  Vector 和 LinkedList等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png&quot; alt=&quot;Java Collection Cheat Sheet&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等&lt;/p&gt;
&lt;p&gt;我们可以看出他们之间的关系以及差别。&lt;/p&gt;
&lt;p&gt;例如：HashMap,
    
    </summary>
    
      <category term="Java" scheme="http://gdky005.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://gdky005.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Okio 简单处理I/O操作</title>
    <link href="http://gdky005.com/2016/06/20/Okio-%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86I-O%E6%93%8D%E4%BD%9C/"/>
    <id>http://gdky005.com/2016/06/20/Okio-简单处理I-O操作/</id>
    <published>2016-06-20T08:59:24.000Z</published>
    <updated>2016-06-20T10:18:47.000Z</updated>
    
    <content type="html">&lt;p&gt;Android 善用Okio简化处理I/O操作&lt;br&gt;Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile &amp;apos;com.squareup.okio:okio:1.6.0&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ohio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。&lt;/p&gt;
&lt;p&gt;而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BufferedSink writeLong(long v) throws IOException {
    if (this.closed) {
        throw new IllegalStateException(&amp;quot;closed&amp;quot;);
    } else {
        this.buffer.writeLong(v);
        return this.emitCompleteSegments();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BufferedSink emitCompleteSegments() throws IOException {
        if(this.closed) {
            throw new IllegalStateException(&amp;quot;closed&amp;quot;);
        } else {
            long byteCount = this.buffer.completeSegmentByteCount();
            if(byteCount &amp;gt; 0L) {
                this.sink.write(this.buffer, byteCount);
            }
            return this;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两个实现类的内部的所有方法都是类似的，这里不一一展开。&lt;br&gt;而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final class SegmentPool {
    static final long MAX_SIZE = 65536L;
    static Segment next;
    static long byteCount;

    private SegmentPool() {
    }

    static Segment take() {
        Class var0 = SegmentPool.class;

        synchronized(SegmentPool.class) {
            if(next != null) {
                Segment result = next;
                next = result.next;
                result.next = null;
                byteCount -= 2048L;
                return result;
            }
        }
        return new Segment();
    }

    static void recycle(Segment segment) {
        if(segment.next == null &amp;amp;&amp;amp; segment.prev == null) {
            if(!segment.shared) {
                Class var1 = SegmentPool.class;

                synchronized(SegmentPool.class) {
                    if(byteCount + 2048L &amp;lt;= 65536L) {
                        byteCount += 2048L;
                        segment.next = next;
                        segment.pos = segment.limit = 0;
                        next = segment;
                    }
                }
            }
        } else {
            throw new IllegalArgumentException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。&lt;/p&gt;
&lt;p&gt;而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Okio.buffer(sink)
Okio.buffer(source)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Okio.sink(new File(&amp;quot;***&amp;quot;));
Okio.sink(new FileOutputStream(new File(&amp;quot;***&amp;quot;)));
Okio.sink(new Socket(&amp;quot;***&amp;quot;,8888));

Okio.source(new File(&amp;quot;***&amp;quot;));
Okio.source(new FileInputStream(new File(&amp;quot;***&amp;quot;)));
Okio.source(new Socket(&amp;quot;****&amp;quot;,8888));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Source source = null;
        BufferedSource bufferedSource = null;

        try {
            File file = new File(&amp;quot;resources/test.txt&amp;quot;);
            source = Okio.source(file);
            bufferedSource = Okio.buffer(source);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }

        Sink sink = null;
        BufferedSink bufferedSink = null;
        try {
            File dest = new File(&amp;quot;resources/dest.txt&amp;quot;);
            sink = Okio.sink(dest);
            bufferedSink = Okio.buffer(sink);
            bufferedSink.writeUtf8(&amp;quot;11111111111&amp;quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Sink sink = null;
        BufferedSink bufferedSink = null;
        GzipSink gzipSink=null;

        try {
            File dest = new File(&amp;quot;resources/gzip.txt&amp;quot;);
            sink = Okio.sink(dest);
            gzipSink=new GzipSink(sink);
            bufferedSink = Okio.buffer(gzipSink);
            bufferedSink.writeUtf8(&amp;quot;android vs ios&amp;quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }

        Source source = null;
        BufferedSource bufferedSource = null;
        GzipSource gzipSource=null;

        try {
            File file = new File(&amp;quot;resources/gzip.txt&amp;quot;);
            source = Okio.source(file);
            gzipSource=new GzipSource(source);
            bufferedSource = Okio.buffer(gzipSource);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。&lt;br&gt;对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class GzipUtil {
        /**
         * GZIP压缩
         *
         * @param data
         * @return
         * @throws Exception
         */
        public static byte[] gzip(byte[] data) throws Exception {
            if (data == null || data.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            GZIPOutputStream zos;
            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));
            byte[] buf = new byte[512];
            int len;

            try {
                zos = new GZIPOutputStream(out);
                while ((len = bis.read(buf)) != -1) {
                    zos.write(buf, 0, len);
                    zos.flush();
                }
                bis.close();
                zos.close();
                return out.toByteArray();
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e2) {
                    }
                }
            }
        }

        /**
         * Gzip解压缩
         *
         * @param b
         * @return
         */
        public static byte[] unGzip(byte[] b) {
            if (b == null || b.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(b);

            try {
                GZIPInputStream gunzip = new GZIPInputStream(in);
                byte[] buffer = new byte[256];
                int n;
                while ((n = gunzip.read(buffer)) &amp;gt;= 0) {
                    out.write(buffer, 0, n);
                }
                return out.toByteArray();
            } catch (IOException e) {
                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), &amp;quot;uncompress error&amp;quot;, e);
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                } catch (Exception e2) {
                }
            }
            return null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。&lt;/p&gt;
&lt;p&gt;在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android 善用Okio简化处理I/O操作&lt;br&gt;Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便
    
    </summary>
    
      <category term="okio" scheme="http://gdky005.com/categories/okio/"/>
    
    
      <category term="okio" scheme="http://gdky005.com/tags/okio/"/>
    
  </entry>
  
</feed>
