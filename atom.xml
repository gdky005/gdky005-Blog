<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤独狂饮</title>
  <subtitle>只要有百分之一的梦想，就要付出百分之百的努力。努力不一定成功，但是不努力就一定不会成功！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gdky005.com/"/>
  <updated>2016-06-20T09:01:15.000Z</updated>
  <id>http://gdky005.com/</id>
  
  <author>
    <name>gdky005</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Okio 简单处理I/O操作</title>
    <link href="http://gdky005.com/2016/06/20/Okio-%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86I-O%E6%93%8D%E4%BD%9C/"/>
    <id>http://gdky005.com/2016/06/20/Okio-简单处理I-O操作/</id>
    <published>2016-06-20T08:59:24.000Z</published>
    <updated>2016-06-20T09:01:15.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Okio-简单处理I-O操作&quot;&gt;&lt;a href=&quot;#Okio-简单处理I-O操作&quot; class=&quot;headerlink&quot; title=&quot;Okio 简单处理I/O操作&quot;&gt;&lt;/a&gt;Okio 简单处理I/O操作&lt;/h1&gt;&lt;p&gt;Android 善用Okio简化处理I/O操作&lt;br&gt;Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile &amp;apos;com.squareup.okio:okio:1.6.0&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ohio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;BufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。&lt;/p&gt;
&lt;p&gt;而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BufferedSink writeLong(long v) throws IOException {
    if (this.closed) {
        throw new IllegalStateException(&amp;quot;closed&amp;quot;);
    } else {
        this.buffer.writeLong(v);
        return this.emitCompleteSegments();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public BufferedSink emitCompleteSegments() throws IOException {
        if(this.closed) {
            throw new IllegalStateException(&amp;quot;closed&amp;quot;);
        } else {
            long byteCount = this.buffer.completeSegmentByteCount();
            if(byteCount &amp;gt; 0L) {
                this.sink.write(this.buffer, byteCount);
            }
            return this;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两个实现类的内部的所有方法都是类似的，这里不一一展开。&lt;br&gt;而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;final class SegmentPool {
    static final long MAX_SIZE = 65536L;
    static Segment next;
    static long byteCount;

    private SegmentPool() {
    }

    static Segment take() {
        Class var0 = SegmentPool.class;

        synchronized(SegmentPool.class) {
            if(next != null) {
                Segment result = next;
                next = result.next;
                result.next = null;
                byteCount -= 2048L;
                return result;
            }
        }
        return new Segment();
    }

    static void recycle(Segment segment) {
        if(segment.next == null &amp;amp;&amp;amp; segment.prev == null) {
            if(!segment.shared) {
                Class var1 = SegmentPool.class;

                synchronized(SegmentPool.class) {
                    if(byteCount + 2048L &amp;lt;= 65536L) {
                        byteCount += 2048L;
                        segment.next = next;
                        segment.pos = segment.limit = 0;
                        next = segment;
                    }
                }
            }
        } else {
            throw new IllegalArgumentException();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。&lt;/p&gt;
&lt;p&gt;而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Okio.buffer(sink)
Okio.buffer(source)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Okio.sink(new File(&amp;quot;***&amp;quot;));
Okio.sink(new FileOutputStream(new File(&amp;quot;***&amp;quot;)));
Okio.sink(new Socket(&amp;quot;***&amp;quot;,8888));

Okio.source(new File(&amp;quot;***&amp;quot;));
Okio.source(new FileInputStream(new File(&amp;quot;***&amp;quot;)));
Okio.source(new Socket(&amp;quot;****&amp;quot;,8888));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Source source = null;
        BufferedSource bufferedSource = null;

        try {
            File file = new File(&amp;quot;resources/test.txt&amp;quot;);
            source = Okio.source(file);
            bufferedSource = Okio.buffer(source);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }

        Sink sink = null;
        BufferedSink bufferedSink = null;
        try {
            File dest = new File(&amp;quot;resources/dest.txt&amp;quot;);
            sink = Okio.sink(dest);
            bufferedSink = Okio.buffer(sink);
            bufferedSink.writeUtf8(&amp;quot;11111111111&amp;quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
        Sink sink = null;
        BufferedSink bufferedSink = null;
        GzipSink gzipSink=null;

        try {
            File dest = new File(&amp;quot;resources/gzip.txt&amp;quot;);
            sink = Okio.sink(dest);
            gzipSink=new GzipSink(sink);
            bufferedSink = Okio.buffer(gzipSink);
            bufferedSink.writeUtf8(&amp;quot;android vs ios&amp;quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }

        Source source = null;
        BufferedSource bufferedSource = null;
        GzipSource gzipSource=null;

        try {
            File file = new File(&amp;quot;resources/gzip.txt&amp;quot;);
            source = Okio.source(file);
            gzipSource=new GzipSource(source);
            bufferedSource = Okio.buffer(gzipSource);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。&lt;br&gt;对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class GzipUtil {
        /**
         * GZIP压缩
         *
         * @param data
         * @return
         * @throws Exception
         */
        public static byte[] gzip(byte[] data) throws Exception {
            if (data == null || data.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            GZIPOutputStream zos;
            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));
            byte[] buf = new byte[512];
            int len;

            try {
                zos = new GZIPOutputStream(out);
                while ((len = bis.read(buf)) != -1) {
                    zos.write(buf, 0, len);
                    zos.flush();
                }
                bis.close();
                zos.close();
                return out.toByteArray();
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e2) {
                    }
                }
            }
        }

        /**
         * Gzip解压缩
         *
         * @param b
         * @return
         */
        public static byte[] unGzip(byte[] b) {
            if (b == null || b.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(b);

            try {
                GZIPInputStream gunzip = new GZIPInputStream(in);
                byte[] buffer = new byte[256];
                int n;
                while ((n = gunzip.read(buffer)) &amp;gt;= 0) {
                    out.write(buffer, 0, n);
                }
                return out.toByteArray();
            } catch (IOException e) {
                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), &amp;quot;uncompress error&amp;quot;, e);
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                } catch (Exception e2) {
                }
            }
            return null;
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。&lt;/p&gt;
&lt;p&gt;在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Okio-简单处理I-O操作&quot;&gt;&lt;a href=&quot;#Okio-简单处理I-O操作&quot; class=&quot;headerlink&quot; title=&quot;Okio 简单处理I/O操作&quot;&gt;&lt;/a&gt;Okio 简单处理I/O操作&lt;/h1&gt;&lt;p&gt;Android 善用Okio简化处理I/O操
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OkHttp3 源码分析【缓存策略】</title>
    <link href="http://gdky005.com/2016/06/20/OkHttp3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/OkHttp3-源码分析【缓存策略】/</id>
    <published>2016-06-20T08:35:10.000Z</published>
    <updated>2016-06-20T08:39:17.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;OkHttp3-源码分析【缓存策略】&quot;&gt;&lt;a href=&quot;#OkHttp3-源码分析【缓存策略】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3 源码分析【缓存策略】&quot;&gt;&lt;/a&gt;OkHttp3 源码分析【缓存策略】&lt;/h1&gt;&lt;p&gt;本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇&lt;/p&gt;
&lt;h3 id=&quot;Http-缓存基础知识&quot;&gt;&lt;a href=&quot;#Http-缓存基础知识&quot; class=&quot;headerlink&quot; title=&quot;Http 缓存基础知识&quot;&gt;&lt;/a&gt;Http 缓存基础知识&lt;/h3&gt;&lt;p&gt;分析源目前，我们先回顾一下 Http 的缓存 Header 的含义&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Expires&lt;br&gt;表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存&lt;br&gt; Expires: Thu, 12 Jan 2017 11:01:33 GMT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cache-Control&lt;br&gt;相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。&lt;/p&gt;
&lt;p&gt; Cache-Control: max-age=31536000, public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修订文件名（Reving Filenames）&lt;br&gt;如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery&lt;br&gt; upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;条件 get 请求 （Conditional GET Requests） 与 304&lt;br&gt;如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请求的方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modified-Date:&lt;br&gt;  Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端再次发送时，通过发送&lt;br&gt;    If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT&lt;/p&gt;
&lt;p&gt;交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETag&lt;br&gt;ETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了&lt;br&gt;  ETag: “5694c7ef-24dc”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端再次请求时，通过发送&lt;br&gt;    If-None-Match:”5694c7ef-24dc”&lt;/p&gt;
&lt;p&gt;交给服务器进行判断，如果还能使用缓存，服务器就返回 304&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;其他标签&lt;ul&gt;
&lt;li&gt;no-cache/no-store: 不使用缓存&lt;ul&gt;
&lt;li&gt;only-if-cached: 只使用缓存&lt;/li&gt;
&lt;li&gt;Date:The date and time that the message was sent&lt;/li&gt;
&lt;li&gt;Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;“only-if-cached”标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。&lt;br&gt;全部的标签，可以到&lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_header_fields&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里看&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h3&gt;&lt;p&gt;OkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;总体请求流程分析&lt;br&gt;CacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出&lt;br&gt;Input（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Request:&lt;br&gt;开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。&lt;/p&gt;
&lt;p&gt;cacheCandildate:&lt;br&gt;也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.&lt;/p&gt;
&lt;p&gt;当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;CacheStrategy 的加工过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CacheStrategy 使用 Factory模式进行构造，参数如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;InternalCache responseCache = Internal.instance.internalCache(client);
//cacheCandidate从disklurcache中获取
//request的url被md5序列化为key,进行缓存查询
Response cacheCandidate = responseCache != null ? responseCache.get(request) : null;
//请求与缓存
factory = new CacheStrategy.Factory(now, request, cacheCandidate);
cacheStrategy = factory.get();
//输出结果
networkRequest = cacheStrategy.networkRequest;
cacheResponse = cacheStrategy.cacheResponse;
//进行一大堆的if判断，内容同上表格
.....
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private CacheStrategy getCandidate() {
  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了
  if (cacheResponse == null) {
    //`没有缓存的网络请求,查上文的表可知是直接访问
    return new CacheStrategy(request, null);
  }

  // 如果缓存的TLS握手信息丢失,返回进行直接连接
  if (request.isHttps() &amp;amp;&amp;amp; cacheResponse.handshake() == null) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  //检测response的状态码,Expired时间,是否有no-cache标签
  if (!isCacheable(cacheResponse, request)) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  CacheControl requestCaching = request.cacheControl();
  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)
  //或者有ETag/Since标签(也就是条件GET请求)
  if (requestCaching.noCache() || hasConditions(request)) {
    //直接连接,把缓存判断交给服务器
    return new CacheStrategy(request, null);
  }
  //根据RFC协议计算
  //计算当前age的时间戳
  //now - sent + age (s)
  long ageMillis = cacheResponseAge();
  //大部分情况服务器设置为max-age
  long freshMillis = computeFreshnessLifetime();

  if (requestCaching.maxAgeSeconds() != -1) {
    //大部分情况下是取max-age
    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
  }

  long minFreshMillis = 0;
  if (requestCaching.minFreshSeconds() != -1) {
    //大部分情况下设置是0
    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
  }

  long maxStaleMillis = 0;
  //ParseHeader中的缓存控制信息
  CacheControl responseCaching = cacheResponse.cacheControl();
  if (!responseCaching.mustRevalidate() &amp;amp;&amp;amp; requestCaching.maxStaleSeconds() != -1) {
    //设置最大过期时间,一般设置为0
    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
  }

  //缓存在过期时间内,可以使用
  //大部分情况下是进行如下判断
  //now - sent + age + 0 &amp;lt; max-age + 0
  if (!responseCaching.noCache() &amp;amp;&amp;amp; ageMillis + minFreshMillis &amp;lt; freshMillis + maxStaleMillis) {
    //返回上次的缓存
    Response.Builder builder = cacheResponse.newBuilder();
    return new CacheStrategy(null, builder.build());
  }

  //缓存失效, 如果有etag等信息
  //进行发送`conditional`请求,交给服务器处理
  Request.Builder conditionalRequestBuilder = request.newBuilder();

  if (etag != null) {
    conditionalRequestBuilder.header(&amp;quot;If-None-Match&amp;quot;, etag);
  } else if (lastModified != null) {
    conditionalRequestBuilder.header(&amp;quot;If-Modified-Since&amp;quot;, lastModifiedString);
  } else if (servedDate != null) {
    conditionalRequestBuilder.header(&amp;quot;If-Modified-Since&amp;quot;, servedDateString);
  }
  //下面请求实质还说网络请求
  Request conditionalRequest = conditionalRequestBuilder.build();
  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,
      cacheResponse) : new CacheStrategy(conditionalRequest, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;太长不看的话，大多数常见的情况可以用这个估算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;now - sent + age &amp;lt; max-age
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;结论&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。&lt;/li&gt;
&lt;li&gt;OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 &lt;strong&gt;没有必要&lt;/strong&gt; 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 &lt;a href=&quot;https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;注释中&lt;/a&gt;。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.&lt;/li&gt;
&lt;li&gt;充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成&lt;/li&gt;
&lt;li&gt;可以使用 alt + space  快速预览某个函数&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/9cebbbd0eeab&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/9cebbbd0eeab&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OkHttp3-源码分析【缓存策略】&quot;&gt;&lt;a href=&quot;#OkHttp3-源码分析【缓存策略】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3 源码分析【缓存策略】&quot;&gt;&lt;/a&gt;OkHttp3 源码分析【缓存策略】&lt;/h1&gt;&lt;p&gt;本文专门分析
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OkHttp3源码分析【任务队列】</title>
    <link href="http://gdky005.com/2016/06/20/OkHttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/OkHttp3源码分析【任务队列】/</id>
    <published>2016-06-20T08:34:26.000Z</published>
    <updated>2016-06-20T08:42:06.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;a href=&quot;#OkHttp3源码分析【任务队列】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;/a&gt;OkHttp3源码分析【任务队列】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池基础&lt;/li&gt;
&lt;li&gt;反向代理模块&lt;/li&gt;
&lt;li&gt;OkHttp 的任务调度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。&lt;/p&gt;
&lt;h1 id=&quot;线程池基础&quot;&gt;&lt;a href=&quot;#线程池基础&quot; class=&quot;headerlink&quot; title=&quot;线程池基础&quot;&gt;&lt;/a&gt;线程池基础&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;线程池好处有哪些&lt;br&gt;线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：&lt;br&gt;如果一台服务完成一项任务的时间为 T&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T1 创建线程的时间
T2 在线程中执行任务的时间，包括线程间同步所需时间
T3 线程销毁的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。&lt;/p&gt;
&lt;p&gt;可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。&lt;/p&gt;
&lt;p&gt;线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过对线程缓存，减少创建和销毁的时间损失&lt;ul&gt;
&lt;li&gt;通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OkHttp 配置的线程池&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 OkHttp 中，使用如下构造了单例线程池&lt;br&gt;    public synchronized ExecutorService executorService() {&lt;br&gt;      if (executorService == null) {&lt;br&gt;        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,&lt;br&gt;            new SynchronousQueue&lt;runnable&gt;(), Util.threadFactory(“OkHttp Dispatcher”, false));&lt;br&gt;      }&lt;br&gt;      return executorService;&lt;br&gt;    }&lt;/runnable&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。&lt;/li&gt;
&lt;li&gt;int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃&lt;em&gt;处理机制&lt;/em&gt;来处理&lt;/li&gt;
&lt;li&gt;long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive&lt;/li&gt;
&lt;li&gt;TimeUnit unit: 时间单位，一般用秒&lt;/li&gt;
&lt;li&gt;BlockingQueue\&lt;runnable\&gt; workQueue:  工作队列&lt;/runnable\&gt;&lt;/li&gt;
&lt;li&gt;ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 “OkHttp Dispatcher” 的线程工厂。&lt;/p&gt;
&lt;p&gt;也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反向代理模型&quot;&gt;&lt;a href=&quot;#反向代理模型&quot; class=&quot;headerlink&quot; title=&quot;反向代理模型&quot;&gt;&lt;/a&gt;反向代理模型&lt;/h3&gt;&lt;p&gt;在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。&lt;/p&gt;
&lt;p&gt;我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现&lt;strong&gt;非阻塞、高并发连接&lt;/strong&gt;，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\&lt;readyasynccalls\&gt;对应 Nginx 的内部缓存&lt;/readyasynccalls\&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体成员如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maxRequests = 64：最大并发请求数为64&lt;/li&gt;
&lt;li&gt;maxRequestsPerHost = 5：每个主机最大请求数为5&lt;/li&gt;
&lt;li&gt;Dispatcher：分发者，也就是生产者（默认在主线程）&lt;/li&gt;
&lt;li&gt;AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）&lt;/li&gt;
&lt;li&gt;ExecutorService：消费者池（也就是线程池）&lt;/li&gt;
&lt;li&gt;Deque\&lt;readyasynccalls\&gt;：缓存（用数组实现，可自动扩容，无大小限制）&lt;/readyasynccalls\&gt;&lt;/li&gt;
&lt;li&gt;Deque\&lt;runningasynccalls\&gt;：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存&lt;/runningasynccalls\&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间&lt;/p&gt;
&lt;h3 id=&quot;OkHttp-的任务调度&quot;&gt;&lt;a href=&quot;#OkHttp-的任务调度&quot; class=&quot;headerlink&quot; title=&quot;OkHttp 的任务调度&quot;&gt;&lt;/a&gt;OkHttp 的任务调度&lt;/h3&gt;&lt;p&gt;当我们使用 OkHttp 的异步请求时，一般进行如下构造：&lt;br&gt;    OkHttpClient client = new OkHttpClient.Builder().build();&lt;br&gt;    Request request = new Request.Builder()&lt;br&gt;        .url(“&lt;a href=&quot;http://qq.com&amp;quot;).get().build(&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://qq.com&amp;quot;).get().build(&lt;/a&gt;);&lt;br&gt;    client.newCall(request).enqueue(new Callback() {&lt;br&gt;      @Override public void onFailure(Call call, IOException e) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  }

  @Override public void onResponse(Call call, Response response) throws IOException {

  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() &amp;lt; maxRequests &amp;amp;&amp;amp; runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {
      //添加正在运行的请求
    runningAsyncCalls.add(call);
       //线程池执行请求
    executorService().execute(call);
  } else {
      //添加到缓存队列
    readyAsyncCalls.add(call);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现请求是否进入缓存的条件如下：&lt;br&gt;    (runningRequests&amp;lt;64 &amp;amp;&amp;amp; runningRequestsPerHost&amp;lt;5)&lt;/p&gt;
&lt;p&gt;如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。&lt;/p&gt;
&lt;p&gt;我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：&lt;br&gt;    @Override protected void execute() {&lt;br&gt;      boolean signalledCallback = false;&lt;br&gt;      try {&lt;br&gt;          //执行耗时IO任务&lt;br&gt;        Response response = getResponseWithInterceptorChain(forWebSocket);&lt;br&gt;        if (canceled) {&lt;br&gt;          signalledCallback = true;&lt;br&gt;          //回调，注意这里回调是在线程池中，而不是想当然的主线程回调&lt;br&gt;          responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));&lt;br&gt;        } else {&lt;br&gt;          signalledCallback = true;&lt;br&gt;          //回调，同上&lt;br&gt;          responseCallback.onResponse(RealCall.this, response);&lt;br&gt;        }&lt;br&gt;      } catch (IOException e) {&lt;br&gt;        if (signalledCallback) {&lt;br&gt;          // Do not signal the callback twice!&lt;br&gt;          logger.log(Level.INFO, “Callback failure for “ + toLoggableString(), e);&lt;br&gt;        } else {&lt;br&gt;          responseCallback.onFailure(RealCall.this, e);&lt;br&gt;        }&lt;br&gt;      } finally {&lt;br&gt;          //最关键的代码&lt;br&gt;        client.dispatcher().finished(this);&lt;br&gt;      }&lt;br&gt;    }&lt;/p&gt;
&lt;p&gt;当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数&lt;br&gt;    private void promoteCalls() {&lt;br&gt;        //如果目前是最大负荷运转，接着等&lt;br&gt;      if (runningAsyncCalls.size() &amp;gt;= maxRequests) return; // Already running max capacity.&lt;br&gt;      //如果缓存等待区是空的，接着等&lt;br&gt;      if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  for (Iterator&amp;lt;AsyncCall&amp;gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
    AsyncCall call = i.next();

    if (runningCallsForHost(call) &amp;lt; maxRequestsPerHost) {
        //将缓存等待区最后一个移动到运行区中，并执行
      i.remove();
      runningAsyncCalls.add(call);
      executorService().execute(call);
    }

    if (runningAsyncCalls.size() &amp;gt;= maxRequests) return; // Reached max capacity.
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码&lt;/p&gt;
&lt;h3 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h3&gt;&lt;p&gt;通过上述的分析，我们知道了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行&lt;/li&gt;
&lt;li&gt;OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出&lt;/li&gt;
&lt;li&gt;OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/6637369d02e7&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/6637369d02e7&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;a href=&quot;#OkHttp3源码分析【任务队列】&quot; class=&quot;headerlink&quot; title=&quot;OkHttp3源码分析【任务队列】&quot;&gt;&lt;/a&gt;OkHttp3源码分析【任务队列】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java Collection Cheat Sheet</title>
    <link href="http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/"/>
    <id>http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/</id>
    <published>2016-06-20T08:21:47.000Z</published>
    <updated>2016-06-20T08:31:11.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;分享Java-Collection-的一张图&quot;&gt;&lt;a href=&quot;#分享Java-Collection-的一张图&quot; class=&quot;headerlink&quot; title=&quot;分享Java Collection 的一张图&quot;&gt;&lt;/a&gt;分享Java Collection 的一张图&lt;/h3&gt;&lt;p&gt;在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等&lt;/p&gt;
&lt;p&gt;我们可以看出他们之间的关系以及差别。&lt;/p&gt;
&lt;p&gt;例如：HashMap, HastTable,  Vector 和 LinkedList等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png&quot; alt=&quot;Java Collection Cheat Sheet&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;分享Java-Collection-的一张图&quot;&gt;&lt;a href=&quot;#分享Java-Collection-的一张图&quot; class=&quot;headerlink&quot; title=&quot;分享Java Collection 的一张图&quot;&gt;&lt;/a&gt;分享Java Collection 的一
    
    </summary>
    
      <category term="Java" scheme="http://gdky005.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://gdky005.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Okhttp3源码分析【DiskLruCache】</title>
    <link href="http://gdky005.com/2016/06/20/Okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90DiskLruCache%E3%80%91/"/>
    <id>http://gdky005.com/2016/06/20/Okhttp3源码分析【DiskLruCache】/</id>
    <published>2016-06-20T07:57:46.000Z</published>
    <updated>2016-06-20T08:40:20.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;a href=&quot;#Okhttp3源码分析【DiskLruCache】&quot; class=&quot;headerlink&quot; title=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;/a&gt;Okhttp3源码分析【DiskLruCache】&lt;/h1&gt;&lt;h3 id=&quot;本文目录&quot;&gt;&lt;a href=&quot;#本文目录&quot; class=&quot;headerlink&quot; title=&quot;本文目录&quot;&gt;&lt;/a&gt;本文目录&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Cache 的简介&lt;/li&gt;
&lt;li&gt;LinkedHashMap 原理&lt;/li&gt;
&lt;li&gt;OkHttp 的文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 &lt;strong&gt;缓存策略&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-Cache-的简介&quot;&gt;&lt;a href=&quot;#1-Cache-的简介&quot; class=&quot;headerlink&quot; title=&quot;1.Cache 的简介&quot;&gt;&lt;/a&gt;1.Cache 的简介&lt;/h3&gt;&lt;p&gt;缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。&lt;/li&gt;
&lt;li&gt;需要实现 &lt;em&gt;排序依据&lt;/em&gt;， 子啊 java 中，可以使用 Comparable\&lt;t\&gt;作为排序的接口。&lt;/t\&gt;&lt;/li&gt;
&lt;li&gt;需要一种 &lt;em&gt;页面置换算法&lt;/em&gt; 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等&lt;/li&gt;
&lt;li&gt;如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Comparable\&lt;t\&gt;是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》&lt;br&gt;2.页面置换算法可以参考阅读《现代操作系统》的中译本&lt;/t\&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-LinkedHashMap-原理&quot;&gt;&lt;a href=&quot;#2-LinkedHashMap-原理&quot; class=&quot;headerlink&quot; title=&quot;2.LinkedHashMap 原理&quot;&gt;&lt;/a&gt;2.LinkedHashMap 原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;源码概述分析&lt;br&gt;在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 HashMap 中，维护了一个 Node\&lt;k,v\&gt;[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。&lt;/k,v\&gt;&lt;/p&gt;
&lt;p&gt;而在 LinkedHashMap 中，除了 Node\&lt;k,v\&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt; table， 还维护着 Entry\&lt;k,v\&gt; head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素&lt;br&gt;    // move node to last&lt;br&gt;    void afterNodeAccess(Node&lt;k,v&gt; e)&lt;br&gt;    // possibly remove eldest&lt;br&gt;    void afterNodeInsertion(boolean evict)&lt;/k,v&gt;&lt;/k,v\&gt;&lt;/k,v\&gt;&lt;/p&gt;
&lt;p&gt;当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建&lt;br&gt;    // move node to last&lt;br&gt;    void afterNodeAccess(Node&lt;k,v&gt; e)&lt;/k,v&gt;&lt;/p&gt;
&lt;p&gt;综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head&lt;/p&gt;
&lt;p&gt;最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现&lt;br&gt;    head &amp;lt;–&amp;gt; …. &amp;lt;–&amp;gt; tail&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;旧元素 &amp;lt;-----------&amp;gt; 反复使用的新元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化&lt;br&gt;    //按照访问顺序排序的Map，设置accessOrder为true&lt;br&gt;    map = new LinkedHashMap&amp;lt;&amp;gt;(0, 0.75f, true);&lt;/p&gt;
&lt;h3 id=&quot;3-OkHttp-的文件系统&quot;&gt;&lt;a href=&quot;#3-OkHttp-的文件系统&quot; class=&quot;headerlink&quot; title=&quot;3.OkHttp 的文件系统&quot;&gt;&lt;/a&gt;3.OkHttp 的文件系统&lt;/h3&gt;&lt;p&gt;OkHttp 中的关键对象如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作&lt;/li&gt;
&lt;li&gt;DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装&lt;/li&gt;
&lt;li&gt;DiskLruCache.Entry: 维护着 key 对应的多个文件&lt;/li&gt;
&lt;li&gt;Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类&lt;/li&gt;
&lt;li&gt;DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）&lt;/li&gt;
&lt;li&gt;Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理&lt;/li&gt;
&lt;li&gt;Response/Request: OkHttp 的请求与回应&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;文件初级封装（FileSystem）&lt;br&gt;众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。&lt;br&gt; File(低级操作，步骤繁琐) -&amp;gt; Okio(封装) －&amp;gt; FileSystem(友好工具类)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Okio 很不错，可以去&lt;a href=&quot;https://github.com/square/okio&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件高级封装（DiskLruCache.Entry/Editor/Snapshot）&lt;br&gt;本部分进行了如下操作，进行了实际的 put/get 操作&lt;br&gt; FileSystem &amp;lt;– DiskLruCache.Entry/Editor –&amp;gt; source/sink(更少参数)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY_METADATA 与 ENTRY_BODY。&lt;/p&gt;
&lt;p&gt;比如在缓存的路径下执行 ls,结果如下：&lt;br&gt;    $ ls&lt;br&gt;    5716ab0f06c49bc7cf602397c51d5677.0&lt;br&gt;    5716ab0f06c49bc7cf602397c51d5677.1&lt;br&gt;    5b2f52377611dc6201a1871bdb997466.0&lt;br&gt;    5b2f52377611dc6201a1871bdb997466.1&lt;br&gt;    journal&lt;br&gt;    …..&lt;/p&gt;
&lt;p&gt;DiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;读取场景：读取时，需要获取快照，通过调用链分析&lt;br&gt;&lt;img src=&quot;http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;序列化与反序列化（Cache.Entry）&lt;br&gt;文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变&lt;blockquote&gt;
&lt;p&gt;Resonse(java对象) \&amp;lt;— Cache.Entry —&gt; source/sink(文件io)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以通过 find usage 位置相同，概括如下：&lt;br&gt;如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。&lt;br&gt;    至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;缓存的自动清理&lt;br&gt;在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。&lt;/p&gt;
&lt;p&gt; new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), Util.threadFactory(&amp;quot;OkHttp DiskLruCache&amp;quot;, true))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当需要清理时，执行清理任务，它将在每次 get/set 后调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private final Runnable cleanupRunnable = new Runnable() {
  public void run() {
    synchronized (DiskLruCache.this) {
      if (!initialized | closed) {
        return; // Nothing to do
      }
      try {
        //遍历LRU缓存(从旧到新进行遍历map),并删除文件
        //直到小于MaxSize为止
        trimToSize();
        if (journalRebuildRequired()) {
          rebuildJournal();
          redundantOpCount = 0;
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作&lt;/li&gt;
&lt;li&gt;OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作&lt;/li&gt;
&lt;li&gt;OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;摘自：&lt;a href=&quot;http://www.jianshu.com/p/23b8aa490a6b&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/23b8aa490a6b&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;a href=&quot;#Okhttp3源码分析【DiskLruCache】&quot; class=&quot;headerlink&quot; title=&quot;Okhttp3源码分析【DiskLruCache】&quot;&gt;&lt;/a&gt;Okhttp3源码分析
    
    </summary>
    
      <category term="okhttp3" scheme="http://gdky005.com/categories/okhttp3/"/>
    
    
      <category term="okhttp3" scheme="http://gdky005.com/tags/okhttp3/"/>
    
  </entry>
  
</feed>
