{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/next/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/author.jpg","path":"images/author.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatqcode.jpeg","path":"images/wechatqcode.jpeg","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"8fa6f9233c9408c6d03eac8eea16cd11fa31464a","modified":1461071833000},{"_id":"source/CNAME","hash":"9bdabd8bcdb91cd4e83d2b19ff784fa8cc69385c","modified":1461071833000},{"_id":"source/robots.txt","hash":"e3af5a688770070dabaa6a240d7da9ae78e8e3ce","modified":1461119826000},{"_id":"source/.DS_Store","hash":"413dd23cab19d60e8acdb596b001686e820d43ff","modified":1466754863000},{"_id":"themes/next/.bowerrc","hash":"80e096fdc1cf912ee85dd9f7e6e77fd40cf60f10","modified":1461071833000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1461071833000},{"_id":"themes/next/.gitignore","hash":"efec790f5b7a0256763e1cc08f12c4f0aff509f6","modified":1461071833000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1461071833000},{"_id":"themes/next/.javascript_ignore","hash":"d619ee13031908cd72666e4ff652d2ea3483b1c3","modified":1461071833000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1461071833000},{"_id":"themes/next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1461071833000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1461071833000},{"_id":"themes/next/_config.yml","hash":"adc8ae777f9f1ac9c009736a74bb766a18ee23dd","modified":1461460999000},{"_id":"themes/next/bower.json","hash":"f89c6700a11d81e067cc97273ca6bf96cb88c8f9","modified":1461071833000},{"_id":"themes/next/gulpfile.coffee","hash":"26e5b1b945704c8bc78b928feede895c4c111c95","modified":1461071833000},{"_id":"themes/next/package.json","hash":"63e9c0f1dd9e5d7f51b4ae383981ef939a2ed45d","modified":1461071833000},{"_id":"source/about/index.md","hash":"b43223b8947594ddc8fcea72e99041edeae0b14b","modified":1461213224000},{"_id":"source/_posts/.DS_Store","hash":"61bcf4edc5c53750a0adf1e17ace32ce28843267","modified":1466768223000},{"_id":"source/_posts/APK反编译Jadx.md","hash":"f3b8d23652d944ebfc11c32c583097f25fff10c8","modified":1461071833000},{"_id":"source/_posts/Android-和-IOS-应用查找bug-利器.md","hash":"c5fcf624fe37568159dd38540135d66ae4f17e84","modified":1461071833000},{"_id":"source/_posts/AndroidStudio.md","hash":"204287c70cc4ab51c0bc26613b55506e98232902","modified":1461071833000},{"_id":"source/_posts/Android-gradle工作原理.md","hash":"64790a725b1c66a839702b78f227235307e45028","modified":1461071833000},{"_id":"source/_posts/Android在图形界面UI方面的工具.md","hash":"6d42a3f5216932031d4d321fbb7566682fab77f3","modified":1461071833000},{"_id":"source/_posts/Android开发者提升技能水平的大招.md","hash":"3c431a74fa57d4a8f29e61d2d12e9a2043b24851","modified":1461071833000},{"_id":"source/_posts/Bug小记-贵金属.md","hash":"62b9b96dc28a47ce5c9d7d1216daebe556b1ada5","modified":1461071833000},{"_id":"source/_posts/Fragment-not-attached-to-Activity-异常.md","hash":"27f30381348af6d5114dbf1a51e3e1342b2eb16e","modified":1461071833000},{"_id":"source/_posts/HTTPS的七个误解.md","hash":"f1fdaff61bdb3adab2d09a424767fb9b72fc2623","modified":1469417145000},{"_id":"source/_posts/Android录音使用-byte-类型获取分贝或声音振幅.md","hash":"eed81caf5e96a7af5dbaacb76b8d330e557ec9da","modified":1461071833000},{"_id":"source/_posts/OkHttp和Okio.md","hash":"860a584f92d481c988de81961fe51cfcca89eb07","modified":1470653389000},{"_id":"source/_posts/OkHttp3-源码分析【缓存策略】.md","hash":"e8f556394b29f9231cdaf79c9cbc3b7de5f38091","modified":1466413562000},{"_id":"source/_posts/Okhttp3源码分析【DiskLruCache】.md","hash":"e6eb93776d439c38001f83535e87a9bcdac500df","modified":1466413547000},{"_id":"source/_posts/OkHttp3源码分析【任务队列】.md","hash":"62b7c22268923657a10f8cd9b7f0e48a4ef5397a","modified":1466413536000},{"_id":"source/_posts/Java-Collection-Cheat-Sheet.md","hash":"9ef59facc8a0a4ea82033d41fef2ad7ff2387fa0","modified":1466417936000},{"_id":"source/_posts/RecyclerView的基类写法.md","hash":"6819dddfef0bdde41f791d33757ac64ce53e757d","modified":1461071833000},{"_id":"source/about/.DS_Store","hash":"a802868e144a4515040090c88f65c5dd3b6c1618","modified":1461038288000},{"_id":"source/_posts/Okio-简单处理I-O操作.md","hash":"73be373cbd05e2ceba98e3df3e9db93cb82c2f42","modified":1466417927000},{"_id":"source/_posts/android-monkey.md","hash":"e3423866d1eaf7aa69d5d28708b4d277a0c80e19","modified":1461071833000},{"_id":"source/_posts/代码面试最常用的10大算法.md","hash":"c14ff81432e98d718ad9f5fb6f3456d5189c74c3","modified":1461071833000},{"_id":"source/_posts/从-volley-切换到-OkHttp-遇到的坑.md","hash":"37c865c4cb4357391af28be7aca7ba2deb1b25ca","modified":1466754909000},{"_id":"source/_posts/一个五年Android开发者百度、阿里、聚美、映客的面试心经.md","hash":"4d74f067b4fae18d8b7c16f0924e805c56a5ab39","modified":1468029353000},{"_id":"source/_posts/使用-Android-Studio-内存分析工具.md","hash":"21f07218cf2f439badcc33fe80bd83e87136cdcf","modified":1466418973000},{"_id":"source/_posts/使用groovy读取excel里面内容.md","hash":"85272d74eaf7526b778e0a5f3349b08968609c79","modified":1466420418000},{"_id":"source/_posts/凯哥高质量文章系列.md","hash":"ffc19058bb08538a11f53aff96a0fc820e5d8f2d","modified":1461071833000},{"_id":"source/_posts/圆角图片处理.md","hash":"4a833991dfa47836ff6a20c0546bf00f7d1439b2","modified":1461071833000},{"_id":"source/_posts/比较好的Android网站.md","hash":"76a42f9557831d60a49930863318f6020dc435dc","modified":1461071833000},{"_id":"source/_posts/推荐processon-让流程图也可以共享.md","hash":"abd1dbb94f68a18063f18e54e338d0ecb45cc8db","modified":1461071833000},{"_id":"source/_posts/日志指南.md","hash":"9c5103d6b90e6ac42820d001bbf4afe4760ca667","modified":1461071833000},{"_id":"source/_posts/是什么使你无法完成工作？——番茄告诉你.md","hash":"113a823828c71d72f6e4c0a2184e8b7ac394007b","modified":1461071833000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1461071833000},{"_id":"source/_posts/程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析.md","hash":"b61e7ee2cdc0b607d352dea72ab3607b3a945e20","modified":1461071833000},{"_id":"source/_posts/网络请求的-UA.md","hash":"2b77fbc195caa1f27138eb45f95f1910a7e98ab6","modified":1466418558000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1461071833000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1461071833000},{"_id":"themes/next/languages/en.yml","hash":"f03799cbdb5a33064ead080bcac4baca1f6bc5f9","modified":1461071833000},{"_id":"themes/next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1461071833000},{"_id":"themes/next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1461071833000},{"_id":"themes/next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1461071833000},{"_id":"themes/next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1461071833000},{"_id":"themes/next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1461071833000},{"_id":"themes/next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1461071833000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"bea452bc49aed171a210d09bd6cddc4e846ea8ab","modified":1461071833000},{"_id":"themes/next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1461071833000},{"_id":"themes/next/layout/_layout.swig","hash":"74157f6cfd679ea11febec632542793f37c5e5d4","modified":1461071833000},{"_id":"themes/next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1461071833000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1461071833000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1461071833000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1461071833000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1461071833000},{"_id":"themes/next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1461071833000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1461071833000},{"_id":"themes/next/test/.jshintrc","hash":"096ed6df627373edd820f24d46b8baf528dee61d","modified":1461071833000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1461071833000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1461071833000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1461071833000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1461071833000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1461071833000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"43c3433155ccd9abcbe7dce2e6bfa1f3a66af18b","modified":1461071833000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"70bd1f11a558a7fc4b8fd7860377f31e0357ceb6","modified":1461071833000},{"_id":"themes/next/layout/_macro/post.swig","hash":"ae280b8bc49b87e3b86ce1a131191c37d6aa37b4","modified":1461071833000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"cd98e1141df1a41ed14f31cd4cf5f5c5f0a9898e","modified":1461071833000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"85327c2174d09c6d69c9033592e6c8f7eb7ac3ba","modified":1461071833000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"82d060fe055d6e423bbc9199f82dfe5c68e74779","modified":1461071833000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1461071833000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1461071833000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"82a9bc2ba60ce68419128ff60624bd74b15dfb78","modified":1461071833000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1461071833000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1461071833000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"0ce71d8322ea7dea82d9371fa2fe13949aa870e3","modified":1461071833000},{"_id":"themes/next/layout/_partials/header.swig","hash":"7739068b69f87ae641dea19c3445169ae80d5df4","modified":1461071833000},{"_id":"themes/next/layout/_partials/head.swig","hash":"1706eaedbbdb6ac210ea320c1740476120c0373f","modified":1461121736000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1461071833000},{"_id":"themes/next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1461071833000},{"_id":"themes/next/source/favicon.ico","hash":"4ac30b59ed069d970341bda8299b08ce848953ab","modified":1461071833000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1461071833000},{"_id":"themes/next/source/images/avatar.jpg","hash":"4155e2fa275ad00f7cdb3431a79180dc9eb2c802","modified":1448682471000},{"_id":"themes/next/source/images/author.jpg","hash":"877fedc0fd7bfd8c8dcc269185591a283693e71c","modified":1461071833000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1461071833000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1461071833000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1461071833000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1461071833000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1461071833000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1461071833000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1461071833000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1461071833000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1461071833000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1461071833000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1461071833000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1461071833000},{"_id":"themes/next/source/images/wechatqcode.jpeg","hash":"c1aa8cb1249d37b732980a6a6e2f3de04f4364cb","modified":1461214386000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1461071833000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"2fc4a0d2c825a512f39c0eadd78452e90615465a","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1461071833000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"1561bd0c107d725252c6d746e9ac177fc18f93bf","modified":1461071833000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"36db00417ab0f7639c4cc95ab6e20a7a69be9560","modified":1461071833000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1461071833000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1461071833000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1461071833000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"c07f7b2f264e5215b8ed42d67e8cef2477558364","modified":1461071833000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1461071833000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"7ca5cb4daa58b3504e17f3e02975e794bc634658","modified":1461071833000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1461071833000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1461071833000},{"_id":"themes/next/source/css/_variables/default.styl","hash":"8ec3307fe42d738b1bbda4b6419d0995f5560222","modified":1461071833000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"2676996e819af2079c552f755ab7933939e151cd","modified":1461071833000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"11d443fc97648d2965d7f8bad9f4a493996fe62f","modified":1461071833000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1461071833000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1461052190000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"4e49707c99c8bbcfa0a607dfdaff0fbb7dffd2a3","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1461052190000},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1461071833000},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1461071833000},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1461071833000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1461071833000},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1461071833000},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1461071833000},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1461071833000},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1461071833000},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1461071833000},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1461071833000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1461071833000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1461071833000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1461071833000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1461071833000},{"_id":"themes/next/source/images/favicon.ico","hash":"4ac30b59ed069d970341bda8299b08ce848953ab","modified":1461071833000},{"_id":"themes/next/source/js/src/utils.js","hash":"a3a3375de818964f4cbed4d0e2c2f97ccee7199e","modified":1461071833000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1461071833000},{"_id":"themes/next/source/js/src/post-details.js","hash":"10247c78fe933a0cfcaad22a2a03e7a026864461","modified":1461071833000},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"44e761721e8ad787ef571a3cc57bbc12d318a2a3","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"334176d838ee528e58468d8bc74ff3a6d3f25b2b","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"3491d3cebabc8a28857200db28a1be65aad6adc2","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1461071833000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"8c7af79407d223486fba72b8150fe045a553bf70","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1461071833000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1461071833000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1461071833000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"4c84903d6a15a903235eec04a560fdeda80c12f3","modified":1461071833000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1461071833000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1461071833000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"04e6c5257814c65e638ab70c53030e8dfdb3f37d","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"6cc10d943d92eac953e6978e46d27ae55584482c","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"6ed60cc621bac096c0ed7534fa25b1a52dc571d4","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"8aca5d9f1df157ab27e699c1b3ba9438b9e039ad","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1461071833000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1461071833000},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"8d7cecde4933900c7df2db9d0a98f5f82f88dc93","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ff30fdbdf22841d0fb55f486a1f55bee4dc19401","modified":1461071833000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1461071833000},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1461071833000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1461071833000},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"89fef1caf94caf76ca09c643b83b0b4d4e417e08","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"3c46efd6601e268093ce6d7b1471d18501878f0d","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"58fb7604b44e3f56d880bbbd95d0baface38c4ee","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"99d994bd19895a4aaa2fa8d12801ec72dd3cf118","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"d4303e6439e70dc23f9151c69bc31a7fb0ece820","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"795d94561888d31cb7a6ff4a125596809ea69b7d","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"e340071ee392f55b32c540d690198f157e588433","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1461071833000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1461071833000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1461071833000},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1461071833000},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1461071833000},{"_id":"public/atom.xml","hash":"1e9d8282553b6e7781314220524aa2907740a582","modified":1470653404631},{"_id":"public/baidusitemap.xml","hash":"6fe9e5ada880670535267a88f7dc6cf48c9f5c8a","modified":1470653404656},{"_id":"public/sitemap.xml","hash":"58700bb01e441cfb1ba7023dbe4577b3de0893a5","modified":1470653404657},{"_id":"public/search.xml","hash":"d5a35da00ed673398d69e7541eb49397a88fb4f0","modified":1470653404657},{"_id":"public/404.html","hash":"547d790b63cbc452d0dfe79e11ef2ffc416504cb","modified":1470653404794},{"_id":"public/about/index.html","hash":"1e3c699424de241f81994d6b7aa44110bba224ca","modified":1470653404794},{"_id":"public/2016/07/08/一个五年Android开发者百度、阿里、聚美、映客的面试心经/index.html","hash":"30407b89af045bb2e61ca5d324a16f37c05770ea","modified":1470653404794},{"_id":"public/2016/07/25/HTTPS的七个误解/index.html","hash":"f17a12f9b9a5599731d46f7bcdebfde3c7be0a4e","modified":1470653404794},{"_id":"public/2016/06/20/使用-Android-Studio-内存分析工具/index.html","hash":"fbac76d8315e51a43d91b58d2f086f0b87186ff6","modified":1470653404794},{"_id":"public/2016/06/20/网络请求的-UA/index.html","hash":"bd364c4145e2e613c209f48d057301e3b33af5fa","modified":1470653404794},{"_id":"public/2016/06/20/从-volley-切换到-OkHttp-遇到的坑/index.html","hash":"01e92254a0787661c201d79b15aa7d6d7d743464","modified":1470653404794},{"_id":"public/2016/06/20/Java-Collection-Cheat-Sheet/index.html","hash":"ef92ec8456dc753c9baddfc4e34d944f66ef8cb9","modified":1470653404794},{"_id":"public/2016/06/20/Okio-简单处理I-O操作/index.html","hash":"91b06de10d5a383ddd74c7d9ded831b260225191","modified":1470653404794},{"_id":"public/2016/06/20/Okhttp3源码分析【DiskLruCache】/index.html","hash":"41824811763c4eb36db7196ed7536cb0a4c7aaba","modified":1470653404794},{"_id":"public/2016/06/20/OkHttp3源码分析【任务队列】/index.html","hash":"2ad0cfbf82fff70ee5c5acf2e9ac6c868b794d40","modified":1470653404794},{"_id":"public/2016/06/20/OkHttp3-源码分析【缓存策略】/index.html","hash":"ed64d84dfb0c3d6ba0d8af825fd851a8bc197d4c","modified":1470653404794},{"_id":"public/2016/02/25/推荐processon-让流程图也可以共享/index.html","hash":"8e1d012a74a56e2d07df7059d95393f6cbc04d18","modified":1470653404794},{"_id":"public/2016/02/24/APK反编译Jadx/index.html","hash":"2909c6c63dc43761f67f08d9d67447142ae70c1f","modified":1470653404794},{"_id":"public/2016/02/19/Android开发者提升技能水平的大招/index.html","hash":"2644a303bc240f928821ef49d3a54def6dd178e0","modified":1470653404794},{"_id":"public/2015/11/27/Fragment-not-attached-to-Activity-异常/index.html","hash":"92352a6c20a787b2282429f720a93b71bc822052","modified":1470653404794},{"_id":"public/2015/11/20/使用groovy读取excel里面内容/index.html","hash":"cf568f7ade3e81e40c1bab7a0dcfe27644f8625b","modified":1470653404794},{"_id":"public/2015/11/20/Bug小记-贵金属/index.html","hash":"f07fb30e019372a5cfe49c5100d9d295f931c558","modified":1470653404794},{"_id":"public/2015/11/20/凯哥高质量文章系列/index.html","hash":"156b2bb92a8bb1d83f242a82841e2a9673ab6fb8","modified":1470653404795},{"_id":"public/2015/11/17/RecyclerView的基类写法/index.html","hash":"696d60ce47c3ff1f97c6132699407aa64e2665d8","modified":1470653404795},{"_id":"public/2015/11/12/程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析/index.html","hash":"e8e3f54e203ff97da03db5f80b022168f9166cdf","modified":1470653404795},{"_id":"public/2016/03/12/代码面试最常用的10大算法/index.html","hash":"7099ccc142646292cbad721ee63165ae572a7a89","modified":1470653404795},{"_id":"public/2015/10/10/圆角图片处理/index.html","hash":"50c5efd74ebed7fe45596a2026aa234e4670193f","modified":1470653404795},{"_id":"public/2015/10/09/Android在图形界面UI方面的工具/index.html","hash":"8aeae7b5fc053956cf8115713a2995760143ce12","modified":1470653404795},{"_id":"public/2015/10/08/Android录音使用-byte-类型获取分贝或声音振幅/index.html","hash":"03d7f16525ce78105ce2b08ee21b4a64e17a1a02","modified":1470653404795},{"_id":"public/2015/09/26/比较好的Android网站/index.html","hash":"1249da74d7cfe832e5e38dcb28f76c5a8593853f","modified":1470653404795},{"_id":"public/2015/09/19/android-monkey/index.html","hash":"6f022bdb2537cb4bec0bed001807af8e5739ce63","modified":1470653404795},{"_id":"public/2015/09/19/AndroidStudio/index.html","hash":"466c1b1218d0e0143e85b025c7a6714aa6273581","modified":1470653404795},{"_id":"public/2015/09/13/Android-gradle工作原理/index.html","hash":"0349ba94d3d4aad0e1ee7cf40a87cf7f2d0b9e2e","modified":1470653404795},{"_id":"public/2015/09/11/日志指南/index.html","hash":"7638550af4c912596d098460572c6898886ccdd6","modified":1470653404795},{"_id":"public/2015/09/13/是什么使你无法完成工作？——番茄告诉你/index.html","hash":"069b6905ffb14444565de56db63d22544387a6ea","modified":1470653404795},{"_id":"public/2015/09/26/Android-和-IOS-应用查找bug-利器/index.html","hash":"bd54287139140cb1ae8e79319153a8e28dc33ca4","modified":1470653404795},{"_id":"public/categories/Java/index.html","hash":"dd2bbd0ade4807a157c05cab02a9cbf805ab2f54","modified":1470653404795},{"_id":"public/categories/okhttp3/index.html","hash":"e759dd975610be47f1d1133da9ffe322ef8bf692","modified":1470653404795},{"_id":"public/categories/okio/index.html","hash":"0a2c0e6ab771d5286be135bc01a771b366931f42","modified":1470653404795},{"_id":"public/categories/android/index.html","hash":"085b88edd9b50697e600fa1a248cc49ade9712fd","modified":1470653404795},{"_id":"public/categories/AndroidStudio/index.html","hash":"3c0221b2d55857996db1905734291fa430d95848","modified":1470653404795},{"_id":"public/archives/index.html","hash":"e4deae5e742d56522a4013cf3127de9071cb7994","modified":1470653404795},{"_id":"public/categories/面试说/index.html","hash":"9da84d01e1787d031f6c36c37ae57cac93c5a928","modified":1470653404795},{"_id":"public/archives/page/2/index.html","hash":"9f64427c6a5131fdf081f6d7ebdc51c01e927370","modified":1470653404795},{"_id":"public/archives/2015/index.html","hash":"9c00992d2affba275ac25ce135c6f2945135f83d","modified":1470653404795},{"_id":"public/categories/groovy/index.html","hash":"b30edb1a52e505fc7c64a3e9a04b8d071f0c696f","modified":1470653404795},{"_id":"public/archives/2015/09/index.html","hash":"05539e69af55c2a8a04630a27c533ec317447964","modified":1470653404795},{"_id":"public/archives/2015/page/2/index.html","hash":"9688e260e3f3bb440ebff2b061c5162e2a31a283","modified":1470653404795},{"_id":"public/archives/2015/11/index.html","hash":"5c1b9f09925a526c59682ff9490d6fa610a25296","modified":1470653404796},{"_id":"public/archives/2015/10/index.html","hash":"b078c628789ce7d198f79e10343aaabd00b6b4c9","modified":1470653404796},{"_id":"public/archives/2016/index.html","hash":"28f9bb644b3c30c3993698d9c901ab3c99643be0","modified":1470653404796},{"_id":"public/archives/2016/page/2/index.html","hash":"f806e81aa6327002244bea111f20aab9e6fdeb9b","modified":1470653404796},{"_id":"public/archives/2016/02/index.html","hash":"05b3e01b96f70e01b762d8af861430ac33f6daca","modified":1470653404796},{"_id":"public/archives/2016/06/index.html","hash":"b189ad9fe4ad8f4df9df54e27b0d8fb18962b93a","modified":1470653404796},{"_id":"public/archives/2016/07/index.html","hash":"7df6b5b36f62f2ae885054874e2b6fc8f43ce49e","modified":1470653404796},{"_id":"public/index.html","hash":"55f5741fee63bcb6d92c9c9600b02cefc63157b0","modified":1470653404796},{"_id":"public/page/2/index.html","hash":"58d90b32076d4bd413753bcb33e9b00877e42886","modified":1470653404796},{"_id":"public/page/3/index.html","hash":"f5fc505f0fdd8b15a9562d615076401a0067333b","modified":1470653404796},{"_id":"public/tags/android/index.html","hash":"2421899c5ca6b55937b85539575f11eb8fb2f37c","modified":1470653404796},{"_id":"public/tags/android-gradle工作原理/index.html","hash":"f008c001fd6641a3dab07856eae2b23af2a96dc6","modified":1470653404796},{"_id":"public/tags/技能提升/index.html","hash":"f952a3e292d2c81cb230861dbdc505f48a8f4007","modified":1470653404796},{"_id":"public/tags/ios/index.html","hash":"faf9d1fb9e91f3ac22b3194ba70747533c854f16","modified":1470653404796},{"_id":"public/tags/https/index.html","hash":"8d1e33a00eb70edef543a3b93310c36bd78d4644","modified":1470653404796},{"_id":"public/tags/android录音/index.html","hash":"8ef67bf3a52ebc42d1ff7722baac260d10fe0b11","modified":1470653404796},{"_id":"public/tags/okhttp3/index.html","hash":"b11da83ef9e2e7430512187860d9ef68c323709c","modified":1470653404796},{"_id":"public/tags/Java/index.html","hash":"269b7dc1deee45c42da40d338dd9a4a95eaa3c81","modified":1470653404796},{"_id":"public/tags/okio/index.html","hash":"6c828b681dd5977a58441f655254bf00b00b99ce","modified":1470653404796},{"_id":"public/tags/算法/index.html","hash":"3b75b80c90f0682bea7284db0bd09c966db9f297","modified":1470653404796},{"_id":"public/tags/groovy/index.html","hash":"291dd3ac68f5bdf7ca4291de04c75b099e4c874d","modified":1470653404796},{"_id":"public/tags/面试心经/index.html","hash":"65da9895b26e213261a8c74b0fe08d180fa0227d","modified":1470653404796},{"_id":"public/tags/干货/index.html","hash":"7ad7e62d4bdc5b739af4b9bb75ab1f122af254fc","modified":1470653404797},{"_id":"public/tags/Android日志规范/index.html","hash":"7c0d9c40c15b7165abaddb59365c56478e5cd758","modified":1470653404797},{"_id":"public/tags/番茄工作法/index.html","hash":"936d2dc0cc18b7de09ca919a809bbb24111c276c","modified":1470653404797},{"_id":"public/tags/Android/index.html","hash":"e518f89c531680874fb625b6b0a2616060dc4cb5","modified":1470653404797},{"_id":"public/tags/AndroidStudio/index.html","hash":"510bb06ee4a97c8e419b1051ddfcd3f0893d7f9e","modified":1470653404797},{"_id":"public/archives/2016/03/index.html","hash":"f9b0d9e44263fa8af5c96397bedaaf3a844d652b","modified":1470653404797},{"_id":"public/archives/page/3/index.html","hash":"2b998ad0270e106addf0b0e99f8385281911e084","modified":1470653404797},{"_id":"public/2016/08/08/OkHttp和Okio/index.html","hash":"61fa0aea6637f81ac68fe5d0f48474bf14ad27fe","modified":1470653404804},{"_id":"public/archives/page/4/index.html","hash":"e2decb2763bac1feb36c40809e69d39bfbb1574e","modified":1470653404805},{"_id":"public/archives/2016/08/index.html","hash":"749c2b5d451fedc736ed809dac36d3a063f77c2c","modified":1470653404805},{"_id":"public/page/4/index.html","hash":"f9d37338d87ae75c0a4e0874532d647b781e0dfa","modified":1470653404805},{"_id":"public/tags/OkHttp-Okio/index.html","hash":"ee171939b86a3dbf86c2423328d0c1a0a210c2c3","modified":1470653404805},{"_id":"public/CNAME","hash":"9bdabd8bcdb91cd4e83d2b19ff784fa8cc69385c","modified":1470653404805},{"_id":"public/images/author.jpg","hash":"877fedc0fd7bfd8c8dcc269185591a283693e71c","modified":1470653404805},{"_id":"public/robots.txt","hash":"e3af5a688770070dabaa6a240d7da9ae78e8e3ce","modified":1470653404805},{"_id":"public/images/avatar.jpg","hash":"4155e2fa275ad00f7cdb3431a79180dc9eb2c802","modified":1470653404805},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1470653404805},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1470653404805},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1470653404805},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1470653404805},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1470653404805},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1470653404805},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1470653404805},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1470653404805},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1470653404805},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1470653404805},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1470653404806},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1470653404806},{"_id":"public/images/wechatqcode.jpeg","hash":"c1aa8cb1249d37b732980a6a6e2f3de04f4364cb","modified":1470653404806},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1470653404806},{"_id":"public/vendors/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1470653404806},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470653404806},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470653404806},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470653404806},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470653404806},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470653404806},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470653404806},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1470653404806},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1470653405680},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1470653405681},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1470653405686},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1470653405686},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1470653405688},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1470653405688},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1470653405688},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1470653405688},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1470653405688},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1470653405688},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1470653405688},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1470653405688},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1470653405688},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1470653405688},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1470653405688},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1470653405688},{"_id":"public/js/src/post-details.js","hash":"10247c78fe933a0cfcaad22a2a03e7a026864461","modified":1470653405688},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1470653405688},{"_id":"public/js/src/utils.js","hash":"a3a3375de818964f4cbed4d0e2c2f97ccee7199e","modified":1470653405688},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1470653405688},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1470653405688},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1470653405688},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1470653405688},{"_id":"public/css/main.css","hash":"30530186c278afeefab67945c60c56c468cfceaf","modified":1470653405688},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1470653405688},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1470653405689},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1470653405689},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1470653405689},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1470653405690},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1470653405690},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1470653405690},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1470653405690},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1470653405690},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1470653405690},{"_id":"public/favicon.ico","hash":"4ac30b59ed069d970341bda8299b08ce848953ab","modified":1470653405690},{"_id":"public/images/favicon.ico","hash":"4ac30b59ed069d970341bda8299b08ce848953ab","modified":1470653405691},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1470653405698},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1470653405698},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1470653405698},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1470653405698},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1470653405698},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1470653405698},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1470653405698},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1470653405698},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1470653405698},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1470653405702}],"Category":[{"name":"okhttp3","_id":"cirlx2ag7000qxzexcu4sfsfo"},{"name":"Java","_id":"cirlx2agn0019xzexlod9kuu4"},{"name":"okio","_id":"cirlx2ags001fxzexo8249whg"},{"name":"android","_id":"cirlx2ah0001nxzexfluidy8z"},{"name":"AndroidStudio","_id":"cirlx2ah5001uxzeximkt42ej"},{"name":"groovy","_id":"cirlx2aha0021xzeximis373m"},{"name":"面试说","_id":"cirlx2ahf0027xzexlf9qys27"}],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2016-04-19T13:17:13.000Z","updated":"2016-04-19T13:17:13.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cirlx2add0000xzexl6d453gc","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>"},{"_content":"### 关于\n    \n- 现居北京，专注移动开发。\n- 喜欢研究一些新技术\n","source":"about/index.md","raw":"### 关于\n    \n- 现居北京，专注移动开发。\n- 喜欢研究一些新技术\n","date":"2016-04-21T04:33:44.000Z","updated":"2016-04-21T04:33:44.000Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cirlx2af10001xzex4y9bxmt2","content":"<h3 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h3><ul>\n<li>现居北京，专注移动开发。</li>\n<li>喜欢研究一些新技术</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h3><ul>\n<li>现居北京，专注移动开发。</li>\n<li>喜欢研究一些新技术</li>\n</ul>\n"}],"Post":[{"title":"JADX反编译源码更easy","date":"2016-02-24T03:54:09.000Z","keywords":null,"_content":"\n\n### JADX反编译源码更easy\n\n> 一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高\n\nCommand line and GUI tools for produce Java source code from Android Dex and Apk files\n\n![](https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67)\n\n\nDownloads\n\n- [unstable](https://drone.io/github.com/skylot/jadx/files)\n- from [github](https://github.com/skylot/jadx/releases)\n- from [sourceforge](http://sourceforge.net/projects/jadx/files/)\n\n\n\n\n参考地址：[ https://github.com/skylot/jadx ](#)","source":"_posts/APK反编译Jadx.md","raw":"title: JADX反编译源码更easy\ndate: 2016-02-24 11:54:09\ncategories:\nkeywords:\ntags:\n---\n\n\n### JADX反编译源码更easy\n\n> 一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高\n\nCommand line and GUI tools for produce Java source code from Android Dex and Apk files\n\n![](https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67)\n\n\nDownloads\n\n- [unstable](https://drone.io/github.com/skylot/jadx/files)\n- from [github](https://github.com/skylot/jadx/releases)\n- from [sourceforge](http://sourceforge.net/projects/jadx/files/)\n\n\n\n\n参考地址：[ https://github.com/skylot/jadx ](#)","slug":"APK反编译Jadx","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2af40002xzexu6ddr3g2","content":"<h3 id=\"JADX反编译源码更easy\"><a href=\"#JADX反编译源码更easy\" class=\"headerlink\" title=\"JADX反编译源码更easy\"></a>JADX反编译源码更easy</h3><blockquote>\n<p>一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高</p>\n</blockquote>\n<p>Command line and GUI tools for produce Java source code from Android Dex and Apk files</p>\n<p><img src=\"https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67\" alt=\"\"></p>\n<p>Downloads</p>\n<ul>\n<li><a href=\"https://drone.io/github.com/skylot/jadx/files\" target=\"_blank\" rel=\"external\">unstable</a></li>\n<li>from <a href=\"https://github.com/skylot/jadx/releases\" target=\"_blank\" rel=\"external\">github</a></li>\n<li>from <a href=\"http://sourceforge.net/projects/jadx/files/\" target=\"_blank\" rel=\"external\">sourceforge</a></li>\n</ul>\n<p>参考地址：<a href=\"#\"> https://github.com/skylot/jadx </a></p>\n","excerpt":"","more":"<h3 id=\"JADX反编译源码更easy\"><a href=\"#JADX反编译源码更easy\" class=\"headerlink\" title=\"JADX反编译源码更easy\"></a>JADX反编译源码更easy</h3><blockquote>\n<p>一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高</p>\n</blockquote>\n<p>Command line and GUI tools for produce Java source code from Android Dex and Apk files</p>\n<p><img src=\"https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67\" alt=\"\"></p>\n<p>Downloads</p>\n<ul>\n<li><a href=\"https://drone.io/github.com/skylot/jadx/files\">unstable</a></li>\n<li>from <a href=\"https://github.com/skylot/jadx/releases\">github</a></li>\n<li>from <a href=\"http://sourceforge.net/projects/jadx/files/\">sourceforge</a></li>\n</ul>\n<p>参考地址：<a href=\"#\"> https://github.com/skylot/jadx </a></p>\n"},{"title":"Android 和 IOS 应用查找bug 利器","date":"2015-09-26T07:12:50.000Z","keywords":null,"_content":"\n[来源: Trinea codeKK][3]\n\n\n查找bug 的神器： [bugtags][1]\n\n\n\n快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br>\n\n\n\t\t  Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n\t\t \n\t\t \n\n\n\n\n![][2]\n\n### 它在移动端是的主要功能包括：\n\n1. 任何地方快速标记 Bug，分配给对应开发\n跟他们官网说的一样，测试从未如此简单！\n\n2. 自动记录 App Crash Bug\nApp Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。\n\n3. 无网下次重传\n\n4. 摇一摇作为彩蛋\nBugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。\n\n\n\n\n### 传统的 App Bug 发现过程是这样的：\n\n> 测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发\n\n> 产品经理跑过来“这个这个地方有问题，你改下”\n\n> 老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug\n\n\n### 使用方式：\n1. 在 [bugtags][1] 里面集成开发对应的SDK，\n2. 添加依赖\n\t`compile 'com.bugtags.library:bugtags-lib:latest.integration'`\n3. 在 Application 初始化\n\n```\t\n\npublic class MyApplication extends Application {\n　@Override\n　public void onCreate() {\n　　super.onCreate();\n\n　　// 在这里初始化\n　　Bugtags.start(\"App key\", this, Bugtags.BTGInvocationEventBubble);\n　}\n}\n\n```\n\n### 添加回调\n\n```\npublic class BaseActivity extends Activity{\n　@Override\n　protected void onResume() {\n　　super.onResume();\n　　// 注：回调 1\n　　Bugtags.onResume(this);\n　}\n　@Override\n　protected void onPause() {\n　　super.onPause();\n　　// 注：回调 2\n　　Bugtags.onPause(this);\n　}\n　@Override\n　public boolean dispatchTouchEvent(MotionEvent event) {\n　　// 注：回调 3\n　　Bugtags.onDispatchTouchEvent(this, event);\n　　return super.dispatchTouchEvent(event);\n　}\n}\n\n```\n\n如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。\n\nPS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-> 授权管理->应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。\n\n<br>\n\n<br>\n\n<br>\n\n###### 目前他们也在计划开放 API，方便其他系统接入。\n\n\n\n\n\n---\n[1]: https://bugtags.com\n[2]: http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir","source":"_posts/Android-和-IOS-应用查找bug-利器.md","raw":"title: Android 和 IOS 应用查找bug 利器\ndate: 2015-09-26 15:12:50\ncategories:\nkeywords:\ntags: android\n---\n\n[来源: Trinea codeKK][3]\n\n\n查找bug 的神器： [bugtags][1]\n\n\n\n快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br>\n\n\n\t\t  Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n\t\t \n\t\t \n\n\n\n\n![][2]\n\n### 它在移动端是的主要功能包括：\n\n1. 任何地方快速标记 Bug，分配给对应开发\n跟他们官网说的一样，测试从未如此简单！\n\n2. 自动记录 App Crash Bug\nApp Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。\n\n3. 无网下次重传\n\n4. 摇一摇作为彩蛋\nBugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。\n\n\n\n\n### 传统的 App Bug 发现过程是这样的：\n\n> 测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发\n\n> 产品经理跑过来“这个这个地方有问题，你改下”\n\n> 老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug\n\n\n### 使用方式：\n1. 在 [bugtags][1] 里面集成开发对应的SDK，\n2. 添加依赖\n\t`compile 'com.bugtags.library:bugtags-lib:latest.integration'`\n3. 在 Application 初始化\n\n```\t\n\npublic class MyApplication extends Application {\n　@Override\n　public void onCreate() {\n　　super.onCreate();\n\n　　// 在这里初始化\n　　Bugtags.start(\"App key\", this, Bugtags.BTGInvocationEventBubble);\n　}\n}\n\n```\n\n### 添加回调\n\n```\npublic class BaseActivity extends Activity{\n　@Override\n　protected void onResume() {\n　　super.onResume();\n　　// 注：回调 1\n　　Bugtags.onResume(this);\n　}\n　@Override\n　protected void onPause() {\n　　super.onPause();\n　　// 注：回调 2\n　　Bugtags.onPause(this);\n　}\n　@Override\n　public boolean dispatchTouchEvent(MotionEvent event) {\n　　// 注：回调 3\n　　Bugtags.onDispatchTouchEvent(this, event);\n　　return super.dispatchTouchEvent(event);\n　}\n}\n\n```\n\n如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。\n\nPS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-> 授权管理->应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。\n\n<br>\n\n<br>\n\n<br>\n\n###### 目前他们也在计划开放 API，方便其他系统接入。\n\n\n\n\n\n---\n[1]: https://bugtags.com\n[2]: http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir","slug":"Android-和-IOS-应用查找bug-利器","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afb0003xzexlmm9cj1k","content":"<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">来源: Trinea codeKK</a></p>\n<p>查找bug 的神器： <a href=\"https://bugtags.com\" target=\"_blank\" rel=\"external\">bugtags</a></p>\n<p>快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br></p>\n<pre><code>Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n</code></pre><p><img src=\"http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"\"></p>\n<h3 id=\"它在移动端是的主要功能包括：\"><a href=\"#它在移动端是的主要功能包括：\" class=\"headerlink\" title=\"它在移动端是的主要功能包括：\"></a>它在移动端是的主要功能包括：</h3><ol>\n<li><p>任何地方快速标记 Bug，分配给对应开发<br>跟他们官网说的一样，测试从未如此简单！</p>\n</li>\n<li><p>自动记录 App Crash Bug<br>App Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。</p>\n</li>\n<li><p>无网下次重传</p>\n</li>\n<li><p>摇一摇作为彩蛋<br>Bugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。</p>\n</li>\n</ol>\n<h3 id=\"传统的-App-Bug-发现过程是这样的：\"><a href=\"#传统的-App-Bug-发现过程是这样的：\" class=\"headerlink\" title=\"传统的 App Bug 发现过程是这样的：\"></a>传统的 App Bug 发现过程是这样的：</h3><blockquote>\n<p>测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发</p>\n<p>产品经理跑过来“这个这个地方有问题，你改下”</p>\n<p>老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug</p>\n</blockquote>\n<h3 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h3><ol>\n<li>在 <a href=\"https://bugtags.com\" target=\"_blank\" rel=\"external\">bugtags</a> 里面集成开发对应的SDK，</li>\n<li>添加依赖<br> <code>compile &#39;com.bugtags.library:bugtags-lib:latest.integration&#39;</code></li>\n<li>在 Application 初始化</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">　<span class=\"meta\">@Override</span></span><br><span class=\"line\">　public void onCreate() &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"comment\">// 在这里初始化</span></span><br><span class=\"line\">　　<span class=\"type\">Bugtags</span>.start(<span class=\"string\">\"App key\"</span>, <span class=\"keyword\">this</span>, <span class=\"type\">Bugtags</span>.<span class=\"type\">BTGInvocationEventBubble</span>);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加回调\"><a href=\"#添加回调\" class=\"headerlink\" title=\"添加回调\"></a>添加回调</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">class</span> <span class=\"selector-tag\">BaseActivity</span> <span class=\"selector-tag\">extends</span> <span class=\"selector-tag\">Activity</span>&#123;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onResume() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onResume</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 1</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onResume</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onPause() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onPause</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 2</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onPause</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 3</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onDispatchTouchEvent</span>(this, event);</span><br><span class=\"line\">　　return super<span class=\"selector-class\">.dispatchTouchEvent</span>(event);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。</p>\n<p>PS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-&gt; 授权管理-&gt;应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。</p>\n<p><br></p>\n<p><br></p>\n<p><br></p>\n<h6 id=\"目前他们也在计划开放-API，方便其他系统接入。\"><a href=\"#目前他们也在计划开放-API，方便其他系统接入。\" class=\"headerlink\" title=\"目前他们也在计划开放 API，方便其他系统接入。\"></a>目前他们也在计划开放 API，方便其他系统接入。</h6><hr>\n","excerpt":"","more":"<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">来源: Trinea codeKK</a></p>\n<p>查找bug 的神器： <a href=\"https://bugtags.com\">bugtags</a></p>\n<p>快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br></p>\n<pre><code>Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n</code></pre><p><img src=\"http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"\"></p>\n<h3 id=\"它在移动端是的主要功能包括：\"><a href=\"#它在移动端是的主要功能包括：\" class=\"headerlink\" title=\"它在移动端是的主要功能包括：\"></a>它在移动端是的主要功能包括：</h3><ol>\n<li><p>任何地方快速标记 Bug，分配给对应开发<br>跟他们官网说的一样，测试从未如此简单！</p>\n</li>\n<li><p>自动记录 App Crash Bug<br>App Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。</p>\n</li>\n<li><p>无网下次重传</p>\n</li>\n<li><p>摇一摇作为彩蛋<br>Bugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。</p>\n</li>\n</ol>\n<h3 id=\"传统的-App-Bug-发现过程是这样的：\"><a href=\"#传统的-App-Bug-发现过程是这样的：\" class=\"headerlink\" title=\"传统的 App Bug 发现过程是这样的：\"></a>传统的 App Bug 发现过程是这样的：</h3><blockquote>\n<p>测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发</p>\n<p>产品经理跑过来“这个这个地方有问题，你改下”</p>\n<p>老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug</p>\n</blockquote>\n<h3 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h3><ol>\n<li>在 <a href=\"https://bugtags.com\">bugtags</a> 里面集成开发对应的SDK，</li>\n<li>添加依赖<br> <code>compile &#39;com.bugtags.library:bugtags-lib:latest.integration&#39;</code></li>\n<li>在 Application 初始化</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">　<span class=\"meta\">@Override</span></span><br><span class=\"line\">　public void onCreate() &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"comment\">// 在这里初始化</span></span><br><span class=\"line\">　　<span class=\"type\">Bugtags</span>.start(<span class=\"string\">\"App key\"</span>, <span class=\"keyword\">this</span>, <span class=\"type\">Bugtags</span>.<span class=\"type\">BTGInvocationEventBubble</span>);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加回调\"><a href=\"#添加回调\" class=\"headerlink\" title=\"添加回调\"></a>添加回调</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">class</span> <span class=\"selector-tag\">BaseActivity</span> <span class=\"selector-tag\">extends</span> <span class=\"selector-tag\">Activity</span>&#123;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onResume() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onResume</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 1</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onResume</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onPause() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onPause</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 2</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onPause</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 3</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onDispatchTouchEvent</span>(this, event);</span><br><span class=\"line\">　　return super<span class=\"selector-class\">.dispatchTouchEvent</span>(event);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。</p>\n<p>PS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-&gt; 授权管理-&gt;应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。</p>\n<p><br></p>\n<p><br></p>\n<p><br></p>\n<h6 id=\"目前他们也在计划开放-API，方便其他系统接入。\"><a href=\"#目前他们也在计划开放-API，方便其他系统接入。\" class=\"headerlink\" title=\"目前他们也在计划开放 API，方便其他系统接入。\"></a>目前他们也在计划开放 API，方便其他系统接入。</h6><hr>\n"},{"title":"AndroidStudio","date":"2015-09-19T09:02:01.000Z","_content":"\nAndroid Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：\n\n- 1.修改系统hosts文件，添加如下2行\n\n\t\t203.208.46.146   dl-ssl.google.com\n\t\t203.208.46.146   dl.google.com\n\t\t\n- 2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行\n\n\t\t-Djava.net.preferIPv4Stack=true  \n\t\t-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n\t\t-Didea.patches.url=http://dl.google.com/android/studio/patches/\n\t\t\n\t**重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n**\n\n- 3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。\n- 4.android studio首次安装运行时卡在更新处理方法\n\t\n\t01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。\n\t\n\t02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加\n\t\t\n\t\tdisable.android.first.run=true \n\n\n本方法适用于在某些网络下无法直接更新的问题\n\n\n---\n\n","source":"_posts/AndroidStudio.md","raw":"title: AndroidStudio\ndate: 2015-09-19 17:02:01\ntags: AndroidStudio\n---\n\nAndroid Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：\n\n- 1.修改系统hosts文件，添加如下2行\n\n\t\t203.208.46.146   dl-ssl.google.com\n\t\t203.208.46.146   dl.google.com\n\t\t\n- 2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行\n\n\t\t-Djava.net.preferIPv4Stack=true  \n\t\t-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n\t\t-Didea.patches.url=http://dl.google.com/android/studio/patches/\n\t\t\n\t**重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n**\n\n- 3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。\n- 4.android studio首次安装运行时卡在更新处理方法\n\t\n\t01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。\n\t\n\t02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加\n\t\t\n\t\tdisable.android.first.run=true \n\n\n本方法适用于在某些网络下无法直接更新的问题\n\n\n---\n\n","slug":"AndroidStudio","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afd0004xzex0daqz1wd","content":"<p>Android Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：</p>\n<ul>\n<li><p>1.修改系统hosts文件，添加如下2行</p>\n<pre><code>203.208.46.146   dl-ssl.google.com\n203.208.46.146   dl.google.com\n</code></pre></li>\n<li><p>2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行</p>\n<pre><code>-Djava.net.preferIPv4Stack=true  \n-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n-Didea.patches.url=http://dl.google.com/android/studio/patches/\n</code></pre><p>  <strong>重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n</strong></p>\n</li>\n<li><p>3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。</p>\n</li>\n<li><p>4.android studio首次安装运行时卡在更新处理方法</p>\n<p>  01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。</p>\n<p>  02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加</p>\n<pre><code>disable.android.first.run=true \n</code></pre></li>\n</ul>\n<p>本方法适用于在某些网络下无法直接更新的问题</p>\n<hr>\n","excerpt":"","more":"<p>Android Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：</p>\n<ul>\n<li><p>1.修改系统hosts文件，添加如下2行</p>\n<pre><code>203.208.46.146   dl-ssl.google.com\n203.208.46.146   dl.google.com\n</code></pre></li>\n<li><p>2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行</p>\n<pre><code>-Djava.net.preferIPv4Stack=true  \n-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n-Didea.patches.url=http://dl.google.com/android/studio/patches/\n</code></pre><p>  <strong>重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n</strong></p>\n</li>\n<li><p>3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。</p>\n</li>\n<li><p>4.android studio首次安装运行时卡在更新处理方法</p>\n<p>  01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。</p>\n<p>  02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加</p>\n<pre><code>disable.android.first.run=true \n</code></pre></li>\n</ul>\n<p>本方法适用于在某些网络下无法直接更新的问题</p>\n<hr>\n"},{"title":"Android_gradle工作原理","date":"2015-09-13T04:47:49.000Z","_content":"\n在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（*不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式*）。\n\n\n### gradle 构建流程：\n\n下图是google官方的构建流程图\n\n![andoroid gradle工作原理图][1]\n\n### 简单可以分为以下几类：\n\n1. AndroidManifest.xml 合并\n2. Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并\n3. Asserts 合并\n\n**以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。**\n\n\n\n\n\n\n---\n[1]: http://i1.tietuku.com/4fa0701d09e5704a.png","source":"_posts/Android-gradle工作原理.md","raw":"title: Android_gradle工作原理\ndate: 2015-09-13 12:47:49\ntags: android gradle工作原理\n---\n\n在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（*不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式*）。\n\n\n### gradle 构建流程：\n\n下图是google官方的构建流程图\n\n![andoroid gradle工作原理图][1]\n\n### 简单可以分为以下几类：\n\n1. AndroidManifest.xml 合并\n2. Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并\n3. Asserts 合并\n\n**以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。**\n\n\n\n\n\n\n---\n[1]: http://i1.tietuku.com/4fa0701d09e5704a.png","slug":"Android-gradle工作原理","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afh0006xzex1nusqmzs","content":"<p>在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（<em>不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式</em>）。</p>\n<h3 id=\"gradle-构建流程：\"><a href=\"#gradle-构建流程：\" class=\"headerlink\" title=\"gradle 构建流程：\"></a>gradle 构建流程：</h3><p>下图是google官方的构建流程图</p>\n<p><img src=\"http://i1.tietuku.com/4fa0701d09e5704a.png\" alt=\"andoroid gradle工作原理图\"></p>\n<h3 id=\"简单可以分为以下几类：\"><a href=\"#简单可以分为以下几类：\" class=\"headerlink\" title=\"简单可以分为以下几类：\"></a>简单可以分为以下几类：</h3><ol>\n<li>AndroidManifest.xml 合并</li>\n<li>Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并</li>\n<li>Asserts 合并</li>\n</ol>\n<p><strong>以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。</strong></p>\n<hr>\n","excerpt":"","more":"<p>在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（<em>不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式</em>）。</p>\n<h3 id=\"gradle-构建流程：\"><a href=\"#gradle-构建流程：\" class=\"headerlink\" title=\"gradle 构建流程：\"></a>gradle 构建流程：</h3><p>下图是google官方的构建流程图</p>\n<p><img src=\"http://i1.tietuku.com/4fa0701d09e5704a.png\" alt=\"andoroid gradle工作原理图\"></p>\n<h3 id=\"简单可以分为以下几类：\"><a href=\"#简单可以分为以下几类：\" class=\"headerlink\" title=\"简单可以分为以下几类：\"></a>简单可以分为以下几类：</h3><ol>\n<li>AndroidManifest.xml 合并</li>\n<li>Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并</li>\n<li>Asserts 合并</li>\n</ol>\n<p><strong>以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。</strong></p>\n<hr>\n"},{"title":"Android在图形界面UI方面的工具","date":"2015-10-09T07:03:19.000Z","keywords":null,"_content":"#### [来源][1]\n\n\n\n之前折腾过一些Android的UI，比如：\n\n### 9patch方面的：\n\n[【记录】继续为Android的EditText制作9 patch图片][2]\n\n其中用到了，无意间发现的，用于专门制作9 patch的在线工具：\n\n[Android Holo Colors][3]\n\n然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：\n\n[Android Asset Studio][4]\n\n其中包含与UI有关的，很多方面的工具：\n\n### 图标有关的\n\n- [Launcher icons][5] ：制作启动界面的图片的？\n- [Action bar and tab icons][6] ：工具栏的图片\n- [Notification icons ][7]：通知栏图片\n- [Navigation drawer indicator][8] ：导航栏图片\n- [Generic icons][9] ：通用的图片\n- [Tab icons (pre-Android 3.0)][10] ：旧的Tab的图片\n- [Menu icons (pre-Android 3.0) ][11]：旧的菜单的图片\n\n### 其他的生成器\n\n[Device frame generator][12] (or see the [official version for Nexus devices][13] ) ：设备帧？\n[Simple nine-patch generator][14] ：简单的9 patch图片生成器\n社区提供的工具\n\n[Android Action Bar Style Generator][15] by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片\n[Android Holo Colors Generator][16] by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。\n总之：\n\n这些工具，都还是很好用的。\n\n当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。\n\n\n---\n[1]: http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\n[2]: http://www.crifan.com/android_make_9_patch_for_edittext/\n[3]: http://android-holo-colors.com/\n[4]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\n[5]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\n[6]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\n[7]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\n[8]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\n[9]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\n[10]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\n[11]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\n[12]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\n[13]: http://developer.android.com/distribute/promote/device-art.html\n[14]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\n[15]: http://jgilfelt.github.com/android-actionbarstylegenerator/\n[16]: http://android-holo-colors.com/\n\n","source":"_posts/Android在图形界面UI方面的工具.md","raw":"title: Android在图形界面UI方面的工具\ndate: 2015-10-09 15:03:19\ncategories:\nkeywords:\ntags: android\n---\n#### [来源][1]\n\n\n\n之前折腾过一些Android的UI，比如：\n\n### 9patch方面的：\n\n[【记录】继续为Android的EditText制作9 patch图片][2]\n\n其中用到了，无意间发现的，用于专门制作9 patch的在线工具：\n\n[Android Holo Colors][3]\n\n然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：\n\n[Android Asset Studio][4]\n\n其中包含与UI有关的，很多方面的工具：\n\n### 图标有关的\n\n- [Launcher icons][5] ：制作启动界面的图片的？\n- [Action bar and tab icons][6] ：工具栏的图片\n- [Notification icons ][7]：通知栏图片\n- [Navigation drawer indicator][8] ：导航栏图片\n- [Generic icons][9] ：通用的图片\n- [Tab icons (pre-Android 3.0)][10] ：旧的Tab的图片\n- [Menu icons (pre-Android 3.0) ][11]：旧的菜单的图片\n\n### 其他的生成器\n\n[Device frame generator][12] (or see the [official version for Nexus devices][13] ) ：设备帧？\n[Simple nine-patch generator][14] ：简单的9 patch图片生成器\n社区提供的工具\n\n[Android Action Bar Style Generator][15] by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片\n[Android Holo Colors Generator][16] by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。\n总之：\n\n这些工具，都还是很好用的。\n\n当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。\n\n\n---\n[1]: http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\n[2]: http://www.crifan.com/android_make_9_patch_for_edittext/\n[3]: http://android-holo-colors.com/\n[4]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\n[5]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\n[6]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\n[7]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\n[8]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\n[9]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\n[10]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\n[11]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\n[12]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\n[13]: http://developer.android.com/distribute/promote/device-art.html\n[14]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\n[15]: http://jgilfelt.github.com/android-actionbarstylegenerator/\n[16]: http://android-holo-colors.com/\n\n","slug":"Android在图形界面UI方面的工具","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afk0007xzexhid9ssyq","content":"<h4 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a><a href=\"http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\" target=\"_blank\" rel=\"external\">来源</a></h4><p>之前折腾过一些Android的UI，比如：</p>\n<h3 id=\"9patch方面的：\"><a href=\"#9patch方面的：\" class=\"headerlink\" title=\"9patch方面的：\"></a>9patch方面的：</h3><p><a href=\"http://www.crifan.com/android_make_9_patch_for_edittext/\" target=\"_blank\" rel=\"external\">【记录】继续为Android的EditText制作9 patch图片</a></p>\n<p>其中用到了，无意间发现的，用于专门制作9 patch的在线工具：</p>\n<p><a href=\"http://android-holo-colors.com/\" target=\"_blank\" rel=\"external\">Android Holo Colors</a></p>\n<p>然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：</p>\n<p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\" target=\"_blank\" rel=\"external\">Android Asset Studio</a></p>\n<p>其中包含与UI有关的，很多方面的工具：</p>\n<h3 id=\"图标有关的\"><a href=\"#图标有关的\" class=\"headerlink\" title=\"图标有关的\"></a>图标有关的</h3><ul>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\" target=\"_blank\" rel=\"external\">Launcher icons</a> ：制作启动界面的图片的？</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\" target=\"_blank\" rel=\"external\">Action bar and tab icons</a> ：工具栏的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\" target=\"_blank\" rel=\"external\">Notification icons </a>：通知栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\" target=\"_blank\" rel=\"external\">Navigation drawer indicator</a> ：导航栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\" target=\"_blank\" rel=\"external\">Generic icons</a> ：通用的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\" target=\"_blank\" rel=\"external\">Tab icons (pre-Android 3.0)</a> ：旧的Tab的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\" target=\"_blank\" rel=\"external\">Menu icons (pre-Android 3.0) </a>：旧的菜单的图片</li>\n</ul>\n<h3 id=\"其他的生成器\"><a href=\"#其他的生成器\" class=\"headerlink\" title=\"其他的生成器\"></a>其他的生成器</h3><p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\" target=\"_blank\" rel=\"external\">Device frame generator</a> (or see the <a href=\"http://developer.android.com/distribute/promote/device-art.html\" target=\"_blank\" rel=\"external\">official version for Nexus devices</a> ) ：设备帧？<br><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\" target=\"_blank\" rel=\"external\">Simple nine-patch generator</a> ：简单的9 patch图片生成器<br>社区提供的工具</p>\n<p><a href=\"http://jgilfelt.github.com/android-actionbarstylegenerator/\" target=\"_blank\" rel=\"external\">Android Action Bar Style Generator</a> by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片<br><a href=\"http://android-holo-colors.com/\" target=\"_blank\" rel=\"external\">Android Holo Colors Generator</a> by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。<br>总之：</p>\n<p>这些工具，都还是很好用的。</p>\n<p>当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。</p>\n<hr>\n","excerpt":"","more":"<h4 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a><a href=\"http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\">来源</a></h4><p>之前折腾过一些Android的UI，比如：</p>\n<h3 id=\"9patch方面的：\"><a href=\"#9patch方面的：\" class=\"headerlink\" title=\"9patch方面的：\"></a>9patch方面的：</h3><p><a href=\"http://www.crifan.com/android_make_9_patch_for_edittext/\">【记录】继续为Android的EditText制作9 patch图片</a></p>\n<p>其中用到了，无意间发现的，用于专门制作9 patch的在线工具：</p>\n<p><a href=\"http://android-holo-colors.com/\">Android Holo Colors</a></p>\n<p>然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：</p>\n<p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\">Android Asset Studio</a></p>\n<p>其中包含与UI有关的，很多方面的工具：</p>\n<h3 id=\"图标有关的\"><a href=\"#图标有关的\" class=\"headerlink\" title=\"图标有关的\"></a>图标有关的</h3><ul>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\">Launcher icons</a> ：制作启动界面的图片的？</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\">Action bar and tab icons</a> ：工具栏的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\">Notification icons </a>：通知栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\">Navigation drawer indicator</a> ：导航栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\">Generic icons</a> ：通用的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\">Tab icons (pre-Android 3.0)</a> ：旧的Tab的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\">Menu icons (pre-Android 3.0) </a>：旧的菜单的图片</li>\n</ul>\n<h3 id=\"其他的生成器\"><a href=\"#其他的生成器\" class=\"headerlink\" title=\"其他的生成器\"></a>其他的生成器</h3><p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\">Device frame generator</a> (or see the <a href=\"http://developer.android.com/distribute/promote/device-art.html\">official version for Nexus devices</a> ) ：设备帧？<br><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\">Simple nine-patch generator</a> ：简单的9 patch图片生成器<br>社区提供的工具</p>\n<p><a href=\"http://jgilfelt.github.com/android-actionbarstylegenerator/\">Android Action Bar Style Generator</a> by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片<br><a href=\"http://android-holo-colors.com/\">Android Holo Colors Generator</a> by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。<br>总之：</p>\n<p>这些工具，都还是很好用的。</p>\n<p>当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。</p>\n<hr>\n"},{"title":"Android开发者提升技能水平的大招","date":"2016-02-19T09:40:14.000Z","keywords":null,"_content":"<br>\n国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。\n\n> 本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。\n\n### 参加活动，沙龙，技术聚会：\n\n参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。\n\n### 参加培训：\n\n公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。\n\n### 参加讨论会：\n\n参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。\n\n### 回答问题：\n\n个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。\n\n### 边吃边学：\n\n如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。\n\n### 加入一个开源项目：\n\n开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。\n\n### 读书，读代码，读博客：\n\n可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。\n\n### 发表博客：\n\n编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。\n\n### 通过做Kata来实践：\n\nKata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。\n\n### 写书：\n\n在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。\n\n这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。\n\n### 看视频教程，听播客，看在线研讨会：\n\n从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。\n\n在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：\n\n![](http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg)\n\n\n**很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？**\n\n<br>\n\n来自：[ http://mobile.51cto.com/anews-417838.htm ](#)\n\n参考：[ https://www.zhihu.com/question/20217218 ](#)","source":"_posts/Android开发者提升技能水平的大招.md","raw":"title: Android开发者提升技能水平的大招\ndate: 2016-02-19 17:40:14\ncategories:\nkeywords:\ntags: 技能提升\n---\n<br>\n国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。\n\n> 本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。\n\n### 参加活动，沙龙，技术聚会：\n\n参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。\n\n### 参加培训：\n\n公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。\n\n### 参加讨论会：\n\n参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。\n\n### 回答问题：\n\n个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。\n\n### 边吃边学：\n\n如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。\n\n### 加入一个开源项目：\n\n开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。\n\n### 读书，读代码，读博客：\n\n可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。\n\n### 发表博客：\n\n编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。\n\n### 通过做Kata来实践：\n\nKata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。\n\n### 写书：\n\n在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。\n\n这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。\n\n### 看视频教程，听播客，看在线研讨会：\n\n从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。\n\n在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：\n\n![](http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg)\n\n\n**很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？**\n\n<br>\n\n来自：[ http://mobile.51cto.com/anews-417838.htm ](#)\n\n参考：[ https://www.zhihu.com/question/20217218 ](#)","slug":"Android开发者提升技能水平的大招","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afq0009xzex28wpn04f","content":"<p><br><br>国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。</p>\n<blockquote>\n<p>本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。</p>\n</blockquote>\n<h3 id=\"参加活动，沙龙，技术聚会：\"><a href=\"#参加活动，沙龙，技术聚会：\" class=\"headerlink\" title=\"参加活动，沙龙，技术聚会：\"></a>参加活动，沙龙，技术聚会：</h3><p>参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。</p>\n<h3 id=\"参加培训：\"><a href=\"#参加培训：\" class=\"headerlink\" title=\"参加培训：\"></a>参加培训：</h3><p>公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。</p>\n<h3 id=\"参加讨论会：\"><a href=\"#参加讨论会：\" class=\"headerlink\" title=\"参加讨论会：\"></a>参加讨论会：</h3><p>参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。</p>\n<h3 id=\"回答问题：\"><a href=\"#回答问题：\" class=\"headerlink\" title=\"回答问题：\"></a>回答问题：</h3><p>个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。</p>\n<h3 id=\"边吃边学：\"><a href=\"#边吃边学：\" class=\"headerlink\" title=\"边吃边学：\"></a>边吃边学：</h3><p>如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。</p>\n<h3 id=\"加入一个开源项目：\"><a href=\"#加入一个开源项目：\" class=\"headerlink\" title=\"加入一个开源项目：\"></a>加入一个开源项目：</h3><p>开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。</p>\n<h3 id=\"读书，读代码，读博客：\"><a href=\"#读书，读代码，读博客：\" class=\"headerlink\" title=\"读书，读代码，读博客：\"></a>读书，读代码，读博客：</h3><p>可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。</p>\n<h3 id=\"发表博客：\"><a href=\"#发表博客：\" class=\"headerlink\" title=\"发表博客：\"></a>发表博客：</h3><p>编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。</p>\n<h3 id=\"通过做Kata来实践：\"><a href=\"#通过做Kata来实践：\" class=\"headerlink\" title=\"通过做Kata来实践：\"></a>通过做Kata来实践：</h3><p>Kata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。</p>\n<h3 id=\"写书：\"><a href=\"#写书：\" class=\"headerlink\" title=\"写书：\"></a>写书：</h3><p>在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。</p>\n<p>这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。</p>\n<h3 id=\"看视频教程，听播客，看在线研讨会：\"><a href=\"#看视频教程，听播客，看在线研讨会：\" class=\"headerlink\" title=\"看视频教程，听播客，看在线研讨会：\"></a>看视频教程，听播客，看在线研讨会：</h3><p>从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。</p>\n<p>在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：</p>\n<p><img src=\"http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg\" alt=\"\"></p>\n<p><strong>很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？</strong></p>\n<p><br></p>\n<p>来自：<a href=\"#\"> http://mobile.51cto.com/anews-417838.htm </a></p>\n<p>参考：<a href=\"#\"> https://www.zhihu.com/question/20217218 </a></p>\n","excerpt":"","more":"<p><br><br>国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。</p>\n<blockquote>\n<p>本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。</p>\n</blockquote>\n<h3 id=\"参加活动，沙龙，技术聚会：\"><a href=\"#参加活动，沙龙，技术聚会：\" class=\"headerlink\" title=\"参加活动，沙龙，技术聚会：\"></a>参加活动，沙龙，技术聚会：</h3><p>参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。</p>\n<h3 id=\"参加培训：\"><a href=\"#参加培训：\" class=\"headerlink\" title=\"参加培训：\"></a>参加培训：</h3><p>公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。</p>\n<h3 id=\"参加讨论会：\"><a href=\"#参加讨论会：\" class=\"headerlink\" title=\"参加讨论会：\"></a>参加讨论会：</h3><p>参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。</p>\n<h3 id=\"回答问题：\"><a href=\"#回答问题：\" class=\"headerlink\" title=\"回答问题：\"></a>回答问题：</h3><p>个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。</p>\n<h3 id=\"边吃边学：\"><a href=\"#边吃边学：\" class=\"headerlink\" title=\"边吃边学：\"></a>边吃边学：</h3><p>如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。</p>\n<h3 id=\"加入一个开源项目：\"><a href=\"#加入一个开源项目：\" class=\"headerlink\" title=\"加入一个开源项目：\"></a>加入一个开源项目：</h3><p>开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。</p>\n<h3 id=\"读书，读代码，读博客：\"><a href=\"#读书，读代码，读博客：\" class=\"headerlink\" title=\"读书，读代码，读博客：\"></a>读书，读代码，读博客：</h3><p>可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。</p>\n<h3 id=\"发表博客：\"><a href=\"#发表博客：\" class=\"headerlink\" title=\"发表博客：\"></a>发表博客：</h3><p>编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。</p>\n<h3 id=\"通过做Kata来实践：\"><a href=\"#通过做Kata来实践：\" class=\"headerlink\" title=\"通过做Kata来实践：\"></a>通过做Kata来实践：</h3><p>Kata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。</p>\n<h3 id=\"写书：\"><a href=\"#写书：\" class=\"headerlink\" title=\"写书：\"></a>写书：</h3><p>在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。</p>\n<p>这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。</p>\n<h3 id=\"看视频教程，听播客，看在线研讨会：\"><a href=\"#看视频教程，听播客，看在线研讨会：\" class=\"headerlink\" title=\"看视频教程，听播客，看在线研讨会：\"></a>看视频教程，听播客，看在线研讨会：</h3><p>从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。</p>\n<p>在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：</p>\n<p><img src=\"http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg\" alt=\"\"></p>\n<p><strong>很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？</strong></p>\n<p><br></p>\n<p>来自：<a href=\"#\"> http://mobile.51cto.com/anews-417838.htm </a></p>\n<p>参考：<a href=\"#\"> https://www.zhihu.com/question/20217218 </a></p>\n"},{"title":"Bug小记(**贵金属)","date":"2015-11-20T10:24:09.000Z","keywords":null,"_content":"# Bug 小记（\\*\\*贵金属）\n\n**作者：球儿**\n\n\n最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：\n####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击\n\n\n使用 GCD 写的倒计时，源代码：\n \n    _isCountDown = YES;\n    __block int timeout=kCountdownTime; //倒计时时间\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\n    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\n    dispatch_source_set_event_handler(_timer, ^{\n        if(timeout<=0){ //倒计时结束，关闭\n            dispatch_source_cancel(_timer);\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n                \n                [self.getSmsCodeBtn setEnabled:YES];\n                _isCountDown = NO;\n            });\n        }else{\n            NSString *strTime = [NSString stringWithFormat:@\"%ds后重发\",timeout];\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n            });\n            timeout--;\n            \n        }\n    });\n    dispatch_resume(_timer);\n\n\n\n如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 [http://blog.csdn.net/zhangyanshen/article/details/46910515][1]\n\n\n\n<font color=green>**解决方案：**</font>\n\n`[sendAuthCodeBtn setTitle:@\"发送验证码\" forState:UIControlStateDisabled];` \n\n\n关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。\n\n</br>\n#### Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\n</br>\nUIButton 设置 title时会闪烁。\n\n<font color=brown>**原因：**</font>UIButton 的 buttonType 是 System 类型时会出现该种问题\n\n<font color=green>**解决方案：**</font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。\n\n</br>\n#### Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\n</br>\nplist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。\n\n<font color=brown>**原因：**</font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。\n\n<font color=green>**解决方案：**</font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）\n\n\n[1]:\thttp://blog.csdn.net/zhangyanshen/article/details/46910515 \"http://blog.csdn.net/zhangyanshen/article/details/46910515\"","source":"_posts/Bug小记-贵金属.md","raw":"title: 'Bug小记(**贵金属)'\ndate: 2015-11-20 18:24:09\ncategories:\nkeywords:\ntags: ios\n---\n# Bug 小记（\\*\\*贵金属）\n\n**作者：球儿**\n\n\n最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：\n####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击\n\n\n使用 GCD 写的倒计时，源代码：\n \n    _isCountDown = YES;\n    __block int timeout=kCountdownTime; //倒计时时间\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\n    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\n    dispatch_source_set_event_handler(_timer, ^{\n        if(timeout<=0){ //倒计时结束，关闭\n            dispatch_source_cancel(_timer);\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n                \n                [self.getSmsCodeBtn setEnabled:YES];\n                _isCountDown = NO;\n            });\n        }else{\n            NSString *strTime = [NSString stringWithFormat:@\"%ds后重发\",timeout];\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n            });\n            timeout--;\n            \n        }\n    });\n    dispatch_resume(_timer);\n\n\n\n如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 [http://blog.csdn.net/zhangyanshen/article/details/46910515][1]\n\n\n\n<font color=green>**解决方案：**</font>\n\n`[sendAuthCodeBtn setTitle:@\"发送验证码\" forState:UIControlStateDisabled];` \n\n\n关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。\n\n</br>\n#### Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\n</br>\nUIButton 设置 title时会闪烁。\n\n<font color=brown>**原因：**</font>UIButton 的 buttonType 是 System 类型时会出现该种问题\n\n<font color=green>**解决方案：**</font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。\n\n</br>\n#### Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\n</br>\nplist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。\n\n<font color=brown>**原因：**</font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。\n\n<font color=green>**解决方案：**</font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）\n\n\n[1]:\thttp://blog.csdn.net/zhangyanshen/article/details/46910515 \"http://blog.csdn.net/zhangyanshen/article/details/46910515\"","slug":"Bug小记-贵金属","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afu000bxzex4ba7btpo","content":"<h1 id=\"Bug-小记（-贵金属）\"><a href=\"#Bug-小记（-贵金属）\" class=\"headerlink\" title=\"Bug 小记（**贵金属）\"></a>Bug 小记（**贵金属）</h1><p><strong>作者：球儿</strong></p>\n<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：</p>\n<p>####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击</p>\n<p>使用 GCD 写的倒计时，源代码：</p>\n<pre><code>_isCountDown = YES;\n__block int timeout=kCountdownTime; //倒计时时间\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\ndispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\ndispatch_source_set_event_handler(_timer, ^{\n    if(timeout&lt;=0){ //倒计时结束，关闭\n        dispatch_source_cancel(_timer);\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n\n            [self.getSmsCodeBtn setEnabled:YES];\n            _isCountDown = NO;\n        });\n    }else{\n        NSString *strTime = [NSString stringWithFormat:@&quot;%ds后重发&quot;,timeout];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n        });\n        timeout--;\n\n    }\n});\ndispatch_resume(_timer);\n</code></pre><p>如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 <a href=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\" title=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zhangyanshen/article/details/46910515</a></p>\n<font color=\"green\"><strong>解决方案：</strong></font>\n\n<p><code>[sendAuthCodeBtn setTitle:@&quot;发送验证码&quot; forState:UIControlStateDisabled];</code> </p>\n<p>关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。</p>\n<p><br></p>\n<h4 id=\"Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\"><a href=\"#Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\" class=\"headerlink\" title=\"Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\"></a>Bug1：倒计时 UIButton 上的文字变更会有闪烁效果</h4><p><br><br>UIButton 设置 title时会闪烁。</p>\n<p><font color=\"brown\"><strong>原因：</strong></font>UIButton 的 buttonType 是 System 类型时会出现该种问题</p>\n<p><font color=\"green\"><strong>解决方案：</strong></font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。</p>\n<p><br></p>\n<h4 id=\"Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"><a href=\"#Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\" class=\"headerlink\" title=\"Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"></a>Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变</h4><p><br><br>plist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。</p>\n<p><font color=\"brown\"><strong>原因：</strong></font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。</p>\n<p><font color=\"green\"><strong>解决方案：</strong></font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）</p>\n","excerpt":"","more":"<h1 id=\"Bug-小记（-贵金属）\"><a href=\"#Bug-小记（-贵金属）\" class=\"headerlink\" title=\"Bug 小记（**贵金属）\"></a>Bug 小记（**贵金属）</h1><p><strong>作者：球儿</strong></p>\n<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：</p>\n<p>####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击</p>\n<p>使用 GCD 写的倒计时，源代码：</p>\n<pre><code>_isCountDown = YES;\n__block int timeout=kCountdownTime; //倒计时时间\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\ndispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\ndispatch_source_set_event_handler(_timer, ^{\n    if(timeout&lt;=0){ //倒计时结束，关闭\n        dispatch_source_cancel(_timer);\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n\n            [self.getSmsCodeBtn setEnabled:YES];\n            _isCountDown = NO;\n        });\n    }else{\n        NSString *strTime = [NSString stringWithFormat:@&quot;%ds后重发&quot;,timeout];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n        });\n        timeout--;\n\n    }\n});\ndispatch_resume(_timer);\n</code></pre><p>如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 <a href=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\" title=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\">http://blog.csdn.net/zhangyanshen/article/details/46910515</a></p>\n<font color=green><strong>解决方案：</strong></font>\n\n<p><code>[sendAuthCodeBtn setTitle:@&quot;发送验证码&quot; forState:UIControlStateDisabled];</code> </p>\n<p>关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。</p>\n<p></br></p>\n<h4 id=\"Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\"><a href=\"#Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\" class=\"headerlink\" title=\"Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\"></a>Bug1：倒计时 UIButton 上的文字变更会有闪烁效果</h4><p></br><br>UIButton 设置 title时会闪烁。</p>\n<p><font color=brown><strong>原因：</strong></font>UIButton 的 buttonType 是 System 类型时会出现该种问题</p>\n<p><font color=green><strong>解决方案：</strong></font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。</p>\n<p></br></p>\n<h4 id=\"Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"><a href=\"#Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\" class=\"headerlink\" title=\"Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"></a>Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变</h4><p></br><br>plist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。</p>\n<p><font color=brown><strong>原因：</strong></font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。</p>\n<p><font color=green><strong>解决方案：</strong></font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）</p>\n"},{"title":"Fragment not attached to Activity 异常","date":"2015-11-27T02:48:17.000Z","keywords":null,"_content":"\n\n### 关于Fragment（XXFragment） not attached to Activity 异常\n\n\n出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：[http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity ](http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0) 回答的主要是在调用\n\n\tgetResources().getString(R.string.app_name); \n\n之前增加一个判断isAdded(),两外说这个异常解决办法的有\n[http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity](http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity)\n\n这个是针对另外一种情况下的解决方式。\n\n### 在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\n\n\n\tBundle b = new Bundle(); \n\tb.putParcelable(\"bitmap\", bitmap2); \n\timageRecognitionFragment.setArguments(b); \n\n设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:\n\n\tjava.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n\n### 分析原因：\n\n你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。\n\n这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了\n","source":"_posts/Fragment-not-attached-to-Activity-异常.md","raw":"title: Fragment not attached to Activity 异常\ndate: 2015-11-27 10:48:17\ncategories:\nkeywords:\ntags: android\n---\n\n\n### 关于Fragment（XXFragment） not attached to Activity 异常\n\n\n出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：[http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity ](http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0) 回答的主要是在调用\n\n\tgetResources().getString(R.string.app_name); \n\n之前增加一个判断isAdded(),两外说这个异常解决办法的有\n[http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity](http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity)\n\n这个是针对另外一种情况下的解决方式。\n\n### 在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\n\n\n\tBundle b = new Bundle(); \n\tb.putParcelable(\"bitmap\", bitmap2); \n\timageRecognitionFragment.setArguments(b); \n\n设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:\n\n\tjava.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n\n### 分析原因：\n\n你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。\n\n这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了\n","slug":"Fragment-not-attached-to-Activity-异常","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afw000dxzex4jzjeb1b","content":"<h3 id=\"关于Fragment（XXFragment）-not-attached-to-Activity-异常\"><a href=\"#关于Fragment（XXFragment）-not-attached-to-Activity-异常\" class=\"headerlink\" title=\"关于Fragment（XXFragment） not attached to Activity 异常\"></a>关于Fragment（XXFragment） not attached to Activity 异常</h3><p>出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：<a href=\"http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity </a> 回答的主要是在调用</p>\n<pre><code>getResources().getString(R.string.app_name); \n</code></pre><p>之前增加一个判断isAdded(),两外说这个异常解决办法的有<br><a href=\"http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity</a></p>\n<p>这个是针对另外一种情况下的解决方式。</p>\n<h3 id=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"><a href=\"#在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\" class=\"headerlink\" title=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"></a>在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常</h3><pre><code>Bundle b = new Bundle(); \nb.putParcelable(&quot;bitmap&quot;, bitmap2); \nimageRecognitionFragment.setArguments(b); \n</code></pre><p>设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:</p>\n<pre><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n</code></pre><h3 id=\"分析原因：\"><a href=\"#分析原因：\" class=\"headerlink\" title=\"分析原因：\"></a>分析原因：</h3><p>你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。</p>\n<p>这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了</p>\n","excerpt":"","more":"<h3 id=\"关于Fragment（XXFragment）-not-attached-to-Activity-异常\"><a href=\"#关于Fragment（XXFragment）-not-attached-to-Activity-异常\" class=\"headerlink\" title=\"关于Fragment（XXFragment） not attached to Activity 异常\"></a>关于Fragment（XXFragment） not attached to Activity 异常</h3><p>出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：<a href=\"http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0\">http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity </a> 回答的主要是在调用</p>\n<pre><code>getResources().getString(R.string.app_name); \n</code></pre><p>之前增加一个判断isAdded(),两外说这个异常解决办法的有<br><a href=\"http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity\">http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity</a></p>\n<p>这个是针对另外一种情况下的解决方式。</p>\n<h3 id=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"><a href=\"#在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\" class=\"headerlink\" title=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"></a>在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常</h3><pre><code>Bundle b = new Bundle(); \nb.putParcelable(&quot;bitmap&quot;, bitmap2); \nimageRecognitionFragment.setArguments(b); \n</code></pre><p>设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:</p>\n<pre><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n</code></pre><h3 id=\"分析原因：\"><a href=\"#分析原因：\" class=\"headerlink\" title=\"分析原因：\"></a>分析原因：</h3><p>你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。</p>\n<p>这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了</p>\n"},{"title":"HTTPS的七个误解","date":"2016-07-25T03:20:13.000Z","keywords":"https, 缓存","_content":"\n这段时间在研究 webview 缓存，为了加快用户进入页面的时间，找了一些资料，突然发现 对 Https 理解的不是很深刻，这里整理一下。\n\n我认为不管是 IOS 同学还是 Android 同学，都应该对此有一定的了解。这篇文章的年底略有久远，但是却可以扫盲，还是值得一看。\n\n![](http://image.beekka.com/blog/201102/bg2011021311.jpg)\n\n### 误解七：HTTPS无法缓存\n许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。\n\n微软的IE项目经理Eric Lawrence写道：\n> \"说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）\"\n\nFirefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。\n\n![](http://image.beekka.com/blog/201102/bg2011021301.png)\n\n### 误解六：SSL证书很贵\n如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。\n在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。\n\n### 误解五：HTTPS站点必须有独享的IP地址\n由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。\n![](http://image.beekka.com/blog/201102/bg2011021302.png)\n\n另外，UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。SNI（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。\n\n### 误解四：转移服务器时要购买新证书\n部署SSL证书，需要这样几步：\n> 1. 在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。\n> 2. 使用CSR文件，购买SSL证书。\n> 3. 安装SSL证书。\n\n这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。\n比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。\n![](http://image.beekka.com/blog/201102/bg2011021303.png)\n\n将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。\n\n### 误解三：HTTPS太慢\n使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些技巧可以大大减少额外开销。\n首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。\n其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。\n![](http://image.beekka.com/blog/201102/bg2011021304.png)\n\n第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。\n\n![](http://image.beekka.com/blog/201102/bg2011021305.png)\n\n同一张网页使用HTTPS协议之后，打开时间变长了。\n\n![](http://image.beekka.com/blog/201102/bg2011021306.png)\n\n建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现：\n\n![](http://image.beekka.com/blog/201102/bg2011021307.png)\n\n然后是HTTPS协议：\n\n![](http://image.beekka.com/blog/201102/bg2011021308.png)\n\n某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。\n\n### 误解二：有了HTTPS，Cookie和查询字符串就安全了\n虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。\n比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id:\n![](http://image.beekka.com/blog/201102/bg2011021309.png)\n\n黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过类似方式泄漏。\n\n### 误解一：只有注册登录页，才需要HTTPS\n这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件Firesheep，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。\n咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因：\n> 1. 这种WiFi通常不会加密，所以很容易监控所有流量。\n> 2.  WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。\n\n以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。\n\n![](http://image.beekka.com/blog/201102/bg2011021310.png)\n\n也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。\n\n\n### 引用地址：\n1. [http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html](http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html)\n2. [http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/](http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/)","source":"_posts/HTTPS的七个误解.md","raw":"title: HTTPS的七个误解\ndate: 2016-07-25 11:20:13\ncategories:\nkeywords: https, 缓存\ntags: https\n---\n\n这段时间在研究 webview 缓存，为了加快用户进入页面的时间，找了一些资料，突然发现 对 Https 理解的不是很深刻，这里整理一下。\n\n我认为不管是 IOS 同学还是 Android 同学，都应该对此有一定的了解。这篇文章的年底略有久远，但是却可以扫盲，还是值得一看。\n\n![](http://image.beekka.com/blog/201102/bg2011021311.jpg)\n\n### 误解七：HTTPS无法缓存\n许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。\n\n微软的IE项目经理Eric Lawrence写道：\n> \"说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）\"\n\nFirefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。\n\n![](http://image.beekka.com/blog/201102/bg2011021301.png)\n\n### 误解六：SSL证书很贵\n如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。\n在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。\n\n### 误解五：HTTPS站点必须有独享的IP地址\n由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。\n![](http://image.beekka.com/blog/201102/bg2011021302.png)\n\n另外，UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。SNI（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。\n\n### 误解四：转移服务器时要购买新证书\n部署SSL证书，需要这样几步：\n> 1. 在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。\n> 2. 使用CSR文件，购买SSL证书。\n> 3. 安装SSL证书。\n\n这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。\n比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。\n![](http://image.beekka.com/blog/201102/bg2011021303.png)\n\n将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。\n\n### 误解三：HTTPS太慢\n使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些技巧可以大大减少额外开销。\n首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。\n其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。\n![](http://image.beekka.com/blog/201102/bg2011021304.png)\n\n第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。\n\n![](http://image.beekka.com/blog/201102/bg2011021305.png)\n\n同一张网页使用HTTPS协议之后，打开时间变长了。\n\n![](http://image.beekka.com/blog/201102/bg2011021306.png)\n\n建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现：\n\n![](http://image.beekka.com/blog/201102/bg2011021307.png)\n\n然后是HTTPS协议：\n\n![](http://image.beekka.com/blog/201102/bg2011021308.png)\n\n某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。\n\n### 误解二：有了HTTPS，Cookie和查询字符串就安全了\n虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。\n比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id:\n![](http://image.beekka.com/blog/201102/bg2011021309.png)\n\n黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过类似方式泄漏。\n\n### 误解一：只有注册登录页，才需要HTTPS\n这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件Firesheep，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。\n咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因：\n> 1. 这种WiFi通常不会加密，所以很容易监控所有流量。\n> 2.  WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。\n\n以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。\n\n![](http://image.beekka.com/blog/201102/bg2011021310.png)\n\n也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。\n\n\n### 引用地址：\n1. [http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html](http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html)\n2. [http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/](http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/)","slug":"HTTPS的七个误解","published":1,"updated":"2016-07-25T03:25:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afy000gxzexap2bt7pl","content":"<p>这段时间在研究 webview 缓存，为了加快用户进入页面的时间，找了一些资料，突然发现 对 Https 理解的不是很深刻，这里整理一下。</p>\n<p>我认为不管是 IOS 同学还是 Android 同学，都应该对此有一定的了解。这篇文章的年底略有久远，但是却可以扫盲，还是值得一看。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021311.jpg\" alt=\"\"></p>\n<h3 id=\"误解七：HTTPS无法缓存\"><a href=\"#误解七：HTTPS无法缓存\" class=\"headerlink\" title=\"误解七：HTTPS无法缓存\"></a>误解七：HTTPS无法缓存</h3><p>许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。</p>\n<p>微软的IE项目经理Eric Lawrence写道：</p>\n<blockquote>\n<p>“说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）”</p>\n</blockquote>\n<p>Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021301.png\" alt=\"\"></p>\n<h3 id=\"误解六：SSL证书很贵\"><a href=\"#误解六：SSL证书很贵\" class=\"headerlink\" title=\"误解六：SSL证书很贵\"></a>误解六：SSL证书很贵</h3><p>如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。<br>在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。</p>\n<h3 id=\"误解五：HTTPS站点必须有独享的IP地址\"><a href=\"#误解五：HTTPS站点必须有独享的IP地址\" class=\"headerlink\" title=\"误解五：HTTPS站点必须有独享的IP地址\"></a>误解五：HTTPS站点必须有独享的IP地址</h3><p>由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，<a href=\"https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。\" target=\"_blank\" rel=\"external\">https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。</a><br><img src=\"http://image.beekka.com/blog/201102/bg2011021302.png\" alt=\"\"></p>\n<p>另外，UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。SNI（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。</p>\n<h3 id=\"误解四：转移服务器时要购买新证书\"><a href=\"#误解四：转移服务器时要购买新证书\" class=\"headerlink\" title=\"误解四：转移服务器时要购买新证书\"></a>误解四：转移服务器时要购买新证书</h3><p>部署SSL证书，需要这样几步：</p>\n<blockquote>\n<ol>\n<li>在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。</li>\n<li>使用CSR文件，购买SSL证书。</li>\n<li>安装SSL证书。</li>\n</ol>\n</blockquote>\n<p>这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。<br>比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。<br><img src=\"http://image.beekka.com/blog/201102/bg2011021303.png\" alt=\"\"></p>\n<p>将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。</p>\n<h3 id=\"误解三：HTTPS太慢\"><a href=\"#误解三：HTTPS太慢\" class=\"headerlink\" title=\"误解三：HTTPS太慢\"></a>误解三：HTTPS太慢</h3><p>使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些技巧可以大大减少额外开销。<br>首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。<br>其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。<br><img src=\"http://image.beekka.com/blog/201102/bg2011021304.png\" alt=\"\"></p>\n<p>第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021305.png\" alt=\"\"></p>\n<p>同一张网页使用HTTPS协议之后，打开时间变长了。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021306.png\" alt=\"\"></p>\n<p>建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现：</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021307.png\" alt=\"\"></p>\n<p>然后是HTTPS协议：</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021308.png\" alt=\"\"></p>\n<p>某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。</p>\n<h3 id=\"误解二：有了HTTPS，Cookie和查询字符串就安全了\"><a href=\"#误解二：有了HTTPS，Cookie和查询字符串就安全了\" class=\"headerlink\" title=\"误解二：有了HTTPS，Cookie和查询字符串就安全了\"></a>误解二：有了HTTPS，Cookie和查询字符串就安全了</h3><p>虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。<br>比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id:<br><img src=\"http://image.beekka.com/blog/201102/bg2011021309.png\" alt=\"\"></p>\n<p>黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过类似方式泄漏。</p>\n<h3 id=\"误解一：只有注册登录页，才需要HTTPS\"><a href=\"#误解一：只有注册登录页，才需要HTTPS\" class=\"headerlink\" title=\"误解一：只有注册登录页，才需要HTTPS\"></a>误解一：只有注册登录页，才需要HTTPS</h3><p>这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件Firesheep，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。<br>咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因：</p>\n<blockquote>\n<ol>\n<li>这种WiFi通常不会加密，所以很容易监控所有流量。</li>\n<li>WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。</li>\n</ol>\n</blockquote>\n<p>以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021310.png\" alt=\"\"></p>\n<p>也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。</p>\n<h3 id=\"引用地址：\"><a href=\"#引用地址：\" class=\"headerlink\" title=\"引用地址：\"></a>引用地址：</h3><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html\" target=\"_blank\" rel=\"external\">http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html</a></li>\n<li><a href=\"http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/\" target=\"_blank\" rel=\"external\">http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/</a></li>\n</ol>\n","excerpt":"","more":"<p>这段时间在研究 webview 缓存，为了加快用户进入页面的时间，找了一些资料，突然发现 对 Https 理解的不是很深刻，这里整理一下。</p>\n<p>我认为不管是 IOS 同学还是 Android 同学，都应该对此有一定的了解。这篇文章的年底略有久远，但是却可以扫盲，还是值得一看。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021311.jpg\" alt=\"\"></p>\n<h3 id=\"误解七：HTTPS无法缓存\"><a href=\"#误解七：HTTPS无法缓存\" class=\"headerlink\" title=\"误解七：HTTPS无法缓存\"></a>误解七：HTTPS无法缓存</h3><p>许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。</p>\n<p>微软的IE项目经理Eric Lawrence写道：</p>\n<blockquote>\n<p>“说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）”</p>\n</blockquote>\n<p>Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021301.png\" alt=\"\"></p>\n<h3 id=\"误解六：SSL证书很贵\"><a href=\"#误解六：SSL证书很贵\" class=\"headerlink\" title=\"误解六：SSL证书很贵\"></a>误解六：SSL证书很贵</h3><p>如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。<br>在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。</p>\n<h3 id=\"误解五：HTTPS站点必须有独享的IP地址\"><a href=\"#误解五：HTTPS站点必须有独享的IP地址\" class=\"headerlink\" title=\"误解五：HTTPS站点必须有独享的IP地址\"></a>误解五：HTTPS站点必须有独享的IP地址</h3><p>由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，<a href=\"https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。\">https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。</a><br><img src=\"http://image.beekka.com/blog/201102/bg2011021302.png\" alt=\"\"></p>\n<p>另外，UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。SNI（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。</p>\n<h3 id=\"误解四：转移服务器时要购买新证书\"><a href=\"#误解四：转移服务器时要购买新证书\" class=\"headerlink\" title=\"误解四：转移服务器时要购买新证书\"></a>误解四：转移服务器时要购买新证书</h3><p>部署SSL证书，需要这样几步：</p>\n<blockquote>\n<ol>\n<li>在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。</li>\n<li>使用CSR文件，购买SSL证书。</li>\n<li>安装SSL证书。</li>\n</ol>\n</blockquote>\n<p>这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。<br>比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。<br><img src=\"http://image.beekka.com/blog/201102/bg2011021303.png\" alt=\"\"></p>\n<p>将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。</p>\n<h3 id=\"误解三：HTTPS太慢\"><a href=\"#误解三：HTTPS太慢\" class=\"headerlink\" title=\"误解三：HTTPS太慢\"></a>误解三：HTTPS太慢</h3><p>使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些技巧可以大大减少额外开销。<br>首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。<br>其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。<br><img src=\"http://image.beekka.com/blog/201102/bg2011021304.png\" alt=\"\"></p>\n<p>第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021305.png\" alt=\"\"></p>\n<p>同一张网页使用HTTPS协议之后，打开时间变长了。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021306.png\" alt=\"\"></p>\n<p>建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现：</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021307.png\" alt=\"\"></p>\n<p>然后是HTTPS协议：</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021308.png\" alt=\"\"></p>\n<p>某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。</p>\n<h3 id=\"误解二：有了HTTPS，Cookie和查询字符串就安全了\"><a href=\"#误解二：有了HTTPS，Cookie和查询字符串就安全了\" class=\"headerlink\" title=\"误解二：有了HTTPS，Cookie和查询字符串就安全了\"></a>误解二：有了HTTPS，Cookie和查询字符串就安全了</h3><p>虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。<br>比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id:<br><img src=\"http://image.beekka.com/blog/201102/bg2011021309.png\" alt=\"\"></p>\n<p>黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过类似方式泄漏。</p>\n<h3 id=\"误解一：只有注册登录页，才需要HTTPS\"><a href=\"#误解一：只有注册登录页，才需要HTTPS\" class=\"headerlink\" title=\"误解一：只有注册登录页，才需要HTTPS\"></a>误解一：只有注册登录页，才需要HTTPS</h3><p>这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件Firesheep，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。<br>咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因：</p>\n<blockquote>\n<ol>\n<li>这种WiFi通常不会加密，所以很容易监控所有流量。</li>\n<li>WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。</li>\n</ol>\n</blockquote>\n<p>以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。</p>\n<p><img src=\"http://image.beekka.com/blog/201102/bg2011021310.png\" alt=\"\"></p>\n<p>也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。</p>\n<h3 id=\"引用地址：\"><a href=\"#引用地址：\" class=\"headerlink\" title=\"引用地址：\"></a>引用地址：</h3><ol>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html\">http://www.ruanyifeng.com/blog/2011/02/seven_myths_about_https.html</a></li>\n<li><a href=\"http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/\">http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/</a></li>\n</ol>\n"},{"title":"Android录音使用 byte 类型获取分贝或声音振幅","date":"2015-10-08T10:10:20.000Z","keywords":"获取分贝值","_content":"\n以下是获取声音振幅的代码：\n\n\n\ttry {\n            while (isRecording) {\n                read = audioRecord.read(data, 0, recBufSize);\n\t//                L.i(context, \"开始获取音频TTT：\" + data.length);\n                if (AudioRecord.ERROR_INVALID_OPERATION != read && retry <= 3) {\n\t//                    L.i(context, \"发出的音频TTT：\" + data.length);\n                    //录音成功，重置录音失败的次数\n                    retry = 0;\n                    int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                    long v = 0;\n                    long tv = 0;\n                    // 将 data 内容取出，进行平方和运算\n                    for (int i = 0; i < data.length; i+=2) {\n                        tv = data[i+1] * 128 + data[i];\n                        tv *= tv;\n                        v += tv;\n                    }\n                    // 平方和除以数据总长度，得到音量大小。\n                    double mean = v / (double) read;\n                    double volume = 10 * Math.log10(mean * 2);\n                    KL.d(AudioThread.class, \"分贝值:\" + volume);\n\n                    EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                    KL.d(AudioThread.class, \"分贝值: {}，v = {}， read  = {}， mean = {}  \", volume, v,\n                            read, mean);\n\n\t//                    L.i(context, \"上传录音状态TTT：\" + up);\n\t//                    if (isTest) {\n\t//                        try {\n\t//                            os.write(data);\n\t//                        } catch (Exception e) {\n\t//                            e.printStackTrace();\n\t//                        }\n\t//                    }\n                } else {\n                    L.i(AudioThread.class, \"TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}\", read, retry);\n                    if (retry <= 3) {\n                        retry++;\n                    } else {\n                        isRecording = false;\n                        EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                        break;\n                    }\n\n                }\n\t//                L.i(context, \"上次音频TTT：\" + data.length);\n\n                Thread.sleep(10);\n\n                if (isRecording())\n                    pauseThread();\n            }\n\n\t//            if (isTest) {\n\t//                try {\n\t//                    os.close();\n\t//                } catch (IOException e) {\n\t//                    e.printStackTrace();\n\t//                }\n\t//            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            L.i(AudioThread.class, \"上传出现异常\");\n\n        }\n        \n        \n效果是：\n\n```\n当前接受到的分贝值: %s，v =15\n当前接受到的分贝值: %s，v =41\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =49\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =64\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =57\n当前接受到的分贝值: %s，v =60\n当前接受到的分贝值: %s，v =58\n当前接受到的分贝值: %s，v =55\n当前接受到的分贝值: %s，v =55\n```\n声音在0-100以内，基本声音维持在 40-60之间","source":"_posts/Android录音使用-byte-类型获取分贝或声音振幅.md","raw":"title: Android录音使用 byte 类型获取分贝或声音振幅\ndate: 2015-10-08 18:10:20\ncategories:\nkeywords: 获取分贝值\ntags: android录音\n---\n\n以下是获取声音振幅的代码：\n\n\n\ttry {\n            while (isRecording) {\n                read = audioRecord.read(data, 0, recBufSize);\n\t//                L.i(context, \"开始获取音频TTT：\" + data.length);\n                if (AudioRecord.ERROR_INVALID_OPERATION != read && retry <= 3) {\n\t//                    L.i(context, \"发出的音频TTT：\" + data.length);\n                    //录音成功，重置录音失败的次数\n                    retry = 0;\n                    int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                    long v = 0;\n                    long tv = 0;\n                    // 将 data 内容取出，进行平方和运算\n                    for (int i = 0; i < data.length; i+=2) {\n                        tv = data[i+1] * 128 + data[i];\n                        tv *= tv;\n                        v += tv;\n                    }\n                    // 平方和除以数据总长度，得到音量大小。\n                    double mean = v / (double) read;\n                    double volume = 10 * Math.log10(mean * 2);\n                    KL.d(AudioThread.class, \"分贝值:\" + volume);\n\n                    EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                    KL.d(AudioThread.class, \"分贝值: {}，v = {}， read  = {}， mean = {}  \", volume, v,\n                            read, mean);\n\n\t//                    L.i(context, \"上传录音状态TTT：\" + up);\n\t//                    if (isTest) {\n\t//                        try {\n\t//                            os.write(data);\n\t//                        } catch (Exception e) {\n\t//                            e.printStackTrace();\n\t//                        }\n\t//                    }\n                } else {\n                    L.i(AudioThread.class, \"TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}\", read, retry);\n                    if (retry <= 3) {\n                        retry++;\n                    } else {\n                        isRecording = false;\n                        EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                        break;\n                    }\n\n                }\n\t//                L.i(context, \"上次音频TTT：\" + data.length);\n\n                Thread.sleep(10);\n\n                if (isRecording())\n                    pauseThread();\n            }\n\n\t//            if (isTest) {\n\t//                try {\n\t//                    os.close();\n\t//                } catch (IOException e) {\n\t//                    e.printStackTrace();\n\t//                }\n\t//            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            L.i(AudioThread.class, \"上传出现异常\");\n\n        }\n        \n        \n效果是：\n\n```\n当前接受到的分贝值: %s，v =15\n当前接受到的分贝值: %s，v =41\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =49\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =64\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =57\n当前接受到的分贝值: %s，v =60\n当前接受到的分贝值: %s，v =58\n当前接受到的分贝值: %s，v =55\n当前接受到的分贝值: %s，v =55\n```\n声音在0-100以内，基本声音维持在 40-60之间","slug":"Android录音使用-byte-类型获取分贝或声音振幅","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2afz000ixzexktluokbv","content":"<p>以下是获取声音振幅的代码：</p>\n<pre><code>try {\n        while (isRecording) {\n            read = audioRecord.read(data, 0, recBufSize);\n//                L.i(context, &quot;开始获取音频TTT：&quot; + data.length);\n            if (AudioRecord.ERROR_INVALID_OPERATION != read &amp;&amp; retry &lt;= 3) {\n//                    L.i(context, &quot;发出的音频TTT：&quot; + data.length);\n                //录音成功，重置录音失败的次数\n                retry = 0;\n                int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                long v = 0;\n                long tv = 0;\n                // 将 data 内容取出，进行平方和运算\n                for (int i = 0; i &lt; data.length; i+=2) {\n                    tv = data[i+1] * 128 + data[i];\n                    tv *= tv;\n                    v += tv;\n                }\n                // 平方和除以数据总长度，得到音量大小。\n                double mean = v / (double) read;\n                double volume = 10 * Math.log10(mean * 2);\n                KL.d(AudioThread.class, &quot;分贝值:&quot; + volume);\n\n                EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                KL.d(AudioThread.class, &quot;分贝值: {}，v = {}， read  = {}， mean = {}  &quot;, volume, v,\n                        read, mean);\n\n//                    L.i(context, &quot;上传录音状态TTT：&quot; + up);\n//                    if (isTest) {\n//                        try {\n//                            os.write(data);\n//                        } catch (Exception e) {\n//                            e.printStackTrace();\n//                        }\n//                    }\n            } else {\n                L.i(AudioThread.class, &quot;TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}&quot;, read, retry);\n                if (retry &lt;= 3) {\n                    retry++;\n                } else {\n                    isRecording = false;\n                    EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                    break;\n                }\n\n            }\n//                L.i(context, &quot;上次音频TTT：&quot; + data.length);\n\n            Thread.sleep(10);\n\n            if (isRecording())\n                pauseThread();\n        }\n\n//            if (isTest) {\n//                try {\n//                    os.close();\n//                } catch (IOException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        L.i(AudioThread.class, &quot;上传出现异常&quot;);\n\n    }\n</code></pre><p>效果是：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">15</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">41</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">49</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">64</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">57</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">60</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">58</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br></pre></td></tr></table></figure>\n<p>声音在0-100以内，基本声音维持在 40-60之间</p>\n","excerpt":"","more":"<p>以下是获取声音振幅的代码：</p>\n<pre><code>try {\n        while (isRecording) {\n            read = audioRecord.read(data, 0, recBufSize);\n//                L.i(context, &quot;开始获取音频TTT：&quot; + data.length);\n            if (AudioRecord.ERROR_INVALID_OPERATION != read &amp;&amp; retry &lt;= 3) {\n//                    L.i(context, &quot;发出的音频TTT：&quot; + data.length);\n                //录音成功，重置录音失败的次数\n                retry = 0;\n                int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                long v = 0;\n                long tv = 0;\n                // 将 data 内容取出，进行平方和运算\n                for (int i = 0; i &lt; data.length; i+=2) {\n                    tv = data[i+1] * 128 + data[i];\n                    tv *= tv;\n                    v += tv;\n                }\n                // 平方和除以数据总长度，得到音量大小。\n                double mean = v / (double) read;\n                double volume = 10 * Math.log10(mean * 2);\n                KL.d(AudioThread.class, &quot;分贝值:&quot; + volume);\n\n                EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                KL.d(AudioThread.class, &quot;分贝值: {}，v = {}， read  = {}， mean = {}  &quot;, volume, v,\n                        read, mean);\n\n//                    L.i(context, &quot;上传录音状态TTT：&quot; + up);\n//                    if (isTest) {\n//                        try {\n//                            os.write(data);\n//                        } catch (Exception e) {\n//                            e.printStackTrace();\n//                        }\n//                    }\n            } else {\n                L.i(AudioThread.class, &quot;TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}&quot;, read, retry);\n                if (retry &lt;= 3) {\n                    retry++;\n                } else {\n                    isRecording = false;\n                    EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                    break;\n                }\n\n            }\n//                L.i(context, &quot;上次音频TTT：&quot; + data.length);\n\n            Thread.sleep(10);\n\n            if (isRecording())\n                pauseThread();\n        }\n\n//            if (isTest) {\n//                try {\n//                    os.close();\n//                } catch (IOException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        L.i(AudioThread.class, &quot;上传出现异常&quot;);\n\n    }\n</code></pre><p>效果是：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">15</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">41</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">49</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">64</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">57</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">60</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">58</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br></pre></td></tr></table></figure>\n<p>声音在0-100以内，基本声音维持在 40-60之间</p>\n"},{"title":"OkHttp和Okio","date":"2016-08-08T10:48:10.000Z","keywords":"OkHttp","_content":"\n\n### 本文摘要\n文本将介绍OkHttp和Okio基本使用\n\n### OkHttp\nHTTP 是现在APP访问网络最流行的方式。通过它我们可以交换数据和媒体信息。而高效的使用HTTP可以让你的加载数据更快并且节省带宽。\n\nOkHttp就是一种HTTP客户端连接，它有如下特性：\n1. HTTP/2多路复用Socket到同一个主机，共享链接。\n2. **采用连接池技术，可以有效的减少Http链接数量。**\n3. 无缝集成GZIP压缩技术。\n4. 支持Response Cache，避免重复请求。\n5. 域名多IP支持。\n\nOkHttp可以处理常见的网络问题：\n1. 如果OkHttp连接一个域名失败后，它会尝试连接下一个该域名的IP地址。（**需要DNS支持**）\n2. OkHttp在初始化链接的时候，会采用最新的TLS特性（SNI，ALPN），如果失败会采用TLS1.0进行链接。\n\n使用OkHttp是非常简单的。它的request/response API采用非常流畅的Builder模式构建。 并且它支持同步阻塞调用以及异步调用。\n\nOkHttp支持Android2.3+。对于Java最低支持1.7+\n\nOkHttp会**自动管理HTTP连接的生命周期**：\n1. 操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接\n2. 如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接）\n3. OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用\n4. 当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用\n\n### GET 请求\n\tpackage com.company;\n\t\n\timport okhttp3.*;\n\t\n\tpublic class Main {\n\t\n\t    public static void main(String[] args) throws Exception {\n\t        OkHttpClient client = new OkHttpClient();\n\t        //请求\n\t        Request request = new Request.Builder()\n\t                .url(\"http://www.baidu.com/\")\n\t                .get()\n\t                .build();\n\t        //发起请求\n\t        Response response = client.newCall(request).execute();\n\t        //结果\n\t        System.out.println(response.body().string());\n\t    }\n\t}\n\t\n\n### POST 请求\n\tpackage com.company;\n\t\n\timport okhttp3.*;\n\t\n\tpublic class Main {\n\t\n\t    public static void main(String[] args) throws Exception {\n\t        OkHttpClient client = new OkHttpClient();\n\t        //参数\n\t        RequestBody requestBody = new FormBody.Builder()\n\t                .add(\"DGM\", \"DGM\")\n\t                .build();\n\t        //请求\n\t        Request request = new Request.Builder()\n\t                .url(\"http://www.baidu.com/\")\n\t                .post(requestBody)\n\t                .build();\n\t        //发起请求\n\t        Response response = client.newCall(request).execute();\n\t        //结果\n\t        System.out.println(response.body().string());\n\t    }\n\t}\n\t\n\n\n### 引入项目中：\n**Maven**\n\t<dependency>\n\t  <groupId>com.squareup.okhttp3</groupId>\n\t  <artifactId>okhttp</artifactId>\n\t  <version>(insert latest version)</version>\n\t</dependency>\n\t\n\n**Gradle**\n\tcompile 'com.squareup.okhttp3:okhttp:(insert latest version)'\n\nPS： (insert latest version) 请替换成 官网最新的\n\n### Okio\n\nOkio是一款新的类库，它可以使得 java.io.\\* 和 java.nio.\\* 更加方便的被使用以及处理数据。 现在我的一些文件操作或者流 必用Okio。\n\n### Copy文件的例子\n\tpackage com.company;\n\t\n\timport okio.BufferedSink;\n\timport okio.BufferedSource;\n\timport okio.Okio;\n\t\n\timport java.io.File;\n\t\n\tpublic class Main {\n\t\n\t    public static void main(String[] args) throws Exception {\n\t        //创建buffer\n\t        BufferedSource source = Okio.buffer(Okio.source(new File(\"data/file1\")));\n\t        BufferedSink sink = Okio.buffer(Okio.sink(new File(\"data/file\" + System.currentTimeMillis())));\n\t        //copy数据\n\t        sink.writeAll(source);\n\t        //关闭资源\n\t        sink.close();\n\t        source.close();\n\t    }\n\t}\n\t\n\n可以发现，通过Okio可以非常方便的处理io数据。\n\n### ByteString 和 Buffer\n\n在Okio中通过ByteString和Buffer这两种类型，提供了高性能和简单的API：\n\n1. ByteString是一种不可改变的byte序列。提供了一种基于String，采用char访问的二进制模式。通过ByteString可以像一般value一样处理二进制数据。并且提供了对encode/decode中的HEX，Base64以及UTF-8支持。\n2. Buffer是一种可变的byte序列。就像ArrayList一样，你不需要知道Buffer的大小。在处理buffer的read/write的时候，就像queue一样。\n\n通过这两个类，可以极大的增强io访问的数据处理。\n\n### Source 和 Sink\n\n这两个类是在 InputStream 以及 OutputStream 上进行抽象而成的。 它还具有如下特性：\n1. Timeout： 可以提供超时处理机制。\n2. Easy to implement： Source 仅仅声明了read，close，timeout方法。实现起来非常的方便。\n3. Easy to use：通过实现/使用BufferedSource和BufferedSink接口，可以更加方便的操作二进制数据。\n4. No artificial distinction between byte streams and char streams：可以非常方便的将二进制数据处理为UTF-8字符串，int等类型数据。\n\nSource 和 Sink 实现了InputStream 以及 OutputStream。你可以将Source看成InputStream，将Sink看成OutputStream。**而通过BufferedSource和BufferedSink可以非常方便的进行数据处理。**\n\n### 总结\n通过开源的square工具，我们可以非常方便的处理io以及http数据。在最新的Android6.0+中，已经剔除了Apache URLConnection类，而采用OkHttp。所以可见OkHttp的代码质量还有有保证的。\n\n##### 链接：\n1. [Okio](https://github.com/square/okio \"Okio\")\n2. [OkHttp](http://square.github.io/okhttp/ \"OkHttp\")\n3. [来源](http://my.oschina.net/darkgem/blog/643980)","source":"_posts/OkHttp和Okio.md","raw":"title: OkHttp和Okio\ndate: 2016-08-08 18:48:10\ncategories:\nkeywords: OkHttp\ntags: OkHttp,Okio\n---\n\n\n### 本文摘要\n文本将介绍OkHttp和Okio基本使用\n\n### OkHttp\nHTTP 是现在APP访问网络最流行的方式。通过它我们可以交换数据和媒体信息。而高效的使用HTTP可以让你的加载数据更快并且节省带宽。\n\nOkHttp就是一种HTTP客户端连接，它有如下特性：\n1. HTTP/2多路复用Socket到同一个主机，共享链接。\n2. **采用连接池技术，可以有效的减少Http链接数量。**\n3. 无缝集成GZIP压缩技术。\n4. 支持Response Cache，避免重复请求。\n5. 域名多IP支持。\n\nOkHttp可以处理常见的网络问题：\n1. 如果OkHttp连接一个域名失败后，它会尝试连接下一个该域名的IP地址。（**需要DNS支持**）\n2. OkHttp在初始化链接的时候，会采用最新的TLS特性（SNI，ALPN），如果失败会采用TLS1.0进行链接。\n\n使用OkHttp是非常简单的。它的request/response API采用非常流畅的Builder模式构建。 并且它支持同步阻塞调用以及异步调用。\n\nOkHttp支持Android2.3+。对于Java最低支持1.7+\n\nOkHttp会**自动管理HTTP连接的生命周期**：\n1. 操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接\n2. 如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接）\n3. OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用\n4. 当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用\n\n### GET 请求\n\tpackage com.company;\n\t\n\timport okhttp3.*;\n\t\n\tpublic class Main {\n\t\n\t    public static void main(String[] args) throws Exception {\n\t        OkHttpClient client = new OkHttpClient();\n\t        //请求\n\t        Request request = new Request.Builder()\n\t                .url(\"http://www.baidu.com/\")\n\t                .get()\n\t                .build();\n\t        //发起请求\n\t        Response response = client.newCall(request).execute();\n\t        //结果\n\t        System.out.println(response.body().string());\n\t    }\n\t}\n\t\n\n### POST 请求\n\tpackage com.company;\n\t\n\timport okhttp3.*;\n\t\n\tpublic class Main {\n\t\n\t    public static void main(String[] args) throws Exception {\n\t        OkHttpClient client = new OkHttpClient();\n\t        //参数\n\t        RequestBody requestBody = new FormBody.Builder()\n\t                .add(\"DGM\", \"DGM\")\n\t                .build();\n\t        //请求\n\t        Request request = new Request.Builder()\n\t                .url(\"http://www.baidu.com/\")\n\t                .post(requestBody)\n\t                .build();\n\t        //发起请求\n\t        Response response = client.newCall(request).execute();\n\t        //结果\n\t        System.out.println(response.body().string());\n\t    }\n\t}\n\t\n\n\n### 引入项目中：\n**Maven**\n\t<dependency>\n\t  <groupId>com.squareup.okhttp3</groupId>\n\t  <artifactId>okhttp</artifactId>\n\t  <version>(insert latest version)</version>\n\t</dependency>\n\t\n\n**Gradle**\n\tcompile 'com.squareup.okhttp3:okhttp:(insert latest version)'\n\nPS： (insert latest version) 请替换成 官网最新的\n\n### Okio\n\nOkio是一款新的类库，它可以使得 java.io.\\* 和 java.nio.\\* 更加方便的被使用以及处理数据。 现在我的一些文件操作或者流 必用Okio。\n\n### Copy文件的例子\n\tpackage com.company;\n\t\n\timport okio.BufferedSink;\n\timport okio.BufferedSource;\n\timport okio.Okio;\n\t\n\timport java.io.File;\n\t\n\tpublic class Main {\n\t\n\t    public static void main(String[] args) throws Exception {\n\t        //创建buffer\n\t        BufferedSource source = Okio.buffer(Okio.source(new File(\"data/file1\")));\n\t        BufferedSink sink = Okio.buffer(Okio.sink(new File(\"data/file\" + System.currentTimeMillis())));\n\t        //copy数据\n\t        sink.writeAll(source);\n\t        //关闭资源\n\t        sink.close();\n\t        source.close();\n\t    }\n\t}\n\t\n\n可以发现，通过Okio可以非常方便的处理io数据。\n\n### ByteString 和 Buffer\n\n在Okio中通过ByteString和Buffer这两种类型，提供了高性能和简单的API：\n\n1. ByteString是一种不可改变的byte序列。提供了一种基于String，采用char访问的二进制模式。通过ByteString可以像一般value一样处理二进制数据。并且提供了对encode/decode中的HEX，Base64以及UTF-8支持。\n2. Buffer是一种可变的byte序列。就像ArrayList一样，你不需要知道Buffer的大小。在处理buffer的read/write的时候，就像queue一样。\n\n通过这两个类，可以极大的增强io访问的数据处理。\n\n### Source 和 Sink\n\n这两个类是在 InputStream 以及 OutputStream 上进行抽象而成的。 它还具有如下特性：\n1. Timeout： 可以提供超时处理机制。\n2. Easy to implement： Source 仅仅声明了read，close，timeout方法。实现起来非常的方便。\n3. Easy to use：通过实现/使用BufferedSource和BufferedSink接口，可以更加方便的操作二进制数据。\n4. No artificial distinction between byte streams and char streams：可以非常方便的将二进制数据处理为UTF-8字符串，int等类型数据。\n\nSource 和 Sink 实现了InputStream 以及 OutputStream。你可以将Source看成InputStream，将Sink看成OutputStream。**而通过BufferedSource和BufferedSink可以非常方便的进行数据处理。**\n\n### 总结\n通过开源的square工具，我们可以非常方便的处理io以及http数据。在最新的Android6.0+中，已经剔除了Apache URLConnection类，而采用OkHttp。所以可见OkHttp的代码质量还有有保证的。\n\n##### 链接：\n1. [Okio](https://github.com/square/okio \"Okio\")\n2. [OkHttp](http://square.github.io/okhttp/ \"OkHttp\")\n3. [来源](http://my.oschina.net/darkgem/blog/643980)","slug":"OkHttp和Okio","published":1,"updated":"2016-08-08T10:49:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ag0000kxzex9009o8bw","content":"<h3 id=\"本文摘要\"><a href=\"#本文摘要\" class=\"headerlink\" title=\"本文摘要\"></a>本文摘要</h3><p>文本将介绍OkHttp和Okio基本使用</p>\n<h3 id=\"OkHttp\"><a href=\"#OkHttp\" class=\"headerlink\" title=\"OkHttp\"></a>OkHttp</h3><p>HTTP 是现在APP访问网络最流行的方式。通过它我们可以交换数据和媒体信息。而高效的使用HTTP可以让你的加载数据更快并且节省带宽。</p>\n<p>OkHttp就是一种HTTP客户端连接，它有如下特性：</p>\n<ol>\n<li>HTTP/2多路复用Socket到同一个主机，共享链接。</li>\n<li><strong>采用连接池技术，可以有效的减少Http链接数量。</strong></li>\n<li>无缝集成GZIP压缩技术。</li>\n<li>支持Response Cache，避免重复请求。</li>\n<li>域名多IP支持。</li>\n</ol>\n<p>OkHttp可以处理常见的网络问题：</p>\n<ol>\n<li>如果OkHttp连接一个域名失败后，它会尝试连接下一个该域名的IP地址。（<strong>需要DNS支持</strong>）</li>\n<li>OkHttp在初始化链接的时候，会采用最新的TLS特性（SNI，ALPN），如果失败会采用TLS1.0进行链接。</li>\n</ol>\n<p>使用OkHttp是非常简单的。它的request/response API采用非常流畅的Builder模式构建。 并且它支持同步阻塞调用以及异步调用。</p>\n<p>OkHttp支持Android2.3+。对于Java最低支持1.7+</p>\n<p>OkHttp会<strong>自动管理HTTP连接的生命周期</strong>：</p>\n<ol>\n<li>操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接</li>\n<li>如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接）</li>\n<li>OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用</li>\n<li>当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用</li>\n</ol>\n<h3 id=\"GET-请求\"><a href=\"#GET-请求\" class=\"headerlink\" title=\"GET 请求\"></a>GET 请求</h3><pre><code>package com.company;\n\nimport okhttp3.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        OkHttpClient client = new OkHttpClient();\n        //请求\n        Request request = new Request.Builder()\n                .url(&quot;http://www.baidu.com/&quot;)\n                .get()\n                .build();\n        //发起请求\n        Response response = client.newCall(request).execute();\n        //结果\n        System.out.println(response.body().string());\n    }\n}\n</code></pre><h3 id=\"POST-请求\"><a href=\"#POST-请求\" class=\"headerlink\" title=\"POST 请求\"></a>POST 请求</h3><pre><code>package com.company;\n\nimport okhttp3.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        OkHttpClient client = new OkHttpClient();\n        //参数\n        RequestBody requestBody = new FormBody.Builder()\n                .add(&quot;DGM&quot;, &quot;DGM&quot;)\n                .build();\n        //请求\n        Request request = new Request.Builder()\n                .url(&quot;http://www.baidu.com/&quot;)\n                .post(requestBody)\n                .build();\n        //发起请求\n        Response response = client.newCall(request).execute();\n        //结果\n        System.out.println(response.body().string());\n    }\n}\n</code></pre><h3 id=\"引入项目中：\"><a href=\"#引入项目中：\" class=\"headerlink\" title=\"引入项目中：\"></a>引入项目中：</h3><p><strong>Maven</strong><br>    <dependency><br>      <groupid>com.squareup.okhttp3</groupid><br>      <artifactid>okhttp</artifactid><br>      <version>(insert latest version)</version><br>    </dependency></p>\n<p><strong>Gradle</strong><br>    compile ‘com.squareup.okhttp3:okhttp:(insert latest version)’</p>\n<p>PS： (insert latest version) 请替换成 官网最新的</p>\n<h3 id=\"Okio\"><a href=\"#Okio\" class=\"headerlink\" title=\"Okio\"></a>Okio</h3><p>Okio是一款新的类库，它可以使得 java.io.* 和 java.nio.* 更加方便的被使用以及处理数据。 现在我的一些文件操作或者流 必用Okio。</p>\n<h3 id=\"Copy文件的例子\"><a href=\"#Copy文件的例子\" class=\"headerlink\" title=\"Copy文件的例子\"></a>Copy文件的例子</h3><pre><code>package com.company;\n\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\nimport java.io.File;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        //创建buffer\n        BufferedSource source = Okio.buffer(Okio.source(new File(&quot;data/file1&quot;)));\n        BufferedSink sink = Okio.buffer(Okio.sink(new File(&quot;data/file&quot; + System.currentTimeMillis())));\n        //copy数据\n        sink.writeAll(source);\n        //关闭资源\n        sink.close();\n        source.close();\n    }\n}\n</code></pre><p>可以发现，通过Okio可以非常方便的处理io数据。</p>\n<h3 id=\"ByteString-和-Buffer\"><a href=\"#ByteString-和-Buffer\" class=\"headerlink\" title=\"ByteString 和 Buffer\"></a>ByteString 和 Buffer</h3><p>在Okio中通过ByteString和Buffer这两种类型，提供了高性能和简单的API：</p>\n<ol>\n<li>ByteString是一种不可改变的byte序列。提供了一种基于String，采用char访问的二进制模式。通过ByteString可以像一般value一样处理二进制数据。并且提供了对encode/decode中的HEX，Base64以及UTF-8支持。</li>\n<li>Buffer是一种可变的byte序列。就像ArrayList一样，你不需要知道Buffer的大小。在处理buffer的read/write的时候，就像queue一样。</li>\n</ol>\n<p>通过这两个类，可以极大的增强io访问的数据处理。</p>\n<h3 id=\"Source-和-Sink\"><a href=\"#Source-和-Sink\" class=\"headerlink\" title=\"Source 和 Sink\"></a>Source 和 Sink</h3><p>这两个类是在 InputStream 以及 OutputStream 上进行抽象而成的。 它还具有如下特性：</p>\n<ol>\n<li>Timeout： 可以提供超时处理机制。</li>\n<li>Easy to implement： Source 仅仅声明了read，close，timeout方法。实现起来非常的方便。</li>\n<li>Easy to use：通过实现/使用BufferedSource和BufferedSink接口，可以更加方便的操作二进制数据。</li>\n<li>No artificial distinction between byte streams and char streams：可以非常方便的将二进制数据处理为UTF-8字符串，int等类型数据。</li>\n</ol>\n<p>Source 和 Sink 实现了InputStream 以及 OutputStream。你可以将Source看成InputStream，将Sink看成OutputStream。<strong>而通过BufferedSource和BufferedSink可以非常方便的进行数据处理。</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过开源的square工具，我们可以非常方便的处理io以及http数据。在最新的Android6.0+中，已经剔除了Apache URLConnection类，而采用OkHttp。所以可见OkHttp的代码质量还有有保证的。</p>\n<h5 id=\"链接：\"><a href=\"#链接：\" class=\"headerlink\" title=\"链接：\"></a>链接：</h5><ol>\n<li><a href=\"https://github.com/square/okio\" title=\"Okio\" target=\"_blank\" rel=\"external\">Okio</a></li>\n<li><a href=\"http://square.github.io/okhttp/\" title=\"OkHttp\" target=\"_blank\" rel=\"external\">OkHttp</a></li>\n<li><a href=\"http://my.oschina.net/darkgem/blog/643980\" target=\"_blank\" rel=\"external\">来源</a></li>\n</ol>\n","excerpt":"","more":"<h3 id=\"本文摘要\"><a href=\"#本文摘要\" class=\"headerlink\" title=\"本文摘要\"></a>本文摘要</h3><p>文本将介绍OkHttp和Okio基本使用</p>\n<h3 id=\"OkHttp\"><a href=\"#OkHttp\" class=\"headerlink\" title=\"OkHttp\"></a>OkHttp</h3><p>HTTP 是现在APP访问网络最流行的方式。通过它我们可以交换数据和媒体信息。而高效的使用HTTP可以让你的加载数据更快并且节省带宽。</p>\n<p>OkHttp就是一种HTTP客户端连接，它有如下特性：</p>\n<ol>\n<li>HTTP/2多路复用Socket到同一个主机，共享链接。</li>\n<li><strong>采用连接池技术，可以有效的减少Http链接数量。</strong></li>\n<li>无缝集成GZIP压缩技术。</li>\n<li>支持Response Cache，避免重复请求。</li>\n<li>域名多IP支持。</li>\n</ol>\n<p>OkHttp可以处理常见的网络问题：</p>\n<ol>\n<li>如果OkHttp连接一个域名失败后，它会尝试连接下一个该域名的IP地址。（<strong>需要DNS支持</strong>）</li>\n<li>OkHttp在初始化链接的时候，会采用最新的TLS特性（SNI，ALPN），如果失败会采用TLS1.0进行链接。</li>\n</ol>\n<p>使用OkHttp是非常简单的。它的request/response API采用非常流畅的Builder模式构建。 并且它支持同步阻塞调用以及异步调用。</p>\n<p>OkHttp支持Android2.3+。对于Java最低支持1.7+</p>\n<p>OkHttp会<strong>自动管理HTTP连接的生命周期</strong>：</p>\n<ol>\n<li>操作Response.body().string()等类型的API，OkHttp会自动将该HTTP连接加入到ConnectionPool中或者直接释放连接</li>\n<li>如果采用stream方式操作流，则需要自己手动关闭，否则会发生HTTP连接泄漏（OkHttp通过WeakReference机制，尽最大努力管理这些泄漏的HTTP连接）</li>\n<li>OkHttp不读取Resonse#Head#Keep-Alive属性来决定该HTTP连接是否能复用，而是直接加入到ConnectionPool进行复用</li>\n<li>当从ConnectionPool中获取HTTP连接的时候，OkHttp发现该HTTP连接已经失效，则关闭该连接，并且重新选择一个HTTP连接进行复用</li>\n</ol>\n<h3 id=\"GET-请求\"><a href=\"#GET-请求\" class=\"headerlink\" title=\"GET 请求\"></a>GET 请求</h3><pre><code>package com.company;\n\nimport okhttp3.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        OkHttpClient client = new OkHttpClient();\n        //请求\n        Request request = new Request.Builder()\n                .url(&quot;http://www.baidu.com/&quot;)\n                .get()\n                .build();\n        //发起请求\n        Response response = client.newCall(request).execute();\n        //结果\n        System.out.println(response.body().string());\n    }\n}\n</code></pre><h3 id=\"POST-请求\"><a href=\"#POST-请求\" class=\"headerlink\" title=\"POST 请求\"></a>POST 请求</h3><pre><code>package com.company;\n\nimport okhttp3.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        OkHttpClient client = new OkHttpClient();\n        //参数\n        RequestBody requestBody = new FormBody.Builder()\n                .add(&quot;DGM&quot;, &quot;DGM&quot;)\n                .build();\n        //请求\n        Request request = new Request.Builder()\n                .url(&quot;http://www.baidu.com/&quot;)\n                .post(requestBody)\n                .build();\n        //发起请求\n        Response response = client.newCall(request).execute();\n        //结果\n        System.out.println(response.body().string());\n    }\n}\n</code></pre><h3 id=\"引入项目中：\"><a href=\"#引入项目中：\" class=\"headerlink\" title=\"引入项目中：\"></a>引入项目中：</h3><p><strong>Maven</strong><br>    <dependency><br>      <groupId>com.squareup.okhttp3</groupId><br>      <artifactId>okhttp</artifactId><br>      <version>(insert latest version)</version><br>    </dependency></p>\n<p><strong>Gradle</strong><br>    compile ‘com.squareup.okhttp3:okhttp:(insert latest version)’</p>\n<p>PS： (insert latest version) 请替换成 官网最新的</p>\n<h3 id=\"Okio\"><a href=\"#Okio\" class=\"headerlink\" title=\"Okio\"></a>Okio</h3><p>Okio是一款新的类库，它可以使得 java.io.* 和 java.nio.* 更加方便的被使用以及处理数据。 现在我的一些文件操作或者流 必用Okio。</p>\n<h3 id=\"Copy文件的例子\"><a href=\"#Copy文件的例子\" class=\"headerlink\" title=\"Copy文件的例子\"></a>Copy文件的例子</h3><pre><code>package com.company;\n\nimport okio.BufferedSink;\nimport okio.BufferedSource;\nimport okio.Okio;\n\nimport java.io.File;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        //创建buffer\n        BufferedSource source = Okio.buffer(Okio.source(new File(&quot;data/file1&quot;)));\n        BufferedSink sink = Okio.buffer(Okio.sink(new File(&quot;data/file&quot; + System.currentTimeMillis())));\n        //copy数据\n        sink.writeAll(source);\n        //关闭资源\n        sink.close();\n        source.close();\n    }\n}\n</code></pre><p>可以发现，通过Okio可以非常方便的处理io数据。</p>\n<h3 id=\"ByteString-和-Buffer\"><a href=\"#ByteString-和-Buffer\" class=\"headerlink\" title=\"ByteString 和 Buffer\"></a>ByteString 和 Buffer</h3><p>在Okio中通过ByteString和Buffer这两种类型，提供了高性能和简单的API：</p>\n<ol>\n<li>ByteString是一种不可改变的byte序列。提供了一种基于String，采用char访问的二进制模式。通过ByteString可以像一般value一样处理二进制数据。并且提供了对encode/decode中的HEX，Base64以及UTF-8支持。</li>\n<li>Buffer是一种可变的byte序列。就像ArrayList一样，你不需要知道Buffer的大小。在处理buffer的read/write的时候，就像queue一样。</li>\n</ol>\n<p>通过这两个类，可以极大的增强io访问的数据处理。</p>\n<h3 id=\"Source-和-Sink\"><a href=\"#Source-和-Sink\" class=\"headerlink\" title=\"Source 和 Sink\"></a>Source 和 Sink</h3><p>这两个类是在 InputStream 以及 OutputStream 上进行抽象而成的。 它还具有如下特性：</p>\n<ol>\n<li>Timeout： 可以提供超时处理机制。</li>\n<li>Easy to implement： Source 仅仅声明了read，close，timeout方法。实现起来非常的方便。</li>\n<li>Easy to use：通过实现/使用BufferedSource和BufferedSink接口，可以更加方便的操作二进制数据。</li>\n<li>No artificial distinction between byte streams and char streams：可以非常方便的将二进制数据处理为UTF-8字符串，int等类型数据。</li>\n</ol>\n<p>Source 和 Sink 实现了InputStream 以及 OutputStream。你可以将Source看成InputStream，将Sink看成OutputStream。<strong>而通过BufferedSource和BufferedSink可以非常方便的进行数据处理。</strong></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>通过开源的square工具，我们可以非常方便的处理io以及http数据。在最新的Android6.0+中，已经剔除了Apache URLConnection类，而采用OkHttp。所以可见OkHttp的代码质量还有有保证的。</p>\n<h5 id=\"链接：\"><a href=\"#链接：\" class=\"headerlink\" title=\"链接：\"></a>链接：</h5><ol>\n<li><a href=\"https://github.com/square/okio\" title=\"Okio\">Okio</a></li>\n<li><a href=\"http://square.github.io/okhttp/\" title=\"OkHttp\">OkHttp</a></li>\n<li><a href=\"http://my.oschina.net/darkgem/blog/643980\">来源</a></li>\n</ol>\n"},{"title":"OkHttp3 源码分析【缓存策略】","date":"2016-06-20T08:35:10.000Z","keywords":"okhttp3","_content":"本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇\n\n### Http 缓存基础知识\n分析源目前，我们先回顾一下 Http 的缓存 Header 的含义\n1. Expires\n表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存\n\tExpires: Thu, 12 Jan 2017 11:01:33 GMT\n\n2. Cache-Control\n相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。\n\n\tCache-Control: max-age=31536000, public\n\n3. 修订文件名（Reving Filenames）\n如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery\n\tupcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js\n\n4. 条件 get 请求 （Conditional GET Requests） 与 304\n如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.\n\n请求的方式有两种：\n- Last-Modified-Date:\n\tLast-Modified: Tue, 12 Jan 2016 09:31:27 GMT\n\n客户端再次发送时，通过发送\n\tIf-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT\n\n交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.\n- ETag\nETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了\n\tETag: \"5694c7ef-24dc\"\n\n客户端再次请求时，通过发送\n\tIf-None-Match:\"5694c7ef-24dc\"\n\n交给服务器进行判断，如果还能使用缓存，服务器就返回 304\n\n> 如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。\n\n- 其他标签\n\t- no-cache/no-store: 不使用缓存\n\t\t- only-if-cached: 只使用缓存\n\t\t- Date:The date and time that the message was sent\n\t\t- Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间\n\n> \"only-if-cached\"标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。\n> 全部的标签，可以到[这里看](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)\n\n以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png)\n\n### 源码分析\nOkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。\n\n1. 总体请求流程分析\nCacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出\nInput（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)\n\nRequest:\n开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。\n\ncacheCandildate:\n也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.\n\n当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png)\n\n> 以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论\n\n基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。\n> 关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断\n\n2. CacheStrategy 的加工过程\n\nCacheStrategy 使用 Factory模式进行构造，参数如下\n\n\tInternalCache responseCache = Internal.instance.internalCache(client);\n\t//cacheCandidate从disklurcache中获取\n\t//request的url被md5序列化为key,进行缓存查询\n\tResponse cacheCandidate = responseCache != null ? responseCache.get(request) : null;\n\t//请求与缓存\n\tfactory = new CacheStrategy.Factory(now, request, cacheCandidate);\n\tcacheStrategy = factory.get();\n\t//输出结果\n\tnetworkRequest = cacheStrategy.networkRequest;\n\tcacheResponse = cacheStrategy.cacheResponse;\n\t//进行一大堆的if判断，内容同上表格\n\t.....\n\n可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下\n\n\tprivate CacheStrategy getCandidate() {\n\t  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了\n\t  if (cacheResponse == null) {\n\t    //`没有缓存的网络请求,查上文的表可知是直接访问\n\t    return new CacheStrategy(request, null);\n\t  }\n\t\n\t  // 如果缓存的TLS握手信息丢失,返回进行直接连接\n\t  if (request.isHttps() && cacheResponse.handshake() == null) {\n\t    //直接访问\n\t    return new CacheStrategy(request, null);\n\t  }\n\t\n\t  //检测response的状态码,Expired时间,是否有no-cache标签\n\t  if (!isCacheable(cacheResponse, request)) {\n\t    //直接访问\n\t    return new CacheStrategy(request, null);\n\t  }\n\t\n\t  CacheControl requestCaching = request.cacheControl();\n\t  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)\n\t  //或者有ETag/Since标签(也就是条件GET请求)\n\t  if (requestCaching.noCache() || hasConditions(request)) {\n\t    //直接连接,把缓存判断交给服务器\n\t    return new CacheStrategy(request, null);\n\t  }\n\t  //根据RFC协议计算\n\t  //计算当前age的时间戳\n\t  //now - sent + age (s)\n\t  long ageMillis = cacheResponseAge();\n\t  //大部分情况服务器设置为max-age\n\t  long freshMillis = computeFreshnessLifetime();\n\t\n\t  if (requestCaching.maxAgeSeconds() != -1) {\n\t    //大部分情况下是取max-age\n\t    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));\n\t  }\n\t\n\t  long minFreshMillis = 0;\n\t  if (requestCaching.minFreshSeconds() != -1) {\n\t    //大部分情况下设置是0\n\t    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());\n\t  }\n\t\n\t  long maxStaleMillis = 0;\n\t  //ParseHeader中的缓存控制信息\n\t  CacheControl responseCaching = cacheResponse.cacheControl();\n\t  if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {\n\t    //设置最大过期时间,一般设置为0\n\t    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());\n\t  }\n\t\n\t  //缓存在过期时间内,可以使用\n\t  //大部分情况下是进行如下判断\n\t  //now - sent + age + 0 < max-age + 0\n\t  if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {\n\t    //返回上次的缓存\n\t    Response.Builder builder = cacheResponse.newBuilder();\n\t    return new CacheStrategy(null, builder.build());\n\t  }\n\t\n\t  //缓存失效, 如果有etag等信息\n\t  //进行发送`conditional`请求,交给服务器处理\n\t  Request.Builder conditionalRequestBuilder = request.newBuilder();\n\t\n\t  if (etag != null) {\n\t    conditionalRequestBuilder.header(\"If-None-Match\", etag);\n\t  } else if (lastModified != null) {\n\t    conditionalRequestBuilder.header(\"If-Modified-Since\", lastModifiedString);\n\t  } else if (servedDate != null) {\n\t    conditionalRequestBuilder.header(\"If-Modified-Since\", servedDateString);\n\t  }\n\t  //下面请求实质还说网络请求\n\t  Request conditionalRequest = conditionalRequestBuilder.build();\n\t  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,\n\t      cacheResponse) : new CacheStrategy(conditionalRequest, null);\n\t}\n\n太长不看的话，大多数常见的情况可以用这个估算\n\n\tnow - sent + age < max-age\n\n> 这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析\n> ![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png)\n\n### 结论\n根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。\n\n1. 通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。\n2. OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 **没有必要** 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 [注释中](https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79)。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.\n3. 充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成\n4. 可以使用 alt + space  快速预览某个函数\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png)\n\n\n\n\n摘自：[http://www.jianshu.com/p/9cebbbd0eeab](http://www.jianshu.com/p/9cebbbd0eeab)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/OkHttp3-源码分析【缓存策略】.md","raw":"title: OkHttp3 源码分析【缓存策略】\ndate: 2016-06-20 16:35:10\ncategories: okhttp3\nkeywords: okhttp3\ntags: okhttp3\n---\n本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇\n\n### Http 缓存基础知识\n分析源目前，我们先回顾一下 Http 的缓存 Header 的含义\n1. Expires\n表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存\n\tExpires: Thu, 12 Jan 2017 11:01:33 GMT\n\n2. Cache-Control\n相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。\n\n\tCache-Control: max-age=31536000, public\n\n3. 修订文件名（Reving Filenames）\n如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery\n\tupcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js\n\n4. 条件 get 请求 （Conditional GET Requests） 与 304\n如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.\n\n请求的方式有两种：\n- Last-Modified-Date:\n\tLast-Modified: Tue, 12 Jan 2016 09:31:27 GMT\n\n客户端再次发送时，通过发送\n\tIf-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT\n\n交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.\n- ETag\nETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了\n\tETag: \"5694c7ef-24dc\"\n\n客户端再次请求时，通过发送\n\tIf-None-Match:\"5694c7ef-24dc\"\n\n交给服务器进行判断，如果还能使用缓存，服务器就返回 304\n\n> 如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。\n\n- 其他标签\n\t- no-cache/no-store: 不使用缓存\n\t\t- only-if-cached: 只使用缓存\n\t\t- Date:The date and time that the message was sent\n\t\t- Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间\n\n> \"only-if-cached\"标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。\n> 全部的标签，可以到[这里看](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)\n\n以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png)\n\n### 源码分析\nOkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。\n\n1. 总体请求流程分析\nCacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出\nInput（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)\n\nRequest:\n开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。\n\ncacheCandildate:\n也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.\n\n当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png)\n\n> 以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论\n\n基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。\n> 关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断\n\n2. CacheStrategy 的加工过程\n\nCacheStrategy 使用 Factory模式进行构造，参数如下\n\n\tInternalCache responseCache = Internal.instance.internalCache(client);\n\t//cacheCandidate从disklurcache中获取\n\t//request的url被md5序列化为key,进行缓存查询\n\tResponse cacheCandidate = responseCache != null ? responseCache.get(request) : null;\n\t//请求与缓存\n\tfactory = new CacheStrategy.Factory(now, request, cacheCandidate);\n\tcacheStrategy = factory.get();\n\t//输出结果\n\tnetworkRequest = cacheStrategy.networkRequest;\n\tcacheResponse = cacheStrategy.cacheResponse;\n\t//进行一大堆的if判断，内容同上表格\n\t.....\n\n可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下\n\n\tprivate CacheStrategy getCandidate() {\n\t  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了\n\t  if (cacheResponse == null) {\n\t    //`没有缓存的网络请求,查上文的表可知是直接访问\n\t    return new CacheStrategy(request, null);\n\t  }\n\t\n\t  // 如果缓存的TLS握手信息丢失,返回进行直接连接\n\t  if (request.isHttps() && cacheResponse.handshake() == null) {\n\t    //直接访问\n\t    return new CacheStrategy(request, null);\n\t  }\n\t\n\t  //检测response的状态码,Expired时间,是否有no-cache标签\n\t  if (!isCacheable(cacheResponse, request)) {\n\t    //直接访问\n\t    return new CacheStrategy(request, null);\n\t  }\n\t\n\t  CacheControl requestCaching = request.cacheControl();\n\t  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)\n\t  //或者有ETag/Since标签(也就是条件GET请求)\n\t  if (requestCaching.noCache() || hasConditions(request)) {\n\t    //直接连接,把缓存判断交给服务器\n\t    return new CacheStrategy(request, null);\n\t  }\n\t  //根据RFC协议计算\n\t  //计算当前age的时间戳\n\t  //now - sent + age (s)\n\t  long ageMillis = cacheResponseAge();\n\t  //大部分情况服务器设置为max-age\n\t  long freshMillis = computeFreshnessLifetime();\n\t\n\t  if (requestCaching.maxAgeSeconds() != -1) {\n\t    //大部分情况下是取max-age\n\t    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));\n\t  }\n\t\n\t  long minFreshMillis = 0;\n\t  if (requestCaching.minFreshSeconds() != -1) {\n\t    //大部分情况下设置是0\n\t    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());\n\t  }\n\t\n\t  long maxStaleMillis = 0;\n\t  //ParseHeader中的缓存控制信息\n\t  CacheControl responseCaching = cacheResponse.cacheControl();\n\t  if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {\n\t    //设置最大过期时间,一般设置为0\n\t    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());\n\t  }\n\t\n\t  //缓存在过期时间内,可以使用\n\t  //大部分情况下是进行如下判断\n\t  //now - sent + age + 0 < max-age + 0\n\t  if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {\n\t    //返回上次的缓存\n\t    Response.Builder builder = cacheResponse.newBuilder();\n\t    return new CacheStrategy(null, builder.build());\n\t  }\n\t\n\t  //缓存失效, 如果有etag等信息\n\t  //进行发送`conditional`请求,交给服务器处理\n\t  Request.Builder conditionalRequestBuilder = request.newBuilder();\n\t\n\t  if (etag != null) {\n\t    conditionalRequestBuilder.header(\"If-None-Match\", etag);\n\t  } else if (lastModified != null) {\n\t    conditionalRequestBuilder.header(\"If-Modified-Since\", lastModifiedString);\n\t  } else if (servedDate != null) {\n\t    conditionalRequestBuilder.header(\"If-Modified-Since\", servedDateString);\n\t  }\n\t  //下面请求实质还说网络请求\n\t  Request conditionalRequest = conditionalRequestBuilder.build();\n\t  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,\n\t      cacheResponse) : new CacheStrategy(conditionalRequest, null);\n\t}\n\n太长不看的话，大多数常见的情况可以用这个估算\n\n\tnow - sent + age < max-age\n\n> 这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析\n> ![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png)\n\n### 结论\n根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。\n\n1. 通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。\n2. OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 **没有必要** 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 [注释中](https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79)。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.\n3. 充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成\n4. 可以使用 alt + space  快速预览某个函数\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png)\n\n\n\n\n摘自：[http://www.jianshu.com/p/9cebbbd0eeab](http://www.jianshu.com/p/9cebbbd0eeab)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"OkHttp3-源码分析【缓存策略】","published":1,"updated":"2016-06-20T09:06:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ag1000mxzexvb7jte33","content":"<p>本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇</p>\n<h3 id=\"Http-缓存基础知识\"><a href=\"#Http-缓存基础知识\" class=\"headerlink\" title=\"Http 缓存基础知识\"></a>Http 缓存基础知识</h3><p>分析源目前，我们先回顾一下 Http 的缓存 Header 的含义</p>\n<ol>\n<li><p>Expires<br>表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存<br> Expires: Thu, 12 Jan 2017 11:01:33 GMT</p>\n</li>\n<li><p>Cache-Control<br>相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。</p>\n<p> Cache-Control: max-age=31536000, public</p>\n</li>\n<li><p>修订文件名（Reving Filenames）<br>如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery<br> upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js</p>\n</li>\n<li><p>条件 get 请求 （Conditional GET Requests） 与 304<br>如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.</p>\n</li>\n</ol>\n<p>请求的方式有两种：</p>\n<ul>\n<li>Last-Modified-Date:<br>  Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT</li>\n</ul>\n<p>客户端再次发送时，通过发送<br>    If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT</p>\n<p>交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.</p>\n<ul>\n<li>ETag<br>ETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了<br>  ETag: “5694c7ef-24dc”</li>\n</ul>\n<p>客户端再次请求时，通过发送<br>    If-None-Match:”5694c7ef-24dc”</p>\n<p>交给服务器进行判断，如果还能使用缓存，服务器就返回 304</p>\n<blockquote>\n<p>如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。</p>\n</blockquote>\n<ul>\n<li>其他标签<ul>\n<li>no-cache/no-store: 不使用缓存<ul>\n<li>only-if-cached: 只使用缓存</li>\n<li>Date:The date and time that the message was sent</li>\n<li>Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>“only-if-cached”标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。<br>全部的标签，可以到<a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\" target=\"_blank\" rel=\"external\">这里看</a></p>\n</blockquote>\n<p>以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png\" alt=\"\"></p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>OkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。</p>\n<ol>\n<li>总体请求流程分析<br>CacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出<br>Input（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)</li>\n</ol>\n<p>Request:<br>开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。</p>\n<p>cacheCandildate:<br>也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.</p>\n<p>当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png\" alt=\"\"></p>\n<blockquote>\n<p>以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论</p>\n</blockquote>\n<p>基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。</p>\n<blockquote>\n<p>关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断</p>\n</blockquote>\n<ol>\n<li>CacheStrategy 的加工过程</li>\n</ol>\n<p>CacheStrategy 使用 Factory模式进行构造，参数如下</p>\n<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);\n//cacheCandidate从disklurcache中获取\n//request的url被md5序列化为key,进行缓存查询\nResponse cacheCandidate = responseCache != null ? responseCache.get(request) : null;\n//请求与缓存\nfactory = new CacheStrategy.Factory(now, request, cacheCandidate);\ncacheStrategy = factory.get();\n//输出结果\nnetworkRequest = cacheStrategy.networkRequest;\ncacheResponse = cacheStrategy.cacheResponse;\n//进行一大堆的if判断，内容同上表格\n.....\n</code></pre><p>可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下</p>\n<pre><code>private CacheStrategy getCandidate() {\n  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了\n  if (cacheResponse == null) {\n    //`没有缓存的网络请求,查上文的表可知是直接访问\n    return new CacheStrategy(request, null);\n  }\n\n  // 如果缓存的TLS握手信息丢失,返回进行直接连接\n  if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) {\n    //直接访问\n    return new CacheStrategy(request, null);\n  }\n\n  //检测response的状态码,Expired时间,是否有no-cache标签\n  if (!isCacheable(cacheResponse, request)) {\n    //直接访问\n    return new CacheStrategy(request, null);\n  }\n\n  CacheControl requestCaching = request.cacheControl();\n  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)\n  //或者有ETag/Since标签(也就是条件GET请求)\n  if (requestCaching.noCache() || hasConditions(request)) {\n    //直接连接,把缓存判断交给服务器\n    return new CacheStrategy(request, null);\n  }\n  //根据RFC协议计算\n  //计算当前age的时间戳\n  //now - sent + age (s)\n  long ageMillis = cacheResponseAge();\n  //大部分情况服务器设置为max-age\n  long freshMillis = computeFreshnessLifetime();\n\n  if (requestCaching.maxAgeSeconds() != -1) {\n    //大部分情况下是取max-age\n    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));\n  }\n\n  long minFreshMillis = 0;\n  if (requestCaching.minFreshSeconds() != -1) {\n    //大部分情况下设置是0\n    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());\n  }\n\n  long maxStaleMillis = 0;\n  //ParseHeader中的缓存控制信息\n  CacheControl responseCaching = cacheResponse.cacheControl();\n  if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) {\n    //设置最大过期时间,一般设置为0\n    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());\n  }\n\n  //缓存在过期时间内,可以使用\n  //大部分情况下是进行如下判断\n  //now - sent + age + 0 &lt; max-age + 0\n  if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) {\n    //返回上次的缓存\n    Response.Builder builder = cacheResponse.newBuilder();\n    return new CacheStrategy(null, builder.build());\n  }\n\n  //缓存失效, 如果有etag等信息\n  //进行发送`conditional`请求,交给服务器处理\n  Request.Builder conditionalRequestBuilder = request.newBuilder();\n\n  if (etag != null) {\n    conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);\n  } else if (lastModified != null) {\n    conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);\n  } else if (servedDate != null) {\n    conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);\n  }\n  //下面请求实质还说网络请求\n  Request conditionalRequest = conditionalRequestBuilder.build();\n  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,\n      cacheResponse) : new CacheStrategy(conditionalRequest, null);\n}\n</code></pre><p>太长不看的话，大多数常见的情况可以用这个估算</p>\n<pre><code>now - sent + age &lt; max-age\n</code></pre><blockquote>\n<p>这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。</p>\n<ol>\n<li>通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。</li>\n<li>OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 <strong>没有必要</strong> 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 <a href=\"https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79\" target=\"_blank\" rel=\"external\">注释中</a>。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.</li>\n<li>充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成</li>\n<li>可以使用 alt + space  快速预览某个函数<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png\" alt=\"\"></li>\n</ol>\n<p>摘自：<a href=\"http://www.jianshu.com/p/9cebbbd0eeab\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/9cebbbd0eeab</a></p>\n","excerpt":"","more":"<p>本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇</p>\n<h3 id=\"Http-缓存基础知识\"><a href=\"#Http-缓存基础知识\" class=\"headerlink\" title=\"Http 缓存基础知识\"></a>Http 缓存基础知识</h3><p>分析源目前，我们先回顾一下 Http 的缓存 Header 的含义</p>\n<ol>\n<li><p>Expires<br>表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存<br> Expires: Thu, 12 Jan 2017 11:01:33 GMT</p>\n</li>\n<li><p>Cache-Control<br>相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。</p>\n<p> Cache-Control: max-age=31536000, public</p>\n</li>\n<li><p>修订文件名（Reving Filenames）<br>如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery<br> upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js</p>\n</li>\n<li><p>条件 get 请求 （Conditional GET Requests） 与 304<br>如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.</p>\n</li>\n</ol>\n<p>请求的方式有两种：</p>\n<ul>\n<li>Last-Modified-Date:<br>  Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT</li>\n</ul>\n<p>客户端再次发送时，通过发送<br>    If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT</p>\n<p>交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.</p>\n<ul>\n<li>ETag<br>ETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了<br>  ETag: “5694c7ef-24dc”</li>\n</ul>\n<p>客户端再次请求时，通过发送<br>    If-None-Match:”5694c7ef-24dc”</p>\n<p>交给服务器进行判断，如果还能使用缓存，服务器就返回 304</p>\n<blockquote>\n<p>如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。</p>\n</blockquote>\n<ul>\n<li>其他标签<ul>\n<li>no-cache/no-store: 不使用缓存<ul>\n<li>only-if-cached: 只使用缓存</li>\n<li>Date:The date and time that the message was sent</li>\n<li>Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>“only-if-cached”标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。<br>全部的标签，可以到<a href=\"https://en.wikipedia.org/wiki/List_of_HTTP_header_fields\">这里看</a></p>\n</blockquote>\n<p>以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png\" alt=\"\"></p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>OkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。</p>\n<ol>\n<li>总体请求流程分析<br>CacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出<br>Input（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)</li>\n</ol>\n<p>Request:<br>开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。</p>\n<p>cacheCandildate:<br>也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.</p>\n<p>当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png\" alt=\"\"></p>\n<blockquote>\n<p>以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论</p>\n</blockquote>\n<p>基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。</p>\n<blockquote>\n<p>关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断</p>\n</blockquote>\n<ol>\n<li>CacheStrategy 的加工过程</li>\n</ol>\n<p>CacheStrategy 使用 Factory模式进行构造，参数如下</p>\n<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);\n//cacheCandidate从disklurcache中获取\n//request的url被md5序列化为key,进行缓存查询\nResponse cacheCandidate = responseCache != null ? responseCache.get(request) : null;\n//请求与缓存\nfactory = new CacheStrategy.Factory(now, request, cacheCandidate);\ncacheStrategy = factory.get();\n//输出结果\nnetworkRequest = cacheStrategy.networkRequest;\ncacheResponse = cacheStrategy.cacheResponse;\n//进行一大堆的if判断，内容同上表格\n.....\n</code></pre><p>可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下</p>\n<pre><code>private CacheStrategy getCandidate() {\n  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了\n  if (cacheResponse == null) {\n    //`没有缓存的网络请求,查上文的表可知是直接访问\n    return new CacheStrategy(request, null);\n  }\n\n  // 如果缓存的TLS握手信息丢失,返回进行直接连接\n  if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) {\n    //直接访问\n    return new CacheStrategy(request, null);\n  }\n\n  //检测response的状态码,Expired时间,是否有no-cache标签\n  if (!isCacheable(cacheResponse, request)) {\n    //直接访问\n    return new CacheStrategy(request, null);\n  }\n\n  CacheControl requestCaching = request.cacheControl();\n  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)\n  //或者有ETag/Since标签(也就是条件GET请求)\n  if (requestCaching.noCache() || hasConditions(request)) {\n    //直接连接,把缓存判断交给服务器\n    return new CacheStrategy(request, null);\n  }\n  //根据RFC协议计算\n  //计算当前age的时间戳\n  //now - sent + age (s)\n  long ageMillis = cacheResponseAge();\n  //大部分情况服务器设置为max-age\n  long freshMillis = computeFreshnessLifetime();\n\n  if (requestCaching.maxAgeSeconds() != -1) {\n    //大部分情况下是取max-age\n    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));\n  }\n\n  long minFreshMillis = 0;\n  if (requestCaching.minFreshSeconds() != -1) {\n    //大部分情况下设置是0\n    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());\n  }\n\n  long maxStaleMillis = 0;\n  //ParseHeader中的缓存控制信息\n  CacheControl responseCaching = cacheResponse.cacheControl();\n  if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) {\n    //设置最大过期时间,一般设置为0\n    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());\n  }\n\n  //缓存在过期时间内,可以使用\n  //大部分情况下是进行如下判断\n  //now - sent + age + 0 &lt; max-age + 0\n  if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) {\n    //返回上次的缓存\n    Response.Builder builder = cacheResponse.newBuilder();\n    return new CacheStrategy(null, builder.build());\n  }\n\n  //缓存失效, 如果有etag等信息\n  //进行发送`conditional`请求,交给服务器处理\n  Request.Builder conditionalRequestBuilder = request.newBuilder();\n\n  if (etag != null) {\n    conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);\n  } else if (lastModified != null) {\n    conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);\n  } else if (servedDate != null) {\n    conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);\n  }\n  //下面请求实质还说网络请求\n  Request conditionalRequest = conditionalRequestBuilder.build();\n  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,\n      cacheResponse) : new CacheStrategy(conditionalRequest, null);\n}\n</code></pre><p>太长不看的话，大多数常见的情况可以用这个估算</p>\n<pre><code>now - sent + age &lt; max-age\n</code></pre><blockquote>\n<p>这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。</p>\n<ol>\n<li>通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。</li>\n<li>OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 <strong>没有必要</strong> 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 <a href=\"https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79\">注释中</a>。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.</li>\n<li>充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成</li>\n<li>可以使用 alt + space  快速预览某个函数<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png\" alt=\"\"></li>\n</ol>\n<p>摘自：<a href=\"http://www.jianshu.com/p/9cebbbd0eeab\">http://www.jianshu.com/p/9cebbbd0eeab</a></p>\n"},{"title":"Okhttp3源码分析【DiskLruCache】","date":"2016-06-20T07:57:46.000Z","keywords":"okhttp3","_content":"### 本文目录\n- Cache 的简介\n- LinkedHashMap 原理\n- OkHttp 的文件系统\n\n本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 **缓存策略**\n\n### 1.Cache 的简介\n缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：\n1. 缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。\n2. 需要实现 *排序依据*， 子啊 java 中，可以使用 Comparable\\<T\\>作为排序的接口。\n3. 需要一种 *页面置换算法* 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等\n4. 如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点\n\n在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。\n\n> 1.Comparable\\<T\\>是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》\n> 2.页面置换算法可以参考阅读《现代操作系统》的中译本\n\n### 2.LinkedHashMap 原理\n1. 源码概述分析\n在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.\n\n在 HashMap 中，维护了一个 Node\\<K,V\\>[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。\n\n而在 LinkedHashMap 中，除了 Node\\<K,V\\>[](#) table， 还维护着 Entry\\<K,V\\> head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素\n\t// move node to last\n\tvoid afterNodeAccess(Node<K,V> e)\n\t// possibly remove eldest\n\tvoid afterNodeInsertion(boolean evict)\n\n当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建\n\t// move node to last\n\tvoid afterNodeAccess(Node<K,V> e)\n\n综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head\n\n最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现\n\thead <--> .... <--> tail\n\t\n\t旧元素 <-----------> 反复使用的新元素\n\n在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化\n\t//按照访问顺序排序的Map，设置accessOrder为true\n\tmap = new LinkedHashMap<>(0, 0.75f, true);\n\n### 3.OkHttp 的文件系统\nOkHttp 中的关键对象如下：\n- FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作\n- DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装\n- DiskLruCache.Entry: 维护着 key 对应的多个文件\n- Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类\n- DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）\n- Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理\n- Response/Request: OkHttp 的请求与回应\n\n1. 文件初级封装（FileSystem）\n众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。\n\tFile(低级操作，步骤繁琐) -> Okio(封装) －> FileSystem(友好工具类)\n\nOkio 很不错，可以去[这里](https://github.com/square/okio)查看。\n\n2. 文件高级封装（DiskLruCache.Entry/Editor/Snapshot）\n本部分进行了如下操作，进行了实际的 put/get 操作\n\tFileSystem <-- DiskLruCache.Entry/Editor --> source/sink(更少参数)\n\nDiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY\\_METADATA 与 ENTRY\\_BODY。\n\n比如在缓存的路径下执行 ls,结果如下：\n\t$ ls\n\t5716ab0f06c49bc7cf602397c51d5677.0\n\t5716ab0f06c49bc7cf602397c51d5677.1\n\t5b2f52377611dc6201a1871bdb997466.0\n\t5b2f52377611dc6201a1871bdb997466.1\n\tjournal\n\t.....\n\nDiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景\n\n- 写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。\n![](http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png)\n- 读取场景：读取时，需要获取快照，通过调用链分析\n![](http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png)\n\n3. 序列化与反序列化（Cache.Entry）\n文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变\n> Resonse(java对象) \\<--- Cache.Entry ---\\> source/sink(文件io)\n\n可以通过 find usage 位置相同，概括如下：\n如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。\n\t至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。\n\t\n\t注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象\n\n4. 缓存的自动清理\n在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。\n\n\tnew ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,\n\t        new LinkedBlockingQueue<Runnable>(), Util.threadFactory(\"OkHttp DiskLruCache\", true))\n\n当需要清理时，执行清理任务，它将在每次 get/set 后调用\n\n\tprivate final Runnable cleanupRunnable = new Runnable() {\n\t  public void run() {\n\t    synchronized (DiskLruCache.this) {\n\t      if (!initialized | closed) {\n\t        return; // Nothing to do\n\t      }\n\t      try {\n\t        //遍历LRU缓存(从旧到新进行遍历map),并删除文件\n\t        //直到小于MaxSize为止\n\t        trimToSize();\n\t        if (journalRebuildRequired()) {\n\t          rebuildJournal();\n\t          redundantOpCount = 0;\n\t        }\n\t      } catch (IOException e) {\n\t        throw new RuntimeException(e);\n\t      }\n\t    }\n\t  }\n\t};\n\n### 总结\n1. OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作\n2. OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作\n3. OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理\n\n\n\n\n\n\n\n\n摘自：http://www.jianshu.com/p/23b8aa490a6b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Okhttp3源码分析【DiskLruCache】.md","raw":"title: Okhttp3源码分析【DiskLruCache】\ndate: 2016-06-20 15:57:46\ncategories: okhttp3\nkeywords: okhttp3\ntags: okhttp3\n---\n### 本文目录\n- Cache 的简介\n- LinkedHashMap 原理\n- OkHttp 的文件系统\n\n本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 **缓存策略**\n\n### 1.Cache 的简介\n缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：\n1. 缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。\n2. 需要实现 *排序依据*， 子啊 java 中，可以使用 Comparable\\<T\\>作为排序的接口。\n3. 需要一种 *页面置换算法* 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等\n4. 如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点\n\n在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。\n\n> 1.Comparable\\<T\\>是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》\n> 2.页面置换算法可以参考阅读《现代操作系统》的中译本\n\n### 2.LinkedHashMap 原理\n1. 源码概述分析\n在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.\n\n在 HashMap 中，维护了一个 Node\\<K,V\\>[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。\n\n而在 LinkedHashMap 中，除了 Node\\<K,V\\>[](#) table， 还维护着 Entry\\<K,V\\> head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素\n\t// move node to last\n\tvoid afterNodeAccess(Node<K,V> e)\n\t// possibly remove eldest\n\tvoid afterNodeInsertion(boolean evict)\n\n当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建\n\t// move node to last\n\tvoid afterNodeAccess(Node<K,V> e)\n\n综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head\n\n最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现\n\thead <--> .... <--> tail\n\t\n\t旧元素 <-----------> 反复使用的新元素\n\n在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化\n\t//按照访问顺序排序的Map，设置accessOrder为true\n\tmap = new LinkedHashMap<>(0, 0.75f, true);\n\n### 3.OkHttp 的文件系统\nOkHttp 中的关键对象如下：\n- FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作\n- DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装\n- DiskLruCache.Entry: 维护着 key 对应的多个文件\n- Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类\n- DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）\n- Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理\n- Response/Request: OkHttp 的请求与回应\n\n1. 文件初级封装（FileSystem）\n众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。\n\tFile(低级操作，步骤繁琐) -> Okio(封装) －> FileSystem(友好工具类)\n\nOkio 很不错，可以去[这里](https://github.com/square/okio)查看。\n\n2. 文件高级封装（DiskLruCache.Entry/Editor/Snapshot）\n本部分进行了如下操作，进行了实际的 put/get 操作\n\tFileSystem <-- DiskLruCache.Entry/Editor --> source/sink(更少参数)\n\nDiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY\\_METADATA 与 ENTRY\\_BODY。\n\n比如在缓存的路径下执行 ls,结果如下：\n\t$ ls\n\t5716ab0f06c49bc7cf602397c51d5677.0\n\t5716ab0f06c49bc7cf602397c51d5677.1\n\t5b2f52377611dc6201a1871bdb997466.0\n\t5b2f52377611dc6201a1871bdb997466.1\n\tjournal\n\t.....\n\nDiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景\n\n- 写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。\n![](http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png)\n- 读取场景：读取时，需要获取快照，通过调用链分析\n![](http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png)\n\n3. 序列化与反序列化（Cache.Entry）\n文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变\n> Resonse(java对象) \\<--- Cache.Entry ---\\> source/sink(文件io)\n\n可以通过 find usage 位置相同，概括如下：\n如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。\n\t至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。\n\t\n\t注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象\n\n4. 缓存的自动清理\n在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。\n\n\tnew ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,\n\t        new LinkedBlockingQueue<Runnable>(), Util.threadFactory(\"OkHttp DiskLruCache\", true))\n\n当需要清理时，执行清理任务，它将在每次 get/set 后调用\n\n\tprivate final Runnable cleanupRunnable = new Runnable() {\n\t  public void run() {\n\t    synchronized (DiskLruCache.this) {\n\t      if (!initialized | closed) {\n\t        return; // Nothing to do\n\t      }\n\t      try {\n\t        //遍历LRU缓存(从旧到新进行遍历map),并删除文件\n\t        //直到小于MaxSize为止\n\t        trimToSize();\n\t        if (journalRebuildRequired()) {\n\t          rebuildJournal();\n\t          redundantOpCount = 0;\n\t        }\n\t      } catch (IOException e) {\n\t        throw new RuntimeException(e);\n\t      }\n\t    }\n\t  }\n\t};\n\n### 总结\n1. OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作\n2. OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作\n3. OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理\n\n\n\n\n\n\n\n\n摘自：http://www.jianshu.com/p/23b8aa490a6b\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Okhttp3源码分析【DiskLruCache】","published":1,"updated":"2016-06-20T09:05:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ag5000oxzexyq7x5kaz","content":"<h3 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h3><ul>\n<li>Cache 的简介</li>\n<li>LinkedHashMap 原理</li>\n<li>OkHttp 的文件系统</li>\n</ul>\n<p>本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 <strong>缓存策略</strong></p>\n<h3 id=\"1-Cache-的简介\"><a href=\"#1-Cache-的简介\" class=\"headerlink\" title=\"1.Cache 的简介\"></a>1.Cache 的简介</h3><p>缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：</p>\n<ol>\n<li>缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。</li>\n<li>需要实现 <em>排序依据</em>， 子啊 java 中，可以使用 Comparable\\<t\\>作为排序的接口。</t\\></li>\n<li>需要一种 <em>页面置换算法</em> 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等</li>\n<li>如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点</li>\n</ol>\n<p>在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。</p>\n<blockquote>\n<p>1.Comparable\\<t\\>是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》<br>2.页面置换算法可以参考阅读《现代操作系统》的中译本</t\\></p>\n</blockquote>\n<h3 id=\"2-LinkedHashMap-原理\"><a href=\"#2-LinkedHashMap-原理\" class=\"headerlink\" title=\"2.LinkedHashMap 原理\"></a>2.LinkedHashMap 原理</h3><ol>\n<li>源码概述分析<br>在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.</li>\n</ol>\n<p>在 HashMap 中，维护了一个 Node\\<k,v\\>[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。</k,v\\></p>\n<p>而在 LinkedHashMap 中，除了 Node\\<k,v\\><a href=\"#\"></a> table， 还维护着 Entry\\<k,v\\> head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素<br>    // move node to last<br>    void afterNodeAccess(Node<k,v> e)<br>    // possibly remove eldest<br>    void afterNodeInsertion(boolean evict)</k,v></k,v\\></k,v\\></p>\n<p>当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建<br>    // move node to last<br>    void afterNodeAccess(Node<k,v> e)</k,v></p>\n<p>综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head</p>\n<p>最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现<br>    head &lt;–&gt; …. &lt;–&gt; tail</p>\n<pre><code>旧元素 &lt;-----------&gt; 反复使用的新元素\n</code></pre><p>在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化<br>    //按照访问顺序排序的Map，设置accessOrder为true<br>    map = new LinkedHashMap&lt;&gt;(0, 0.75f, true);</p>\n<h3 id=\"3-OkHttp-的文件系统\"><a href=\"#3-OkHttp-的文件系统\" class=\"headerlink\" title=\"3.OkHttp 的文件系统\"></a>3.OkHttp 的文件系统</h3><p>OkHttp 中的关键对象如下：</p>\n<ul>\n<li>FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作</li>\n<li>DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装</li>\n<li>DiskLruCache.Entry: 维护着 key 对应的多个文件</li>\n<li>Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类</li>\n<li>DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）</li>\n<li>Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理</li>\n<li>Response/Request: OkHttp 的请求与回应</li>\n</ul>\n<ol>\n<li>文件初级封装（FileSystem）<br>众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。<br> File(低级操作，步骤繁琐) -&gt; Okio(封装) －&gt; FileSystem(友好工具类)</li>\n</ol>\n<p>Okio 很不错，可以去<a href=\"https://github.com/square/okio\" target=\"_blank\" rel=\"external\">这里</a>查看。</p>\n<ol>\n<li>文件高级封装（DiskLruCache.Entry/Editor/Snapshot）<br>本部分进行了如下操作，进行了实际的 put/get 操作<br> FileSystem &lt;– DiskLruCache.Entry/Editor –&gt; source/sink(更少参数)</li>\n</ol>\n<p>DiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY_METADATA 与 ENTRY_BODY。</p>\n<p>比如在缓存的路径下执行 ls,结果如下：<br>    $ ls<br>    5716ab0f06c49bc7cf602397c51d5677.0<br>    5716ab0f06c49bc7cf602397c51d5677.1<br>    5b2f52377611dc6201a1871bdb997466.0<br>    5b2f52377611dc6201a1871bdb997466.1<br>    journal<br>    …..</p>\n<p>DiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景</p>\n<ul>\n<li>写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png\" alt=\"\"></li>\n<li>读取场景：读取时，需要获取快照，通过调用链分析<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png\" alt=\"\"></li>\n</ul>\n<ol>\n<li>序列化与反序列化（Cache.Entry）<br>文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变<blockquote>\n<p>Resonse(java对象) \\&lt;— Cache.Entry —> source/sink(文件io)</p>\n</blockquote>\n</li>\n</ol>\n<p>可以通过 find usage 位置相同，概括如下：<br>如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。<br>    至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。</p>\n<pre><code>注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象\n</code></pre><ol>\n<li><p>缓存的自动清理<br>在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。</p>\n<p> new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,</p>\n<pre><code>new LinkedBlockingQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp DiskLruCache&quot;, true))\n</code></pre></li>\n</ol>\n<p>当需要清理时，执行清理任务，它将在每次 get/set 后调用</p>\n<pre><code>private final Runnable cleanupRunnable = new Runnable() {\n  public void run() {\n    synchronized (DiskLruCache.this) {\n      if (!initialized | closed) {\n        return; // Nothing to do\n      }\n      try {\n        //遍历LRU缓存(从旧到新进行遍历map),并删除文件\n        //直到小于MaxSize为止\n        trimToSize();\n        if (journalRebuildRequired()) {\n          rebuildJournal();\n          redundantOpCount = 0;\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n};\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作</li>\n<li>OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作</li>\n<li>OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理</li>\n</ol>\n<p>摘自：<a href=\"http://www.jianshu.com/p/23b8aa490a6b\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/23b8aa490a6b</a></p>\n","excerpt":"","more":"<h3 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h3><ul>\n<li>Cache 的简介</li>\n<li>LinkedHashMap 原理</li>\n<li>OkHttp 的文件系统</li>\n</ul>\n<p>本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 <strong>缓存策略</strong></p>\n<h3 id=\"1-Cache-的简介\"><a href=\"#1-Cache-的简介\" class=\"headerlink\" title=\"1.Cache 的简介\"></a>1.Cache 的简介</h3><p>缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：</p>\n<ol>\n<li>缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。</li>\n<li>需要实现 <em>排序依据</em>， 子啊 java 中，可以使用 Comparable\\<T\\>作为排序的接口。</li>\n<li>需要一种 <em>页面置换算法</em> 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等</li>\n<li>如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点</li>\n</ol>\n<p>在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。</p>\n<blockquote>\n<p>1.Comparable\\<T\\>是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》<br>2.页面置换算法可以参考阅读《现代操作系统》的中译本</p>\n</blockquote>\n<h3 id=\"2-LinkedHashMap-原理\"><a href=\"#2-LinkedHashMap-原理\" class=\"headerlink\" title=\"2.LinkedHashMap 原理\"></a>2.LinkedHashMap 原理</h3><ol>\n<li>源码概述分析<br>在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.</li>\n</ol>\n<p>在 HashMap 中，维护了一个 Node\\<K,V\\>[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。</p>\n<p>而在 LinkedHashMap 中，除了 Node\\<K,V\\><a href=\"#\"></a> table， 还维护着 Entry\\<K,V\\> head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素<br>    // move node to last<br>    void afterNodeAccess(Node<K,V> e)<br>    // possibly remove eldest<br>    void afterNodeInsertion(boolean evict)</p>\n<p>当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建<br>    // move node to last<br>    void afterNodeAccess(Node<K,V> e)</p>\n<p>综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head</p>\n<p>最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现<br>    head &lt;–&gt; …. &lt;–&gt; tail</p>\n<pre><code>旧元素 &lt;-----------&gt; 反复使用的新元素\n</code></pre><p>在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化<br>    //按照访问顺序排序的Map，设置accessOrder为true<br>    map = new LinkedHashMap&lt;&gt;(0, 0.75f, true);</p>\n<h3 id=\"3-OkHttp-的文件系统\"><a href=\"#3-OkHttp-的文件系统\" class=\"headerlink\" title=\"3.OkHttp 的文件系统\"></a>3.OkHttp 的文件系统</h3><p>OkHttp 中的关键对象如下：</p>\n<ul>\n<li>FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作</li>\n<li>DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装</li>\n<li>DiskLruCache.Entry: 维护着 key 对应的多个文件</li>\n<li>Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类</li>\n<li>DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）</li>\n<li>Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理</li>\n<li>Response/Request: OkHttp 的请求与回应</li>\n</ul>\n<ol>\n<li>文件初级封装（FileSystem）<br>众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。<br> File(低级操作，步骤繁琐) -&gt; Okio(封装) －&gt; FileSystem(友好工具类)</li>\n</ol>\n<p>Okio 很不错，可以去<a href=\"https://github.com/square/okio\">这里</a>查看。</p>\n<ol>\n<li>文件高级封装（DiskLruCache.Entry/Editor/Snapshot）<br>本部分进行了如下操作，进行了实际的 put/get 操作<br> FileSystem &lt;– DiskLruCache.Entry/Editor –&gt; source/sink(更少参数)</li>\n</ol>\n<p>DiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY_METADATA 与 ENTRY_BODY。</p>\n<p>比如在缓存的路径下执行 ls,结果如下：<br>    $ ls<br>    5716ab0f06c49bc7cf602397c51d5677.0<br>    5716ab0f06c49bc7cf602397c51d5677.1<br>    5b2f52377611dc6201a1871bdb997466.0<br>    5b2f52377611dc6201a1871bdb997466.1<br>    journal<br>    …..</p>\n<p>DiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景</p>\n<ul>\n<li>写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png\" alt=\"\"></li>\n<li>读取场景：读取时，需要获取快照，通过调用链分析<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png\" alt=\"\"></li>\n</ul>\n<ol>\n<li>序列化与反序列化（Cache.Entry）<br>文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变<blockquote>\n<p>Resonse(java对象) \\&lt;— Cache.Entry —> source/sink(文件io)</p>\n</blockquote>\n</li>\n</ol>\n<p>可以通过 find usage 位置相同，概括如下：<br>如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。<br>    至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。</p>\n<pre><code>注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象\n</code></pre><ol>\n<li><p>缓存的自动清理<br>在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。</p>\n<p> new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,</p>\n<pre><code>new LinkedBlockingQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp DiskLruCache&quot;, true))\n</code></pre></li>\n</ol>\n<p>当需要清理时，执行清理任务，它将在每次 get/set 后调用</p>\n<pre><code>private final Runnable cleanupRunnable = new Runnable() {\n  public void run() {\n    synchronized (DiskLruCache.this) {\n      if (!initialized | closed) {\n        return; // Nothing to do\n      }\n      try {\n        //遍历LRU缓存(从旧到新进行遍历map),并删除文件\n        //直到小于MaxSize为止\n        trimToSize();\n        if (journalRebuildRequired()) {\n          rebuildJournal();\n          redundantOpCount = 0;\n        }\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n};\n</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ol>\n<li>OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作</li>\n<li>OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作</li>\n<li>OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理</li>\n</ol>\n<p>摘自：<a href=\"http://www.jianshu.com/p/23b8aa490a6b\">http://www.jianshu.com/p/23b8aa490a6b</a></p>\n"},{"title":"OkHttp3源码分析【任务队列】","date":"2016-06-20T08:34:26.000Z","keywords":"okhttp3","_content":"\n### 本文目录\n1. 线程池基础\n2. 反向代理模块\n3. OkHttp 的任务调度\n\nOkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。\n\n\n# 线程池基础\n 1. 线程池好处有哪些\n线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：\n\n多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：\n如果一台服务完成一项任务的时间为 T\n\n\tT1 创建线程的时间\n\tT2 在线程中执行任务的时间，包括线程间同步所需时间\n\tT3 线程销毁的时间\n\n显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。\n\n可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。\n\n线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。\n- 通过对线程缓存，减少创建和销毁的时间损失\n\t- 通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力\n\n在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了\n\n2. OkHttp 配置的线程池\n\n在 OkHttp 中，使用如下构造了单例线程池\n\tpublic synchronized ExecutorService executorService() {\n\t  if (executorService == null) {\n\t    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n\t        new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\t  }\n\t  return executorService;\n\t}\n\n参数说明：\n- int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。\n- int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃*处理机制*来处理\n- long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive\n- TimeUnit unit: 时间单位，一般用秒\n- BlockingQueue\\<Runnable\\> workQueue:  工作队列\n- ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等\n\n可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max\\_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 \"OkHttp Dispatcher\" 的线程工厂。\n\n也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。\n\n> 在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers\n\n### 反向代理模型\n在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。\n\n我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现**非阻塞、高并发连接**，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png)\n\n而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\\<readyAsyncCalls\\>对应 Nginx 的内部缓存\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png)\n\n具体成员如下：\n\n- maxRequests = 64：最大并发请求数为64\n- maxRequestsPerHost = 5：每个主机最大请求数为5\n- Dispatcher：分发者，也就是生产者（默认在主线程）\n- AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）\n- ExecutorService：消费者池（也就是线程池）\n- Deque\\<readyAsyncCalls\\>：缓存（用数组实现，可自动扩容，无大小限制）\n- Deque\\<runningAsyncCalls\\>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存\n\n通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间\n\n### OkHttp 的任务调度\n当我们使用 OkHttp 的异步请求时，一般进行如下构造：\n\tOkHttpClient client = new OkHttpClient.Builder().build();\n\tRequest request = new Request.Builder()\n\t    .url(\"http://qq.com\").get().build();\n\tclient.newCall(request).enqueue(new Callback() {\n\t  @Override public void onFailure(Call call, IOException e) {\n\t\n\t  }\n\t\n\t  @Override public void onResponse(Call call, Response response) throws IOException {\n\t\n\t  }\n\t});\n\n当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作\n\n\tsynchronized void enqueue(AsyncCall call) {\n\t  if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t      //添加正在运行的请求\n\t    runningAsyncCalls.add(call);\n\t       //线程池执行请求\n\t    executorService().execute(call);\n\t  } else {\n\t      //添加到缓存队列\n\t    readyAsyncCalls.add(call);\n\t  }\n\t}\n\n可以发现请求是否进入缓存的条件如下：\n\t(runningRequests<64 && runningRequestsPerHost<5)\n\n如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。\n\n我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：\n\t@Override protected void execute() {\n\t  boolean signalledCallback = false;\n\t  try {\n\t      //执行耗时IO任务\n\t    Response response = getResponseWithInterceptorChain(forWebSocket);\n\t    if (canceled) {\n\t      signalledCallback = true;\n\t      //回调，注意这里回调是在线程池中，而不是想当然的主线程回调\n\t      responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t    } else {\n\t      signalledCallback = true;\n\t      //回调，同上\n\t      responseCallback.onResponse(RealCall.this, response);\n\t    }\n\t  } catch (IOException e) {\n\t    if (signalledCallback) {\n\t      // Do not signal the callback twice!\n\t      logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n\t    } else {\n\t      responseCallback.onFailure(RealCall.this, e);\n\t    }\n\t  } finally {\n\t      //最关键的代码\n\t    client.dispatcher().finished(this);\n\t  }\n\t}\n\n当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数\n\tprivate void promoteCalls() {\n\t    //如果目前是最大负荷运转，接着等\n\t  if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n\t  //如果缓存等待区是空的，接着等\n\t  if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\t\n\t  for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n\t    AsyncCall call = i.next();\n\t\n\t    if (runningCallsForHost(call) < maxRequestsPerHost) {\n\t        //将缓存等待区最后一个移动到运行区中，并执行\n\t      i.remove();\n\t      runningAsyncCalls.add(call);\n\t      executorService().execute(call);\n\t    }\n\t\n\t    if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n\t  }\n\t}\n\n这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码\n\n### Summary\n通过上述的分析，我们知道了：\n1. OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行\n2. OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出\n3. OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度\n\n\n\n\n\n\n\n摘自：[http://www.jianshu.com/p/6637369d02e7](http://www.jianshu.com/p/6637369d02e7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/OkHttp3源码分析【任务队列】.md","raw":"title: OkHttp3源码分析【任务队列】\ndate: 2016-06-20 16:34:26\ncategories: okhttp3\nkeywords: okhttp3\ntags: okhttp3\n---\n\n### 本文目录\n1. 线程池基础\n2. 反向代理模块\n3. OkHttp 的任务调度\n\nOkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。\n\n\n# 线程池基础\n 1. 线程池好处有哪些\n线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：\n\n多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：\n如果一台服务完成一项任务的时间为 T\n\n\tT1 创建线程的时间\n\tT2 在线程中执行任务的时间，包括线程间同步所需时间\n\tT3 线程销毁的时间\n\n显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。\n\n可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。\n\n线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。\n- 通过对线程缓存，减少创建和销毁的时间损失\n\t- 通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力\n\n在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了\n\n2. OkHttp 配置的线程池\n\n在 OkHttp 中，使用如下构造了单例线程池\n\tpublic synchronized ExecutorService executorService() {\n\t  if (executorService == null) {\n\t    executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,\n\t        new SynchronousQueue<Runnable>(), Util.threadFactory(\"OkHttp Dispatcher\", false));\n\t  }\n\t  return executorService;\n\t}\n\n参数说明：\n- int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。\n- int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃*处理机制*来处理\n- long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive\n- TimeUnit unit: 时间单位，一般用秒\n- BlockingQueue\\<Runnable\\> workQueue:  工作队列\n- ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等\n\n可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max\\_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 \"OkHttp Dispatcher\" 的线程工厂。\n\n也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。\n\n> 在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers\n\n### 反向代理模型\n在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。\n\n我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现**非阻塞、高并发连接**，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png)\n\n而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\\<readyAsyncCalls\\>对应 Nginx 的内部缓存\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png)\n\n具体成员如下：\n\n- maxRequests = 64：最大并发请求数为64\n- maxRequestsPerHost = 5：每个主机最大请求数为5\n- Dispatcher：分发者，也就是生产者（默认在主线程）\n- AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）\n- ExecutorService：消费者池（也就是线程池）\n- Deque\\<readyAsyncCalls\\>：缓存（用数组实现，可自动扩容，无大小限制）\n- Deque\\<runningAsyncCalls\\>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存\n\n通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间\n\n### OkHttp 的任务调度\n当我们使用 OkHttp 的异步请求时，一般进行如下构造：\n\tOkHttpClient client = new OkHttpClient.Builder().build();\n\tRequest request = new Request.Builder()\n\t    .url(\"http://qq.com\").get().build();\n\tclient.newCall(request).enqueue(new Callback() {\n\t  @Override public void onFailure(Call call, IOException e) {\n\t\n\t  }\n\t\n\t  @Override public void onResponse(Call call, Response response) throws IOException {\n\t\n\t  }\n\t});\n\n当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作\n\n\tsynchronized void enqueue(AsyncCall call) {\n\t  if (runningAsyncCalls.size() < maxRequests && runningCallsForHost(call) < maxRequestsPerHost) {\n\t      //添加正在运行的请求\n\t    runningAsyncCalls.add(call);\n\t       //线程池执行请求\n\t    executorService().execute(call);\n\t  } else {\n\t      //添加到缓存队列\n\t    readyAsyncCalls.add(call);\n\t  }\n\t}\n\n可以发现请求是否进入缓存的条件如下：\n\t(runningRequests<64 && runningRequestsPerHost<5)\n\n如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。\n\n我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：\n\t@Override protected void execute() {\n\t  boolean signalledCallback = false;\n\t  try {\n\t      //执行耗时IO任务\n\t    Response response = getResponseWithInterceptorChain(forWebSocket);\n\t    if (canceled) {\n\t      signalledCallback = true;\n\t      //回调，注意这里回调是在线程池中，而不是想当然的主线程回调\n\t      responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\"));\n\t    } else {\n\t      signalledCallback = true;\n\t      //回调，同上\n\t      responseCallback.onResponse(RealCall.this, response);\n\t    }\n\t  } catch (IOException e) {\n\t    if (signalledCallback) {\n\t      // Do not signal the callback twice!\n\t      logger.log(Level.INFO, \"Callback failure for \" + toLoggableString(), e);\n\t    } else {\n\t      responseCallback.onFailure(RealCall.this, e);\n\t    }\n\t  } finally {\n\t      //最关键的代码\n\t    client.dispatcher().finished(this);\n\t  }\n\t}\n\n当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数\n\tprivate void promoteCalls() {\n\t    //如果目前是最大负荷运转，接着等\n\t  if (runningAsyncCalls.size() >= maxRequests) return; // Already running max capacity.\n\t  //如果缓存等待区是空的，接着等\n\t  if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.\n\t\n\t  for (Iterator<AsyncCall> i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n\t    AsyncCall call = i.next();\n\t\n\t    if (runningCallsForHost(call) < maxRequestsPerHost) {\n\t        //将缓存等待区最后一个移动到运行区中，并执行\n\t      i.remove();\n\t      runningAsyncCalls.add(call);\n\t      executorService().execute(call);\n\t    }\n\t\n\t    if (runningAsyncCalls.size() >= maxRequests) return; // Reached max capacity.\n\t  }\n\t}\n\n这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码\n\n### Summary\n通过上述的分析，我们知道了：\n1. OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行\n2. OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出\n3. OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度\n\n\n\n\n\n\n\n摘自：[http://www.jianshu.com/p/6637369d02e7](http://www.jianshu.com/p/6637369d02e7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"OkHttp3源码分析【任务队列】","published":1,"updated":"2016-06-20T09:05:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ag7000rxzex14rw4ujf","content":"<h3 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h3><ol>\n<li>线程池基础</li>\n<li>反向代理模块</li>\n<li>OkHttp 的任务调度</li>\n</ol>\n<p>OkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。</p>\n<h1 id=\"线程池基础\"><a href=\"#线程池基础\" class=\"headerlink\" title=\"线程池基础\"></a>线程池基础</h1><ol>\n<li>线程池好处有哪些<br>线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：</li>\n</ol>\n<p>多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：<br>如果一台服务完成一项任务的时间为 T</p>\n<pre><code>T1 创建线程的时间\nT2 在线程中执行任务的时间，包括线程间同步所需时间\nT3 线程销毁的时间\n</code></pre><p>显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。</p>\n<p>可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。</p>\n<p>线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。</p>\n<ul>\n<li>通过对线程缓存，减少创建和销毁的时间损失<ul>\n<li>通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力</li>\n</ul>\n</li>\n</ul>\n<p>在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了</p>\n<ol>\n<li>OkHttp 配置的线程池</li>\n</ol>\n<p>在 OkHttp 中，使用如下构造了单例线程池<br>    public synchronized ExecutorService executorService() {<br>      if (executorService == null) {<br>        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,<br>            new SynchronousQueue<runnable>(), Util.threadFactory(“OkHttp Dispatcher”, false));<br>      }<br>      return executorService;<br>    }</runnable></p>\n<p>参数说明：</p>\n<ul>\n<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</li>\n<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃<em>处理机制</em>来处理</li>\n<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>\n<li>TimeUnit unit: 时间单位，一般用秒</li>\n<li>BlockingQueue\\<runnable\\> workQueue:  工作队列</runnable\\></li>\n<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>\n</ul>\n<p>可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 “OkHttp Dispatcher” 的线程工厂。</p>\n<p>也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。</p>\n<blockquote>\n<p>在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers</p>\n</blockquote>\n<h3 id=\"反向代理模型\"><a href=\"#反向代理模型\" class=\"headerlink\" title=\"反向代理模型\"></a>反向代理模型</h3><p>在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。</p>\n<p>我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现<strong>非阻塞、高并发连接</strong>，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png\" alt=\"\"></p>\n<p>而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\\<readyasynccalls\\>对应 Nginx 的内部缓存</readyasynccalls\\></p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png\" alt=\"\"></p>\n<p>具体成员如下：</p>\n<ul>\n<li>maxRequests = 64：最大并发请求数为64</li>\n<li>maxRequestsPerHost = 5：每个主机最大请求数为5</li>\n<li>Dispatcher：分发者，也就是生产者（默认在主线程）</li>\n<li>AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）</li>\n<li>ExecutorService：消费者池（也就是线程池）</li>\n<li>Deque\\<readyasynccalls\\>：缓存（用数组实现，可自动扩容，无大小限制）</readyasynccalls\\></li>\n<li>Deque\\<runningasynccalls\\>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</runningasynccalls\\></li>\n</ul>\n<p>通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间</p>\n<h3 id=\"OkHttp-的任务调度\"><a href=\"#OkHttp-的任务调度\" class=\"headerlink\" title=\"OkHttp 的任务调度\"></a>OkHttp 的任务调度</h3><p>当我们使用 OkHttp 的异步请求时，一般进行如下构造：<br>    OkHttpClient client = new OkHttpClient.Builder().build();<br>    Request request = new Request.Builder()<br>        .url(“<a href=\"http://qq.com&quot;).get().build(\" target=\"_blank\" rel=\"external\">http://qq.com&quot;).get().build(</a>);<br>    client.newCall(request).enqueue(new Callback() {<br>      @Override public void onFailure(Call call, IOException e) {</p>\n<pre><code>  }\n\n  @Override public void onResponse(Call call, Response response) throws IOException {\n\n  }\n});\n</code></pre><p>当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作</p>\n<pre><code>synchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      //添加正在运行的请求\n    runningAsyncCalls.add(call);\n       //线程池执行请求\n    executorService().execute(call);\n  } else {\n      //添加到缓存队列\n    readyAsyncCalls.add(call);\n  }\n}\n</code></pre><p>可以发现请求是否进入缓存的条件如下：<br>    (runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)</p>\n<p>如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。</p>\n<p>我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：<br>    @Override protected void execute() {<br>      boolean signalledCallback = false;<br>      try {<br>          //执行耗时IO任务<br>        Response response = getResponseWithInterceptorChain(forWebSocket);<br>        if (canceled) {<br>          signalledCallback = true;<br>          //回调，注意这里回调是在线程池中，而不是想当然的主线程回调<br>          responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));<br>        } else {<br>          signalledCallback = true;<br>          //回调，同上<br>          responseCallback.onResponse(RealCall.this, response);<br>        }<br>      } catch (IOException e) {<br>        if (signalledCallback) {<br>          // Do not signal the callback twice!<br>          logger.log(Level.INFO, “Callback failure for “ + toLoggableString(), e);<br>        } else {<br>          responseCallback.onFailure(RealCall.this, e);<br>        }<br>      } finally {<br>          //最关键的代码<br>        client.dispatcher().finished(this);<br>      }<br>    }</p>\n<p>当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数<br>    private void promoteCalls() {<br>        //如果目前是最大负荷运转，接着等<br>      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.<br>      //如果缓存等待区是空的，接着等<br>      if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</p>\n<pre><code>  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n    AsyncCall call = i.next();\n\n    if (runningCallsForHost(call) &lt; maxRequestsPerHost) {\n        //将缓存等待区最后一个移动到运行区中，并执行\n      i.remove();\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    }\n\n    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.\n  }\n}\n</code></pre><p>这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>通过上述的分析，我们知道了：</p>\n<ol>\n<li>OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行</li>\n<li>OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出</li>\n<li>OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度</li>\n</ol>\n<p>摘自：<a href=\"http://www.jianshu.com/p/6637369d02e7\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/6637369d02e7</a></p>\n","excerpt":"","more":"<h3 id=\"本文目录\"><a href=\"#本文目录\" class=\"headerlink\" title=\"本文目录\"></a>本文目录</h3><ol>\n<li>线程池基础</li>\n<li>反向代理模块</li>\n<li>OkHttp 的任务调度</li>\n</ol>\n<p>OkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。</p>\n<h1 id=\"线程池基础\"><a href=\"#线程池基础\" class=\"headerlink\" title=\"线程池基础\"></a>线程池基础</h1><ol>\n<li>线程池好处有哪些<br>线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：</li>\n</ol>\n<p>多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：<br>如果一台服务完成一项任务的时间为 T</p>\n<pre><code>T1 创建线程的时间\nT2 在线程中执行任务的时间，包括线程间同步所需时间\nT3 线程销毁的时间\n</code></pre><p>显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。</p>\n<p>可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。</p>\n<p>线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。</p>\n<ul>\n<li>通过对线程缓存，减少创建和销毁的时间损失<ul>\n<li>通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力</li>\n</ul>\n</li>\n</ul>\n<p>在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了</p>\n<ol>\n<li>OkHttp 配置的线程池</li>\n</ol>\n<p>在 OkHttp 中，使用如下构造了单例线程池<br>    public synchronized ExecutorService executorService() {<br>      if (executorService == null) {<br>        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,<br>            new SynchronousQueue<Runnable>(), Util.threadFactory(“OkHttp Dispatcher”, false));<br>      }<br>      return executorService;<br>    }</p>\n<p>参数说明：</p>\n<ul>\n<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</li>\n<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃<em>处理机制</em>来处理</li>\n<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>\n<li>TimeUnit unit: 时间单位，一般用秒</li>\n<li>BlockingQueue\\<Runnable\\> workQueue:  工作队列</li>\n<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>\n</ul>\n<p>可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 “OkHttp Dispatcher” 的线程工厂。</p>\n<p>也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。</p>\n<blockquote>\n<p>在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers</p>\n</blockquote>\n<h3 id=\"反向代理模型\"><a href=\"#反向代理模型\" class=\"headerlink\" title=\"反向代理模型\"></a>反向代理模型</h3><p>在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。</p>\n<p>我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现<strong>非阻塞、高并发连接</strong>，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png\" alt=\"\"></p>\n<p>而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\\<readyAsyncCalls\\>对应 Nginx 的内部缓存</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png\" alt=\"\"></p>\n<p>具体成员如下：</p>\n<ul>\n<li>maxRequests = 64：最大并发请求数为64</li>\n<li>maxRequestsPerHost = 5：每个主机最大请求数为5</li>\n<li>Dispatcher：分发者，也就是生产者（默认在主线程）</li>\n<li>AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）</li>\n<li>ExecutorService：消费者池（也就是线程池）</li>\n<li>Deque\\<readyAsyncCalls\\>：缓存（用数组实现，可自动扩容，无大小限制）</li>\n<li>Deque\\<runningAsyncCalls\\>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</li>\n</ul>\n<p>通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间</p>\n<h3 id=\"OkHttp-的任务调度\"><a href=\"#OkHttp-的任务调度\" class=\"headerlink\" title=\"OkHttp 的任务调度\"></a>OkHttp 的任务调度</h3><p>当我们使用 OkHttp 的异步请求时，一般进行如下构造：<br>    OkHttpClient client = new OkHttpClient.Builder().build();<br>    Request request = new Request.Builder()<br>        .url(“<a href=\"http://qq.com&quot;).get().build(\">http://qq.com&quot;).get().build(</a>);<br>    client.newCall(request).enqueue(new Callback() {<br>      @Override public void onFailure(Call call, IOException e) {</p>\n<pre><code>  }\n\n  @Override public void onResponse(Call call, Response response) throws IOException {\n\n  }\n});\n</code></pre><p>当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作</p>\n<pre><code>synchronized void enqueue(AsyncCall call) {\n  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {\n      //添加正在运行的请求\n    runningAsyncCalls.add(call);\n       //线程池执行请求\n    executorService().execute(call);\n  } else {\n      //添加到缓存队列\n    readyAsyncCalls.add(call);\n  }\n}\n</code></pre><p>可以发现请求是否进入缓存的条件如下：<br>    (runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)</p>\n<p>如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。</p>\n<p>我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：<br>    @Override protected void execute() {<br>      boolean signalledCallback = false;<br>      try {<br>          //执行耗时IO任务<br>        Response response = getResponseWithInterceptorChain(forWebSocket);<br>        if (canceled) {<br>          signalledCallback = true;<br>          //回调，注意这里回调是在线程池中，而不是想当然的主线程回调<br>          responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));<br>        } else {<br>          signalledCallback = true;<br>          //回调，同上<br>          responseCallback.onResponse(RealCall.this, response);<br>        }<br>      } catch (IOException e) {<br>        if (signalledCallback) {<br>          // Do not signal the callback twice!<br>          logger.log(Level.INFO, “Callback failure for “ + toLoggableString(), e);<br>        } else {<br>          responseCallback.onFailure(RealCall.this, e);<br>        }<br>      } finally {<br>          //最关键的代码<br>        client.dispatcher().finished(this);<br>      }<br>    }</p>\n<p>当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数<br>    private void promoteCalls() {<br>        //如果目前是最大负荷运转，接着等<br>      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.<br>      //如果缓存等待区是空的，接着等<br>      if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</p>\n<pre><code>  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {\n    AsyncCall call = i.next();\n\n    if (runningCallsForHost(call) &lt; maxRequestsPerHost) {\n        //将缓存等待区最后一个移动到运行区中，并执行\n      i.remove();\n      runningAsyncCalls.add(call);\n      executorService().execute(call);\n    }\n\n    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.\n  }\n}\n</code></pre><p>这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>通过上述的分析，我们知道了：</p>\n<ol>\n<li>OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行</li>\n<li>OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出</li>\n<li>OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度</li>\n</ol>\n<p>摘自：<a href=\"http://www.jianshu.com/p/6637369d02e7\">http://www.jianshu.com/p/6637369d02e7</a></p>\n"},{"title":"分享Java Collection 的一张图","date":"2016-06-20T09:09:48.000Z","keywords":"Java","_content":" \n\n在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等\n\n我们可以看出他们之间的关系以及差别。\n\n例如：HashMap, HastTable,  Vector 和 LinkedList等\n\n\n![Java Collection Cheat Sheet](http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png)\n","source":"_posts/Java-Collection-Cheat-Sheet.md","raw":"title: 分享Java Collection 的一张图\ndate: 2016-06-20 17:09:48\ncategories: Java\nkeywords: Java\ntags: Java\n---\n \n\n在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等\n\n我们可以看出他们之间的关系以及差别。\n\n例如：HashMap, HastTable,  Vector 和 LinkedList等\n\n\n![Java Collection Cheat Sheet](http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png)\n","slug":"Java-Collection-Cheat-Sheet","published":1,"updated":"2016-06-20T10:18:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agb000txzextb2o5xr6","content":"<p>在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等</p>\n<p>我们可以看出他们之间的关系以及差别。</p>\n<p>例如：HashMap, HastTable,  Vector 和 LinkedList等</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png\" alt=\"Java Collection Cheat Sheet\"></p>\n","excerpt":"","more":"<p>在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等</p>\n<p>我们可以看出他们之间的关系以及差别。</p>\n<p>例如：HashMap, HastTable,  Vector 和 LinkedList等</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png\" alt=\"Java Collection Cheat Sheet\"></p>\n"},{"title":"RecyclerView的基类写法","date":"2015-11-17T03:01:47.000Z","keywords":null,"_content":"\n# RecyclerView的基类写法\n\n### KLBaseRecyclerAdapter\\<T\\> \n\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.LayoutInflater;\n\timport android.view.View;\n\timport android.view.ViewGroup;\n\n\timport java.util.ArrayList;\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/16.\n\t */\n\tpublic abstract class KLBaseRecyclerAdapter<T> extends RecyclerView.Adapter {\n\n\t    protected Context mContext;\n\t    protected LayoutInflater mInflater;\n\t    protected List<T> datas = new ArrayList<T>();\n\n\t    private View.OnClickListener onClickListener ;\n\n\t    public KLBaseRecyclerAdapter(Context context) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas = new ArrayList<T>();\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public KLBaseRecyclerAdapter(Context context, List<T> datas) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas.addAll(datas);\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public void setOnClickListener(View.OnClickListener onClickListener) {\n\t        this.onClickListener = onClickListener;\n\t    }\n\n\t    /**\n\t     * 加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void setData(List<T> datas) {\n\t        if (null != datas) {\n\t//            if (this.datas.size() > 0) {\n\t//                this.datas.clear();\n\t//            }\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    public List<T> getData() {\n\t        return this.datas;\n\t    }\n\n\t    public T getOneData(int potion) {\n\t        return datas.get(potion);\n\t    }\n\n\t    /**\n\t     * 上拉加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void addData(List<T> datas) {\n\t        if (null != datas) {\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    /**\n\t     * 清除数据源\n\t     */\n\t    public void clearData() {\n\t        if (datas != null) {\n\t            datas.clear();\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    @Override\n\t    public long getItemId(int position) {\n\t        return position;\n\t    }\n\n\t    @Override\n\t    public int getItemCount() {\n\t        return datas != null ? datas.size() : 0;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t        View view = mInflater.inflate(setConvertView(), parent, false);\n\t        return setViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n\t        onBindViewHolder((KLViewHolder)holder, position);\n\t    }\n\n\t    public abstract int setConvertView();\n\t    \n\t    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n\t    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n\t    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n\t        public KLViewHolder(View convertView) {\n\t            super(convertView);\n\n\t            initView(convertView);\n\n\t            if (onClickListener != null)\n\t                convertView.setOnClickListener(onClickListener);\n\t        }\n\n\t        abstract void initView(View convertView);\n\t    }\n\t}\n\n\n### 实现：\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.View;\n\timport android.widget.TextView;\n\n\timport com.zhuyongit.recyclerviewdemo.R;\n\timport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/17.\n\t */\n\tpublic class TestAdapter extends KLBaseRecyclerAdapter<NewsBean> {\n\n\t    public TestAdapter(Context context) {\n\t        super(context);\n\t    }\n\n\t    public TestAdapter(Context context, List<NewsBean> datas) {\n\t        super(context, datas);\n\t    }\n\n\t    @Override\n\t    public int setConvertView() {\n\t        return R.layout.grid_recycler_item_layout;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder setViewHolder(View view) {\n\t        return new ViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(KLViewHolder holder, int position) {\n\t        ViewHolder _viewHolder = (ViewHolder) holder;\n\t        NewsBean  _newsBean = getData().get(position);\n\t        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n\t        _viewHolder.tvContent.setText(_newsBean.getContent());\n\t    }\n\n\t    class ViewHolder extends KLViewHolder{\n\n\t        private TextView tvTitle ;\n\t        private TextView tvContent ;\n\n\t        public ViewHolder(View convertView) {\n\t            super(convertView);\n\t        }\n\n\t        @Override\n\t        void initView(View convertView) {\n\t            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n\t            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n\t        }\n\t    }\n\t}\n\n\t\n","source":"_posts/RecyclerView的基类写法.md","raw":"title: RecyclerView的基类写法\ndate: 2015-11-17 11:01:47\ncategories:\nkeywords:\ntags: android\n---\n\n# RecyclerView的基类写法\n\n### KLBaseRecyclerAdapter\\<T\\> \n\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.LayoutInflater;\n\timport android.view.View;\n\timport android.view.ViewGroup;\n\n\timport java.util.ArrayList;\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/16.\n\t */\n\tpublic abstract class KLBaseRecyclerAdapter<T> extends RecyclerView.Adapter {\n\n\t    protected Context mContext;\n\t    protected LayoutInflater mInflater;\n\t    protected List<T> datas = new ArrayList<T>();\n\n\t    private View.OnClickListener onClickListener ;\n\n\t    public KLBaseRecyclerAdapter(Context context) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas = new ArrayList<T>();\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public KLBaseRecyclerAdapter(Context context, List<T> datas) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas.addAll(datas);\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public void setOnClickListener(View.OnClickListener onClickListener) {\n\t        this.onClickListener = onClickListener;\n\t    }\n\n\t    /**\n\t     * 加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void setData(List<T> datas) {\n\t        if (null != datas) {\n\t//            if (this.datas.size() > 0) {\n\t//                this.datas.clear();\n\t//            }\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    public List<T> getData() {\n\t        return this.datas;\n\t    }\n\n\t    public T getOneData(int potion) {\n\t        return datas.get(potion);\n\t    }\n\n\t    /**\n\t     * 上拉加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void addData(List<T> datas) {\n\t        if (null != datas) {\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    /**\n\t     * 清除数据源\n\t     */\n\t    public void clearData() {\n\t        if (datas != null) {\n\t            datas.clear();\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    @Override\n\t    public long getItemId(int position) {\n\t        return position;\n\t    }\n\n\t    @Override\n\t    public int getItemCount() {\n\t        return datas != null ? datas.size() : 0;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t        View view = mInflater.inflate(setConvertView(), parent, false);\n\t        return setViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n\t        onBindViewHolder((KLViewHolder)holder, position);\n\t    }\n\n\t    public abstract int setConvertView();\n\t    \n\t    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n\t    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n\t    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n\t        public KLViewHolder(View convertView) {\n\t            super(convertView);\n\n\t            initView(convertView);\n\n\t            if (onClickListener != null)\n\t                convertView.setOnClickListener(onClickListener);\n\t        }\n\n\t        abstract void initView(View convertView);\n\t    }\n\t}\n\n\n### 实现：\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.View;\n\timport android.widget.TextView;\n\n\timport com.zhuyongit.recyclerviewdemo.R;\n\timport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/17.\n\t */\n\tpublic class TestAdapter extends KLBaseRecyclerAdapter<NewsBean> {\n\n\t    public TestAdapter(Context context) {\n\t        super(context);\n\t    }\n\n\t    public TestAdapter(Context context, List<NewsBean> datas) {\n\t        super(context, datas);\n\t    }\n\n\t    @Override\n\t    public int setConvertView() {\n\t        return R.layout.grid_recycler_item_layout;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder setViewHolder(View view) {\n\t        return new ViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(KLViewHolder holder, int position) {\n\t        ViewHolder _viewHolder = (ViewHolder) holder;\n\t        NewsBean  _newsBean = getData().get(position);\n\t        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n\t        _viewHolder.tvContent.setText(_newsBean.getContent());\n\t    }\n\n\t    class ViewHolder extends KLViewHolder{\n\n\t        private TextView tvTitle ;\n\t        private TextView tvContent ;\n\n\t        public ViewHolder(View convertView) {\n\t            super(convertView);\n\t        }\n\n\t        @Override\n\t        void initView(View convertView) {\n\t            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n\t            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n\t        }\n\t    }\n\t}\n\n\t\n","slug":"RecyclerView的基类写法","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agd000vxzexzu71bxr9","content":"<h1 id=\"RecyclerView的基类写法\"><a href=\"#RecyclerView的基类写法\" class=\"headerlink\" title=\"RecyclerView的基类写法\"></a>RecyclerView的基类写法</h1><h3 id=\"KLBaseRecyclerAdapter\"><a href=\"#KLBaseRecyclerAdapter\" class=\"headerlink\" title=\"KLBaseRecyclerAdapter\\\"></a>KLBaseRecyclerAdapter\\<t\\></t\\></h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/16.\n */\npublic abstract class KLBaseRecyclerAdapter&lt;T&gt; extends RecyclerView.Adapter {\n\n    protected Context mContext;\n    protected LayoutInflater mInflater;\n    protected List&lt;T&gt; datas = new ArrayList&lt;T&gt;();\n\n    private View.OnClickListener onClickListener ;\n\n    public KLBaseRecyclerAdapter(Context context) {\n        super();\n        this.mContext = context;\n        this.datas = new ArrayList&lt;T&gt;();\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public KLBaseRecyclerAdapter(Context context, List&lt;T&gt; datas) {\n        super();\n        this.mContext = context;\n        this.datas.addAll(datas);\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public void setOnClickListener(View.OnClickListener onClickListener) {\n        this.onClickListener = onClickListener;\n    }\n\n    /**\n     * 加载数据\n     *\n     * @param datas\n     */\n    public void setData(List&lt;T&gt; datas) {\n        if (null != datas) {\n//            if (this.datas.size() &gt; 0) {\n//                this.datas.clear();\n//            }\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    public List&lt;T&gt; getData() {\n        return this.datas;\n    }\n\n    public T getOneData(int potion) {\n        return datas.get(potion);\n    }\n\n    /**\n     * 上拉加载数据\n     *\n     * @param datas\n     */\n    public void addData(List&lt;T&gt; datas) {\n        if (null != datas) {\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    /**\n     * 清除数据源\n     */\n    public void clearData() {\n        if (datas != null) {\n            datas.clear();\n            notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public int getItemCount() {\n        return datas != null ? datas.size() : 0;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = mInflater.inflate(setConvertView(), parent, false);\n        return setViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        onBindViewHolder((KLViewHolder)holder, position);\n    }\n\n    public abstract int setConvertView();\n\n    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n        public KLViewHolder(View convertView) {\n            super(convertView);\n\n            initView(convertView);\n\n            if (onClickListener != null)\n                convertView.setOnClickListener(onClickListener);\n        }\n\n        abstract void initView(View convertView);\n    }\n}\n</code></pre><h3 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.widget.TextView;\n\nimport com.zhuyongit.recyclerviewdemo.R;\nimport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/17.\n */\npublic class TestAdapter extends KLBaseRecyclerAdapter&lt;NewsBean&gt; {\n\n    public TestAdapter(Context context) {\n        super(context);\n    }\n\n    public TestAdapter(Context context, List&lt;NewsBean&gt; datas) {\n        super(context, datas);\n    }\n\n    @Override\n    public int setConvertView() {\n        return R.layout.grid_recycler_item_layout;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder setViewHolder(View view) {\n        return new ViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(KLViewHolder holder, int position) {\n        ViewHolder _viewHolder = (ViewHolder) holder;\n        NewsBean  _newsBean = getData().get(position);\n        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n        _viewHolder.tvContent.setText(_newsBean.getContent());\n    }\n\n    class ViewHolder extends KLViewHolder{\n\n        private TextView tvTitle ;\n        private TextView tvContent ;\n\n        public ViewHolder(View convertView) {\n            super(convertView);\n        }\n\n        @Override\n        void initView(View convertView) {\n            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n        }\n    }\n}\n</code></pre>","excerpt":"","more":"<h1 id=\"RecyclerView的基类写法\"><a href=\"#RecyclerView的基类写法\" class=\"headerlink\" title=\"RecyclerView的基类写法\"></a>RecyclerView的基类写法</h1><h3 id=\"KLBaseRecyclerAdapter\"><a href=\"#KLBaseRecyclerAdapter\" class=\"headerlink\" title=\"KLBaseRecyclerAdapter\\\"></a>KLBaseRecyclerAdapter\\<T\\></h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/16.\n */\npublic abstract class KLBaseRecyclerAdapter&lt;T&gt; extends RecyclerView.Adapter {\n\n    protected Context mContext;\n    protected LayoutInflater mInflater;\n    protected List&lt;T&gt; datas = new ArrayList&lt;T&gt;();\n\n    private View.OnClickListener onClickListener ;\n\n    public KLBaseRecyclerAdapter(Context context) {\n        super();\n        this.mContext = context;\n        this.datas = new ArrayList&lt;T&gt;();\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public KLBaseRecyclerAdapter(Context context, List&lt;T&gt; datas) {\n        super();\n        this.mContext = context;\n        this.datas.addAll(datas);\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public void setOnClickListener(View.OnClickListener onClickListener) {\n        this.onClickListener = onClickListener;\n    }\n\n    /**\n     * 加载数据\n     *\n     * @param datas\n     */\n    public void setData(List&lt;T&gt; datas) {\n        if (null != datas) {\n//            if (this.datas.size() &gt; 0) {\n//                this.datas.clear();\n//            }\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    public List&lt;T&gt; getData() {\n        return this.datas;\n    }\n\n    public T getOneData(int potion) {\n        return datas.get(potion);\n    }\n\n    /**\n     * 上拉加载数据\n     *\n     * @param datas\n     */\n    public void addData(List&lt;T&gt; datas) {\n        if (null != datas) {\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    /**\n     * 清除数据源\n     */\n    public void clearData() {\n        if (datas != null) {\n            datas.clear();\n            notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public int getItemCount() {\n        return datas != null ? datas.size() : 0;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = mInflater.inflate(setConvertView(), parent, false);\n        return setViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        onBindViewHolder((KLViewHolder)holder, position);\n    }\n\n    public abstract int setConvertView();\n\n    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n        public KLViewHolder(View convertView) {\n            super(convertView);\n\n            initView(convertView);\n\n            if (onClickListener != null)\n                convertView.setOnClickListener(onClickListener);\n        }\n\n        abstract void initView(View convertView);\n    }\n}\n</code></pre><h3 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.widget.TextView;\n\nimport com.zhuyongit.recyclerviewdemo.R;\nimport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/17.\n */\npublic class TestAdapter extends KLBaseRecyclerAdapter&lt;NewsBean&gt; {\n\n    public TestAdapter(Context context) {\n        super(context);\n    }\n\n    public TestAdapter(Context context, List&lt;NewsBean&gt; datas) {\n        super(context, datas);\n    }\n\n    @Override\n    public int setConvertView() {\n        return R.layout.grid_recycler_item_layout;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder setViewHolder(View view) {\n        return new ViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(KLViewHolder holder, int position) {\n        ViewHolder _viewHolder = (ViewHolder) holder;\n        NewsBean  _newsBean = getData().get(position);\n        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n        _viewHolder.tvContent.setText(_newsBean.getContent());\n    }\n\n    class ViewHolder extends KLViewHolder{\n\n        private TextView tvTitle ;\n        private TextView tvContent ;\n\n        public ViewHolder(View convertView) {\n            super(convertView);\n        }\n\n        @Override\n        void initView(View convertView) {\n            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n        }\n    }\n}\n</code></pre>"},{"title":"Okio 简单处理I/O操作","date":"2016-06-20T08:59:24.000Z","keywords":"okio","_content":"\nAndroid 善用Okio简化处理I/O操作\nOkio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。\n\n\tcompile 'com.squareup.okio:okio:1.6.0'\n\nOhio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。\n![](http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png)\n\n它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；\n![](http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png)\n\nBufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。\n\n而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。 \n![](http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png)\n\n用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：\n\n\tpublic BufferedSink writeLong(long v) throws IOException {\n\t    if (this.closed) {\n\t        throw new IllegalStateException(\"closed\");\n\t    } else {\n\t        this.buffer.writeLong(v);\n\t        return this.emitCompleteSegments();\n\t    }\n\t}\n \n\n可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。\n\n\tpublic BufferedSink emitCompleteSegments() throws IOException {\n\t        if(this.closed) {\n\t            throw new IllegalStateException(\"closed\");\n\t        } else {\n\t            long byteCount = this.buffer.completeSegmentByteCount();\n\t            if(byteCount > 0L) {\n\t                this.sink.write(this.buffer, byteCount);\n\t            }\n\t            return this;\n\t        }\n\t    }\n\n这两个实现类的内部的所有方法都是类似的，这里不一一展开。\n而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。\n\n\tfinal class SegmentPool {\n\t    static final long MAX_SIZE = 65536L;\n\t    static Segment next;\n\t    static long byteCount;\n\t\n\t    private SegmentPool() {\n\t    }\n\t\n\t    static Segment take() {\n\t        Class var0 = SegmentPool.class;\n\t        \n\t        synchronized(SegmentPool.class) {\n\t            if(next != null) {\n\t                Segment result = next;\n\t                next = result.next;\n\t                result.next = null;\n\t                byteCount -= 2048L;\n\t                return result;\n\t            }\n\t        }\n\t        return new Segment();\n\t    }\n\t\n\t    static void recycle(Segment segment) {\n\t        if(segment.next == null && segment.prev == null) {\n\t            if(!segment.shared) {\n\t                Class var1 = SegmentPool.class;\n\t\n\t                synchronized(SegmentPool.class) {\n\t                    if(byteCount + 2048L <= 65536L) {\n\t                        byteCount += 2048L;\n\t                        segment.next = next;\n\t                        segment.pos = segment.limit = 0;\n\t                        next = segment;\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            throw new IllegalArgumentException();\n\t        }\n\t    }\n\t}\n\n内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。\n\n而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下\n\n\tOkio.buffer(sink)\n\tOkio.buffer(source)\n\n但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下\n\n\n\tOkio.sink(new File(\"***\"));\n\tOkio.sink(new FileOutputStream(new File(\"***\")));\n\tOkio.sink(new Socket(\"***\",8888));\n\t\n\tOkio.source(new File(\"***\"));\n\tOkio.source(new FileInputStream(new File(\"***\")));\n\tOkio.source(new Socket(\"****\",8888));\n\n这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。\n\n\tpublic static void main(String[] args) {\n\t        Source source = null;\n\t        BufferedSource bufferedSource = null;\n\t\n\t        try {\n\t            File file = new File(\"resources/test.txt\");\n\t            source = Okio.source(file);\n\t            bufferedSource = Okio.buffer(source);\n\t            String content = bufferedSource.readUtf8();\n\t            System.out.println(content);\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSource);\n\t        }\n\t\n\t        Sink sink = null;\n\t        BufferedSink bufferedSink = null;\n\t        try {\n\t            File dest = new File(\"resources/dest.txt\");\n\t            sink = Okio.sink(dest);\n\t            bufferedSink = Okio.buffer(sink);\n\t            bufferedSink.writeUtf8(\"11111111111\");\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSink);\n\t        }\n\t    }\n\t\n\t    public static void closeQuietly(Closeable closeable) {\n\t        if (closeable != null) {\n\t            try {\n\t                closeable.close();\n\t            } catch (RuntimeException rethrown) {\n\t                throw rethrown;\n\t            } catch (Exception ignored) {\n\t            }\n\t        }\n\t    }\n\t\n或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能\n\n\tpublic static void main(String[] args) {\n\t        Sink sink = null;\n\t        BufferedSink bufferedSink = null;\n\t        GzipSink gzipSink=null;\n\t\n\t        try {\n\t            File dest = new File(\"resources/gzip.txt\");\n\t            sink = Okio.sink(dest);\n\t            gzipSink=new GzipSink(sink);\n\t            bufferedSink = Okio.buffer(gzipSink);\n\t            bufferedSink.writeUtf8(\"android vs ios\");\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSink);\n\t        }\n\t\n\t        Source source = null;\n\t        BufferedSource bufferedSource = null;\n\t        GzipSource gzipSource=null;\n\t\n\t        try {\n\t            File file = new File(\"resources/gzip.txt\");\n\t            source = Okio.source(file);\n\t            gzipSource=new GzipSource(source);\n\t            bufferedSource = Okio.buffer(gzipSource);\n\t            String content = bufferedSource.readUtf8();\n\t            System.out.println(content);\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSource);\n\t        }\n\t    }\n\t\n\t    public static void closeQuietly(Closeable closeable) {\n\t        if (closeable != null) {\n\t            try {\n\t                closeable.close();\n\t            } catch (RuntimeException rethrown) {\n\t                throw rethrown;\n\t            } catch (Exception ignored) {\n\t            }\n\t        }\n\t    }\n\n验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。\n对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的\n\n\tpublic class GzipUtil {\n\t        /**\n\t         * GZIP压缩\n\t         *\n\t         * @param data\n\t         * @return\n\t         * @throws Exception\n\t         */\n\t        public static byte[] gzip(byte[] data) throws Exception {\n\t            if (data == null || data.length == 0) {\n\t                return null;\n\t            }\n\t            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t            GZIPOutputStream zos;\n\t            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));\n\t            byte[] buf = new byte[512];\n\t            int len;\n\t\n\t            try {\n\t                zos = new GZIPOutputStream(out);\n\t                while ((len = bis.read(buf)) != -1) {\n\t                    zos.write(buf, 0, len);\n\t                    zos.flush();\n\t                }\n\t                bis.close();\n\t                zos.close();\n\t                return out.toByteArray();\n\t            } finally {\n\t                if (out != null) {\n\t                    try {\n\t                        out.close();\n\t                    } catch (Exception e2) {\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Gzip解压缩\n\t         *\n\t         * @param b\n\t         * @return\n\t         */\n\t        public static byte[] unGzip(byte[] b) {\n\t            if (b == null || b.length == 0) {\n\t                return null;\n\t            }\n\t            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t            ByteArrayInputStream in = new ByteArrayInputStream(b);\n\t\n\t            try {\n\t                GZIPInputStream gunzip = new GZIPInputStream(in);\n\t                byte[] buffer = new byte[256];\n\t                int n;\n\t                while ((n = gunzip.read(buffer)) >= 0) {\n\t                    out.write(buffer, 0, n);\n\t                }\n\t                return out.toByteArray();\n\t            } catch (IOException e) {\n\t                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), \"uncompress error\", e);\n\t            } finally {\n\t                try {\n\t                    if (out != null) {\n\t                        out.close();\n\t                    }\n\t                    if (in != null) {\n\t                        in.close();\n\t                    }\n\t                } catch (Exception e2) {\n\t                }\n\t            }\n\t            return null;\n\t        }\n\t    }\n\n此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。\n\n在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/Okio-简单处理I-O操作.md","raw":"title: Okio 简单处理I/O操作\ndate: 2016-06-20 16:59:24\ncategories: okio\nkeywords: okio\ntags: okio\n---\n\nAndroid 善用Okio简化处理I/O操作\nOkio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。\n\n\tcompile 'com.squareup.okio:okio:1.6.0'\n\nOhio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。\n![](http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png)\n\n它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；\n![](http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png)\n\nBufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。\n\n而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。 \n![](http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png)\n\n用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：\n\n\tpublic BufferedSink writeLong(long v) throws IOException {\n\t    if (this.closed) {\n\t        throw new IllegalStateException(\"closed\");\n\t    } else {\n\t        this.buffer.writeLong(v);\n\t        return this.emitCompleteSegments();\n\t    }\n\t}\n \n\n可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。\n\n\tpublic BufferedSink emitCompleteSegments() throws IOException {\n\t        if(this.closed) {\n\t            throw new IllegalStateException(\"closed\");\n\t        } else {\n\t            long byteCount = this.buffer.completeSegmentByteCount();\n\t            if(byteCount > 0L) {\n\t                this.sink.write(this.buffer, byteCount);\n\t            }\n\t            return this;\n\t        }\n\t    }\n\n这两个实现类的内部的所有方法都是类似的，这里不一一展开。\n而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。\n\n\tfinal class SegmentPool {\n\t    static final long MAX_SIZE = 65536L;\n\t    static Segment next;\n\t    static long byteCount;\n\t\n\t    private SegmentPool() {\n\t    }\n\t\n\t    static Segment take() {\n\t        Class var0 = SegmentPool.class;\n\t        \n\t        synchronized(SegmentPool.class) {\n\t            if(next != null) {\n\t                Segment result = next;\n\t                next = result.next;\n\t                result.next = null;\n\t                byteCount -= 2048L;\n\t                return result;\n\t            }\n\t        }\n\t        return new Segment();\n\t    }\n\t\n\t    static void recycle(Segment segment) {\n\t        if(segment.next == null && segment.prev == null) {\n\t            if(!segment.shared) {\n\t                Class var1 = SegmentPool.class;\n\t\n\t                synchronized(SegmentPool.class) {\n\t                    if(byteCount + 2048L <= 65536L) {\n\t                        byteCount += 2048L;\n\t                        segment.next = next;\n\t                        segment.pos = segment.limit = 0;\n\t                        next = segment;\n\t                    }\n\t                }\n\t            }\n\t        } else {\n\t            throw new IllegalArgumentException();\n\t        }\n\t    }\n\t}\n\n内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。\n\n而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下\n\n\tOkio.buffer(sink)\n\tOkio.buffer(source)\n\n但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下\n\n\n\tOkio.sink(new File(\"***\"));\n\tOkio.sink(new FileOutputStream(new File(\"***\")));\n\tOkio.sink(new Socket(\"***\",8888));\n\t\n\tOkio.source(new File(\"***\"));\n\tOkio.source(new FileInputStream(new File(\"***\")));\n\tOkio.source(new Socket(\"****\",8888));\n\n这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。\n\n\tpublic static void main(String[] args) {\n\t        Source source = null;\n\t        BufferedSource bufferedSource = null;\n\t\n\t        try {\n\t            File file = new File(\"resources/test.txt\");\n\t            source = Okio.source(file);\n\t            bufferedSource = Okio.buffer(source);\n\t            String content = bufferedSource.readUtf8();\n\t            System.out.println(content);\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSource);\n\t        }\n\t\n\t        Sink sink = null;\n\t        BufferedSink bufferedSink = null;\n\t        try {\n\t            File dest = new File(\"resources/dest.txt\");\n\t            sink = Okio.sink(dest);\n\t            bufferedSink = Okio.buffer(sink);\n\t            bufferedSink.writeUtf8(\"11111111111\");\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSink);\n\t        }\n\t    }\n\t\n\t    public static void closeQuietly(Closeable closeable) {\n\t        if (closeable != null) {\n\t            try {\n\t                closeable.close();\n\t            } catch (RuntimeException rethrown) {\n\t                throw rethrown;\n\t            } catch (Exception ignored) {\n\t            }\n\t        }\n\t    }\n\t\n或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能\n\n\tpublic static void main(String[] args) {\n\t        Sink sink = null;\n\t        BufferedSink bufferedSink = null;\n\t        GzipSink gzipSink=null;\n\t\n\t        try {\n\t            File dest = new File(\"resources/gzip.txt\");\n\t            sink = Okio.sink(dest);\n\t            gzipSink=new GzipSink(sink);\n\t            bufferedSink = Okio.buffer(gzipSink);\n\t            bufferedSink.writeUtf8(\"android vs ios\");\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSink);\n\t        }\n\t\n\t        Source source = null;\n\t        BufferedSource bufferedSource = null;\n\t        GzipSource gzipSource=null;\n\t\n\t        try {\n\t            File file = new File(\"resources/gzip.txt\");\n\t            source = Okio.source(file);\n\t            gzipSource=new GzipSource(source);\n\t            bufferedSource = Okio.buffer(gzipSource);\n\t            String content = bufferedSource.readUtf8();\n\t            System.out.println(content);\n\t        } catch (FileNotFoundException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } finally {\n\t            closeQuietly(bufferedSource);\n\t        }\n\t    }\n\t\n\t    public static void closeQuietly(Closeable closeable) {\n\t        if (closeable != null) {\n\t            try {\n\t                closeable.close();\n\t            } catch (RuntimeException rethrown) {\n\t                throw rethrown;\n\t            } catch (Exception ignored) {\n\t            }\n\t        }\n\t    }\n\n验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。\n对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的\n\n\tpublic class GzipUtil {\n\t        /**\n\t         * GZIP压缩\n\t         *\n\t         * @param data\n\t         * @return\n\t         * @throws Exception\n\t         */\n\t        public static byte[] gzip(byte[] data) throws Exception {\n\t            if (data == null || data.length == 0) {\n\t                return null;\n\t            }\n\t            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t            GZIPOutputStream zos;\n\t            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));\n\t            byte[] buf = new byte[512];\n\t            int len;\n\t\n\t            try {\n\t                zos = new GZIPOutputStream(out);\n\t                while ((len = bis.read(buf)) != -1) {\n\t                    zos.write(buf, 0, len);\n\t                    zos.flush();\n\t                }\n\t                bis.close();\n\t                zos.close();\n\t                return out.toByteArray();\n\t            } finally {\n\t                if (out != null) {\n\t                    try {\n\t                        out.close();\n\t                    } catch (Exception e2) {\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Gzip解压缩\n\t         *\n\t         * @param b\n\t         * @return\n\t         */\n\t        public static byte[] unGzip(byte[] b) {\n\t            if (b == null || b.length == 0) {\n\t                return null;\n\t            }\n\t            ByteArrayOutputStream out = new ByteArrayOutputStream();\n\t            ByteArrayInputStream in = new ByteArrayInputStream(b);\n\t\n\t            try {\n\t                GZIPInputStream gunzip = new GZIPInputStream(in);\n\t                byte[] buffer = new byte[256];\n\t                int n;\n\t                while ((n = gunzip.read(buffer)) >= 0) {\n\t                    out.write(buffer, 0, n);\n\t                }\n\t                return out.toByteArray();\n\t            } catch (IOException e) {\n\t                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), \"uncompress error\", e);\n\t            } finally {\n\t                try {\n\t                    if (out != null) {\n\t                        out.close();\n\t                    }\n\t                    if (in != null) {\n\t                        in.close();\n\t                    }\n\t                } catch (Exception e2) {\n\t                }\n\t            }\n\t            return null;\n\t        }\n\t    }\n\n此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。\n\n在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Okio-简单处理I-O操作","published":1,"updated":"2016-06-20T10:18:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agg000xxzexb7imz0c9","content":"<p>Android 善用Okio简化处理I/O操作<br>Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。</p>\n<pre><code>compile &apos;com.squareup.okio:okio:1.6.0&apos;\n</code></pre><p>Ohio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png\" alt=\"\"></p>\n<p>它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png\" alt=\"\"></p>\n<p>BufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。</p>\n<p>而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png\" alt=\"\"></p>\n<p>用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：</p>\n<pre><code>public BufferedSink writeLong(long v) throws IOException {\n    if (this.closed) {\n        throw new IllegalStateException(&quot;closed&quot;);\n    } else {\n        this.buffer.writeLong(v);\n        return this.emitCompleteSegments();\n    }\n}\n</code></pre><p>可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。</p>\n<pre><code>public BufferedSink emitCompleteSegments() throws IOException {\n        if(this.closed) {\n            throw new IllegalStateException(&quot;closed&quot;);\n        } else {\n            long byteCount = this.buffer.completeSegmentByteCount();\n            if(byteCount &gt; 0L) {\n                this.sink.write(this.buffer, byteCount);\n            }\n            return this;\n        }\n    }\n</code></pre><p>这两个实现类的内部的所有方法都是类似的，这里不一一展开。<br>而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。</p>\n<pre><code>final class SegmentPool {\n    static final long MAX_SIZE = 65536L;\n    static Segment next;\n    static long byteCount;\n\n    private SegmentPool() {\n    }\n\n    static Segment take() {\n        Class var0 = SegmentPool.class;\n\n        synchronized(SegmentPool.class) {\n            if(next != null) {\n                Segment result = next;\n                next = result.next;\n                result.next = null;\n                byteCount -= 2048L;\n                return result;\n            }\n        }\n        return new Segment();\n    }\n\n    static void recycle(Segment segment) {\n        if(segment.next == null &amp;&amp; segment.prev == null) {\n            if(!segment.shared) {\n                Class var1 = SegmentPool.class;\n\n                synchronized(SegmentPool.class) {\n                    if(byteCount + 2048L &lt;= 65536L) {\n                        byteCount += 2048L;\n                        segment.next = next;\n                        segment.pos = segment.limit = 0;\n                        next = segment;\n                    }\n                }\n            }\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n</code></pre><p>内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。</p>\n<p>而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下</p>\n<pre><code>Okio.buffer(sink)\nOkio.buffer(source)\n</code></pre><p>但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下</p>\n<pre><code>Okio.sink(new File(&quot;***&quot;));\nOkio.sink(new FileOutputStream(new File(&quot;***&quot;)));\nOkio.sink(new Socket(&quot;***&quot;,8888));\n\nOkio.source(new File(&quot;***&quot;));\nOkio.source(new FileInputStream(new File(&quot;***&quot;)));\nOkio.source(new Socket(&quot;****&quot;,8888));\n</code></pre><p>这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。</p>\n<pre><code>public static void main(String[] args) {\n        Source source = null;\n        BufferedSource bufferedSource = null;\n\n        try {\n            File file = new File(&quot;resources/test.txt&quot;);\n            source = Okio.source(file);\n            bufferedSource = Okio.buffer(source);\n            String content = bufferedSource.readUtf8();\n            System.out.println(content);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSource);\n        }\n\n        Sink sink = null;\n        BufferedSink bufferedSink = null;\n        try {\n            File dest = new File(&quot;resources/dest.txt&quot;);\n            sink = Okio.sink(dest);\n            bufferedSink = Okio.buffer(sink);\n            bufferedSink.writeUtf8(&quot;11111111111&quot;);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSink);\n        }\n    }\n\n    public static void closeQuietly(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (RuntimeException rethrown) {\n                throw rethrown;\n            } catch (Exception ignored) {\n            }\n        }\n    }\n</code></pre><p>或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能</p>\n<pre><code>public static void main(String[] args) {\n        Sink sink = null;\n        BufferedSink bufferedSink = null;\n        GzipSink gzipSink=null;\n\n        try {\n            File dest = new File(&quot;resources/gzip.txt&quot;);\n            sink = Okio.sink(dest);\n            gzipSink=new GzipSink(sink);\n            bufferedSink = Okio.buffer(gzipSink);\n            bufferedSink.writeUtf8(&quot;android vs ios&quot;);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSink);\n        }\n\n        Source source = null;\n        BufferedSource bufferedSource = null;\n        GzipSource gzipSource=null;\n\n        try {\n            File file = new File(&quot;resources/gzip.txt&quot;);\n            source = Okio.source(file);\n            gzipSource=new GzipSource(source);\n            bufferedSource = Okio.buffer(gzipSource);\n            String content = bufferedSource.readUtf8();\n            System.out.println(content);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSource);\n        }\n    }\n\n    public static void closeQuietly(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (RuntimeException rethrown) {\n                throw rethrown;\n            } catch (Exception ignored) {\n            }\n        }\n    }\n</code></pre><p>验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。<br>对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的</p>\n<pre><code>public class GzipUtil {\n        /**\n         * GZIP压缩\n         *\n         * @param data\n         * @return\n         * @throws Exception\n         */\n        public static byte[] gzip(byte[] data) throws Exception {\n            if (data == null || data.length == 0) {\n                return null;\n            }\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            GZIPOutputStream zos;\n            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));\n            byte[] buf = new byte[512];\n            int len;\n\n            try {\n                zos = new GZIPOutputStream(out);\n                while ((len = bis.read(buf)) != -1) {\n                    zos.write(buf, 0, len);\n                    zos.flush();\n                }\n                bis.close();\n                zos.close();\n                return out.toByteArray();\n            } finally {\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (Exception e2) {\n                    }\n                }\n            }\n        }\n\n        /**\n         * Gzip解压缩\n         *\n         * @param b\n         * @return\n         */\n        public static byte[] unGzip(byte[] b) {\n            if (b == null || b.length == 0) {\n                return null;\n            }\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            ByteArrayInputStream in = new ByteArrayInputStream(b);\n\n            try {\n                GZIPInputStream gunzip = new GZIPInputStream(in);\n                byte[] buffer = new byte[256];\n                int n;\n                while ((n = gunzip.read(buffer)) &gt;= 0) {\n                    out.write(buffer, 0, n);\n                }\n                return out.toByteArray();\n            } catch (IOException e) {\n                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), &quot;uncompress error&quot;, e);\n            } finally {\n                try {\n                    if (out != null) {\n                        out.close();\n                    }\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (Exception e2) {\n                }\n            }\n            return null;\n        }\n    }\n</code></pre><p>此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。</p>\n<p>在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。</p>\n","excerpt":"","more":"<p>Android 善用Okio简化处理I/O操作<br>Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。</p>\n<pre><code>compile &apos;com.squareup.okio:okio:1.6.0&apos;\n</code></pre><p>Ohio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png\" alt=\"\"></p>\n<p>它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png\" alt=\"\"></p>\n<p>BufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。</p>\n<p>而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png\" alt=\"\"></p>\n<p>用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：</p>\n<pre><code>public BufferedSink writeLong(long v) throws IOException {\n    if (this.closed) {\n        throw new IllegalStateException(&quot;closed&quot;);\n    } else {\n        this.buffer.writeLong(v);\n        return this.emitCompleteSegments();\n    }\n}\n</code></pre><p>可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。</p>\n<pre><code>public BufferedSink emitCompleteSegments() throws IOException {\n        if(this.closed) {\n            throw new IllegalStateException(&quot;closed&quot;);\n        } else {\n            long byteCount = this.buffer.completeSegmentByteCount();\n            if(byteCount &gt; 0L) {\n                this.sink.write(this.buffer, byteCount);\n            }\n            return this;\n        }\n    }\n</code></pre><p>这两个实现类的内部的所有方法都是类似的，这里不一一展开。<br>而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。</p>\n<pre><code>final class SegmentPool {\n    static final long MAX_SIZE = 65536L;\n    static Segment next;\n    static long byteCount;\n\n    private SegmentPool() {\n    }\n\n    static Segment take() {\n        Class var0 = SegmentPool.class;\n\n        synchronized(SegmentPool.class) {\n            if(next != null) {\n                Segment result = next;\n                next = result.next;\n                result.next = null;\n                byteCount -= 2048L;\n                return result;\n            }\n        }\n        return new Segment();\n    }\n\n    static void recycle(Segment segment) {\n        if(segment.next == null &amp;&amp; segment.prev == null) {\n            if(!segment.shared) {\n                Class var1 = SegmentPool.class;\n\n                synchronized(SegmentPool.class) {\n                    if(byteCount + 2048L &lt;= 65536L) {\n                        byteCount += 2048L;\n                        segment.next = next;\n                        segment.pos = segment.limit = 0;\n                        next = segment;\n                    }\n                }\n            }\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n}\n</code></pre><p>内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。</p>\n<p>而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下</p>\n<pre><code>Okio.buffer(sink)\nOkio.buffer(source)\n</code></pre><p>但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下</p>\n<pre><code>Okio.sink(new File(&quot;***&quot;));\nOkio.sink(new FileOutputStream(new File(&quot;***&quot;)));\nOkio.sink(new Socket(&quot;***&quot;,8888));\n\nOkio.source(new File(&quot;***&quot;));\nOkio.source(new FileInputStream(new File(&quot;***&quot;)));\nOkio.source(new Socket(&quot;****&quot;,8888));\n</code></pre><p>这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。</p>\n<pre><code>public static void main(String[] args) {\n        Source source = null;\n        BufferedSource bufferedSource = null;\n\n        try {\n            File file = new File(&quot;resources/test.txt&quot;);\n            source = Okio.source(file);\n            bufferedSource = Okio.buffer(source);\n            String content = bufferedSource.readUtf8();\n            System.out.println(content);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSource);\n        }\n\n        Sink sink = null;\n        BufferedSink bufferedSink = null;\n        try {\n            File dest = new File(&quot;resources/dest.txt&quot;);\n            sink = Okio.sink(dest);\n            bufferedSink = Okio.buffer(sink);\n            bufferedSink.writeUtf8(&quot;11111111111&quot;);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSink);\n        }\n    }\n\n    public static void closeQuietly(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (RuntimeException rethrown) {\n                throw rethrown;\n            } catch (Exception ignored) {\n            }\n        }\n    }\n</code></pre><p>或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能</p>\n<pre><code>public static void main(String[] args) {\n        Sink sink = null;\n        BufferedSink bufferedSink = null;\n        GzipSink gzipSink=null;\n\n        try {\n            File dest = new File(&quot;resources/gzip.txt&quot;);\n            sink = Okio.sink(dest);\n            gzipSink=new GzipSink(sink);\n            bufferedSink = Okio.buffer(gzipSink);\n            bufferedSink.writeUtf8(&quot;android vs ios&quot;);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSink);\n        }\n\n        Source source = null;\n        BufferedSource bufferedSource = null;\n        GzipSource gzipSource=null;\n\n        try {\n            File file = new File(&quot;resources/gzip.txt&quot;);\n            source = Okio.source(file);\n            gzipSource=new GzipSource(source);\n            bufferedSource = Okio.buffer(gzipSource);\n            String content = bufferedSource.readUtf8();\n            System.out.println(content);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            closeQuietly(bufferedSource);\n        }\n    }\n\n    public static void closeQuietly(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (RuntimeException rethrown) {\n                throw rethrown;\n            } catch (Exception ignored) {\n            }\n        }\n    }\n</code></pre><p>验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。<br>对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的</p>\n<pre><code>public class GzipUtil {\n        /**\n         * GZIP压缩\n         *\n         * @param data\n         * @return\n         * @throws Exception\n         */\n        public static byte[] gzip(byte[] data) throws Exception {\n            if (data == null || data.length == 0) {\n                return null;\n            }\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            GZIPOutputStream zos;\n            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));\n            byte[] buf = new byte[512];\n            int len;\n\n            try {\n                zos = new GZIPOutputStream(out);\n                while ((len = bis.read(buf)) != -1) {\n                    zos.write(buf, 0, len);\n                    zos.flush();\n                }\n                bis.close();\n                zos.close();\n                return out.toByteArray();\n            } finally {\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (Exception e2) {\n                    }\n                }\n            }\n        }\n\n        /**\n         * Gzip解压缩\n         *\n         * @param b\n         * @return\n         */\n        public static byte[] unGzip(byte[] b) {\n            if (b == null || b.length == 0) {\n                return null;\n            }\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            ByteArrayInputStream in = new ByteArrayInputStream(b);\n\n            try {\n                GZIPInputStream gunzip = new GZIPInputStream(in);\n                byte[] buffer = new byte[256];\n                int n;\n                while ((n = gunzip.read(buffer)) &gt;= 0) {\n                    out.write(buffer, 0, n);\n                }\n                return out.toByteArray();\n            } catch (IOException e) {\n                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), &quot;uncompress error&quot;, e);\n            } finally {\n                try {\n                    if (out != null) {\n                        out.close();\n                    }\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (Exception e2) {\n                }\n            }\n            return null;\n        }\n    }\n</code></pre><p>此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。</p>\n<p>在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。</p>\n"},{"title":"monkey 测试命令，保存到SD，遇到崩溃继续","date":"2015-09-19T11:16:05.000Z","keywords":"android,monkey,adb","_content":"\n\n### 开始测试：\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v 600000>/mnt/sdcard/monkey1.txt & \n```\n\n### 保存monkey 和 logcat 的日志\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v -v 15000000>>/mnt/sdcard/monkey_kaola.txt & logcat  -v time >>/mnt/sdcard/logcat.txt\n```\n\n### 终止：\n\n```\nadb shell\nps|grep monkey\nkill id\n```\n\n###### adb logcat -s com.xx.xx","source":"_posts/android-monkey.md","raw":"title: monkey 测试命令，保存到SD，遇到崩溃继续\ndate: 2015-09-19 19:16:05\ncategories: android\nkeywords: android,monkey,adb\ntags: android\n---\n\n\n### 开始测试：\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v 600000>/mnt/sdcard/monkey1.txt & \n```\n\n### 保存monkey 和 logcat 的日志\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v -v 15000000>>/mnt/sdcard/monkey_kaola.txt & logcat  -v time >>/mnt/sdcard/logcat.txt\n```\n\n### 终止：\n\n```\nadb shell\nps|grep monkey\nkill id\n```\n\n###### adb logcat -s com.xx.xx","slug":"android-monkey","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agj0011xzex8yisz7gl","content":"<h3 id=\"开始测试：\"><a href=\"#开始测试：\" class=\"headerlink\" title=\"开始测试：\"></a>开始测试：</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v <span class=\"number\">600000</span>&gt;/mnt/sdcard/monkey1<span class=\"selector-class\">.txt</span> &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存monkey-和-logcat-的日志\"><a href=\"#保存monkey-和-logcat-的日志\" class=\"headerlink\" title=\"保存monkey 和 logcat 的日志\"></a>保存monkey 和 logcat 的日志</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v -v <span class=\"number\">15000000</span>&gt;&gt;/mnt/sdcard/monkey_kaola<span class=\"selector-class\">.txt</span> &amp; logcat  -v <span class=\"selector-tag\">time</span> &gt;&gt;/mnt/sdcard/logcat.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"终止：\"><a href=\"#终止：\" class=\"headerlink\" title=\"终止：\"></a>终止：</h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb <span class=\"keyword\">shell</span></span><br><span class=\"line\"><span class=\"keyword\">ps</span>|<span class=\"keyword\">grep</span> monkey</span><br><span class=\"line\">kill id</span><br></pre></td></tr></table></figure>\n<h6 id=\"adb-logcat-s-com-xx-xx\"><a href=\"#adb-logcat-s-com-xx-xx\" class=\"headerlink\" title=\"adb logcat -s com.xx.xx\"></a>adb logcat -s com.xx.xx</h6>","excerpt":"","more":"<h3 id=\"开始测试：\"><a href=\"#开始测试：\" class=\"headerlink\" title=\"开始测试：\"></a>开始测试：</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v <span class=\"number\">600000</span>&gt;/mnt/sdcard/monkey1<span class=\"selector-class\">.txt</span> &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存monkey-和-logcat-的日志\"><a href=\"#保存monkey-和-logcat-的日志\" class=\"headerlink\" title=\"保存monkey 和 logcat 的日志\"></a>保存monkey 和 logcat 的日志</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v -v <span class=\"number\">15000000</span>&gt;&gt;/mnt/sdcard/monkey_kaola<span class=\"selector-class\">.txt</span> &amp; logcat  -v <span class=\"selector-tag\">time</span> &gt;&gt;/mnt/sdcard/logcat.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"终止：\"><a href=\"#终止：\" class=\"headerlink\" title=\"终止：\"></a>终止：</h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb <span class=\"keyword\">shell</span></span><br><span class=\"line\"><span class=\"keyword\">ps</span>|<span class=\"keyword\">grep</span> monkey</span><br><span class=\"line\">kill id</span><br></pre></td></tr></table></figure>\n<h6 id=\"adb-logcat-s-com-xx-xx\"><a href=\"#adb-logcat-s-com-xx-xx\" class=\"headerlink\" title=\"adb logcat -s com.xx.xx\"></a>adb logcat -s com.xx.xx</h6>"},{"title":"从 volley 切换到 OkHttp 遇到的坑","date":"2016-06-20T10:17:30.000Z","keywords":"okhttp3","_content":"\n这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。\n\n之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.\n\n### 代理异常？\n切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。\n\n根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 \n\n之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？\n\n经过对比后发现：原来是 之前写 volley 的时候是这样的：\n\n\t\tHttpURLConnection connection;\n\t        if (\"https\".equals(url.getProtocol())) {\n\t            Proxy proxy = new Proxy(Proxy.Type.HTTP,\n\t                    InetSocketAddress\n\t                            .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));\n\t            connection = (HttpURLConnection) url\n\t                    .openConnection(proxy);\n\t            connection.addRequestProperty(\"Proxy-Authorization\",\n\t                    \"Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6\");\n\t        } else {\n\t            Proxy proxy = new Proxy(Proxy.Type.HTTP,\n\t                    InetSocketAddress\n\t                            .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));\n\t            connection = (HttpURLConnection) url\n\t                    .openConnection(proxy);\n\t            connection.addRequestProperty(\"Authorization\",\n\t                    \"Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6\");\n\t        }\n\t        connection.addRequestProperty(\"Proxy-Connection\", \"Keep-Alive\");\n\n主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。\n\n但是在 okhttp 里面貌似是不需要区分的。只需要这样写：\n\n\t/**\n\t     * 设置联通流量 代理功能\n\t     * @param builder\n\t     */\n\t    private void setUnicomProxy(OkHttpClient.Builder builder) {\n\t        //添加联通代理功能\n\t        if (TrafficUtil.getUnicomProxyAvailable()) {\n\t            Authenticator proxyAuthenticator = new Authenticator() {\n\t                @Override\n\t                public okhttp3.Request authenticate(Route route, Response response) throws IOException {\n\t                    return response.request().newBuilder().header(\"Proxy-Authorization\", \"Basic \" +\n\t                            \"MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6\").header(\"Proxy-Connection\",\n\t                            \"Keep-Alive\").build();\n\t                }\n\t            };\n\t\n\t            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,\n\t                    FLOWPACKAGETCPPORT)));\n\t            builder.proxyAuthenticator(proxyAuthenticator);\n\t        }\n\t    }\n\n就可以了。\n` FLOWPACKAGEHOST -> test.proxy.1111.com (这是域名)`\n` FLOWPACKAGETCPPORT -> 8143\n`\n这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。\n\n`备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈`\n\n### SSL/STL证书 出错？\n这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：\n\n\t\t@NonNull\n\t    private SSLContext getSslContext(InputStream... certificates) {\n\t        SSLContext sslContext = null;\n\t\n\t        try {\n\t            CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n\t            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\t            keyStore.load(null);\n\t            int index = 0;\n\t            for (InputStream certificate : certificates) {\n\t                String certificateAlias = Integer.toString(index++);\n\t                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate\n\t                        (certificate));\n\t                try {\n\t                    if (certificate != null)\n\t                        certificate.close();\n\t                } catch (IOException e) {\n\t                    e.printStackTrace();\n\t                }\n\t            }\n\t\n\t            sslContext = SSLContext.getInstance(\"TLS\");\n\t\n\t            TrustManagerFactory trustManagerFactory =\n\t                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\t\n\t            trustManagerFactory.init(keyStore);\n\t            sslContext.init(null, trustManagerFactory.getTrustManagers(),\n\t                    new SecureRandom());\n\t\n\t        } catch (KeyStoreException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } catch (NoSuchAlgorithmException e) {\n\t            e.printStackTrace();\n\t        } catch (KeyManagementException e) {\n\t            e.printStackTrace();\n\t        } catch (Exception e){\n\t            e.printStackTrace();\n\t        }   finally {\n\t        }\n\t\n\t        return sslContext;\n\t    }\n\n\t/**\n\t     * 启用 OkHttps 域名校验功能\n\t     * @param builder\n\t     */\n\t    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {\n\t        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R\n\t                .raw.kl_magic));\n\t\n\t        if (sslContext != null) {\n\t            builder.hostnameVerifier(new HostnameVerifier() {\n\t                @Override\n\t                public boolean verify(String hostname, SSLSession session) {\n\t                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();\n\t                    return hostnameVerifier.verify(\"xxx.com\", session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)\n\t                }\n\t            });\n\t            builder.sslSocketFactory(sslContext.getSocketFactory());\n\t        }\n\t    }\n\n这句是非常重要的：\n`hostnameVerifier.verify(\"xxx.com\", session);  \n`主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。\n\n之前尝试过使用 使用\n\tbuilder.hostnameVerifier(new AllowAllHostnameVerifier());\n\n这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。\n\n### post 参数不能为空？\n这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).\n\n但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 [okhttp issue](https://github.com/square/okhttp/issues/751) 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。\n\n具体参考这个：\n\n\tpublic void addRequest(int method, final Map<String, String> params, final String baseUrl,\n\t                           final TypeReference<? extends BaseResponse> type, final JsonResultCallback callback) {\n\t\t\t\t......\n\t          if (params.size() == 0 && method == Request.Method.POST)\n\t            params.put(\"temp\", \"temp\"); //解决 method POST must have a request body.;\n\t\t\t\t......\n\t}\n\n这三个问题解决后，基本就可以放心使用了。","source":"_posts/从-volley-切换到-OkHttp-遇到的坑.md","raw":"title: 从 volley 切换到 OkHttp 遇到的坑\ndate: 2016-06-20 18:17:30\ncategories: okhttp3\nkeywords: okhttp3\ntags: okhttp3\n---\n\n这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。\n\n之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.\n\n### 代理异常？\n切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。\n\n根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 \n\n之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？\n\n经过对比后发现：原来是 之前写 volley 的时候是这样的：\n\n\t\tHttpURLConnection connection;\n\t        if (\"https\".equals(url.getProtocol())) {\n\t            Proxy proxy = new Proxy(Proxy.Type.HTTP,\n\t                    InetSocketAddress\n\t                            .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));\n\t            connection = (HttpURLConnection) url\n\t                    .openConnection(proxy);\n\t            connection.addRequestProperty(\"Proxy-Authorization\",\n\t                    \"Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6\");\n\t        } else {\n\t            Proxy proxy = new Proxy(Proxy.Type.HTTP,\n\t                    InetSocketAddress\n\t                            .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));\n\t            connection = (HttpURLConnection) url\n\t                    .openConnection(proxy);\n\t            connection.addRequestProperty(\"Authorization\",\n\t                    \"Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6\");\n\t        }\n\t        connection.addRequestProperty(\"Proxy-Connection\", \"Keep-Alive\");\n\n主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。\n\n但是在 okhttp 里面貌似是不需要区分的。只需要这样写：\n\n\t/**\n\t     * 设置联通流量 代理功能\n\t     * @param builder\n\t     */\n\t    private void setUnicomProxy(OkHttpClient.Builder builder) {\n\t        //添加联通代理功能\n\t        if (TrafficUtil.getUnicomProxyAvailable()) {\n\t            Authenticator proxyAuthenticator = new Authenticator() {\n\t                @Override\n\t                public okhttp3.Request authenticate(Route route, Response response) throws IOException {\n\t                    return response.request().newBuilder().header(\"Proxy-Authorization\", \"Basic \" +\n\t                            \"MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6\").header(\"Proxy-Connection\",\n\t                            \"Keep-Alive\").build();\n\t                }\n\t            };\n\t\n\t            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,\n\t                    FLOWPACKAGETCPPORT)));\n\t            builder.proxyAuthenticator(proxyAuthenticator);\n\t        }\n\t    }\n\n就可以了。\n` FLOWPACKAGEHOST -> test.proxy.1111.com (这是域名)`\n` FLOWPACKAGETCPPORT -> 8143\n`\n这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。\n\n`备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈`\n\n### SSL/STL证书 出错？\n这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：\n\n\t\t@NonNull\n\t    private SSLContext getSslContext(InputStream... certificates) {\n\t        SSLContext sslContext = null;\n\t\n\t        try {\n\t            CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n\t            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n\t            keyStore.load(null);\n\t            int index = 0;\n\t            for (InputStream certificate : certificates) {\n\t                String certificateAlias = Integer.toString(index++);\n\t                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate\n\t                        (certificate));\n\t                try {\n\t                    if (certificate != null)\n\t                        certificate.close();\n\t                } catch (IOException e) {\n\t                    e.printStackTrace();\n\t                }\n\t            }\n\t\n\t            sslContext = SSLContext.getInstance(\"TLS\");\n\t\n\t            TrustManagerFactory trustManagerFactory =\n\t                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\t\n\t            trustManagerFactory.init(keyStore);\n\t            sslContext.init(null, trustManagerFactory.getTrustManagers(),\n\t                    new SecureRandom());\n\t\n\t        } catch (KeyStoreException e) {\n\t            e.printStackTrace();\n\t        } catch (IOException e) {\n\t            e.printStackTrace();\n\t        } catch (NoSuchAlgorithmException e) {\n\t            e.printStackTrace();\n\t        } catch (KeyManagementException e) {\n\t            e.printStackTrace();\n\t        } catch (Exception e){\n\t            e.printStackTrace();\n\t        }   finally {\n\t        }\n\t\n\t        return sslContext;\n\t    }\n\n\t/**\n\t     * 启用 OkHttps 域名校验功能\n\t     * @param builder\n\t     */\n\t    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {\n\t        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R\n\t                .raw.kl_magic));\n\t\n\t        if (sslContext != null) {\n\t            builder.hostnameVerifier(new HostnameVerifier() {\n\t                @Override\n\t                public boolean verify(String hostname, SSLSession session) {\n\t                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();\n\t                    return hostnameVerifier.verify(\"xxx.com\", session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)\n\t                }\n\t            });\n\t            builder.sslSocketFactory(sslContext.getSocketFactory());\n\t        }\n\t    }\n\n这句是非常重要的：\n`hostnameVerifier.verify(\"xxx.com\", session);  \n`主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。\n\n之前尝试过使用 使用\n\tbuilder.hostnameVerifier(new AllowAllHostnameVerifier());\n\n这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。\n\n### post 参数不能为空？\n这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).\n\n但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 [okhttp issue](https://github.com/square/okhttp/issues/751) 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。\n\n具体参考这个：\n\n\tpublic void addRequest(int method, final Map<String, String> params, final String baseUrl,\n\t                           final TypeReference<? extends BaseResponse> type, final JsonResultCallback callback) {\n\t\t\t\t......\n\t          if (params.size() == 0 && method == Request.Method.POST)\n\t            params.put(\"temp\", \"temp\"); //解决 method POST must have a request body.;\n\t\t\t\t......\n\t}\n\n这三个问题解决后，基本就可以放心使用了。","slug":"从-volley-切换到-OkHttp-遇到的坑","published":1,"updated":"2016-06-24T07:55:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agl0014xzexy6l7528t","content":"<p>这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。</p>\n<p>之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.</p>\n<h3 id=\"代理异常？\"><a href=\"#代理异常？\" class=\"headerlink\" title=\"代理异常？\"></a>代理异常？</h3><p>切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。</p>\n<p>根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 </p>\n<p>之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？</p>\n<p>经过对比后发现：原来是 之前写 volley 的时候是这样的：</p>\n<pre><code>HttpURLConnection connection;\n    if (&quot;https&quot;.equals(url.getProtocol())) {\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                InetSocketAddress\n                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));\n        connection = (HttpURLConnection) url\n                .openConnection(proxy);\n        connection.addRequestProperty(&quot;Proxy-Authorization&quot;,\n                &quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;);\n    } else {\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                InetSocketAddress\n                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));\n        connection = (HttpURLConnection) url\n                .openConnection(proxy);\n        connection.addRequestProperty(&quot;Authorization&quot;,\n                &quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;);\n    }\n    connection.addRequestProperty(&quot;Proxy-Connection&quot;, &quot;Keep-Alive&quot;);\n</code></pre><p>主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。</p>\n<p>但是在 okhttp 里面貌似是不需要区分的。只需要这样写：</p>\n<pre><code>/**\n     * 设置联通流量 代理功能\n     * @param builder\n     */\n    private void setUnicomProxy(OkHttpClient.Builder builder) {\n        //添加联通代理功能\n        if (TrafficUtil.getUnicomProxyAvailable()) {\n            Authenticator proxyAuthenticator = new Authenticator() {\n                @Override\n                public okhttp3.Request authenticate(Route route, Response response) throws IOException {\n                    return response.request().newBuilder().header(&quot;Proxy-Authorization&quot;, &quot;Basic &quot; +\n                            &quot;MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;).header(&quot;Proxy-Connection&quot;,\n                            &quot;Keep-Alive&quot;).build();\n                }\n            };\n\n            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,\n                    FLOWPACKAGETCPPORT)));\n            builder.proxyAuthenticator(proxyAuthenticator);\n        }\n    }\n</code></pre><p>就可以了。<br><code>FLOWPACKAGEHOST -&gt; test.proxy.1111.com (这是域名)</code><br><code>FLOWPACKAGETCPPORT -&gt; 8143</code><br>这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。</p>\n<p><code>备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈</code></p>\n<h3 id=\"SSL-STL证书-出错？\"><a href=\"#SSL-STL证书-出错？\" class=\"headerlink\" title=\"SSL/STL证书 出错？\"></a>SSL/STL证书 出错？</h3><p>这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：</p>\n<pre><code>    @NonNull\n    private SSLContext getSslContext(InputStream... certificates) {\n        SSLContext sslContext = null;\n\n        try {\n            CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null);\n            int index = 0;\n            for (InputStream certificate : certificates) {\n                String certificateAlias = Integer.toString(index++);\n                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate\n                        (certificate));\n                try {\n                    if (certificate != null)\n                        certificate.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            sslContext = SSLContext.getInstance(&quot;TLS&quot;);\n\n            TrustManagerFactory trustManagerFactory =\n                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustManagerFactory.init(keyStore);\n            sslContext.init(null, trustManagerFactory.getTrustManagers(),\n                    new SecureRandom());\n\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        } catch (Exception e){\n            e.printStackTrace();\n        }   finally {\n        }\n\n        return sslContext;\n    }\n\n/**\n     * 启用 OkHttps 域名校验功能\n     * @param builder\n     */\n    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {\n        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R\n                .raw.kl_magic));\n\n        if (sslContext != null) {\n            builder.hostnameVerifier(new HostnameVerifier() {\n                @Override\n                public boolean verify(String hostname, SSLSession session) {\n                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();\n                    return hostnameVerifier.verify(&quot;xxx.com&quot;, session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)\n                }\n            });\n            builder.sslSocketFactory(sslContext.getSocketFactory());\n        }\n    }\n</code></pre><p>这句是非常重要的：<br><code>hostnameVerifier.verify(&quot;xxx.com&quot;, session);</code>主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。</p>\n<p>之前尝试过使用 使用<br>    builder.hostnameVerifier(new AllowAllHostnameVerifier());</p>\n<p>这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。</p>\n<h3 id=\"post-参数不能为空？\"><a href=\"#post-参数不能为空？\" class=\"headerlink\" title=\"post 参数不能为空？\"></a>post 参数不能为空？</h3><p>这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).</p>\n<p>但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 <a href=\"https://github.com/square/okhttp/issues/751\" target=\"_blank\" rel=\"external\">okhttp issue</a> 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。</p>\n<p>具体参考这个：</p>\n<pre><code>public void addRequest(int method, final Map&lt;String, String&gt; params, final String baseUrl,\n                           final TypeReference&lt;? extends BaseResponse&gt; type, final JsonResultCallback callback) {\n            ......\n          if (params.size() == 0 &amp;&amp; method == Request.Method.POST)\n            params.put(&quot;temp&quot;, &quot;temp&quot;); //解决 method POST must have a request body.;\n            ......\n}\n</code></pre><p>这三个问题解决后，基本就可以放心使用了。</p>\n","excerpt":"","more":"<p>这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。</p>\n<p>之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.</p>\n<h3 id=\"代理异常？\"><a href=\"#代理异常？\" class=\"headerlink\" title=\"代理异常？\"></a>代理异常？</h3><p>切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。</p>\n<p>根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 </p>\n<p>之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？</p>\n<p>经过对比后发现：原来是 之前写 volley 的时候是这样的：</p>\n<pre><code>HttpURLConnection connection;\n    if (&quot;https&quot;.equals(url.getProtocol())) {\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                InetSocketAddress\n                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));\n        connection = (HttpURLConnection) url\n                .openConnection(proxy);\n        connection.addRequestProperty(&quot;Proxy-Authorization&quot;,\n                &quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;);\n    } else {\n        Proxy proxy = new Proxy(Proxy.Type.HTTP,\n                InetSocketAddress\n                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));\n        connection = (HttpURLConnection) url\n                .openConnection(proxy);\n        connection.addRequestProperty(&quot;Authorization&quot;,\n                &quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;);\n    }\n    connection.addRequestProperty(&quot;Proxy-Connection&quot;, &quot;Keep-Alive&quot;);\n</code></pre><p>主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。</p>\n<p>但是在 okhttp 里面貌似是不需要区分的。只需要这样写：</p>\n<pre><code>/**\n     * 设置联通流量 代理功能\n     * @param builder\n     */\n    private void setUnicomProxy(OkHttpClient.Builder builder) {\n        //添加联通代理功能\n        if (TrafficUtil.getUnicomProxyAvailable()) {\n            Authenticator proxyAuthenticator = new Authenticator() {\n                @Override\n                public okhttp3.Request authenticate(Route route, Response response) throws IOException {\n                    return response.request().newBuilder().header(&quot;Proxy-Authorization&quot;, &quot;Basic &quot; +\n                            &quot;MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;).header(&quot;Proxy-Connection&quot;,\n                            &quot;Keep-Alive&quot;).build();\n                }\n            };\n\n            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,\n                    FLOWPACKAGETCPPORT)));\n            builder.proxyAuthenticator(proxyAuthenticator);\n        }\n    }\n</code></pre><p>就可以了。<br><code>FLOWPACKAGEHOST -&gt; test.proxy.1111.com (这是域名)</code><br><code>FLOWPACKAGETCPPORT -&gt; 8143</code><br>这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。</p>\n<p><code>备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈</code></p>\n<h3 id=\"SSL-STL证书-出错？\"><a href=\"#SSL-STL证书-出错？\" class=\"headerlink\" title=\"SSL/STL证书 出错？\"></a>SSL/STL证书 出错？</h3><p>这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：</p>\n<pre><code>    @NonNull\n    private SSLContext getSslContext(InputStream... certificates) {\n        SSLContext sslContext = null;\n\n        try {\n            CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);\n            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n            keyStore.load(null);\n            int index = 0;\n            for (InputStream certificate : certificates) {\n                String certificateAlias = Integer.toString(index++);\n                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate\n                        (certificate));\n                try {\n                    if (certificate != null)\n                        certificate.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            sslContext = SSLContext.getInstance(&quot;TLS&quot;);\n\n            TrustManagerFactory trustManagerFactory =\n                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustManagerFactory.init(keyStore);\n            sslContext.init(null, trustManagerFactory.getTrustManagers(),\n                    new SecureRandom());\n\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (KeyManagementException e) {\n            e.printStackTrace();\n        } catch (Exception e){\n            e.printStackTrace();\n        }   finally {\n        }\n\n        return sslContext;\n    }\n\n/**\n     * 启用 OkHttps 域名校验功能\n     * @param builder\n     */\n    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {\n        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R\n                .raw.kl_magic));\n\n        if (sslContext != null) {\n            builder.hostnameVerifier(new HostnameVerifier() {\n                @Override\n                public boolean verify(String hostname, SSLSession session) {\n                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();\n                    return hostnameVerifier.verify(&quot;xxx.com&quot;, session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)\n                }\n            });\n            builder.sslSocketFactory(sslContext.getSocketFactory());\n        }\n    }\n</code></pre><p>这句是非常重要的：<br><code>hostnameVerifier.verify(&quot;xxx.com&quot;, session);</code>主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。</p>\n<p>之前尝试过使用 使用<br>    builder.hostnameVerifier(new AllowAllHostnameVerifier());</p>\n<p>这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。</p>\n<h3 id=\"post-参数不能为空？\"><a href=\"#post-参数不能为空？\" class=\"headerlink\" title=\"post 参数不能为空？\"></a>post 参数不能为空？</h3><p>这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).</p>\n<p>但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 <a href=\"https://github.com/square/okhttp/issues/751\">okhttp issue</a> 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。</p>\n<p>具体参考这个：</p>\n<pre><code>public void addRequest(int method, final Map&lt;String, String&gt; params, final String baseUrl,\n                           final TypeReference&lt;? extends BaseResponse&gt; type, final JsonResultCallback callback) {\n            ......\n          if (params.size() == 0 &amp;&amp; method == Request.Method.POST)\n            params.put(&quot;temp&quot;, &quot;temp&quot;); //解决 method POST must have a request body.;\n            ......\n}\n</code></pre><p>这三个问题解决后，基本就可以放心使用了。</p>\n"},{"title":"代码面试最常用的10大算法","date":"2016-03-12T00:32:44.000Z","keywords":"算法","_content":"### 代码面试最常用的10大算法\n\n> 面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。\n\n在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。\n本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。\n\n### 1. String/Array/Matrix\n\n    toCharArray() //get char array of a String\n    Arrays.sort()  //sort an array\n    Arrays.toString(char[] a) //convert to string\n    charAt(int x) //get a char at the specific index\n    length() //string length\n    length //array size \n    substring(int beginIndex) \n    substring(int beginIndex, int endIndex)\n    Integer.valueOf()//string to integer\n    String.valueOf()/integer to string\n\nString/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。\n下面列出一些需要高级算法才能解决的经典问题：\n- [Evaluate Reverse Polish Notation](http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/)\n- [Longest Palindromic Substring](http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/)\n- [单词分割](http://www.programcreek.com/2012/12/leetcode-solution-word-break/)\n- [字梯](http://www.programcreek.com/2012/12/leetcode-word-ladder/)\n- [Median of Two Sorted Arrays](http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/)\n- [正则表达式匹配￼Java](http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/)\n- [合并间隔](http://merge%20intervals/)\n- [插入间隔](http://www.programcreek.com/2012/12/leetcode-insert-interval/)\n- [Two Sum](http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/)\n- 3Sum\n- 4Sum\n- 3Sum Closest\n- String to Integer\n- 合并排序数组\n- Valid Parentheses\n- 实现strStr()\n- Set Matrix Zeroes\n- 搜索插入位置\n- Longest Consecutive Sequence\n- Valid Palindrome\n- 螺旋矩阵\n- 搜索一个二维矩阵\n- 旋转图像\n- 三角形\n- Distinct Subsequences Total\n- Maximum Subarray\n- 删除重复的排序数组\n- 删除重复的排序数组2\n- 查找没有重复的最长子串\n- 包含两个独特字符的最长子串\n- Palindrome Partitioning\n\n### 2. 链表\n在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   \n\n    class Node {\n        int val;\n        Node next;\n     \n        Node(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n\n比较流行的两个链表例子就是栈和队列。\n#### 栈（Stack） \n\n    class Stack{\n        Node top; \n     \n        public Node peek(){\n            if(top != null){\n                return top;\n            }\n     \n            return null;\n        }\n     \n        public Node pop(){\n            if(top == null){\n                return null;\n            }else{\n                Node temp = new Node(top.val);\n                top = top.next;\n                return temp;    \n            }\n        }\n     \n        public void push(Node n){\n            if(n != null){\n                n.next = top;\n                top = n;\n            }\n        }\n    }\n\n#### 队列（Queue）\n\n    class Queue{\n        Node first, last;\n    &nbsp;\n        public void enqueue(Node n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n    &nbsp;\n        public Node dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                Node temp = new Node(first.val);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。\n在实际中，需要用到链表的算法有：\n\n- 插入两个数字\n- 重新排序列表\n- 链表周期\n- Copy List with Random Pointer\n- 合并两个有序列表\n- 合并多个排序列表\n- 从排序列表中删除重复的\n- 分区列表\n- LRU缓存\n\n### 3. 树&堆\n这里的树通常是指二叉树。\n\n    class TreeNode{\n        int value;\n        TreeNode left;\n        TreeNode right;\n    } \n\n下面是一些与二叉树有关的概念：\n\n\n- 二叉树搜索：对于所有节点，顺序是：left children \\<= current node \\<= right children；\n- 平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；\n- 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；\n- 完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；\n- 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n\n堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。\n\n下面列出一些基于二叉树和堆的算法：\n\n- 二叉树前序遍历\n- 二叉树中序遍历\n- 二叉树后序遍历\n- 字梯\n- 验证二叉查找树\n- 把二叉树变平放到链表里\n- 二叉树路径和\n- 从前序和后序构建二叉树\n- 把有序数组转换为二叉查找树\n- 把有序列表转为二叉查找树\n- 最小深度二叉树\n- 二叉树最大路径和\n- 平衡二叉树\n\n### 4. Graph \n与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。\n\n![](http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg)\n\n#### 第一步，定义一个GraphNode\n    class GraphNode{ \n        int val;\n        GraphNode next;\n        GraphNode[] neighbors;\n        boolean visited;\n     \n        GraphNode(int x) {\n            val = x;\n        }\n     \n        GraphNode(int x, GraphNode[] n){\n            val = x;\n            neighbors = n;\n        }\n     \n        public String toString(){\n            return \"value: \"+ this.val; \n        }\n    }\n\n#### 第二步，定义一个队列\n\n    class Queue{\n        GraphNode first, last;\n     \n        public void enqueue(GraphNode n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n     \n        public GraphNode dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                GraphNode temp = new GraphNode(first.val, first.neighbors);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n#### 第三步，使用队列进行宽度优先搜索\n    public class GraphTest {\n     \n        public static void main(String[] args) {\n            GraphNode n1 = new GraphNode(1); \n            GraphNode n2 = new GraphNode(2); \n            GraphNode n3 = new GraphNode(3); \n            GraphNode n4 = new GraphNode(4); \n            GraphNode n5 = new GraphNode(5); \n     \n            n1.neighbors = new GraphNode[]{n2,n3,n5};\n            n2.neighbors = new GraphNode[]{n1,n4};\n            n3.neighbors = new GraphNode[]{n1,n4,n5};\n            n4.neighbors = new GraphNode[]{n2,n3,n5};\n            n5.neighbors = new GraphNode[]{n1,n3,n4};\n     \n            breathFirstSearch(n1, 5);\n        }\n     \n        public static void breathFirstSearch(GraphNode root, int x){\n            if(root.val == x)\n                System.out.println(\"find in root\");\n     \n            Queue queue = new Queue();\n            root.visited = true;\n            queue.enqueue(root);\n     \n            while(queue.first != null){\n                GraphNode c = (GraphNode) queue.dequeue();\n                for(GraphNode n: c.neighbors){\n     \n                    if(!n.visited){\n                        System.out.print(n + \" \");\n                        n.visited = true;\n                        if(n.val == x)\n                            System.out.println(\"Find \"+n);\n                        queue.enqueue(n);\n                    }\n                }\n            }\n        }\n    }\n\n#### 输出结果：\n    value: 2 value: 3 value: 5 Find value: 5 \n    value: 4\n\n实际中，基于Graph需要经常用到的算法：\n\n- 克隆Graph\n\n### 5. 排序\n不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。\n\n![](http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg)\n\nBinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   \n\n下面是这些算法的具体实例，另外，你还可以阅读： [Java开发者在实际操作中是如何排序的](http://www.programcreek.com/2014/03/how-developers-sort-in-java/)。\n\n- 归并排序\n- 快速排序\n- 插入排序\n\n### 6. 递归和迭代\n下面通过一个例子来说明什么是递归。\n#### 问题：\n\n> 这里有n个台阶，每次能爬1或2节，请问有多少种爬法？\n\n#### 步骤1：查找n和n-1之间的关系\n为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   \n\n#### 步骤2：确保开始条件是正确的\nf(0) = 0;   \nf(1) = 1; \n\n    public static int f(int n){\n        if(n <= 2) return n;\n        int x = f(n-1) + f(n-2);\n        return x;\n    }\n\n递归方法的时间复杂度指数为n，这里会有很多冗余计算。\n    f(5)\n    f(4) + f(3)\n    f(3) + f(2) + f(2) + f(1)\n    f(2) + f(1) + f(2) + f(2) + f(1)\n\n该递归可以很简单地转换为迭代。 \n    public static int f(int n) {\n     \n        if (n <= 2){\n            return n;\n        }\n     \n        int first = 1, second = 2;\n        int third = 0;\n     \n        for (int i = 3; i <= n; i++) {\n            third = first + second;\n            first = second;\n            second = third;\n        }\n     \n        return third;\n    }\n\n在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 [这里](http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/)看看。\n### 7. 动态规划\n动态规划主要用来解决如下技术问题：\n- 通过较小的子例来解决一个实例；\n- 对于一个较小的实例，可能需要许多个解决方案；\n- 把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；\n- 附加空间用来节省时间。\n上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：\n    public static int[] A = new int[100];\n     \n    public static int f3(int n) {\n        if (n <= 2)\n            A[n]= n;\n     \n        if(A[n] > 0)\n            return A[n];\n        else\n            A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\n        return A[n];\n    }\n\n一些基于动态规划的算法：\n\n- 编辑距离\n- 最长回文子串\n- 单词分割\n- 最大的子数组\n\n### 8. 位操作\n位操作符：\n![](http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg)\n\n从一个给定的数n中找位i（i从0开始，然后向右开始）\n\n    public static boolean getBit(int num, int i){\n        int result = num & (1<<i);\n     \n        if(result == 0){\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n例如，获取10的第二位：\n    i=1, n=10\n    1<<1= 10\n    1010&10=10\n    10 is not 0, so return true;\n\n典型的位算法：\n\n\n- Find Single Number\n- Maximum Binary Gap\n\n### 9. 概率\n\n通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： \n> 有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）\n\n    public static double caculateProbability(int n){\n        double x = 1; \n     \n        for(int i=0; i<n; i++){\n            x *=  (365.0-i)/365.0;\n        }\n     \n        double pro = Math.round((1-x) * 100);\n        return pro/100;\n    }I\n\n结果：\n> calculateProbability(50) = 0.97\n### 10. 组合和排列\n\n组合和排列的主要差别在于顺序是否重要。\n例1：\n> 1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？\n例2：\n> 有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？\n\n基于它们的一些常见算法\n- 排列\n- 排列2\n- 排列顺序\n\n来自：[http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview](http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview)\n","source":"_posts/代码面试最常用的10大算法.md","raw":"title: 代码面试最常用的10大算法\ndate: 2016-03-12 08:32:44\ncategories:\nkeywords: 算法\ntags: 算法\n---\n### 代码面试最常用的10大算法\n\n> 面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。\n\n在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。\n本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。\n\n### 1. String/Array/Matrix\n\n    toCharArray() //get char array of a String\n    Arrays.sort()  //sort an array\n    Arrays.toString(char[] a) //convert to string\n    charAt(int x) //get a char at the specific index\n    length() //string length\n    length //array size \n    substring(int beginIndex) \n    substring(int beginIndex, int endIndex)\n    Integer.valueOf()//string to integer\n    String.valueOf()/integer to string\n\nString/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。\n下面列出一些需要高级算法才能解决的经典问题：\n- [Evaluate Reverse Polish Notation](http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/)\n- [Longest Palindromic Substring](http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/)\n- [单词分割](http://www.programcreek.com/2012/12/leetcode-solution-word-break/)\n- [字梯](http://www.programcreek.com/2012/12/leetcode-word-ladder/)\n- [Median of Two Sorted Arrays](http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/)\n- [正则表达式匹配￼Java](http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/)\n- [合并间隔](http://merge%20intervals/)\n- [插入间隔](http://www.programcreek.com/2012/12/leetcode-insert-interval/)\n- [Two Sum](http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/)\n- 3Sum\n- 4Sum\n- 3Sum Closest\n- String to Integer\n- 合并排序数组\n- Valid Parentheses\n- 实现strStr()\n- Set Matrix Zeroes\n- 搜索插入位置\n- Longest Consecutive Sequence\n- Valid Palindrome\n- 螺旋矩阵\n- 搜索一个二维矩阵\n- 旋转图像\n- 三角形\n- Distinct Subsequences Total\n- Maximum Subarray\n- 删除重复的排序数组\n- 删除重复的排序数组2\n- 查找没有重复的最长子串\n- 包含两个独特字符的最长子串\n- Palindrome Partitioning\n\n### 2. 链表\n在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   \n\n    class Node {\n        int val;\n        Node next;\n     \n        Node(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n\n比较流行的两个链表例子就是栈和队列。\n#### 栈（Stack） \n\n    class Stack{\n        Node top; \n     \n        public Node peek(){\n            if(top != null){\n                return top;\n            }\n     \n            return null;\n        }\n     \n        public Node pop(){\n            if(top == null){\n                return null;\n            }else{\n                Node temp = new Node(top.val);\n                top = top.next;\n                return temp;    \n            }\n        }\n     \n        public void push(Node n){\n            if(n != null){\n                n.next = top;\n                top = n;\n            }\n        }\n    }\n\n#### 队列（Queue）\n\n    class Queue{\n        Node first, last;\n    &nbsp;\n        public void enqueue(Node n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n    &nbsp;\n        public Node dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                Node temp = new Node(first.val);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。\n在实际中，需要用到链表的算法有：\n\n- 插入两个数字\n- 重新排序列表\n- 链表周期\n- Copy List with Random Pointer\n- 合并两个有序列表\n- 合并多个排序列表\n- 从排序列表中删除重复的\n- 分区列表\n- LRU缓存\n\n### 3. 树&堆\n这里的树通常是指二叉树。\n\n    class TreeNode{\n        int value;\n        TreeNode left;\n        TreeNode right;\n    } \n\n下面是一些与二叉树有关的概念：\n\n\n- 二叉树搜索：对于所有节点，顺序是：left children \\<= current node \\<= right children；\n- 平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；\n- 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；\n- 完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；\n- 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n\n堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。\n\n下面列出一些基于二叉树和堆的算法：\n\n- 二叉树前序遍历\n- 二叉树中序遍历\n- 二叉树后序遍历\n- 字梯\n- 验证二叉查找树\n- 把二叉树变平放到链表里\n- 二叉树路径和\n- 从前序和后序构建二叉树\n- 把有序数组转换为二叉查找树\n- 把有序列表转为二叉查找树\n- 最小深度二叉树\n- 二叉树最大路径和\n- 平衡二叉树\n\n### 4. Graph \n与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。\n\n![](http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg)\n\n#### 第一步，定义一个GraphNode\n    class GraphNode{ \n        int val;\n        GraphNode next;\n        GraphNode[] neighbors;\n        boolean visited;\n     \n        GraphNode(int x) {\n            val = x;\n        }\n     \n        GraphNode(int x, GraphNode[] n){\n            val = x;\n            neighbors = n;\n        }\n     \n        public String toString(){\n            return \"value: \"+ this.val; \n        }\n    }\n\n#### 第二步，定义一个队列\n\n    class Queue{\n        GraphNode first, last;\n     \n        public void enqueue(GraphNode n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n     \n        public GraphNode dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                GraphNode temp = new GraphNode(first.val, first.neighbors);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n#### 第三步，使用队列进行宽度优先搜索\n    public class GraphTest {\n     \n        public static void main(String[] args) {\n            GraphNode n1 = new GraphNode(1); \n            GraphNode n2 = new GraphNode(2); \n            GraphNode n3 = new GraphNode(3); \n            GraphNode n4 = new GraphNode(4); \n            GraphNode n5 = new GraphNode(5); \n     \n            n1.neighbors = new GraphNode[]{n2,n3,n5};\n            n2.neighbors = new GraphNode[]{n1,n4};\n            n3.neighbors = new GraphNode[]{n1,n4,n5};\n            n4.neighbors = new GraphNode[]{n2,n3,n5};\n            n5.neighbors = new GraphNode[]{n1,n3,n4};\n     \n            breathFirstSearch(n1, 5);\n        }\n     \n        public static void breathFirstSearch(GraphNode root, int x){\n            if(root.val == x)\n                System.out.println(\"find in root\");\n     \n            Queue queue = new Queue();\n            root.visited = true;\n            queue.enqueue(root);\n     \n            while(queue.first != null){\n                GraphNode c = (GraphNode) queue.dequeue();\n                for(GraphNode n: c.neighbors){\n     \n                    if(!n.visited){\n                        System.out.print(n + \" \");\n                        n.visited = true;\n                        if(n.val == x)\n                            System.out.println(\"Find \"+n);\n                        queue.enqueue(n);\n                    }\n                }\n            }\n        }\n    }\n\n#### 输出结果：\n    value: 2 value: 3 value: 5 Find value: 5 \n    value: 4\n\n实际中，基于Graph需要经常用到的算法：\n\n- 克隆Graph\n\n### 5. 排序\n不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。\n\n![](http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg)\n\nBinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   \n\n下面是这些算法的具体实例，另外，你还可以阅读： [Java开发者在实际操作中是如何排序的](http://www.programcreek.com/2014/03/how-developers-sort-in-java/)。\n\n- 归并排序\n- 快速排序\n- 插入排序\n\n### 6. 递归和迭代\n下面通过一个例子来说明什么是递归。\n#### 问题：\n\n> 这里有n个台阶，每次能爬1或2节，请问有多少种爬法？\n\n#### 步骤1：查找n和n-1之间的关系\n为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   \n\n#### 步骤2：确保开始条件是正确的\nf(0) = 0;   \nf(1) = 1; \n\n    public static int f(int n){\n        if(n <= 2) return n;\n        int x = f(n-1) + f(n-2);\n        return x;\n    }\n\n递归方法的时间复杂度指数为n，这里会有很多冗余计算。\n    f(5)\n    f(4) + f(3)\n    f(3) + f(2) + f(2) + f(1)\n    f(2) + f(1) + f(2) + f(2) + f(1)\n\n该递归可以很简单地转换为迭代。 \n    public static int f(int n) {\n     \n        if (n <= 2){\n            return n;\n        }\n     \n        int first = 1, second = 2;\n        int third = 0;\n     \n        for (int i = 3; i <= n; i++) {\n            third = first + second;\n            first = second;\n            second = third;\n        }\n     \n        return third;\n    }\n\n在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 [这里](http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/)看看。\n### 7. 动态规划\n动态规划主要用来解决如下技术问题：\n- 通过较小的子例来解决一个实例；\n- 对于一个较小的实例，可能需要许多个解决方案；\n- 把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；\n- 附加空间用来节省时间。\n上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：\n    public static int[] A = new int[100];\n     \n    public static int f3(int n) {\n        if (n <= 2)\n            A[n]= n;\n     \n        if(A[n] > 0)\n            return A[n];\n        else\n            A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\n        return A[n];\n    }\n\n一些基于动态规划的算法：\n\n- 编辑距离\n- 最长回文子串\n- 单词分割\n- 最大的子数组\n\n### 8. 位操作\n位操作符：\n![](http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg)\n\n从一个给定的数n中找位i（i从0开始，然后向右开始）\n\n    public static boolean getBit(int num, int i){\n        int result = num & (1<<i);\n     \n        if(result == 0){\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n例如，获取10的第二位：\n    i=1, n=10\n    1<<1= 10\n    1010&10=10\n    10 is not 0, so return true;\n\n典型的位算法：\n\n\n- Find Single Number\n- Maximum Binary Gap\n\n### 9. 概率\n\n通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： \n> 有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）\n\n    public static double caculateProbability(int n){\n        double x = 1; \n     \n        for(int i=0; i<n; i++){\n            x *=  (365.0-i)/365.0;\n        }\n     \n        double pro = Math.round((1-x) * 100);\n        return pro/100;\n    }I\n\n结果：\n> calculateProbability(50) = 0.97\n### 10. 组合和排列\n\n组合和排列的主要差别在于顺序是否重要。\n例1：\n> 1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？\n例2：\n> 有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？\n\n基于它们的一些常见算法\n- 排列\n- 排列2\n- 排列顺序\n\n来自：[http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview](http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview)\n","slug":"代码面试最常用的10大算法","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agm0018xzexg5xgtuxk","content":"<h3 id=\"代码面试最常用的10大算法\"><a href=\"#代码面试最常用的10大算法\" class=\"headerlink\" title=\"代码面试最常用的10大算法\"></a>代码面试最常用的10大算法</h3><blockquote>\n<p>面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。</p>\n</blockquote>\n<p>在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。<br>本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。</p>\n<h3 id=\"1-String-Array-Matrix\"><a href=\"#1-String-Array-Matrix\" class=\"headerlink\" title=\"1. String/Array/Matrix\"></a>1. String/Array/Matrix</h3><pre><code>toCharArray() //get char array of a String\nArrays.sort()  //sort an array\nArrays.toString(char[] a) //convert to string\ncharAt(int x) //get a char at the specific index\nlength() //string length\nlength //array size \nsubstring(int beginIndex) \nsubstring(int beginIndex, int endIndex)\nInteger.valueOf()//string to integer\nString.valueOf()/integer to string\n</code></pre><p>String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。<br>下面列出一些需要高级算法才能解决的经典问题：</p>\n<ul>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"external\">Evaluate Reverse Polish Notation</a></li>\n<li><a href=\"http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/\" target=\"_blank\" rel=\"external\">Longest Palindromic Substring</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-word-break/\" target=\"_blank\" rel=\"external\">单词分割</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-word-ladder/\" target=\"_blank\" rel=\"external\">字梯</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/\" target=\"_blank\" rel=\"external\">Median of Two Sorted Arrays</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/\" target=\"_blank\" rel=\"external\">正则表达式匹配￼Java</a></li>\n<li><a href=\"http://merge%20intervals/\" target=\"_blank\" rel=\"external\">合并间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-insert-interval/\" target=\"_blank\" rel=\"external\">插入间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/\" target=\"_blank\" rel=\"external\">Two Sum</a></li>\n<li>3Sum</li>\n<li>4Sum</li>\n<li>3Sum Closest</li>\n<li>String to Integer</li>\n<li>合并排序数组</li>\n<li>Valid Parentheses</li>\n<li>实现strStr()</li>\n<li>Set Matrix Zeroes</li>\n<li>搜索插入位置</li>\n<li>Longest Consecutive Sequence</li>\n<li>Valid Palindrome</li>\n<li>螺旋矩阵</li>\n<li>搜索一个二维矩阵</li>\n<li>旋转图像</li>\n<li>三角形</li>\n<li>Distinct Subsequences Total</li>\n<li>Maximum Subarray</li>\n<li>删除重复的排序数组</li>\n<li>删除重复的排序数组2</li>\n<li>查找没有重复的最长子串</li>\n<li>包含两个独特字符的最长子串</li>\n<li>Palindrome Partitioning</li>\n</ul>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2. 链表\"></a>2. 链表</h3><p>在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   </p>\n<pre><code>class Node {\n    int val;\n    Node next;\n\n    Node(int x) {\n        val = x;\n        next = null;\n    }\n}\n</code></pre><p>比较流行的两个链表例子就是栈和队列。</p>\n<h4 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h4><pre><code>class Stack{\n    Node top; \n\n    public Node peek(){\n        if(top != null){\n            return top;\n        }\n\n        return null;\n    }\n\n    public Node pop(){\n        if(top == null){\n            return null;\n        }else{\n            Node temp = new Node(top.val);\n            top = top.next;\n            return temp;    \n        }\n    }\n\n    public void push(Node n){\n        if(n != null){\n            n.next = top;\n            top = n;\n        }\n    }\n}\n</code></pre><h4 id=\"队列（Queue）\"><a href=\"#队列（Queue）\" class=\"headerlink\" title=\"队列（Queue）\"></a>队列（Queue）</h4><pre><code>class Queue{\n    Node first, last;\n&amp;nbsp;\n    public void enqueue(Node n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n&amp;nbsp;\n    public Node dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            Node temp = new Node(first.val);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><p>值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。<br>在实际中，需要用到链表的算法有：</p>\n<ul>\n<li>插入两个数字</li>\n<li>重新排序列表</li>\n<li>链表周期</li>\n<li>Copy List with Random Pointer</li>\n<li>合并两个有序列表</li>\n<li>合并多个排序列表</li>\n<li>从排序列表中删除重复的</li>\n<li>分区列表</li>\n<li>LRU缓存</li>\n</ul>\n<h3 id=\"3-树-amp-堆\"><a href=\"#3-树-amp-堆\" class=\"headerlink\" title=\"3. 树&amp;堆\"></a>3. 树&amp;堆</h3><p>这里的树通常是指二叉树。</p>\n<pre><code>class TreeNode{\n    int value;\n    TreeNode left;\n    TreeNode right;\n} \n</code></pre><p>下面是一些与二叉树有关的概念：</p>\n<ul>\n<li>二叉树搜索：对于所有节点，顺序是：left children \\&lt;= current node \\&lt;= right children；</li>\n<li>平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；</li>\n<li>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；</li>\n<li>完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；</li>\n<li>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</li>\n</ul>\n<p>堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>\n<p>下面列出一些基于二叉树和堆的算法：</p>\n<ul>\n<li>二叉树前序遍历</li>\n<li>二叉树中序遍历</li>\n<li>二叉树后序遍历</li>\n<li>字梯</li>\n<li>验证二叉查找树</li>\n<li>把二叉树变平放到链表里</li>\n<li>二叉树路径和</li>\n<li>从前序和后序构建二叉树</li>\n<li>把有序数组转换为二叉查找树</li>\n<li>把有序列表转为二叉查找树</li>\n<li>最小深度二叉树</li>\n<li>二叉树最大路径和</li>\n<li>平衡二叉树</li>\n</ul>\n<h3 id=\"4-Graph\"><a href=\"#4-Graph\" class=\"headerlink\" title=\"4. Graph\"></a>4. Graph</h3><p>与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg\" alt=\"\"></p>\n<h4 id=\"第一步，定义一个GraphNode\"><a href=\"#第一步，定义一个GraphNode\" class=\"headerlink\" title=\"第一步，定义一个GraphNode\"></a>第一步，定义一个GraphNode</h4><pre><code>class GraphNode{ \n    int val;\n    GraphNode next;\n    GraphNode[] neighbors;\n    boolean visited;\n\n    GraphNode(int x) {\n        val = x;\n    }\n\n    GraphNode(int x, GraphNode[] n){\n        val = x;\n        neighbors = n;\n    }\n\n    public String toString(){\n        return &quot;value: &quot;+ this.val; \n    }\n}\n</code></pre><h4 id=\"第二步，定义一个队列\"><a href=\"#第二步，定义一个队列\" class=\"headerlink\" title=\"第二步，定义一个队列\"></a>第二步，定义一个队列</h4><pre><code>class Queue{\n    GraphNode first, last;\n\n    public void enqueue(GraphNode n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n\n    public GraphNode dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            GraphNode temp = new GraphNode(first.val, first.neighbors);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><h4 id=\"第三步，使用队列进行宽度优先搜索\"><a href=\"#第三步，使用队列进行宽度优先搜索\" class=\"headerlink\" title=\"第三步，使用队列进行宽度优先搜索\"></a>第三步，使用队列进行宽度优先搜索</h4><pre><code>public class GraphTest {\n\n    public static void main(String[] args) {\n        GraphNode n1 = new GraphNode(1); \n        GraphNode n2 = new GraphNode(2); \n        GraphNode n3 = new GraphNode(3); \n        GraphNode n4 = new GraphNode(4); \n        GraphNode n5 = new GraphNode(5); \n\n        n1.neighbors = new GraphNode[]{n2,n3,n5};\n        n2.neighbors = new GraphNode[]{n1,n4};\n        n3.neighbors = new GraphNode[]{n1,n4,n5};\n        n4.neighbors = new GraphNode[]{n2,n3,n5};\n        n5.neighbors = new GraphNode[]{n1,n3,n4};\n\n        breathFirstSearch(n1, 5);\n    }\n\n    public static void breathFirstSearch(GraphNode root, int x){\n        if(root.val == x)\n            System.out.println(&quot;find in root&quot;);\n\n        Queue queue = new Queue();\n        root.visited = true;\n        queue.enqueue(root);\n\n        while(queue.first != null){\n            GraphNode c = (GraphNode) queue.dequeue();\n            for(GraphNode n: c.neighbors){\n\n                if(!n.visited){\n                    System.out.print(n + &quot; &quot;);\n                    n.visited = true;\n                    if(n.val == x)\n                        System.out.println(&quot;Find &quot;+n);\n                    queue.enqueue(n);\n                }\n            }\n        }\n    }\n}\n</code></pre><h4 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h4><pre><code>value: 2 value: 3 value: 5 Find value: 5 \nvalue: 4\n</code></pre><p>实际中，基于Graph需要经常用到的算法：</p>\n<ul>\n<li>克隆Graph</li>\n</ul>\n<h3 id=\"5-排序\"><a href=\"#5-排序\" class=\"headerlink\" title=\"5. 排序\"></a>5. 排序</h3><p>不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg\" alt=\"\"></p>\n<p>BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   </p>\n<p>下面是这些算法的具体实例，另外，你还可以阅读： <a href=\"http://www.programcreek.com/2014/03/how-developers-sort-in-java/\" target=\"_blank\" rel=\"external\">Java开发者在实际操作中是如何排序的</a>。</p>\n<ul>\n<li>归并排序</li>\n<li>快速排序</li>\n<li>插入排序</li>\n</ul>\n<h3 id=\"6-递归和迭代\"><a href=\"#6-递归和迭代\" class=\"headerlink\" title=\"6. 递归和迭代\"></a>6. 递归和迭代</h3><p>下面通过一个例子来说明什么是递归。</p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><blockquote>\n<p>这里有n个台阶，每次能爬1或2节，请问有多少种爬法？</p>\n</blockquote>\n<h4 id=\"步骤1：查找n和n-1之间的关系\"><a href=\"#步骤1：查找n和n-1之间的关系\" class=\"headerlink\" title=\"步骤1：查找n和n-1之间的关系\"></a>步骤1：查找n和n-1之间的关系</h4><p>为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   </p>\n<h4 id=\"步骤2：确保开始条件是正确的\"><a href=\"#步骤2：确保开始条件是正确的\" class=\"headerlink\" title=\"步骤2：确保开始条件是正确的\"></a>步骤2：确保开始条件是正确的</h4><p>f(0) = 0;<br>f(1) = 1; </p>\n<pre><code>public static int f(int n){\n    if(n &lt;= 2) return n;\n    int x = f(n-1) + f(n-2);\n    return x;\n}\n</code></pre><p>递归方法的时间复杂度指数为n，这里会有很多冗余计算。<br>    f(5)<br>    f(4) + f(3)<br>    f(3) + f(2) + f(2) + f(1)<br>    f(2) + f(1) + f(2) + f(2) + f(1)</p>\n<p>该递归可以很简单地转换为迭代。<br>    public static int f(int n) {</p>\n<pre><code>    if (n &lt;= 2){\n        return n;\n    }\n\n    int first = 1, second = 2;\n    int third = 0;\n\n    for (int i = 3; i &lt;= n; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n\n    return third;\n}\n</code></pre><p>在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 <a href=\"http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/\" target=\"_blank\" rel=\"external\">这里</a>看看。</p>\n<h3 id=\"7-动态规划\"><a href=\"#7-动态规划\" class=\"headerlink\" title=\"7. 动态规划\"></a>7. 动态规划</h3><p>动态规划主要用来解决如下技术问题：</p>\n<ul>\n<li>通过较小的子例来解决一个实例；</li>\n<li>对于一个较小的实例，可能需要许多个解决方案；</li>\n<li>把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；</li>\n<li><p>附加空间用来节省时间。<br>上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：<br>  public static int[] A = new int[100];</p>\n<p>  public static int f3(int n) {</p>\n<pre><code>if (n &lt;= 2)\n    A[n]= n;\n\nif(A[n] &gt; 0)\n    return A[n];\nelse\n    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\nreturn A[n];\n</code></pre><p>  }</p>\n</li>\n</ul>\n<p>一些基于动态规划的算法：</p>\n<ul>\n<li>编辑距离</li>\n<li>最长回文子串</li>\n<li>单词分割</li>\n<li>最大的子数组</li>\n</ul>\n<h3 id=\"8-位操作\"><a href=\"#8-位操作\" class=\"headerlink\" title=\"8. 位操作\"></a>8. 位操作</h3><p>位操作符：<br><img src=\"http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg\" alt=\"\"></p>\n<p>从一个给定的数n中找位i（i从0开始，然后向右开始）</p>\n<pre><code>public static boolean getBit(int num, int i){\n    int result = num &amp; (1&lt;&lt;i);\n\n    if(result == 0){\n        return false;\n    }else{\n        return true;\n    }\n}\n</code></pre><p>例如，获取10的第二位：<br>    i=1, n=10<br>    1&lt;&lt;1= 10<br>    1010&amp;10=10<br>    10 is not 0, so return true;</p>\n<p>典型的位算法：</p>\n<ul>\n<li>Find Single Number</li>\n<li>Maximum Binary Gap</li>\n</ul>\n<h3 id=\"9-概率\"><a href=\"#9-概率\" class=\"headerlink\" title=\"9. 概率\"></a>9. 概率</h3><p>通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： </p>\n<blockquote>\n<p>有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）</p>\n</blockquote>\n<pre><code>public static double caculateProbability(int n){\n    double x = 1; \n\n    for(int i=0; i&lt;n; i++){\n        x *=  (365.0-i)/365.0;\n    }\n\n    double pro = Math.round((1-x) * 100);\n    return pro/100;\n}I\n</code></pre><p>结果：</p>\n<blockquote>\n<p>calculateProbability(50) = 0.97</p>\n<h3 id=\"10-组合和排列\"><a href=\"#10-组合和排列\" class=\"headerlink\" title=\"10. 组合和排列\"></a>10. 组合和排列</h3></blockquote>\n<p>组合和排列的主要差别在于顺序是否重要。<br>例1：</p>\n<blockquote>\n<p>1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？<br>例2：<br>有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？</p>\n</blockquote>\n<p>基于它们的一些常见算法</p>\n<ul>\n<li>排列</li>\n<li>排列2</li>\n<li>排列顺序</li>\n</ul>\n<p>来自：<a href=\"http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview\" target=\"_blank\" rel=\"external\">http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview</a></p>\n","excerpt":"","more":"<h3 id=\"代码面试最常用的10大算法\"><a href=\"#代码面试最常用的10大算法\" class=\"headerlink\" title=\"代码面试最常用的10大算法\"></a>代码面试最常用的10大算法</h3><blockquote>\n<p>面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。</p>\n</blockquote>\n<p>在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。<br>本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。</p>\n<h3 id=\"1-String-Array-Matrix\"><a href=\"#1-String-Array-Matrix\" class=\"headerlink\" title=\"1. String/Array/Matrix\"></a>1. String/Array/Matrix</h3><pre><code>toCharArray() //get char array of a String\nArrays.sort()  //sort an array\nArrays.toString(char[] a) //convert to string\ncharAt(int x) //get a char at the specific index\nlength() //string length\nlength //array size \nsubstring(int beginIndex) \nsubstring(int beginIndex, int endIndex)\nInteger.valueOf()//string to integer\nString.valueOf()/integer to string\n</code></pre><p>String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。<br>下面列出一些需要高级算法才能解决的经典问题：</p>\n<ul>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/\">Evaluate Reverse Polish Notation</a></li>\n<li><a href=\"http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/\">Longest Palindromic Substring</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-word-break/\">单词分割</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-word-ladder/\">字梯</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/\">Median of Two Sorted Arrays</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/\">正则表达式匹配￼Java</a></li>\n<li><a href=\"http://merge%20intervals/\">合并间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-insert-interval/\">插入间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/\">Two Sum</a></li>\n<li>3Sum</li>\n<li>4Sum</li>\n<li>3Sum Closest</li>\n<li>String to Integer</li>\n<li>合并排序数组</li>\n<li>Valid Parentheses</li>\n<li>实现strStr()</li>\n<li>Set Matrix Zeroes</li>\n<li>搜索插入位置</li>\n<li>Longest Consecutive Sequence</li>\n<li>Valid Palindrome</li>\n<li>螺旋矩阵</li>\n<li>搜索一个二维矩阵</li>\n<li>旋转图像</li>\n<li>三角形</li>\n<li>Distinct Subsequences Total</li>\n<li>Maximum Subarray</li>\n<li>删除重复的排序数组</li>\n<li>删除重复的排序数组2</li>\n<li>查找没有重复的最长子串</li>\n<li>包含两个独特字符的最长子串</li>\n<li>Palindrome Partitioning</li>\n</ul>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2. 链表\"></a>2. 链表</h3><p>在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   </p>\n<pre><code>class Node {\n    int val;\n    Node next;\n\n    Node(int x) {\n        val = x;\n        next = null;\n    }\n}\n</code></pre><p>比较流行的两个链表例子就是栈和队列。</p>\n<h4 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h4><pre><code>class Stack{\n    Node top; \n\n    public Node peek(){\n        if(top != null){\n            return top;\n        }\n\n        return null;\n    }\n\n    public Node pop(){\n        if(top == null){\n            return null;\n        }else{\n            Node temp = new Node(top.val);\n            top = top.next;\n            return temp;    \n        }\n    }\n\n    public void push(Node n){\n        if(n != null){\n            n.next = top;\n            top = n;\n        }\n    }\n}\n</code></pre><h4 id=\"队列（Queue）\"><a href=\"#队列（Queue）\" class=\"headerlink\" title=\"队列（Queue）\"></a>队列（Queue）</h4><pre><code>class Queue{\n    Node first, last;\n&amp;nbsp;\n    public void enqueue(Node n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n&amp;nbsp;\n    public Node dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            Node temp = new Node(first.val);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><p>值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。<br>在实际中，需要用到链表的算法有：</p>\n<ul>\n<li>插入两个数字</li>\n<li>重新排序列表</li>\n<li>链表周期</li>\n<li>Copy List with Random Pointer</li>\n<li>合并两个有序列表</li>\n<li>合并多个排序列表</li>\n<li>从排序列表中删除重复的</li>\n<li>分区列表</li>\n<li>LRU缓存</li>\n</ul>\n<h3 id=\"3-树-amp-堆\"><a href=\"#3-树-amp-堆\" class=\"headerlink\" title=\"3. 树&amp;堆\"></a>3. 树&amp;堆</h3><p>这里的树通常是指二叉树。</p>\n<pre><code>class TreeNode{\n    int value;\n    TreeNode left;\n    TreeNode right;\n} \n</code></pre><p>下面是一些与二叉树有关的概念：</p>\n<ul>\n<li>二叉树搜索：对于所有节点，顺序是：left children \\&lt;= current node \\&lt;= right children；</li>\n<li>平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；</li>\n<li>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；</li>\n<li>完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；</li>\n<li>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</li>\n</ul>\n<p>堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>\n<p>下面列出一些基于二叉树和堆的算法：</p>\n<ul>\n<li>二叉树前序遍历</li>\n<li>二叉树中序遍历</li>\n<li>二叉树后序遍历</li>\n<li>字梯</li>\n<li>验证二叉查找树</li>\n<li>把二叉树变平放到链表里</li>\n<li>二叉树路径和</li>\n<li>从前序和后序构建二叉树</li>\n<li>把有序数组转换为二叉查找树</li>\n<li>把有序列表转为二叉查找树</li>\n<li>最小深度二叉树</li>\n<li>二叉树最大路径和</li>\n<li>平衡二叉树</li>\n</ul>\n<h3 id=\"4-Graph\"><a href=\"#4-Graph\" class=\"headerlink\" title=\"4. Graph\"></a>4. Graph</h3><p>与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg\" alt=\"\"></p>\n<h4 id=\"第一步，定义一个GraphNode\"><a href=\"#第一步，定义一个GraphNode\" class=\"headerlink\" title=\"第一步，定义一个GraphNode\"></a>第一步，定义一个GraphNode</h4><pre><code>class GraphNode{ \n    int val;\n    GraphNode next;\n    GraphNode[] neighbors;\n    boolean visited;\n\n    GraphNode(int x) {\n        val = x;\n    }\n\n    GraphNode(int x, GraphNode[] n){\n        val = x;\n        neighbors = n;\n    }\n\n    public String toString(){\n        return &quot;value: &quot;+ this.val; \n    }\n}\n</code></pre><h4 id=\"第二步，定义一个队列\"><a href=\"#第二步，定义一个队列\" class=\"headerlink\" title=\"第二步，定义一个队列\"></a>第二步，定义一个队列</h4><pre><code>class Queue{\n    GraphNode first, last;\n\n    public void enqueue(GraphNode n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n\n    public GraphNode dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            GraphNode temp = new GraphNode(first.val, first.neighbors);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><h4 id=\"第三步，使用队列进行宽度优先搜索\"><a href=\"#第三步，使用队列进行宽度优先搜索\" class=\"headerlink\" title=\"第三步，使用队列进行宽度优先搜索\"></a>第三步，使用队列进行宽度优先搜索</h4><pre><code>public class GraphTest {\n\n    public static void main(String[] args) {\n        GraphNode n1 = new GraphNode(1); \n        GraphNode n2 = new GraphNode(2); \n        GraphNode n3 = new GraphNode(3); \n        GraphNode n4 = new GraphNode(4); \n        GraphNode n5 = new GraphNode(5); \n\n        n1.neighbors = new GraphNode[]{n2,n3,n5};\n        n2.neighbors = new GraphNode[]{n1,n4};\n        n3.neighbors = new GraphNode[]{n1,n4,n5};\n        n4.neighbors = new GraphNode[]{n2,n3,n5};\n        n5.neighbors = new GraphNode[]{n1,n3,n4};\n\n        breathFirstSearch(n1, 5);\n    }\n\n    public static void breathFirstSearch(GraphNode root, int x){\n        if(root.val == x)\n            System.out.println(&quot;find in root&quot;);\n\n        Queue queue = new Queue();\n        root.visited = true;\n        queue.enqueue(root);\n\n        while(queue.first != null){\n            GraphNode c = (GraphNode) queue.dequeue();\n            for(GraphNode n: c.neighbors){\n\n                if(!n.visited){\n                    System.out.print(n + &quot; &quot;);\n                    n.visited = true;\n                    if(n.val == x)\n                        System.out.println(&quot;Find &quot;+n);\n                    queue.enqueue(n);\n                }\n            }\n        }\n    }\n}\n</code></pre><h4 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h4><pre><code>value: 2 value: 3 value: 5 Find value: 5 \nvalue: 4\n</code></pre><p>实际中，基于Graph需要经常用到的算法：</p>\n<ul>\n<li>克隆Graph</li>\n</ul>\n<h3 id=\"5-排序\"><a href=\"#5-排序\" class=\"headerlink\" title=\"5. 排序\"></a>5. 排序</h3><p>不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg\" alt=\"\"></p>\n<p>BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   </p>\n<p>下面是这些算法的具体实例，另外，你还可以阅读： <a href=\"http://www.programcreek.com/2014/03/how-developers-sort-in-java/\">Java开发者在实际操作中是如何排序的</a>。</p>\n<ul>\n<li>归并排序</li>\n<li>快速排序</li>\n<li>插入排序</li>\n</ul>\n<h3 id=\"6-递归和迭代\"><a href=\"#6-递归和迭代\" class=\"headerlink\" title=\"6. 递归和迭代\"></a>6. 递归和迭代</h3><p>下面通过一个例子来说明什么是递归。</p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><blockquote>\n<p>这里有n个台阶，每次能爬1或2节，请问有多少种爬法？</p>\n</blockquote>\n<h4 id=\"步骤1：查找n和n-1之间的关系\"><a href=\"#步骤1：查找n和n-1之间的关系\" class=\"headerlink\" title=\"步骤1：查找n和n-1之间的关系\"></a>步骤1：查找n和n-1之间的关系</h4><p>为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   </p>\n<h4 id=\"步骤2：确保开始条件是正确的\"><a href=\"#步骤2：确保开始条件是正确的\" class=\"headerlink\" title=\"步骤2：确保开始条件是正确的\"></a>步骤2：确保开始条件是正确的</h4><p>f(0) = 0;<br>f(1) = 1; </p>\n<pre><code>public static int f(int n){\n    if(n &lt;= 2) return n;\n    int x = f(n-1) + f(n-2);\n    return x;\n}\n</code></pre><p>递归方法的时间复杂度指数为n，这里会有很多冗余计算。<br>    f(5)<br>    f(4) + f(3)<br>    f(3) + f(2) + f(2) + f(1)<br>    f(2) + f(1) + f(2) + f(2) + f(1)</p>\n<p>该递归可以很简单地转换为迭代。<br>    public static int f(int n) {</p>\n<pre><code>    if (n &lt;= 2){\n        return n;\n    }\n\n    int first = 1, second = 2;\n    int third = 0;\n\n    for (int i = 3; i &lt;= n; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n\n    return third;\n}\n</code></pre><p>在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 <a href=\"http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/\">这里</a>看看。</p>\n<h3 id=\"7-动态规划\"><a href=\"#7-动态规划\" class=\"headerlink\" title=\"7. 动态规划\"></a>7. 动态规划</h3><p>动态规划主要用来解决如下技术问题：</p>\n<ul>\n<li>通过较小的子例来解决一个实例；</li>\n<li>对于一个较小的实例，可能需要许多个解决方案；</li>\n<li>把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；</li>\n<li><p>附加空间用来节省时间。<br>上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：<br>  public static int[] A = new int[100];</p>\n<p>  public static int f3(int n) {</p>\n<pre><code>if (n &lt;= 2)\n    A[n]= n;\n\nif(A[n] &gt; 0)\n    return A[n];\nelse\n    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\nreturn A[n];\n</code></pre><p>  }</p>\n</li>\n</ul>\n<p>一些基于动态规划的算法：</p>\n<ul>\n<li>编辑距离</li>\n<li>最长回文子串</li>\n<li>单词分割</li>\n<li>最大的子数组</li>\n</ul>\n<h3 id=\"8-位操作\"><a href=\"#8-位操作\" class=\"headerlink\" title=\"8. 位操作\"></a>8. 位操作</h3><p>位操作符：<br><img src=\"http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg\" alt=\"\"></p>\n<p>从一个给定的数n中找位i（i从0开始，然后向右开始）</p>\n<pre><code>public static boolean getBit(int num, int i){\n    int result = num &amp; (1&lt;&lt;i);\n\n    if(result == 0){\n        return false;\n    }else{\n        return true;\n    }\n}\n</code></pre><p>例如，获取10的第二位：<br>    i=1, n=10<br>    1&lt;&lt;1= 10<br>    1010&amp;10=10<br>    10 is not 0, so return true;</p>\n<p>典型的位算法：</p>\n<ul>\n<li>Find Single Number</li>\n<li>Maximum Binary Gap</li>\n</ul>\n<h3 id=\"9-概率\"><a href=\"#9-概率\" class=\"headerlink\" title=\"9. 概率\"></a>9. 概率</h3><p>通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： </p>\n<blockquote>\n<p>有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）</p>\n</blockquote>\n<pre><code>public static double caculateProbability(int n){\n    double x = 1; \n\n    for(int i=0; i&lt;n; i++){\n        x *=  (365.0-i)/365.0;\n    }\n\n    double pro = Math.round((1-x) * 100);\n    return pro/100;\n}I\n</code></pre><p>结果：</p>\n<blockquote>\n<p>calculateProbability(50) = 0.97</p>\n<h3 id=\"10-组合和排列\"><a href=\"#10-组合和排列\" class=\"headerlink\" title=\"10. 组合和排列\"></a>10. 组合和排列</h3></blockquote>\n<p>组合和排列的主要差别在于顺序是否重要。<br>例1：</p>\n<blockquote>\n<p>1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？<br>例2：<br>有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？</p>\n</blockquote>\n<p>基于它们的一些常见算法</p>\n<ul>\n<li>排列</li>\n<li>排列2</li>\n<li>排列顺序</li>\n</ul>\n<p>来自：<a href=\"http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview\">http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview</a></p>\n"},{"title":"使用 Android Studio 内存分析工具","date":"2016-06-20T10:33:33.000Z","keywords":"AndroidStudio","_content":"\n\n### App的内存使用可以通过以下三个工具分析： \n- Heap Viewer\n- Memory Monitor\n- Allocation Tracker\n并且，这个三个是互补的可视化内存分析工具。\n\n1. 使用 Memory Monitor 可以查找非正常的 GC 导致的性能问题。\n2. 运行 Heap Viewer可以确认出 object 类型是不是 不必要的，或者分配的内存超出我们的预期估计，可能是持续增长，我们预期是在不需要的时候，可以回收内存。\n3. 使用 Allocation Tracker 可以确定出你的代码中存在的问题。\n\n### Memory Monitor\n![](http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_01.png)\n- 显示你的 App 当前某一时刻的内存状态（包括可用内存，和占用内存）的曲线图，用电压跌落 的方式展示 Garbage Collection (GC) 的现象。\n- 可以方便的看出 app 的卡顿是否是由于频繁 GC（内存 频繁回收，一个 app 在手机上分配的内存是一定的，但手机厂商决定手机内存的大小，因此当我们的 app 的内存达到一定的峰值的时候，系统就会回收内存，保证 App的正常运行） 导致。\n- 提供一种快速看出App 是否是由于 运行内存不足 而导致的 crash(崩溃)的方法。\n- 当前运行的app ，每一秒更新占用内存的状况。\n- 有助于识别潜在的内存泄漏。\n- 有助于识别 App 的 GC模式,并确定它们是否正常和你所希望的样子。\n- 它很容易使用，并且很容易看明白\n- 然而，Memory Monitor 不能告诉你哪些对象是有问题的，或者给你指出代码中存在的问题\n\n### Heap Viewer\n![Allocation Tracker](http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_02.png)\n- 根据类型 分配许多对象 的快照图。\n- 每一次的样本数据 是自动采集或者你手动触发。\n- 帮助确定哪些对象类型可能是内存泄漏。\n- 然而，你 **必须自己寻找** 在一段时间内曲线图的变化发送了什么。 （重点，需要**采集两次以上**的数据进行**对比**，才能明确，出问题的地方在哪里）\n### Allocation Tracker\n[![](http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_03.png)](# \"Allocation Tracker\")\n- 显示你的代码在在一定的时间内分配的 object 类型，Object 的大小，分配的线程和堆栈的大小\n- 帮助识别 内存的改变是通过 循环分配或重新分配。\n- 可以结合使用 Heap Viewer 来跟踪内存泄露，例如，如果你看到了一个 bitmap 对象 在 heap 上分配的大小。你可以使用 Allocation Tracker 找到它分配的位置。\n- 然而，它需要时间和经验来学习理解这个工具的使用。\n\n","source":"_posts/使用-Android-Studio-内存分析工具.md","raw":"title: 使用 Android Studio 内存分析工具\ndate: 2016-06-20 18:33:33\ncategories: AndroidStudio\nkeywords: AndroidStudio\ntags: AndroidStudio\n---\n\n\n### App的内存使用可以通过以下三个工具分析： \n- Heap Viewer\n- Memory Monitor\n- Allocation Tracker\n并且，这个三个是互补的可视化内存分析工具。\n\n1. 使用 Memory Monitor 可以查找非正常的 GC 导致的性能问题。\n2. 运行 Heap Viewer可以确认出 object 类型是不是 不必要的，或者分配的内存超出我们的预期估计，可能是持续增长，我们预期是在不需要的时候，可以回收内存。\n3. 使用 Allocation Tracker 可以确定出你的代码中存在的问题。\n\n### Memory Monitor\n![](http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_01.png)\n- 显示你的 App 当前某一时刻的内存状态（包括可用内存，和占用内存）的曲线图，用电压跌落 的方式展示 Garbage Collection (GC) 的现象。\n- 可以方便的看出 app 的卡顿是否是由于频繁 GC（内存 频繁回收，一个 app 在手机上分配的内存是一定的，但手机厂商决定手机内存的大小，因此当我们的 app 的内存达到一定的峰值的时候，系统就会回收内存，保证 App的正常运行） 导致。\n- 提供一种快速看出App 是否是由于 运行内存不足 而导致的 crash(崩溃)的方法。\n- 当前运行的app ，每一秒更新占用内存的状况。\n- 有助于识别潜在的内存泄漏。\n- 有助于识别 App 的 GC模式,并确定它们是否正常和你所希望的样子。\n- 它很容易使用，并且很容易看明白\n- 然而，Memory Monitor 不能告诉你哪些对象是有问题的，或者给你指出代码中存在的问题\n\n### Heap Viewer\n![Allocation Tracker](http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_02.png)\n- 根据类型 分配许多对象 的快照图。\n- 每一次的样本数据 是自动采集或者你手动触发。\n- 帮助确定哪些对象类型可能是内存泄漏。\n- 然而，你 **必须自己寻找** 在一段时间内曲线图的变化发送了什么。 （重点，需要**采集两次以上**的数据进行**对比**，才能明确，出问题的地方在哪里）\n### Allocation Tracker\n[![](http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_03.png)](# \"Allocation Tracker\")\n- 显示你的代码在在一定的时间内分配的 object 类型，Object 的大小，分配的线程和堆栈的大小\n- 帮助识别 内存的改变是通过 循环分配或重新分配。\n- 可以结合使用 Heap Viewer 来跟踪内存泄露，例如，如果你看到了一个 bitmap 对象 在 heap 上分配的大小。你可以使用 Allocation Tracker 找到它分配的位置。\n- 然而，它需要时间和经验来学习理解这个工具的使用。\n\n","slug":"使用-Android-Studio-内存分析工具","published":1,"updated":"2016-06-20T10:36:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ago001bxzex1bcbgny3","content":"<h3 id=\"App的内存使用可以通过以下三个工具分析：\"><a href=\"#App的内存使用可以通过以下三个工具分析：\" class=\"headerlink\" title=\"App的内存使用可以通过以下三个工具分析：\"></a>App的内存使用可以通过以下三个工具分析：</h3><ul>\n<li>Heap Viewer</li>\n<li>Memory Monitor</li>\n<li>Allocation Tracker<br>并且，这个三个是互补的可视化内存分析工具。</li>\n</ul>\n<ol>\n<li>使用 Memory Monitor 可以查找非正常的 GC 导致的性能问题。</li>\n<li>运行 Heap Viewer可以确认出 object 类型是不是 不必要的，或者分配的内存超出我们的预期估计，可能是持续增长，我们预期是在不需要的时候，可以回收内存。</li>\n<li>使用 Allocation Tracker 可以确定出你的代码中存在的问题。</li>\n</ol>\n<h3 id=\"Memory-Monitor\"><a href=\"#Memory-Monitor\" class=\"headerlink\" title=\"Memory Monitor\"></a>Memory Monitor</h3><p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_01.png\" alt=\"\"></p>\n<ul>\n<li>显示你的 App 当前某一时刻的内存状态（包括可用内存，和占用内存）的曲线图，用电压跌落 的方式展示 Garbage Collection (GC) 的现象。</li>\n<li>可以方便的看出 app 的卡顿是否是由于频繁 GC（内存 频繁回收，一个 app 在手机上分配的内存是一定的，但手机厂商决定手机内存的大小，因此当我们的 app 的内存达到一定的峰值的时候，系统就会回收内存，保证 App的正常运行） 导致。</li>\n<li>提供一种快速看出App 是否是由于 运行内存不足 而导致的 crash(崩溃)的方法。</li>\n<li>当前运行的app ，每一秒更新占用内存的状况。</li>\n<li>有助于识别潜在的内存泄漏。</li>\n<li>有助于识别 App 的 GC模式,并确定它们是否正常和你所希望的样子。</li>\n<li>它很容易使用，并且很容易看明白</li>\n<li>然而，Memory Monitor 不能告诉你哪些对象是有问题的，或者给你指出代码中存在的问题</li>\n</ul>\n<h3 id=\"Heap-Viewer\"><a href=\"#Heap-Viewer\" class=\"headerlink\" title=\"Heap Viewer\"></a>Heap Viewer</h3><p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_02.png\" alt=\"Allocation Tracker\"></p>\n<ul>\n<li>根据类型 分配许多对象 的快照图。</li>\n<li>每一次的样本数据 是自动采集或者你手动触发。</li>\n<li>帮助确定哪些对象类型可能是内存泄漏。</li>\n<li>然而，你 <strong>必须自己寻找</strong> 在一段时间内曲线图的变化发送了什么。 （重点，需要<strong>采集两次以上</strong>的数据进行<strong>对比</strong>，才能明确，出问题的地方在哪里）<h3 id=\"Allocation-Tracker\"><a href=\"#Allocation-Tracker\" class=\"headerlink\" title=\"Allocation Tracker\"></a>Allocation Tracker</h3><a href=\"#\" title=\"Allocation Tracker\"><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_03.png\" alt=\"\"></a></li>\n<li>显示你的代码在在一定的时间内分配的 object 类型，Object 的大小，分配的线程和堆栈的大小</li>\n<li>帮助识别 内存的改变是通过 循环分配或重新分配。</li>\n<li>可以结合使用 Heap Viewer 来跟踪内存泄露，例如，如果你看到了一个 bitmap 对象 在 heap 上分配的大小。你可以使用 Allocation Tracker 找到它分配的位置。</li>\n<li>然而，它需要时间和经验来学习理解这个工具的使用。</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"App的内存使用可以通过以下三个工具分析：\"><a href=\"#App的内存使用可以通过以下三个工具分析：\" class=\"headerlink\" title=\"App的内存使用可以通过以下三个工具分析：\"></a>App的内存使用可以通过以下三个工具分析：</h3><ul>\n<li>Heap Viewer</li>\n<li>Memory Monitor</li>\n<li>Allocation Tracker<br>并且，这个三个是互补的可视化内存分析工具。</li>\n</ul>\n<ol>\n<li>使用 Memory Monitor 可以查找非正常的 GC 导致的性能问题。</li>\n<li>运行 Heap Viewer可以确认出 object 类型是不是 不必要的，或者分配的内存超出我们的预期估计，可能是持续增长，我们预期是在不需要的时候，可以回收内存。</li>\n<li>使用 Allocation Tracker 可以确定出你的代码中存在的问题。</li>\n</ol>\n<h3 id=\"Memory-Monitor\"><a href=\"#Memory-Monitor\" class=\"headerlink\" title=\"Memory Monitor\"></a>Memory Monitor</h3><p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_01.png\" alt=\"\"></p>\n<ul>\n<li>显示你的 App 当前某一时刻的内存状态（包括可用内存，和占用内存）的曲线图，用电压跌落 的方式展示 Garbage Collection (GC) 的现象。</li>\n<li>可以方便的看出 app 的卡顿是否是由于频繁 GC（内存 频繁回收，一个 app 在手机上分配的内存是一定的，但手机厂商决定手机内存的大小，因此当我们的 app 的内存达到一定的峰值的时候，系统就会回收内存，保证 App的正常运行） 导致。</li>\n<li>提供一种快速看出App 是否是由于 运行内存不足 而导致的 crash(崩溃)的方法。</li>\n<li>当前运行的app ，每一秒更新占用内存的状况。</li>\n<li>有助于识别潜在的内存泄漏。</li>\n<li>有助于识别 App 的 GC模式,并确定它们是否正常和你所希望的样子。</li>\n<li>它很容易使用，并且很容易看明白</li>\n<li>然而，Memory Monitor 不能告诉你哪些对象是有问题的，或者给你指出代码中存在的问题</li>\n</ul>\n<h3 id=\"Heap-Viewer\"><a href=\"#Heap-Viewer\" class=\"headerlink\" title=\"Heap Viewer\"></a>Heap Viewer</h3><p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_02.png\" alt=\"Allocation Tracker\"></p>\n<ul>\n<li>根据类型 分配许多对象 的快照图。</li>\n<li>每一次的样本数据 是自动采集或者你手动触发。</li>\n<li>帮助确定哪些对象类型可能是内存泄漏。</li>\n<li>然而，你 <strong>必须自己寻找</strong> 在一段时间内曲线图的变化发送了什么。 （重点，需要<strong>采集两次以上</strong>的数据进行<strong>对比</strong>，才能明确，出问题的地方在哪里）<h3 id=\"Allocation-Tracker\"><a href=\"#Allocation-Tracker\" class=\"headerlink\" title=\"Allocation Tracker\"></a>Allocation Tracker</h3><a href=\"#\" title=\"Allocation Tracker\"><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/AS_memory_03.png\" alt=\"\"></a></li>\n<li>显示你的代码在在一定的时间内分配的 object 类型，Object 的大小，分配的线程和堆栈的大小</li>\n<li>帮助识别 内存的改变是通过 循环分配或重新分配。</li>\n<li>可以结合使用 Heap Viewer 来跟踪内存泄露，例如，如果你看到了一个 bitmap 对象 在 heap 上分配的大小。你可以使用 Allocation Tracker 找到它分配的位置。</li>\n<li>然而，它需要时间和经验来学习理解这个工具的使用。</li>\n</ul>\n"},{"title":"使用groovy读取excel里面内容","date":"2015-11-20T08:27:54.000Z","keywords":"groovy","_content":"# 使用groovy读取excel里面内容\n\n### 需要依赖\n[apache.org/poi](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n### 项目目录结构：\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_1.png)\n\n项目 assets 下面放了一个people.xlsx文件\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_2.png)\n\n### **PS**：\n- 本文依赖 [Groovy读取excel文件](http://blog.csdn.net/andyxuq/article/details/7916098) 尝试读取后，发现不能运行\n- 下载 Apache的POI组建 遇到问题\n\n### 项目的源码：\n\n\timport org.apache.poi.ss.usermodel.Row\n\timport org.apache.poi.xssf.usermodel.XSSFCell\n\timport org.apache.poi.xssf.usermodel.XSSFRow\n\timport org.apache.poi.xssf.usermodel.XSSFSheet\n\timport org.apache.poi.xssf.usermodel.XSSFWorkbook\n\t/**\n\t * Created by WangQing on 15/11/20.\n\t */\n\tclass TestGroovy {\n\t\n\t\n\t\n\t    void updateResourceDate(){\n\t        def filePath = \"./assets/people.xlsx\"\n\t\n\t\n\t        File file = new File(filePath)\n\t\n\t        FileInputStream is = new FileInputStream(file);\n\t\n\t        XSSFWorkbook workbook = new XSSFWorkbook(is);\n\t        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\t\n\t        //循环sheet\n\t        (0..<workbook.sheetIterator().collect {return it}.@size).each {s->\n\t            XSSFSheet sheet = workbook.getSheetAt(s);\n\t            int rows = sheet.physicalNumberOfRows;\n\t\n\t            //忽略第一行,标题行\n\t            (1..<rows).each{r->\n\t                XSSFRow row = sheet.getRow(r);\n\t                def cells = row.physicalNumberOfCells;\n\t\n\t                (0..<cells).each{c->\n\t                    XSSFCell cell = row.getCell(c);\n\t\n\t                    def name = \"\";\n\t\n\t                    switch (c) {\n\t                        case 0:\n\t                            name = \"A:\"\n\t                            break;\n\t                        case 1:\n\t                            name = \"B:\"\n\t                            break\n\t                        case 2:\n\t                            name = \"C:\"\n\t                            break\n\t                        case 3:\n\t                            name = \"D:\"\n\t                            break\n\t                    }\n\t                    print name + \"  \"+cell+ \", \";\n\t\n\t\n\t                }\n\t                println \"\";\n\t            }\n\t        }\n\t    }\n\t\n\t    static main(args) {\n\t        TestGroovy a = new TestGroovy();\n\t        a.updateResourceDate();\n\t    }\n\t}\n\t\n\n项目运行结果：\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_3.png)\n\n### Apache的POI组建 遇到问题\n首先进入网址：[http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_4.png)\n\n其中该项目中使用了\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_5.png)\nxmlbeans-2.6.0.jar\n\n这个文件在上面的 lib 下面。\n\n因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 \n\n*HSSFRow*  ，发现报错：\n\tRequest processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents\n\n\tPOIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(\"xxx.xlsx\"));\n\tHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n\n原因是：\nHSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls \nXSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx\n\n所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。","source":"_posts/使用groovy读取excel里面内容.md","raw":"title: 使用groovy读取excel里面内容\ndate: 2015-11-20 16:27:54\ncategories: groovy\nkeywords: groovy\ntags: groovy\n---\n# 使用groovy读取excel里面内容\n\n### 需要依赖\n[apache.org/poi](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n### 项目目录结构：\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_1.png)\n\n项目 assets 下面放了一个people.xlsx文件\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_2.png)\n\n### **PS**：\n- 本文依赖 [Groovy读取excel文件](http://blog.csdn.net/andyxuq/article/details/7916098) 尝试读取后，发现不能运行\n- 下载 Apache的POI组建 遇到问题\n\n### 项目的源码：\n\n\timport org.apache.poi.ss.usermodel.Row\n\timport org.apache.poi.xssf.usermodel.XSSFCell\n\timport org.apache.poi.xssf.usermodel.XSSFRow\n\timport org.apache.poi.xssf.usermodel.XSSFSheet\n\timport org.apache.poi.xssf.usermodel.XSSFWorkbook\n\t/**\n\t * Created by WangQing on 15/11/20.\n\t */\n\tclass TestGroovy {\n\t\n\t\n\t\n\t    void updateResourceDate(){\n\t        def filePath = \"./assets/people.xlsx\"\n\t\n\t\n\t        File file = new File(filePath)\n\t\n\t        FileInputStream is = new FileInputStream(file);\n\t\n\t        XSSFWorkbook workbook = new XSSFWorkbook(is);\n\t        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\t\n\t        //循环sheet\n\t        (0..<workbook.sheetIterator().collect {return it}.@size).each {s->\n\t            XSSFSheet sheet = workbook.getSheetAt(s);\n\t            int rows = sheet.physicalNumberOfRows;\n\t\n\t            //忽略第一行,标题行\n\t            (1..<rows).each{r->\n\t                XSSFRow row = sheet.getRow(r);\n\t                def cells = row.physicalNumberOfCells;\n\t\n\t                (0..<cells).each{c->\n\t                    XSSFCell cell = row.getCell(c);\n\t\n\t                    def name = \"\";\n\t\n\t                    switch (c) {\n\t                        case 0:\n\t                            name = \"A:\"\n\t                            break;\n\t                        case 1:\n\t                            name = \"B:\"\n\t                            break\n\t                        case 2:\n\t                            name = \"C:\"\n\t                            break\n\t                        case 3:\n\t                            name = \"D:\"\n\t                            break\n\t                    }\n\t                    print name + \"  \"+cell+ \", \";\n\t\n\t\n\t                }\n\t                println \"\";\n\t            }\n\t        }\n\t    }\n\t\n\t    static main(args) {\n\t        TestGroovy a = new TestGroovy();\n\t        a.updateResourceDate();\n\t    }\n\t}\n\t\n\n项目运行结果：\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_3.png)\n\n### Apache的POI组建 遇到问题\n首先进入网址：[http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_4.png)\n\n其中该项目中使用了\n![](http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_5.png)\nxmlbeans-2.6.0.jar\n\n这个文件在上面的 lib 下面。\n\n因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 \n\n*HSSFRow*  ，发现报错：\n\tRequest processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents\n\n\tPOIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(\"xxx.xlsx\"));\n\tHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n\n原因是：\nHSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls \nXSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx\n\n所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。","slug":"使用groovy读取excel里面内容","published":1,"updated":"2016-06-20T11:00:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agr001exzex8gitrmq9","content":"<h1 id=\"使用groovy读取excel里面内容\"><a href=\"#使用groovy读取excel里面内容\" class=\"headerlink\" title=\"使用groovy读取excel里面内容\"></a>使用groovy读取excel里面内容</h1><h3 id=\"需要依赖\"><a href=\"#需要依赖\" class=\"headerlink\" title=\"需要依赖\"></a>需要依赖</h3><p><a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\" target=\"_blank\" rel=\"external\">apache.org/poi</a></p>\n<h3 id=\"项目目录结构：\"><a href=\"#项目目录结构：\" class=\"headerlink\" title=\"项目目录结构：\"></a>项目目录结构：</h3><p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_1.png\" alt=\"\"></p>\n<p>项目 assets 下面放了一个people.xlsx文件</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_2.png\" alt=\"\"></p>\n<h3 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a><strong>PS</strong>：</h3><ul>\n<li>本文依赖 <a href=\"http://blog.csdn.net/andyxuq/article/details/7916098\" target=\"_blank\" rel=\"external\">Groovy读取excel文件</a> 尝试读取后，发现不能运行</li>\n<li>下载 Apache的POI组建 遇到问题</li>\n</ul>\n<h3 id=\"项目的源码：\"><a href=\"#项目的源码：\" class=\"headerlink\" title=\"项目的源码：\"></a>项目的源码：</h3><pre><code>import org.apache.poi.ss.usermodel.Row\nimport org.apache.poi.xssf.usermodel.XSSFCell\nimport org.apache.poi.xssf.usermodel.XSSFRow\nimport org.apache.poi.xssf.usermodel.XSSFSheet\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook\n/**\n * Created by WangQing on 15/11/20.\n */\nclass TestGroovy {\n\n\n\n    void updateResourceDate(){\n        def filePath = &quot;./assets/people.xlsx&quot;\n\n\n        File file = new File(filePath)\n\n        FileInputStream is = new FileInputStream(file);\n\n        XSSFWorkbook workbook = new XSSFWorkbook(is);\n        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\n        //循环sheet\n        (0..&lt;workbook.sheetIterator().collect {return it}.@size).each {s-&gt;\n            XSSFSheet sheet = workbook.getSheetAt(s);\n            int rows = sheet.physicalNumberOfRows;\n\n            //忽略第一行,标题行\n            (1..&lt;rows).each{r-&gt;\n                XSSFRow row = sheet.getRow(r);\n                def cells = row.physicalNumberOfCells;\n\n                (0..&lt;cells).each{c-&gt;\n                    XSSFCell cell = row.getCell(c);\n\n                    def name = &quot;&quot;;\n\n                    switch (c) {\n                        case 0:\n                            name = &quot;A:&quot;\n                            break;\n                        case 1:\n                            name = &quot;B:&quot;\n                            break\n                        case 2:\n                            name = &quot;C:&quot;\n                            break\n                        case 3:\n                            name = &quot;D:&quot;\n                            break\n                    }\n                    print name + &quot;  &quot;+cell+ &quot;, &quot;;\n\n\n                }\n                println &quot;&quot;;\n            }\n        }\n    }\n\n    static main(args) {\n        TestGroovy a = new TestGroovy();\n        a.updateResourceDate();\n    }\n}\n</code></pre><p>项目运行结果：<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_3.png\" alt=\"\"></p>\n<h3 id=\"Apache的POI组建-遇到问题\"><a href=\"#Apache的POI组建-遇到问题\" class=\"headerlink\" title=\"Apache的POI组建 遇到问题\"></a>Apache的POI组建 遇到问题</h3><p>首先进入网址：<a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\" target=\"_blank\" rel=\"external\">http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip</a></p>\n<p>下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_4.png\" alt=\"\"></p>\n<p>其中该项目中使用了<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_5.png\" alt=\"\"><br>xmlbeans-2.6.0.jar</p>\n<p>这个文件在上面的 lib 下面。</p>\n<p>因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 </p>\n<p><em>HSSFRow</em>  ，发现报错：<br>    Request processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents</p>\n<pre><code>POIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(&quot;xxx.xlsx&quot;));\nHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n</code></pre><p>原因是：<br>HSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls<br>XSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx</p>\n<p>所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。</p>\n","excerpt":"","more":"<h1 id=\"使用groovy读取excel里面内容\"><a href=\"#使用groovy读取excel里面内容\" class=\"headerlink\" title=\"使用groovy读取excel里面内容\"></a>使用groovy读取excel里面内容</h1><h3 id=\"需要依赖\"><a href=\"#需要依赖\" class=\"headerlink\" title=\"需要依赖\"></a>需要依赖</h3><p><a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\">apache.org/poi</a></p>\n<h3 id=\"项目目录结构：\"><a href=\"#项目目录结构：\" class=\"headerlink\" title=\"项目目录结构：\"></a>项目目录结构：</h3><p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_1.png\" alt=\"\"></p>\n<p>项目 assets 下面放了一个people.xlsx文件</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_2.png\" alt=\"\"></p>\n<h3 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a><strong>PS</strong>：</h3><ul>\n<li>本文依赖 <a href=\"http://blog.csdn.net/andyxuq/article/details/7916098\">Groovy读取excel文件</a> 尝试读取后，发现不能运行</li>\n<li>下载 Apache的POI组建 遇到问题</li>\n</ul>\n<h3 id=\"项目的源码：\"><a href=\"#项目的源码：\" class=\"headerlink\" title=\"项目的源码：\"></a>项目的源码：</h3><pre><code>import org.apache.poi.ss.usermodel.Row\nimport org.apache.poi.xssf.usermodel.XSSFCell\nimport org.apache.poi.xssf.usermodel.XSSFRow\nimport org.apache.poi.xssf.usermodel.XSSFSheet\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook\n/**\n * Created by WangQing on 15/11/20.\n */\nclass TestGroovy {\n\n\n\n    void updateResourceDate(){\n        def filePath = &quot;./assets/people.xlsx&quot;\n\n\n        File file = new File(filePath)\n\n        FileInputStream is = new FileInputStream(file);\n\n        XSSFWorkbook workbook = new XSSFWorkbook(is);\n        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\n        //循环sheet\n        (0..&lt;workbook.sheetIterator().collect {return it}.@size).each {s-&gt;\n            XSSFSheet sheet = workbook.getSheetAt(s);\n            int rows = sheet.physicalNumberOfRows;\n\n            //忽略第一行,标题行\n            (1..&lt;rows).each{r-&gt;\n                XSSFRow row = sheet.getRow(r);\n                def cells = row.physicalNumberOfCells;\n\n                (0..&lt;cells).each{c-&gt;\n                    XSSFCell cell = row.getCell(c);\n\n                    def name = &quot;&quot;;\n\n                    switch (c) {\n                        case 0:\n                            name = &quot;A:&quot;\n                            break;\n                        case 1:\n                            name = &quot;B:&quot;\n                            break\n                        case 2:\n                            name = &quot;C:&quot;\n                            break\n                        case 3:\n                            name = &quot;D:&quot;\n                            break\n                    }\n                    print name + &quot;  &quot;+cell+ &quot;, &quot;;\n\n\n                }\n                println &quot;&quot;;\n            }\n        }\n    }\n\n    static main(args) {\n        TestGroovy a = new TestGroovy();\n        a.updateResourceDate();\n    }\n}\n</code></pre><p>项目运行结果：<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_3.png\" alt=\"\"></p>\n<h3 id=\"Apache的POI组建-遇到问题\"><a href=\"#Apache的POI组建-遇到问题\" class=\"headerlink\" title=\"Apache的POI组建 遇到问题\"></a>Apache的POI组建 遇到问题</h3><p>首先进入网址：<a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\">http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip</a></p>\n<p>下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_4.png\" alt=\"\"></p>\n<p>其中该项目中使用了<br><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/groovy_excelgroovy_excel_5.png\" alt=\"\"><br>xmlbeans-2.6.0.jar</p>\n<p>这个文件在上面的 lib 下面。</p>\n<p>因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 </p>\n<p><em>HSSFRow</em>  ，发现报错：<br>    Request processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents</p>\n<pre><code>POIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(&quot;xxx.xlsx&quot;));\nHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n</code></pre><p>原因是：<br>HSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls<br>XSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx</p>\n<p>所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。</p>\n"},{"title":"一个五年Android开发者百度、阿里、聚美、映客的面试心经","date":"2016-07-08T04:13:29.000Z","keywords":"android面试,经验,经历,百度，阿里","_content":"\n\n### 花絮\n\n本文为完整版，加了一些彩蛋哦！文末有面试和必备的技能点总结。\n\n> 也许会有人感叹某些人的运气比较好，但是他们不曾知道对方吃过多少苦，受过多少委屈。某些时候就是需要我们用心去发现突破点，然后顺势而上，抓住机遇，那么你将会走向另外一条大道，成就另外一个全新的自我。\n  \n\n先简单说说我最近的面试经历吧。面试的公司很多，其中有让我心血沸腾的经历，也有让我感到失望到无助的经历，我将这些体会都记录下来，细想之后很值得，面了这么多公司，要是最后什么也没有留下来，那就太浪费了。至少对于我来说有些东西在整理总结之后才能得到一个肯定的答案。希望这些能对即将换工作或者打算看看机会的你有一些帮助。\n\n> 下文真的很长，你可以把这篇文章当做看小说一样，快速浏览一下，但是希望你能将文中提到的那些技能掌握。那也就不枉费我花了一两天时间专门整理这些。我的这些经验仅供参考，希望你能做的比我好，同时希望你在以后的面试中能轻松应对。\n\n### 为何离职？\n\n先从我的换工作的动机开始说吧。\n\n公司裁员的时候老大说:『你就留下好好干吧，以后不管公司怎么分股票、期权，肯定少不了你』。我非常信任我的老大，跟着老大一起工作，感觉是一种享受。\n\n但是没想到裁员后，公司内部大动荡，主业务线从客户端A 业务线转移到另外的B 业务线上。我主要负责A客户端的架构，这下可真闲下来了。B 业务线那边的业务量还是很忙的，没时间配合我做一些架构上的事情。于是我每天就看看资料，补充点能量。\n\n呆了几天后，就后悔当初没有拿 N+1 走，有一种被老大忽悠的感觉。 因为公司接下来的操作让我很是不爽，先是晚上打车不能超过30，然后福利大减，瞬间没有工作的心情了。再过了一两周后公司宣布新一轮融资成功，可惜只融到了 2千多万美元（按照预期应会更高），然后接着招新人。\n\n我特么无语了，站在公司的角度是没有任何问题的，可以节省开销，也可以容纳新鲜血液。但是我作为一个老员工，心寒，走的员工都拿到了 N+1，我们这些老员工什么也没有得到，反而福利大减，伤人啊! 现在即使我想走，什么也得不到，一种莫名的恼火涌上心头（只怪本人经历尚浅，看不清一些大的趋势，还是老鸟们聪明，拿钱走人，然后换一个新工作，好不自在啊）。\n\n不过理智分析一些这样确实有好处，可以给自己留很多的时间来选择更好的公司。就如此刻的我一样，在公司悠闲的上着班，骑驴找马，遇到合适的，可以立刻走。其实细想一下，如果我当时拿了 N+1 走了后，可能会迫切的需要一份合适的工作，然后迅速入职。至于新公司怎么样，还真不敢确定。\n\n已经动了想走的心，意味着再也不可能在这里很安分的待下去了。\n\n### 面试分级\n\n于是我决定开始投递简历（世界那么大，我想去外面的世界看看）。这次看机会与往常不同，我决定好好准备一番，然后开始投递简历，主要渠道是 “X钩”，辅助渠道是猎头。\n\n这次看机会我将所有公司分为三类： \n1. A类： BAT公司，非常靠谱，各项待遇都是很优厚的\n2. B类：一些知名的互联网公司（基本都在C轮以上），基本很靠谱，该有的都少不了\n3. C类：就是那些正在招聘的公司，没啥名气，虽然钱多但是事也多。靠不靠谱真还不知道，只能碰运气\n\n### 基础知识不可少\n\n以前我基本都是直接去面试，总以为Android工作好几年了，出去面试基本没啥问题，因此带着那份傲娇的自信 总是碰壁，尤其遇到很多基础性的问题，一时真不知道怎么回答？还有一些问题之前都记得很准确，但是在面试官问的时候，就一个大写的懵逼表情。\n\n在我出去面试之前，我已经把 《大话数据结构》 基本看完了（想想我之前的生活，每天早上七点多起床，然后看几页，洗漱完就去公司）。虽然没怎么记住，但是遇到这些相关问题，还是能很容易回答出来的。因为有了以前的教训，而且这次我也是很认真的准备了好久（可以说蓄谋已久啦，我心里其实很明白互联网公司可能存在很多风险，尤其是没有盈利的公司，唯有技术这东西必须牢牢掌握住，才能立于不败之地），因此我准备把Java基础巩固下，但是手头没啥合适的书籍和资料。\n\n还好民间有很多厉害的开发者，他们不以盈利为目的，只为完成某种需求，开发一款 app,然后发布到应用市场，给需要的人。于是我就找到一个 “Java面试训练” 的App,下载量还可以，就安装到手机上，开启刷题模式，应该刷了10来天吧（都是在上班，下班时间看一点，虽然时间比较零散，但是这样记得最深刻）。在之后的面试中，基本很少遇见一些奇葩的java基础。\n\n> 这里不得不提一件事，那就是从 app 崛起的那一刻起，就有很多的 中间商，一个小作坊的屋子里有很多电脑或者不知名的设备，屋子里慢慢的数据线，犹如蜘蛛网一样连接着很多设备，做着一些神秘的事情。不用我说你们应该也知道他们做着一些很肮脏的事情，我就不细说干什么了，简单举个例子：这群人的老大看中某个市场上某款游戏非常火爆，或者 app 特别的火，于是通过反编译等技术修改这些 app,然后重新打包上线到一些不是很知名的app 渠道或者小型应用时长，还有一些论坛，一旦有用户下载，就会在 app中弹出广告，在游戏中做各种充值操作，甚至在你无意间点到一个按钮就会自动扣除你的话费。这是前几年干的事情，新闻中也纰漏了很多，这里只能说监管不力。\n>\n><br>\n>但是随后各个公司都意识到这样的安全问题于是有了 app加固的技术，无法修改 app,即便修改了，但是也运行不起来，所以一定要注重安全性问题。\n\n### 刚踏入架构师之路的经历\n\n这次我给自己的规划是做一个架构师，但是我深知架构师可不是闹着玩的，必须要有很强的一面，因此我在简历里面写的只是“架构师方向”。我在K公司 做得是架构师方向，因此我觉得有必要朝着这个方向发力，虽然现在不是很厉害，但是坚持一两年后，即使不是非常厉害，但是也距离非常厉害很近（这里使用了《孙子兵法》的一句：“求其上,得其中;求其中,得其下,求其下,必败。” ）。\n\n这个想法来源于在K 公司我第一任leader曾经跟我说过的话：『对于新东西，如果你觉得掌握了，但是不应用到项目里面来，是没有什么意义的，时间长了还是会忘记的。』我很庆幸我有一个好老大（我是属于双领导型的，K 公司 A项目的负责人是我的leader，但是我的直接汇报对象是 K 公司的副技术总监，下文就成为老大），用他的话来说就是经常踢着我的屁股走。\n\n当我在网上了解到很多实用的新技术时，跟他随意吐露一句话，他就能非常用心的倾听我的想法，并鼓励我将这些东西带入到项目中来。从那以后我就开始看很多新技术，感觉合适的会引进到我们的项目中。从之后的证明中来看，是非常有价值的。\n\n曾经遇到的情况是这样的：当我刚进入K公司后，打杂一个多月，就被关到了 小黑屋（呜呜呜，好可怕的小黑屋，996的制度）。然后才开始正常的架构师之路，第一步就是统一开发环境，在我来公司后，我发现公司的android同事用的开发工具种类真是繁多啊，神马 Eclipse、IntelliJ IDEA、Android Studio、Windows、Ubuntu、Mac。刚进公司的时候我曾经用鄙夷的眼神看过那些 Eclipse 的童鞋，真是无力吐槽了。于是我给 老大说：『咱们的开发环境最好统一起来，现在各式各样的工具，弄个东西真费劲。』于是老大二话不说，就在群里跟大家吼，都务必切换到 Android Studio（以下简称 AS），由我来监督并执行。于是我拿着鸡毛当令箭，给大伙把地址什么的都找好，发到群里去，让他们自己下载（后期我们就搭建了 ftp服务器将这些常用的工具都放在里面，省的再去下载了）。 翻墙工具我使用 goagent（不怎么稳定），给其他人分享也太费劲了，因此让他们自己搞定。老大自己有一个 VPS，于是给大伙共享后，环境基本就统一了。\n\n> 期间有一个小插曲：\n> 一个年龄 比我大的同事在用 Eclipse，在我推广我的 AS 时，他说比较忙，没时间弄。我就急了，因为我刚到公司不久，老大分配给我的任务，推行不下去，这可不行啊，没说几句吵起来了。最后我也知道不能太着急，但是已经吵了，关系肯定不咋样，老大当时开会去了，我知道自己太心虚了，因此主动给老大承认错误，说我和那谁谁吵架了，因为他不用AS。最后在老大的劝说下，这个人就勉强切换到 AS了。\n> 其实这个人就是我之后的新Leader，每每想到这里我就全身发冷汗，Leader要虐你，你还能有好活路么？还好这个Leader人比较好，人也比较大气会处事，不怎么跟我计较。我已经对着佛祖忏悔了N多次。\n\n\n### 第一天面试\n\n我用 “X钩” 开始捡一些不怎么有名的C 类公司投递，很快就收到了很多的 面试邀请。\n\n##### 首次面试——国外输入法\n\n记得当时去的第一家公司是做国外做输入法的，做的还不错。从外面能看见一栋略微有点老的大厦，办公环境很一般。\n\n进去后很巧的是遇见了一个熟人，第一位面试官竟然认识我之前在X游的一个同事，然后我们就聊开了，他也没怎么难为我，就问了我几个很简单的问题，例如：handler的原理，多线程。我按照记忆中的样子说给他听，然后就第一关就轻松过了。\n\n等了一会，另外一个面试官进来了，问了一长串问题，基本就是 Android的相关的基础，然后第二个又轻松过了。\n\n等到第三关的时候，一个年龄稍微大的人进来了，很容易能看出，这个人应是该技术团队的负责人，问了一些工作经历后，然后问了一个最让我印象深刻的问题是：『你了解过Android上的黑科技么？比如Android 5.0 之上有一个辅助功能，如果用户开启后，就能像豌豆荚那样自动安装app,等同于拥有了root权限，但是手机重启后，这个就自动关闭了，有没有办法可以自动打开呢？』据他了解，有很多不知名的小App 都实现了，但是很多大公司都没用。 我想好好一会，说可能这些app 被厂商列入了白名单，因此重启手机后还能自动打开那个辅助功能。我实在想不出如何能实现这样的效果。最后他告诉我，其实他们也是分析了好久，才发现，那些小App, 都是开启了一个进程（或者是service，具体记不清了，有兴趣的童鞋可以试试）来守护，因此能够开启。这么一说，我也瞬间明白了。\n\n但同时我提到这样做会可能会导致耗电量增加啊，对方的一句话把我真雷住了。“那能费多少电。。。” ，我瞬间无语了。但是他们可能因为某些需求必须如此做，因此要实现这样的功能，相对于电量来说应该也能接受，不至于比什么都玩不了的强，体验也确实提升了很多。不用用户每次去开启那个开关，虽然有点风险，但是相对于Android上的风险来说，确实低很多。\n\n等第三轮面试完成后，然后Hr 小妹妹带我到一个很大的会议室，见到一个很年轻的人，听Hr说，这个人应是CEO之类的，反正职称很高。他就问了些职业规划，平时有什么兴趣爱好，以后有什么打算，薪资要多少？我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。平时就看看书，参加沙龙活动，没事打打游戏。他也简单回答我一些问题。之后就是让我先走，等通知。\n\n傻傻的我还就这样高兴的走了，因为我总体感觉还是很棒的，毕竟连过4轮哈。从最后的结果中能明白，其实应该是要的薪资太高了。为什么这么说呢？因为一般情况下，最后一轮就是简单看看你这个人怎么样，技术关肯定没问题，否则前三关就 pass 了。可能对方觉得你要的薪资和你的实力不符合，也可能他们想再对比看看，选择一个更合适的人选。\n\n##### 58到家\n\n从上一家公司面过后，我就紧接着去第二家公司 58到家，在大屯路东地铁站附近。到了后刚好12点，电话联系后，他们说班车司机都午休去了，要等到2点才能过去（58到家面试需要从地铁站做班车过去，路程还算能接受的）。然后我就吃了点饭，在附近网吧 撸一局，看时间点差不多了，我就去那块坐车了，差不多走了5分钟做就到了。\n\n北苑路北美国际商务中心，这块有很多公司，什么珍爱网之类的都在那附近。\n\n第一轮面试我的是一个小伙，问了一些基本的Android基础，然后问了一下 android的绘图原理，我说： onMeasure, onLayout, onDraw。 然后他说每一个什么作用？ 那个onMeasuer主要做什么的？并举了一个例子：一个自定义的滚动View A里面如何放另外一个滚动的View B？我说把 View B将 onMeasure 里面的高设置成最大，这样就能解决冲突问题。最后他简单说了一些 onMeasure 里面的几个参数，我对此加深了解了。\n\n第一关也就这样过去了，等到第二关的时候看起来一个挺帅气的男人带着一个很显眼的婚戒跟我说一些项目流程上的东西，因为我在K 公司这块跟老大接触的比较多，因此一般问题难不住我，轻松就过了。\n\n等到第三关的时候，问我一些工作经历，然后问问职业发展规划，平时的兴趣爱好，以及你觉得得你和其他人有什么优势。我挺好奇的，为什么最后的这些面试官都要问类似的问题，之后从一个关系还不错的猎头那里了解到，其实他们也就是了解下以后的动向，以及看看这个人的人品。关于优势我是这么说的：我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。其实和上面的回答一样，这基本就是所说的套路。他们可以用套路，我们为何不可呢？ 嘿嘿，别学我，自己根据实际情况来。\n\n本以为就结束了，没想到他们说 CTO不在，可能还有复试，先让HR大美女跟我谈谈。HR慢条斯理的跟我说了一些待遇什么的，了解了下我的状况，问我要多少。我基本和上一个公司说的一个样。\n\n之后再来复试的时候，这个大美女HR给我了一些建议，说这个CTO是阿里出来的，喜欢会说话的人，想到什么就说什么，别紧张。在这面的时候，我就很放松，该怎么说就怎说，他也问了一些职业发展规划，以及我的经历，基本10来分钟就结束。我只想说大美女 HR 真真是体贴入微，感觉很 Nice, 这轮基本也顺利过了。之后这个HR直接说我被评为T5，但是以后可以继续努力，我也欣然接受了。不管怎么样，反正拿到offer再说，之后慢慢对比。\n\n##### 楚楚街\n\n说起这第三家 楚楚街 我就一肚子火，也不是说第三家不好，只是在去的路上让我备受折磨。从大屯路东 到 知春路，坐地铁应该几十分钟就到了。当时已经快四点了，5点面试，然后我就打算坐车去（不想再挤地铁了，想轻轻松松的过去），特么的为了省那几块钱，我选择拼车，在路上本以为只需要最多一个小时就到，没想到花了我1个半小时(只能感叹北京的车真多，路上堵的不行不行的)。哎，到他们公司的时候都快6点了，还好我提前在电话里和HR说过，他们说6点也是可以的。于是第三个面试就开始了。\n\n首先过来第一位面试官，看样子应该是 Android 技术 leader，开始问了我一些基础的面试题，比如：View 的事件分发机制，View的绘图，ListView 的实现原理（这个应该是几年前面试的时候经常问题，没想到现在也能遇见）。聊了好一会，然后他拿出他们的客户端给我演示了一个页面，说这个界面比较卡顿，让我分析下原因。我看过后，提出了几个有效的检测卡顿的方案，他们的这个界面主要是Listview 的 item 里面包含了一个 viewpager，然后 viewpager 的 item 里面有一个大view, 上面有N 多图片 + 动画效果，因此实现起来很麻烦,最后导致性能卡顿（不得不说产品同学，你的想象力真丰富啊，有没有考虑过研发同学的心情）。然后，他感觉得到了共鸣，因此接下来说话就比较放松了，他说和我年龄差不多，感觉我还是很厉害的（我不禁惶恐不安，我感觉还行，但是应该不是他说的很厉害，可能只是工作时间长了，该积累下来的东西大部分都有了），互留了微信，方便以后的交流（事实是没有啥交流的，只是当你面试通过后，可以有一个拉你入伙的渠道，嘿嘿，不晓得对不）。\n\n第二个进来的面试官长得挺帅气的，手上戴着戒指（之所以提到这个，是因为在我在我的印象中这个最亮眼，很多次在和他交流的过程中，我都比较紧张，我就盯着这块看用来放松，说真的如果看着对方的眼睛，双方可能都不会自在，当然除非你很有自信的时候是可以的）。开始简单问了下工作经历，然后就开始聊技术，第一个就是问我知道不知道 二分法，我当时楞了一下，猛然间反应不过来，最后专门确认问了下是不是 二分查找。然后我说在一个数组里面每次查找的时候从中间点开始对比，大于就右边找，小于就左边找，顺带提了一句这要在一个顺序的数组里面。然后面试官就说，二分查找还得每次先排一次序？我当时说是的，结果就感觉很2，可能没理解清楚面试官表达的是什么或者说我的表达有问题，其实我想说最开始的数组就是一个有序数组，但是面试官可能误解了我的意思，以为每次查到后，都要先排一次序（只能说悲催啊）。\n\n这个问题过了后就再问了我一个问题：『你来说说 Java 的内存管理。』这个问题在一两年前上就栽过跟头，所以当时专门看过相关文章。但是当我回答的时候，由于长时间没怎么看过了，记忆有点松动，大体的说出来了，但是不够准确（回去后就好好补充了下，在之后的面试过程中遇到的概率还是非常大的，尤其在第二面的时候）。然后他问我要多少薪资，我当时说 XX，然后他就问我是不是可以低一些呢？我开始说可以低一点，但是当他问低多少的时候，我心想上面两个公司的 offer 基本感觉到手了，这个可以适当的要高点，能给就来，给不了那就算了（我事后想想才明白，这种2B 的想法绝对不能有，要时刻保持低调，把握住任何一次机会）。最后他说，我得对得起兄弟们（怎么说呢？估计是刚回答的时候不是特别的满意，还有感觉我要的太高了），你这个薪资我没法跟上面谈。然后可想而知，当然肯定没有结果了。\n\n因此奉劝各位，要时刻保持低调，谦虚谨慎，莫要装B，否则肯定遭雷劈，我这就是一个活生生的例子。\n\n### 第二轮B 类公司面试：\n\n面试有很多，说起来可能会长篇大论，以下就总结性的说说，不再说明具体细节，只说我们之后在面试的时候应该注意的地方，以及他们对应聘者的要求。\n\n##### 映客 && 蘑菇街\n\n映客直播在望京soho,很高大上的地方，t1,t2,t3分别对应从低到高的大楼。到公司后，感觉还可以，第一个面我的人是一个技术，基本就问到一些Android 的面试题，没有任何悬念就过了，第二面的时候，感觉那个人还是比较随和的，问了 Java 内存管理的东西，以及一些其他的问题，最后还都聊得挺开心，第三面的时候直接就是 HR谈薪资，很容易就过了。\n\n在望京 soho 还去过 蘑菇街，里面的人技术比较好，我当时过去的时候已经6点了。那个面试官就跟我聊人生理想，提到一些 Android系统原理性的东西，但是感觉回答的不是很好。面试官感觉还是很不错的，然后给我说你以后要多看看例如 handler 原理，windowManager 的东西，并且从源码上去分析，网络上的理论知识还是要结合实践的，真是受教了。这部分我有点弱，虽然知道原理，但是看过源码的东西还是很少的，以后需要注重补充。他说他才是高级，我要应聘的这个 架构师肯定是不行的，问我是否愿意做其他的，我当然表示愿意了，现在要综合提升能力，才能往更高层走。\n\n最后的最后，他很搞笑的跟我说：『我这人真不骗人』。我还纳闷啥意思，最后他说：『今天已经很晚了，第二轮的面试官不在，我明天给你向上反馈下（从之后的一个同事的口中才明白，一般说第二轮的面试官不在，基本就是说你没戏，很委婉的一种说法而已）』。\n\n结束后我看了一下表，我晕，一面就面试我了一个半小时，真特么无语了。不过收获还是很大的，知道自己的不足后，就知道需要补充哪些东西了。\n\n##### 乐视\n\n去了一趟姚家园的乐视，只能说看着挺风光的，但是进去后，特么的真虐人。\n\n电梯分区，还只能在一边的乘坐，很不赶巧的是我去的时间刚好是10点，对于他们公司来说这就是高峰期，电梯根本排不上队，而且乱糟糟的（之前在X游的时候，大家都是排队的，这边没有，可能地方太小了，排不开吧）。电梯上不去了，看来只能跟一些人爬楼梯，一直爬到9层，感觉都喘不过气了。\n\n上去后一个很美的 HR（长腿姐）带我找面试官，然后表示没有会议室，原来的会议室都变成工位了，所以让我先在一个小角落呆着（保洁阿姨的专属位置），过了好一会面试官姗姗来迟，也是一些非常基础性的东西，最主要的是他们提到了推送，怎么实现，已经存活情况说了一些。\n\n第二个面试官也是特么来得晚，等了 N 久，闲的无聊就和保洁阿姨聊天，顺带看看他们的办公环境，只能说真心挤得慌。第二位面试官来了后就看看我的经历，因为第一轮的技术面都过了，因此简单聊了下，就说说他们的发展前景，要做海外产品。听我的兴致勃勃，很开心，然后让我等会。\n\n他们基本都去吃饭了，留下了我在那里干等，然后来了一个HR 的小妹妹，跟我谈薪资以及经历，貌似对我一两年换工作有很大意见，哥就好好给她普及了一番互联网界的基础知识。没想到就在快要搞定的时候，这个小妹妹的老大过来了，然后就看见一个身材超棒，腿很长的漂亮姐姐 HR（长腿姐），坐在我的对面（小妹妹示意我这是她的老大）。瞬间不爽了，都马上谈完了，结果换人再来，真无语了。只能将刚刚的辉煌时刻再来装 B一次，然后谈薪资神马的，给的也不是很多，我要 XX，她说那么多，只能给我薪资范围最低的一个档次。好吧，就接着吧，然后非要我先填写一份背景调查表，如果没有问题后，才给我发 offer，我看到美女拿着那份很大的 纸张，瞬间无语了。\n\n我当时就不怎么开心，然后长腿姐毕竟老练的很问到：『说你是不是有事？』。我说是的，待会1点还有其他地方的面试，然后她说：『那你先回去吧，这个表格发你邮箱，你写好后发给我。』然后长腿姐就送我出去，我又特么的一路爬楼梯下去（9层啊），电梯等了 N 久都下不去。\n\n### 接下来说说几个有意思的公司\n\n##### 新浪\n\n新浪位于理想国际大厦，记得几年前去新浪面试的时候，傻傻的都没准备就去了，结果第一关就挂了。\n\n这次是下午去，外面还飘着毛毛细雨。去了后竟然特么的让我做面试题，哥已经不做面试题很多年。但是想起了之前的经历，还是老老实实写写，据我估计面试的哥们应该会问上面的东西。还好这次做了万全的准备，刷了 N 多面试题，补充了基础的数据结构理论知识。写起来如行云流水，嗖嗖嗖的没几分钟就完了。\n\n第一个面试的哥们看看卷子，没啥意见，然后问最后一道纠错编程题有没有什么问题，我虽然指出了几个错误，但是感觉他还不是特别满意。因此我仔细看了下，原来是一个静态变量引用了 Activity 的上下文,然后指出，他再问了一些偏底层的东西以及性能优化的地方，轻轻松松就过了。\n\n等到第二面的时候，这个人一看就是技术大牛，问了很多 Java 层面的东西，多态，抽象类，多线程，内存管理等等。我感觉回答的不是太好，多态那有点问题，其他的应该还可以。\n\n然后就进入了第三面，第三面的面试官应该是部门负责人，问了工作经历上的事情以及兴趣爱好，之后的发展方向，想做什么层面的。最后很不幸的是在等待第四面的时候，最开始给我题的美眉告诉我时间很晚了，让我先回去，之后等消息。\n\n至少这次来比第一次高级了很多，不至于第一轮就被刷下去。最后分析了下原因，还是薪资要的太高了，尤其是这类公司。\n\n##### 滴滴\n\n滴滴位于西二旗，应该有两个办公地点，其实我一直很想去滴滴，福利待遇很不错。一年前去过一次，很可惜在第一轮的时候，因为在某些适配方面回答的不是太好，因此失去了机会。\n\n这次已经准备很多了，进来后还是在去年的位置上坐下等面试官。说实话感觉滴滴成长的很快，办公环境都变的更漂亮了，哈哈哈。\n\n这个面试官一看就是一个技术宅，开始对我各种炮轰。面试题一个接一个的，在我连续回答十来个题后，看见他还在问，记得在提及到 volatile 的作用的时候，我就开始不爽了，这个东西记得之前在源码里面见过，但是具体的一时说不上来，看着他那样子，埋头在纸上给我出题，我就不怎么配合了。面试了那么多家，就你问了 N 多问题，还有完没完了（其实这也算是抗压的一种面试方式）？我直接说不知道，然后他再问了几个基础性的东西，我想都不想直接说不知道，他貌似已经看出来我已经很不爽了，然后说，那你说说你项目中有没有比较 NB 或者比较有亮点的地方。我的回答直接是：没有。然后他也就不怎么问了，说那先这样。我说：好，就这样，我先走了。 然后潇洒的离开滴滴。\n\n现在想想真特么的很2B，应该低调低调再低调。也可能是那天下午太累了，上午面试了两家，而且已经拿到两家的 offer 了，还都不错，在这特么憋屈，才表现的如此差劲。其实对于问题，知道的话就好好说，不知道的话，可以说说思路和想法，然后说说以后会怎么做，利用迂回包抄策略去应答，准没错。至少给面试官知道你还是可以动脑子的人。\n\n在此我真心后悔当时的冲动，向滴滴那位面试官表示歉意。其实不用那样的，我们只需在面试的时候尽力表现自我就可以，以后切莫带着情绪去看待或者回答问题。\n\n对于人生中的很多问题也是这样的，这次栽倒坑里去了（用我老大的话来说，你不在这里踩坑，总有一天也会在另外一个地方踩到，到时候的损失就不可估计，趁着年轻多多历练自己），总结之后才能更近一步。\n\n##### 百度外卖\n\n百度外卖现在已经不属于百度了，而是单独分出来。\n\n我的一个同事去了百度外卖，我感觉他的能力和我差不多，我就让他推荐了。\n\n去后，上了一个很长的台阶（感觉很庄重的样子），要刷卡才能进去。等了好长时间，面试官把我领到楼下的公共办公桌，就是那种中间空地，周围都是楼层，能看见其他人在楼层间走动。一个年龄见长的面试官，开始感觉挺随和的，然后说跟我聊聊 Android 基础。\n\n第一个问就是：『咱们先来谈谈 Android 的四大组件。』我彻底懵逼了，尼玛，跟我谈四大组件，有意思么? 没想到一直到最后都跟我谈这些，一个接一个的问。说到广播那块，关于一个 app 被杀掉进程后，是否还能收到广播的问题纠结了好久。\n\n然后让我画我之前设计的架构图，我就随便画了画，但是没想到这个看起来很好的面试官让我大跌眼镜，他用鄙夷的笑容告诉我：『你这也太初级了。』我当时心里有几万只草泥马在崩腾，你都30+了，就不知道鼓励新人啊，我都说过我刚做架构的时间不长，而且鄙视我，有本事你也弄一个架构给我看看啊，一点不尊重我们年轻一辈的劳动成果。也许就怪我当时我真就按照他说的草草画几笔吧，没怎么认真对待。我去其他公司面试的时候，虽然这个图不怎么样，但是至少能解决 某些领域的问题，其他面试官都很谦虚。这个百度外卖的面试官，真不是我喜欢的领导，如果以后真让他来带我，那就真完蛋了，很多时候我们都是因为某些人扼杀了我们最初美好的萌芽，而从此失去了创新的意识。\n\n很庆幸的是我在 K 公司的时候，老大一直鼓励我创新，遇到想做的就去做，所以一路下来，虽然很累，但是干的很开心。\n\n所以每当有人问当初为什么选择K 公司的时候，我都会自豪的说：『我的老大很不错，我在那里很很舒服，很开心』。记得在我离开的时候老大给我最后劝告就是：『你要时刻反思自己此刻是不是已经被别人洗脑了。』\n\n\n### 第三轮：\n\n##### 1.百度\n\n百度位于海淀区上地十街附近，有很多大厦。 我去的是一个做国外工具的部门，去了后，被百度的环境和氛围震惊到了，在一个很大的技术园区，有网易，百度，腾讯公司，对面还有一个大楼正在修建，估计会是另外一个互联网公司的场地。\n\n进入大厦里面后，由于还没来得及吃饭，边吃手里的饼，边浏览下百度的外围办公区。进入百度的大楼后，两个入口都设有刷卡机。\n\n在空闲区等了好一会，然后一个人带我进入大厦。在进去之前，到前台那块面试官输入自己的邮箱账号，然后让我填写其他登记信息，我印象最深的是显示器上边贴着一个纸条，说：请离开的时候在此登记，否则会进入百度的黑名单（意思就这样，具体记不清了）。当时震惊了半天，没想到竟然这个严格。\n\n和面试官进入大楼里面后，只记得的印象是：很整洁，高大。出楼梯后，脚踩着厚厚的地毯，稍微走快点，都感觉很松弛，脚下如踩棉花一样。\n\n为什么有地毯，而不是地板砖————到了夏天很多漂亮的长腿美女穿着高跟鞋踩在地板砖上是一个怎么样的体验呢？噔噔噔...... \n\n我在等候区等到第一个面试官，然后我们简单聊了下 Android技术，其中有两点有必要提下：\n\n- 其中一点是：说说 View 的事件分发机制。然后我就说了好多，从 WindowManager-\\>window-\\>Decorview-\\>子 view。最后我说当所有的 view 都不处理事件，事件会最后会传递到 Activity 的 onTouchEvent 上。然后面试官立刻说：『哈？你这是颠覆我的三观啊？』 然后我意识到可能有问题，但是记得 《Android 艺术开发探索》上确实写过到 Activity，但是不是到 onTouchEvent还真没底。面试官很自信的样子，让我颤抖了。但是随着我的坚信，面试官说：『不行，我不能冤枉你是不！』立刻在手边的 MBP 上看了一下，自言自语感叹道：『还真有啊！』 我顿时无语了。\n\n- 另外一点是：问我 Service 上能不能弹出对话框。对于这个问题，我印象最深刻了，记得一年前的时候，在另外一个公司就因为这个问题让我尴尬万分，回去后专门对这块进行补充。我的回答是可以的，但是面试官面带差异的表情告诉我这是不行的，Dialog 必须要依附于 Window 才能显示出来。然后我的解释会让面试官郁闷一会：我说这个是可以弹出的，我之前也专门试过，不过他弹出是有条件的。 条件是：\n\t- 必须在 Manifest 里面注册系统权限\n\t- 在显示 dialog 的时候必须要加一个 flag.\n\t我的理由是：系统对话框可以在低电量的时候弹出对话框，我们同样也可以采用该方式来实现。\n\n面试官语塞，然后给我说 Dialog 是必须要依附在 Window 上，Toast 其实也是一个 Window。我听着这些话，就想起以前看过的一篇文章上也确实是这么说的。估计该面试官回去要好好补充下一些知识了哦。 然后该面试官让我不能用 Arraylist,用数组 写一个队列。这块刚好我在之前项目中特意用了一下，写的时候，主要有三个方法： put(), get(),peek(). 然后考虑下队列的特性，一端进入，一端出去。我当时遇到了盲点，没怎么写完，最后给面试官说了下思路，大体是对的。但是关于选择位置那块没怎么想好。不过这不阻碍我进入第二轮。\n\n第二轮面试的时候，面试官带了很多纸张，我瞬间压力山大，知道不太妙。不出所料，这个面试官，从动画实现原理，到 handler 实现原理，一步步深入各种原理，当我感觉回答的不错的时候，然后他就顺着我的问题继续深入。我只能说我尽力了，有些东西，平时开发的时候真心不注意，但是就因为没有留意，所以就没法继续回答他的问题。\n\n面试官把我带出大厦的那一刻，我心情很不好，很可惜没进入百度，之后应该需要准备很多东西。我要说，我还会再来的，哈哈哈！ 最后也归还身上的一个牌子到前台后，省的被拉入到黑名单（好吓人的样子）。\n\n以后有时间多看看原理性的东西，最好整理一个自己的博客，写上自己的一些看法和感悟，这样记得最深刻，即使几年后也不会遗忘，只是看看别人总结的东西，真的就不怎么记得住。\n\n关于博客可以使用 Hexo, 我的博客也是如此，可以整理一些自己的东西与心得。\n\n### 2.阿里\n\n这次去的是一个阿里的高德部门，在望京 Soho 附近的 首开广场。去了以后首先找厕所，你们知道么？厕所竟然从大厦楼层的的一个角转了一大半圈才找到，回来后进入找不到前台了...... 瞬间无语了。问了好一个美女才回到前台，然后接待我的 HR美女貌似等得不太耐烦了（宝宝心里苦，厕所好远，都找不到回来的路了）。在一个小型会议室等待面试官，看了下布置氛围和环境，感觉太棒了，很多东西都体贴入微。\n\n> 回顾上次阿里的悲痛遭遇\n> <br>\n> 其实这是我第二次来这边面试了，上一次过来的时候，是刚过完年。提到这里我就苦不堪言，为何如此说呢？当时是2016年2月15日，因为我参加好朋友的婚礼（不得不说，我这个年纪的人都开始结婚了，这次回去有4个好朋友都结婚，可想而知，一场完了以后还有另一场，虽然累，但是值得）推迟了好几天才回北京，在参加同学婚礼的时候接收到阿里高德部门的面试邀请。回到北京的当天是12点多，然后回家，一个关系非常好的朋友说今天她们要宴请公司的人吃饭，因为她们结婚了，让我帮忙弄个 MTV。我想这是朋友的终身大事，因此必须要好好干。\n> <br>\n> 我下午4点是阿里高德的面试，因此时间很紧促。我凭借我大学的技能在两个小时内搞定这个 MTV，总体来说还不错，就迅速发给朋友，弄完已经3点了，然后打车立刻去首开广场。\n> <br>\n> 高德的面试是4点钟，匆匆赶到后，就等待面试官。面试很不理想，因为什么都没有准备，而且心力憔悴。面试官问的是一些基础的 Java 问题，很可惜我没怎么回答好。于是就深深的浪费了一次机会，之后和朋友提起此事，无比后悔，当时其实是可以和 HR 电话再约一个时间的。\n> <br>\n> 这次对我的打击很大很大，因为这是我这么多年第一次面试 BAT 的职位，一上来就受挫，很不是滋味。**我在这里失利后我就各种准备资料，增强自己的能力，面试前必须要刷题，虽然简单，但是不失为一种方法，虽然不一定有用，但是会加深印象，尤其是去 BAT 这些公司，一定要准备好，否则就别浪费机会，这就是我的教训和经验。**\n> <br>\n> 为了6月份的这次面试策划了很久。以前对什么可能都不是很上心，但是这个事件深深的刺激我了。\n\n第一个面试官来了后问了一些基本问题，很顺利就进入到第二轮面试。\n\n第二轮也基本是技术面试，问了一些 Android 基础和 Java 基础以及内存管理。\n\n第三轮的面试官应是部门负责人，看起来很好说话的，问了一些经历和基本情况后，问我薪资要多少以及之后的发展方向。我说要 XX，之后希望在架构方面发展，但是也可以从业务开始。貌似这里回答的不怎么好。然后让我留了他的联系方式，我知道很有戏哦。\n\n因为我在进入 K 公司的时候也是这样的，老大感觉我很不错，于是留了微信后，我基本就顺利入职。\n\n回去后的一两天还是很焦虑的，但是我知道大公司都是有流程的，因此我告诉自己不要焦急。过了一两天后他主动加我微信，然后问了些基本情况后，就说他要做最后的总结，让我等着，最迟一周后就有消息。我感觉希望超大的，开心了好久，本以为就可以这样过去。但是一周时间过去了，没人通知我，我开始焦急了，于是我开始主动和他说话，反思自己是否有什么地方做的不好。\n\n经过很多面试后我总结出了结论就是要薪资太高了，于是我在微信里面给他说，只要能过去，薪资低点也是可以的。但是问了他好几次，他都没有回话，看着微信消息记录，都是我发给他，而他没有回复，已经过去好多天了，我知道没希望了，他说不管怎么样都会给我回复的，但是我真绝望了。\n\n就像相亲一样，遇到一个不错的美女，开始都一起聊得很不错，她开始加你好友，并且和你说看好你，不管能不能做女朋友，她之后一定会回复，但是苦苦等待一段时间后，不管你怎么给她说话，但是她就是不理你。可能她真的忙，但是也不可能连续一两天都这么忙吧。于是你知道没结果，因为无言等同于没有希望。为了避免一些幻想的存在，你会将她删除掉，不想留下任何关于他的信息。\n\n同样我也是把这个阿里高德的老大的联系方式删掉，微信也删掉。在我失去希望的时候，过了几天看见他要主动加我，但是我想可能只是安慰的话语，最多告诉我，我不适合他们的职位，因此我为了避免尴尬，直接删除那个加我好友的请求（如果说真的合适的话，应该会很重视你的，不可能好几天都回复，怎么有一种备胎的感觉，呜呜呜，我不想被发好人卡，宁愿做高傲的兔子，也不想做纸老虎，虽然尽管只是纸老虎，但是也会拥有属于它的一片森林）。\n\n于是阿里的这次机会就失去了。\n\n总结后的结论就是：去大公司要的薪资不要太高，否则对方只能感谢你的到来，因为比你优秀的人太多了。\n  \n\n### 聚美优品\n\n聚美优品 位于东四十条地铁站附近。路过一个竹亭子后，进入大厦里面需要用身份证在前台那块登记后给我一个纸条，上面写着我的身份证信息，然后在门禁卡附近刷二维码进入（真担心个人信息泄露哦，当然一般情况下没人会关注你是谁的，千万别干坏事哦，会被查出来的，哈哈哈）。\n\n推荐我去聚美优品的同事接我上去后，带我到前台填写基本信息。我只写了最基本的信息，然后她说，你就写这么点啊。我说，其实这些信息够用了，写那么多没用，还会暴露你的个人信息。面试成功后，如果有需要可以写详细些，但是一般去面试最好别写身份证信息。工作经历基本也只是最近两个，之前的就不用写了，写那么多没什么用，简历中都会有的。\n\n记得刚工作那会，傻傻的全写了，真耽误了不少时间。过了一会，她把我交给 漂亮的HR 温柔姐，然后就先忙去了。温柔姐告诉我一般情况下有两轮基本就过了，先让架构师老大直接面我，让我先等候。\n\n过了一会温柔姐不好意思的跟我说架构老大先让一个技术面我，问我是否有意见，我当然没意见了，这是很标准的面试流程（如果你有意见，建议还是别说太多的话，基本都这样的，要淡定）。\n\n一面技术给我一种很成熟的感觉，开始问了我一些基础技术问题，外加 Java 内存管理知识。后给我出了一道算法题，说有一个数组最多存储6个数，如果有普通用户的话，存储四个 vip的客户，另外两个是普通用户（留出一定的空间给普通用户），让考虑全面点（一般都是结合实际场景，让你写出一个算法，要具备的能力就是抽象，处理问题的思路与细节，还有最基本的编码功底）。\n\n然后我就考虑各种情况，第一种是非空情况，然后下面就是几个大的 if else, 至少四个条件，基本涵盖了全部情况，然后每个条件里面写上对应的存储数据的过程。由于我的四个大条件都把距离占的差不多了，在写里面细节的时候，用中文描述。过了一会他回来后，看了下说：『你这个还有中文啊！』 我尴尬的笑着说：『我先写条件的，最后发现没有空位了，只能用文字代替了，你看我正在另外一个纸上写全部的完整算法。』指了指纸上刚写一小半的代码。他也会心一笑，并指出算法上应该改进的地方，基本 ok 啦。\n\n然后等第二轮的面试，看起来更成熟，但是说话有一种很亲近的感觉。问了基本情况，然后拿出他们的 app 让我看看首页的实现效果，说说怎么实现的。对于这种情况，基本就是考察你的抽象能力，以及分析问题的能力。我先说出使用 ListView 的 header，footview,然后使用 ListView 的 type 来实现。然后简单说了一些性能优化的东西，该面试官提出我的做法可能会存在性能瓶颈。其实他说出这块是在指导我说这块会有问题，我当然明白他的意思，于是说这块采用 recyclerview + fresco 来实现，可以有效的改善问题（其实提到这些，就说明你看过很多新技术了，有时间最好还是要自己练练这些东西，毕竟孰能生巧）。\n\n他也没深究，基本就感觉不错，开始谈了谈他们的目前状况，以及即将遇到的问题。他在只言片语中都把我当做内部人看，我也心里感觉很舒服。最后告诉我如果我愿意，他就向上报备了，意思是可以继续下一轮。当时他问到我的薪资的时候，因为之前已经说了 N 多次，有的成功，有的感觉很亏，于是这次我并没有说，只是笑笑，而对方说：『那就按照年薪算吧，你打算要多少呢？』我当时什么也没有多想，然后就说：『我希望在我现有的薪资基础上，能上涨15% - 20%。』他经过在手机上一阵比划后，告诉我可以达到我的预期效果。整个过程感觉很愉悦。\n\n因为面过了一些，并有offer，但是还是想多看看，结果把自己搞的疲惫不堪。但是最后的最后，温柔姐给我打电话说面试通过。\n\n### 最终结果\n\n最终我辞职后在家休息几天，没事的时候去咖啡馆看看书，上上网，好好过几天轻松的日子，然后再说定去哪里工作。\n\n### 总结：面试和必备的技能\n\n这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。\n\n1. 一般情况下第一轮都是基础面试，需要扎实的基础\n\t- 最常用的Android 基础知识\n\t- Java 基础知识\n\t- 了解一些 常用东西的原理，例如：handler， thread 等\n\t- 项目中的技术点\n2. 第二轮的时候需要了解更深层次的东西\n\t- Android 事件分发机制原理\n\t- Android 绘图机制原理\n\t- WindowManager 的相关知识\n\t- 进程间传输方式\n\t- Java 内存管理机制\n\t- 一些常用的 list,map 原理，以及子类之间的差别\n3. 能进入第三轮基本没什么问题，但是要注意以下问题\n\t- 该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度\n\t- 当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。\n\t- 我们的面试原则就是拿到合理薪资，得到 offer\n\t- 个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。\n\t- 你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。\n\n如果你有面试的疑问或者困惑，可以加我的微信公众账号:[mianshishuo](http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg \"面试说\"), 可以扫描下方二维码，一起来吐槽面试中的感受。我将不定期分享最新的 Android 面试题与面试经验。也可以将你们的面试经验与问题发给我一同讨论，非常感谢。\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg \"微信公众账号：面试说\")\n\n\n\n\n\n","source":"_posts/一个五年Android开发者百度、阿里、聚美、映客的面试心经.md","raw":"title: 一个五年Android开发者百度、阿里、聚美、映客的面试心经\ndate: 2016-07-08 12:13:29\ncategories: 面试说\nkeywords: android面试,经验,经历,百度，阿里\ntags: 面试心经\n---\n\n\n### 花絮\n\n本文为完整版，加了一些彩蛋哦！文末有面试和必备的技能点总结。\n\n> 也许会有人感叹某些人的运气比较好，但是他们不曾知道对方吃过多少苦，受过多少委屈。某些时候就是需要我们用心去发现突破点，然后顺势而上，抓住机遇，那么你将会走向另外一条大道，成就另外一个全新的自我。\n  \n\n先简单说说我最近的面试经历吧。面试的公司很多，其中有让我心血沸腾的经历，也有让我感到失望到无助的经历，我将这些体会都记录下来，细想之后很值得，面了这么多公司，要是最后什么也没有留下来，那就太浪费了。至少对于我来说有些东西在整理总结之后才能得到一个肯定的答案。希望这些能对即将换工作或者打算看看机会的你有一些帮助。\n\n> 下文真的很长，你可以把这篇文章当做看小说一样，快速浏览一下，但是希望你能将文中提到的那些技能掌握。那也就不枉费我花了一两天时间专门整理这些。我的这些经验仅供参考，希望你能做的比我好，同时希望你在以后的面试中能轻松应对。\n\n### 为何离职？\n\n先从我的换工作的动机开始说吧。\n\n公司裁员的时候老大说:『你就留下好好干吧，以后不管公司怎么分股票、期权，肯定少不了你』。我非常信任我的老大，跟着老大一起工作，感觉是一种享受。\n\n但是没想到裁员后，公司内部大动荡，主业务线从客户端A 业务线转移到另外的B 业务线上。我主要负责A客户端的架构，这下可真闲下来了。B 业务线那边的业务量还是很忙的，没时间配合我做一些架构上的事情。于是我每天就看看资料，补充点能量。\n\n呆了几天后，就后悔当初没有拿 N+1 走，有一种被老大忽悠的感觉。 因为公司接下来的操作让我很是不爽，先是晚上打车不能超过30，然后福利大减，瞬间没有工作的心情了。再过了一两周后公司宣布新一轮融资成功，可惜只融到了 2千多万美元（按照预期应会更高），然后接着招新人。\n\n我特么无语了，站在公司的角度是没有任何问题的，可以节省开销，也可以容纳新鲜血液。但是我作为一个老员工，心寒，走的员工都拿到了 N+1，我们这些老员工什么也没有得到，反而福利大减，伤人啊! 现在即使我想走，什么也得不到，一种莫名的恼火涌上心头（只怪本人经历尚浅，看不清一些大的趋势，还是老鸟们聪明，拿钱走人，然后换一个新工作，好不自在啊）。\n\n不过理智分析一些这样确实有好处，可以给自己留很多的时间来选择更好的公司。就如此刻的我一样，在公司悠闲的上着班，骑驴找马，遇到合适的，可以立刻走。其实细想一下，如果我当时拿了 N+1 走了后，可能会迫切的需要一份合适的工作，然后迅速入职。至于新公司怎么样，还真不敢确定。\n\n已经动了想走的心，意味着再也不可能在这里很安分的待下去了。\n\n### 面试分级\n\n于是我决定开始投递简历（世界那么大，我想去外面的世界看看）。这次看机会与往常不同，我决定好好准备一番，然后开始投递简历，主要渠道是 “X钩”，辅助渠道是猎头。\n\n这次看机会我将所有公司分为三类： \n1. A类： BAT公司，非常靠谱，各项待遇都是很优厚的\n2. B类：一些知名的互联网公司（基本都在C轮以上），基本很靠谱，该有的都少不了\n3. C类：就是那些正在招聘的公司，没啥名气，虽然钱多但是事也多。靠不靠谱真还不知道，只能碰运气\n\n### 基础知识不可少\n\n以前我基本都是直接去面试，总以为Android工作好几年了，出去面试基本没啥问题，因此带着那份傲娇的自信 总是碰壁，尤其遇到很多基础性的问题，一时真不知道怎么回答？还有一些问题之前都记得很准确，但是在面试官问的时候，就一个大写的懵逼表情。\n\n在我出去面试之前，我已经把 《大话数据结构》 基本看完了（想想我之前的生活，每天早上七点多起床，然后看几页，洗漱完就去公司）。虽然没怎么记住，但是遇到这些相关问题，还是能很容易回答出来的。因为有了以前的教训，而且这次我也是很认真的准备了好久（可以说蓄谋已久啦，我心里其实很明白互联网公司可能存在很多风险，尤其是没有盈利的公司，唯有技术这东西必须牢牢掌握住，才能立于不败之地），因此我准备把Java基础巩固下，但是手头没啥合适的书籍和资料。\n\n还好民间有很多厉害的开发者，他们不以盈利为目的，只为完成某种需求，开发一款 app,然后发布到应用市场，给需要的人。于是我就找到一个 “Java面试训练” 的App,下载量还可以，就安装到手机上，开启刷题模式，应该刷了10来天吧（都是在上班，下班时间看一点，虽然时间比较零散，但是这样记得最深刻）。在之后的面试中，基本很少遇见一些奇葩的java基础。\n\n> 这里不得不提一件事，那就是从 app 崛起的那一刻起，就有很多的 中间商，一个小作坊的屋子里有很多电脑或者不知名的设备，屋子里慢慢的数据线，犹如蜘蛛网一样连接着很多设备，做着一些神秘的事情。不用我说你们应该也知道他们做着一些很肮脏的事情，我就不细说干什么了，简单举个例子：这群人的老大看中某个市场上某款游戏非常火爆，或者 app 特别的火，于是通过反编译等技术修改这些 app,然后重新打包上线到一些不是很知名的app 渠道或者小型应用时长，还有一些论坛，一旦有用户下载，就会在 app中弹出广告，在游戏中做各种充值操作，甚至在你无意间点到一个按钮就会自动扣除你的话费。这是前几年干的事情，新闻中也纰漏了很多，这里只能说监管不力。\n>\n><br>\n>但是随后各个公司都意识到这样的安全问题于是有了 app加固的技术，无法修改 app,即便修改了，但是也运行不起来，所以一定要注重安全性问题。\n\n### 刚踏入架构师之路的经历\n\n这次我给自己的规划是做一个架构师，但是我深知架构师可不是闹着玩的，必须要有很强的一面，因此我在简历里面写的只是“架构师方向”。我在K公司 做得是架构师方向，因此我觉得有必要朝着这个方向发力，虽然现在不是很厉害，但是坚持一两年后，即使不是非常厉害，但是也距离非常厉害很近（这里使用了《孙子兵法》的一句：“求其上,得其中;求其中,得其下,求其下,必败。” ）。\n\n这个想法来源于在K 公司我第一任leader曾经跟我说过的话：『对于新东西，如果你觉得掌握了，但是不应用到项目里面来，是没有什么意义的，时间长了还是会忘记的。』我很庆幸我有一个好老大（我是属于双领导型的，K 公司 A项目的负责人是我的leader，但是我的直接汇报对象是 K 公司的副技术总监，下文就成为老大），用他的话来说就是经常踢着我的屁股走。\n\n当我在网上了解到很多实用的新技术时，跟他随意吐露一句话，他就能非常用心的倾听我的想法，并鼓励我将这些东西带入到项目中来。从那以后我就开始看很多新技术，感觉合适的会引进到我们的项目中。从之后的证明中来看，是非常有价值的。\n\n曾经遇到的情况是这样的：当我刚进入K公司后，打杂一个多月，就被关到了 小黑屋（呜呜呜，好可怕的小黑屋，996的制度）。然后才开始正常的架构师之路，第一步就是统一开发环境，在我来公司后，我发现公司的android同事用的开发工具种类真是繁多啊，神马 Eclipse、IntelliJ IDEA、Android Studio、Windows、Ubuntu、Mac。刚进公司的时候我曾经用鄙夷的眼神看过那些 Eclipse 的童鞋，真是无力吐槽了。于是我给 老大说：『咱们的开发环境最好统一起来，现在各式各样的工具，弄个东西真费劲。』于是老大二话不说，就在群里跟大家吼，都务必切换到 Android Studio（以下简称 AS），由我来监督并执行。于是我拿着鸡毛当令箭，给大伙把地址什么的都找好，发到群里去，让他们自己下载（后期我们就搭建了 ftp服务器将这些常用的工具都放在里面，省的再去下载了）。 翻墙工具我使用 goagent（不怎么稳定），给其他人分享也太费劲了，因此让他们自己搞定。老大自己有一个 VPS，于是给大伙共享后，环境基本就统一了。\n\n> 期间有一个小插曲：\n> 一个年龄 比我大的同事在用 Eclipse，在我推广我的 AS 时，他说比较忙，没时间弄。我就急了，因为我刚到公司不久，老大分配给我的任务，推行不下去，这可不行啊，没说几句吵起来了。最后我也知道不能太着急，但是已经吵了，关系肯定不咋样，老大当时开会去了，我知道自己太心虚了，因此主动给老大承认错误，说我和那谁谁吵架了，因为他不用AS。最后在老大的劝说下，这个人就勉强切换到 AS了。\n> 其实这个人就是我之后的新Leader，每每想到这里我就全身发冷汗，Leader要虐你，你还能有好活路么？还好这个Leader人比较好，人也比较大气会处事，不怎么跟我计较。我已经对着佛祖忏悔了N多次。\n\n\n### 第一天面试\n\n我用 “X钩” 开始捡一些不怎么有名的C 类公司投递，很快就收到了很多的 面试邀请。\n\n##### 首次面试——国外输入法\n\n记得当时去的第一家公司是做国外做输入法的，做的还不错。从外面能看见一栋略微有点老的大厦，办公环境很一般。\n\n进去后很巧的是遇见了一个熟人，第一位面试官竟然认识我之前在X游的一个同事，然后我们就聊开了，他也没怎么难为我，就问了我几个很简单的问题，例如：handler的原理，多线程。我按照记忆中的样子说给他听，然后就第一关就轻松过了。\n\n等了一会，另外一个面试官进来了，问了一长串问题，基本就是 Android的相关的基础，然后第二个又轻松过了。\n\n等到第三关的时候，一个年龄稍微大的人进来了，很容易能看出，这个人应是该技术团队的负责人，问了一些工作经历后，然后问了一个最让我印象深刻的问题是：『你了解过Android上的黑科技么？比如Android 5.0 之上有一个辅助功能，如果用户开启后，就能像豌豆荚那样自动安装app,等同于拥有了root权限，但是手机重启后，这个就自动关闭了，有没有办法可以自动打开呢？』据他了解，有很多不知名的小App 都实现了，但是很多大公司都没用。 我想好好一会，说可能这些app 被厂商列入了白名单，因此重启手机后还能自动打开那个辅助功能。我实在想不出如何能实现这样的效果。最后他告诉我，其实他们也是分析了好久，才发现，那些小App, 都是开启了一个进程（或者是service，具体记不清了，有兴趣的童鞋可以试试）来守护，因此能够开启。这么一说，我也瞬间明白了。\n\n但同时我提到这样做会可能会导致耗电量增加啊，对方的一句话把我真雷住了。“那能费多少电。。。” ，我瞬间无语了。但是他们可能因为某些需求必须如此做，因此要实现这样的功能，相对于电量来说应该也能接受，不至于比什么都玩不了的强，体验也确实提升了很多。不用用户每次去开启那个开关，虽然有点风险，但是相对于Android上的风险来说，确实低很多。\n\n等第三轮面试完成后，然后Hr 小妹妹带我到一个很大的会议室，见到一个很年轻的人，听Hr说，这个人应是CEO之类的，反正职称很高。他就问了些职业规划，平时有什么兴趣爱好，以后有什么打算，薪资要多少？我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。平时就看看书，参加沙龙活动，没事打打游戏。他也简单回答我一些问题。之后就是让我先走，等通知。\n\n傻傻的我还就这样高兴的走了，因为我总体感觉还是很棒的，毕竟连过4轮哈。从最后的结果中能明白，其实应该是要的薪资太高了。为什么这么说呢？因为一般情况下，最后一轮就是简单看看你这个人怎么样，技术关肯定没问题，否则前三关就 pass 了。可能对方觉得你要的薪资和你的实力不符合，也可能他们想再对比看看，选择一个更合适的人选。\n\n##### 58到家\n\n从上一家公司面过后，我就紧接着去第二家公司 58到家，在大屯路东地铁站附近。到了后刚好12点，电话联系后，他们说班车司机都午休去了，要等到2点才能过去（58到家面试需要从地铁站做班车过去，路程还算能接受的）。然后我就吃了点饭，在附近网吧 撸一局，看时间点差不多了，我就去那块坐车了，差不多走了5分钟做就到了。\n\n北苑路北美国际商务中心，这块有很多公司，什么珍爱网之类的都在那附近。\n\n第一轮面试我的是一个小伙，问了一些基本的Android基础，然后问了一下 android的绘图原理，我说： onMeasure, onLayout, onDraw。 然后他说每一个什么作用？ 那个onMeasuer主要做什么的？并举了一个例子：一个自定义的滚动View A里面如何放另外一个滚动的View B？我说把 View B将 onMeasure 里面的高设置成最大，这样就能解决冲突问题。最后他简单说了一些 onMeasure 里面的几个参数，我对此加深了解了。\n\n第一关也就这样过去了，等到第二关的时候看起来一个挺帅气的男人带着一个很显眼的婚戒跟我说一些项目流程上的东西，因为我在K 公司这块跟老大接触的比较多，因此一般问题难不住我，轻松就过了。\n\n等到第三关的时候，问我一些工作经历，然后问问职业发展规划，平时的兴趣爱好，以及你觉得得你和其他人有什么优势。我挺好奇的，为什么最后的这些面试官都要问类似的问题，之后从一个关系还不错的猎头那里了解到，其实他们也就是了解下以后的动向，以及看看这个人的人品。关于优势我是这么说的：我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。其实和上面的回答一样，这基本就是所说的套路。他们可以用套路，我们为何不可呢？ 嘿嘿，别学我，自己根据实际情况来。\n\n本以为就结束了，没想到他们说 CTO不在，可能还有复试，先让HR大美女跟我谈谈。HR慢条斯理的跟我说了一些待遇什么的，了解了下我的状况，问我要多少。我基本和上一个公司说的一个样。\n\n之后再来复试的时候，这个大美女HR给我了一些建议，说这个CTO是阿里出来的，喜欢会说话的人，想到什么就说什么，别紧张。在这面的时候，我就很放松，该怎么说就怎说，他也问了一些职业发展规划，以及我的经历，基本10来分钟就结束。我只想说大美女 HR 真真是体贴入微，感觉很 Nice, 这轮基本也顺利过了。之后这个HR直接说我被评为T5，但是以后可以继续努力，我也欣然接受了。不管怎么样，反正拿到offer再说，之后慢慢对比。\n\n##### 楚楚街\n\n说起这第三家 楚楚街 我就一肚子火，也不是说第三家不好，只是在去的路上让我备受折磨。从大屯路东 到 知春路，坐地铁应该几十分钟就到了。当时已经快四点了，5点面试，然后我就打算坐车去（不想再挤地铁了，想轻轻松松的过去），特么的为了省那几块钱，我选择拼车，在路上本以为只需要最多一个小时就到，没想到花了我1个半小时(只能感叹北京的车真多，路上堵的不行不行的)。哎，到他们公司的时候都快6点了，还好我提前在电话里和HR说过，他们说6点也是可以的。于是第三个面试就开始了。\n\n首先过来第一位面试官，看样子应该是 Android 技术 leader，开始问了我一些基础的面试题，比如：View 的事件分发机制，View的绘图，ListView 的实现原理（这个应该是几年前面试的时候经常问题，没想到现在也能遇见）。聊了好一会，然后他拿出他们的客户端给我演示了一个页面，说这个界面比较卡顿，让我分析下原因。我看过后，提出了几个有效的检测卡顿的方案，他们的这个界面主要是Listview 的 item 里面包含了一个 viewpager，然后 viewpager 的 item 里面有一个大view, 上面有N 多图片 + 动画效果，因此实现起来很麻烦,最后导致性能卡顿（不得不说产品同学，你的想象力真丰富啊，有没有考虑过研发同学的心情）。然后，他感觉得到了共鸣，因此接下来说话就比较放松了，他说和我年龄差不多，感觉我还是很厉害的（我不禁惶恐不安，我感觉还行，但是应该不是他说的很厉害，可能只是工作时间长了，该积累下来的东西大部分都有了），互留了微信，方便以后的交流（事实是没有啥交流的，只是当你面试通过后，可以有一个拉你入伙的渠道，嘿嘿，不晓得对不）。\n\n第二个进来的面试官长得挺帅气的，手上戴着戒指（之所以提到这个，是因为在我在我的印象中这个最亮眼，很多次在和他交流的过程中，我都比较紧张，我就盯着这块看用来放松，说真的如果看着对方的眼睛，双方可能都不会自在，当然除非你很有自信的时候是可以的）。开始简单问了下工作经历，然后就开始聊技术，第一个就是问我知道不知道 二分法，我当时楞了一下，猛然间反应不过来，最后专门确认问了下是不是 二分查找。然后我说在一个数组里面每次查找的时候从中间点开始对比，大于就右边找，小于就左边找，顺带提了一句这要在一个顺序的数组里面。然后面试官就说，二分查找还得每次先排一次序？我当时说是的，结果就感觉很2，可能没理解清楚面试官表达的是什么或者说我的表达有问题，其实我想说最开始的数组就是一个有序数组，但是面试官可能误解了我的意思，以为每次查到后，都要先排一次序（只能说悲催啊）。\n\n这个问题过了后就再问了我一个问题：『你来说说 Java 的内存管理。』这个问题在一两年前上就栽过跟头，所以当时专门看过相关文章。但是当我回答的时候，由于长时间没怎么看过了，记忆有点松动，大体的说出来了，但是不够准确（回去后就好好补充了下，在之后的面试过程中遇到的概率还是非常大的，尤其在第二面的时候）。然后他问我要多少薪资，我当时说 XX，然后他就问我是不是可以低一些呢？我开始说可以低一点，但是当他问低多少的时候，我心想上面两个公司的 offer 基本感觉到手了，这个可以适当的要高点，能给就来，给不了那就算了（我事后想想才明白，这种2B 的想法绝对不能有，要时刻保持低调，把握住任何一次机会）。最后他说，我得对得起兄弟们（怎么说呢？估计是刚回答的时候不是特别的满意，还有感觉我要的太高了），你这个薪资我没法跟上面谈。然后可想而知，当然肯定没有结果了。\n\n因此奉劝各位，要时刻保持低调，谦虚谨慎，莫要装B，否则肯定遭雷劈，我这就是一个活生生的例子。\n\n### 第二轮B 类公司面试：\n\n面试有很多，说起来可能会长篇大论，以下就总结性的说说，不再说明具体细节，只说我们之后在面试的时候应该注意的地方，以及他们对应聘者的要求。\n\n##### 映客 && 蘑菇街\n\n映客直播在望京soho,很高大上的地方，t1,t2,t3分别对应从低到高的大楼。到公司后，感觉还可以，第一个面我的人是一个技术，基本就问到一些Android 的面试题，没有任何悬念就过了，第二面的时候，感觉那个人还是比较随和的，问了 Java 内存管理的东西，以及一些其他的问题，最后还都聊得挺开心，第三面的时候直接就是 HR谈薪资，很容易就过了。\n\n在望京 soho 还去过 蘑菇街，里面的人技术比较好，我当时过去的时候已经6点了。那个面试官就跟我聊人生理想，提到一些 Android系统原理性的东西，但是感觉回答的不是很好。面试官感觉还是很不错的，然后给我说你以后要多看看例如 handler 原理，windowManager 的东西，并且从源码上去分析，网络上的理论知识还是要结合实践的，真是受教了。这部分我有点弱，虽然知道原理，但是看过源码的东西还是很少的，以后需要注重补充。他说他才是高级，我要应聘的这个 架构师肯定是不行的，问我是否愿意做其他的，我当然表示愿意了，现在要综合提升能力，才能往更高层走。\n\n最后的最后，他很搞笑的跟我说：『我这人真不骗人』。我还纳闷啥意思，最后他说：『今天已经很晚了，第二轮的面试官不在，我明天给你向上反馈下（从之后的一个同事的口中才明白，一般说第二轮的面试官不在，基本就是说你没戏，很委婉的一种说法而已）』。\n\n结束后我看了一下表，我晕，一面就面试我了一个半小时，真特么无语了。不过收获还是很大的，知道自己的不足后，就知道需要补充哪些东西了。\n\n##### 乐视\n\n去了一趟姚家园的乐视，只能说看着挺风光的，但是进去后，特么的真虐人。\n\n电梯分区，还只能在一边的乘坐，很不赶巧的是我去的时间刚好是10点，对于他们公司来说这就是高峰期，电梯根本排不上队，而且乱糟糟的（之前在X游的时候，大家都是排队的，这边没有，可能地方太小了，排不开吧）。电梯上不去了，看来只能跟一些人爬楼梯，一直爬到9层，感觉都喘不过气了。\n\n上去后一个很美的 HR（长腿姐）带我找面试官，然后表示没有会议室，原来的会议室都变成工位了，所以让我先在一个小角落呆着（保洁阿姨的专属位置），过了好一会面试官姗姗来迟，也是一些非常基础性的东西，最主要的是他们提到了推送，怎么实现，已经存活情况说了一些。\n\n第二个面试官也是特么来得晚，等了 N 久，闲的无聊就和保洁阿姨聊天，顺带看看他们的办公环境，只能说真心挤得慌。第二位面试官来了后就看看我的经历，因为第一轮的技术面都过了，因此简单聊了下，就说说他们的发展前景，要做海外产品。听我的兴致勃勃，很开心，然后让我等会。\n\n他们基本都去吃饭了，留下了我在那里干等，然后来了一个HR 的小妹妹，跟我谈薪资以及经历，貌似对我一两年换工作有很大意见，哥就好好给她普及了一番互联网界的基础知识。没想到就在快要搞定的时候，这个小妹妹的老大过来了，然后就看见一个身材超棒，腿很长的漂亮姐姐 HR（长腿姐），坐在我的对面（小妹妹示意我这是她的老大）。瞬间不爽了，都马上谈完了，结果换人再来，真无语了。只能将刚刚的辉煌时刻再来装 B一次，然后谈薪资神马的，给的也不是很多，我要 XX，她说那么多，只能给我薪资范围最低的一个档次。好吧，就接着吧，然后非要我先填写一份背景调查表，如果没有问题后，才给我发 offer，我看到美女拿着那份很大的 纸张，瞬间无语了。\n\n我当时就不怎么开心，然后长腿姐毕竟老练的很问到：『说你是不是有事？』。我说是的，待会1点还有其他地方的面试，然后她说：『那你先回去吧，这个表格发你邮箱，你写好后发给我。』然后长腿姐就送我出去，我又特么的一路爬楼梯下去（9层啊），电梯等了 N 久都下不去。\n\n### 接下来说说几个有意思的公司\n\n##### 新浪\n\n新浪位于理想国际大厦，记得几年前去新浪面试的时候，傻傻的都没准备就去了，结果第一关就挂了。\n\n这次是下午去，外面还飘着毛毛细雨。去了后竟然特么的让我做面试题，哥已经不做面试题很多年。但是想起了之前的经历，还是老老实实写写，据我估计面试的哥们应该会问上面的东西。还好这次做了万全的准备，刷了 N 多面试题，补充了基础的数据结构理论知识。写起来如行云流水，嗖嗖嗖的没几分钟就完了。\n\n第一个面试的哥们看看卷子，没啥意见，然后问最后一道纠错编程题有没有什么问题，我虽然指出了几个错误，但是感觉他还不是特别满意。因此我仔细看了下，原来是一个静态变量引用了 Activity 的上下文,然后指出，他再问了一些偏底层的东西以及性能优化的地方，轻轻松松就过了。\n\n等到第二面的时候，这个人一看就是技术大牛，问了很多 Java 层面的东西，多态，抽象类，多线程，内存管理等等。我感觉回答的不是太好，多态那有点问题，其他的应该还可以。\n\n然后就进入了第三面，第三面的面试官应该是部门负责人，问了工作经历上的事情以及兴趣爱好，之后的发展方向，想做什么层面的。最后很不幸的是在等待第四面的时候，最开始给我题的美眉告诉我时间很晚了，让我先回去，之后等消息。\n\n至少这次来比第一次高级了很多，不至于第一轮就被刷下去。最后分析了下原因，还是薪资要的太高了，尤其是这类公司。\n\n##### 滴滴\n\n滴滴位于西二旗，应该有两个办公地点，其实我一直很想去滴滴，福利待遇很不错。一年前去过一次，很可惜在第一轮的时候，因为在某些适配方面回答的不是太好，因此失去了机会。\n\n这次已经准备很多了，进来后还是在去年的位置上坐下等面试官。说实话感觉滴滴成长的很快，办公环境都变的更漂亮了，哈哈哈。\n\n这个面试官一看就是一个技术宅，开始对我各种炮轰。面试题一个接一个的，在我连续回答十来个题后，看见他还在问，记得在提及到 volatile 的作用的时候，我就开始不爽了，这个东西记得之前在源码里面见过，但是具体的一时说不上来，看着他那样子，埋头在纸上给我出题，我就不怎么配合了。面试了那么多家，就你问了 N 多问题，还有完没完了（其实这也算是抗压的一种面试方式）？我直接说不知道，然后他再问了几个基础性的东西，我想都不想直接说不知道，他貌似已经看出来我已经很不爽了，然后说，那你说说你项目中有没有比较 NB 或者比较有亮点的地方。我的回答直接是：没有。然后他也就不怎么问了，说那先这样。我说：好，就这样，我先走了。 然后潇洒的离开滴滴。\n\n现在想想真特么的很2B，应该低调低调再低调。也可能是那天下午太累了，上午面试了两家，而且已经拿到两家的 offer 了，还都不错，在这特么憋屈，才表现的如此差劲。其实对于问题，知道的话就好好说，不知道的话，可以说说思路和想法，然后说说以后会怎么做，利用迂回包抄策略去应答，准没错。至少给面试官知道你还是可以动脑子的人。\n\n在此我真心后悔当时的冲动，向滴滴那位面试官表示歉意。其实不用那样的，我们只需在面试的时候尽力表现自我就可以，以后切莫带着情绪去看待或者回答问题。\n\n对于人生中的很多问题也是这样的，这次栽倒坑里去了（用我老大的话来说，你不在这里踩坑，总有一天也会在另外一个地方踩到，到时候的损失就不可估计，趁着年轻多多历练自己），总结之后才能更近一步。\n\n##### 百度外卖\n\n百度外卖现在已经不属于百度了，而是单独分出来。\n\n我的一个同事去了百度外卖，我感觉他的能力和我差不多，我就让他推荐了。\n\n去后，上了一个很长的台阶（感觉很庄重的样子），要刷卡才能进去。等了好长时间，面试官把我领到楼下的公共办公桌，就是那种中间空地，周围都是楼层，能看见其他人在楼层间走动。一个年龄见长的面试官，开始感觉挺随和的，然后说跟我聊聊 Android 基础。\n\n第一个问就是：『咱们先来谈谈 Android 的四大组件。』我彻底懵逼了，尼玛，跟我谈四大组件，有意思么? 没想到一直到最后都跟我谈这些，一个接一个的问。说到广播那块，关于一个 app 被杀掉进程后，是否还能收到广播的问题纠结了好久。\n\n然后让我画我之前设计的架构图，我就随便画了画，但是没想到这个看起来很好的面试官让我大跌眼镜，他用鄙夷的笑容告诉我：『你这也太初级了。』我当时心里有几万只草泥马在崩腾，你都30+了，就不知道鼓励新人啊，我都说过我刚做架构的时间不长，而且鄙视我，有本事你也弄一个架构给我看看啊，一点不尊重我们年轻一辈的劳动成果。也许就怪我当时我真就按照他说的草草画几笔吧，没怎么认真对待。我去其他公司面试的时候，虽然这个图不怎么样，但是至少能解决 某些领域的问题，其他面试官都很谦虚。这个百度外卖的面试官，真不是我喜欢的领导，如果以后真让他来带我，那就真完蛋了，很多时候我们都是因为某些人扼杀了我们最初美好的萌芽，而从此失去了创新的意识。\n\n很庆幸的是我在 K 公司的时候，老大一直鼓励我创新，遇到想做的就去做，所以一路下来，虽然很累，但是干的很开心。\n\n所以每当有人问当初为什么选择K 公司的时候，我都会自豪的说：『我的老大很不错，我在那里很很舒服，很开心』。记得在我离开的时候老大给我最后劝告就是：『你要时刻反思自己此刻是不是已经被别人洗脑了。』\n\n\n### 第三轮：\n\n##### 1.百度\n\n百度位于海淀区上地十街附近，有很多大厦。 我去的是一个做国外工具的部门，去了后，被百度的环境和氛围震惊到了，在一个很大的技术园区，有网易，百度，腾讯公司，对面还有一个大楼正在修建，估计会是另外一个互联网公司的场地。\n\n进入大厦里面后，由于还没来得及吃饭，边吃手里的饼，边浏览下百度的外围办公区。进入百度的大楼后，两个入口都设有刷卡机。\n\n在空闲区等了好一会，然后一个人带我进入大厦。在进去之前，到前台那块面试官输入自己的邮箱账号，然后让我填写其他登记信息，我印象最深的是显示器上边贴着一个纸条，说：请离开的时候在此登记，否则会进入百度的黑名单（意思就这样，具体记不清了）。当时震惊了半天，没想到竟然这个严格。\n\n和面试官进入大楼里面后，只记得的印象是：很整洁，高大。出楼梯后，脚踩着厚厚的地毯，稍微走快点，都感觉很松弛，脚下如踩棉花一样。\n\n为什么有地毯，而不是地板砖————到了夏天很多漂亮的长腿美女穿着高跟鞋踩在地板砖上是一个怎么样的体验呢？噔噔噔...... \n\n我在等候区等到第一个面试官，然后我们简单聊了下 Android技术，其中有两点有必要提下：\n\n- 其中一点是：说说 View 的事件分发机制。然后我就说了好多，从 WindowManager-\\>window-\\>Decorview-\\>子 view。最后我说当所有的 view 都不处理事件，事件会最后会传递到 Activity 的 onTouchEvent 上。然后面试官立刻说：『哈？你这是颠覆我的三观啊？』 然后我意识到可能有问题，但是记得 《Android 艺术开发探索》上确实写过到 Activity，但是不是到 onTouchEvent还真没底。面试官很自信的样子，让我颤抖了。但是随着我的坚信，面试官说：『不行，我不能冤枉你是不！』立刻在手边的 MBP 上看了一下，自言自语感叹道：『还真有啊！』 我顿时无语了。\n\n- 另外一点是：问我 Service 上能不能弹出对话框。对于这个问题，我印象最深刻了，记得一年前的时候，在另外一个公司就因为这个问题让我尴尬万分，回去后专门对这块进行补充。我的回答是可以的，但是面试官面带差异的表情告诉我这是不行的，Dialog 必须要依附于 Window 才能显示出来。然后我的解释会让面试官郁闷一会：我说这个是可以弹出的，我之前也专门试过，不过他弹出是有条件的。 条件是：\n\t- 必须在 Manifest 里面注册系统权限\n\t- 在显示 dialog 的时候必须要加一个 flag.\n\t我的理由是：系统对话框可以在低电量的时候弹出对话框，我们同样也可以采用该方式来实现。\n\n面试官语塞，然后给我说 Dialog 是必须要依附在 Window 上，Toast 其实也是一个 Window。我听着这些话，就想起以前看过的一篇文章上也确实是这么说的。估计该面试官回去要好好补充下一些知识了哦。 然后该面试官让我不能用 Arraylist,用数组 写一个队列。这块刚好我在之前项目中特意用了一下，写的时候，主要有三个方法： put(), get(),peek(). 然后考虑下队列的特性，一端进入，一端出去。我当时遇到了盲点，没怎么写完，最后给面试官说了下思路，大体是对的。但是关于选择位置那块没怎么想好。不过这不阻碍我进入第二轮。\n\n第二轮面试的时候，面试官带了很多纸张，我瞬间压力山大，知道不太妙。不出所料，这个面试官，从动画实现原理，到 handler 实现原理，一步步深入各种原理，当我感觉回答的不错的时候，然后他就顺着我的问题继续深入。我只能说我尽力了，有些东西，平时开发的时候真心不注意，但是就因为没有留意，所以就没法继续回答他的问题。\n\n面试官把我带出大厦的那一刻，我心情很不好，很可惜没进入百度，之后应该需要准备很多东西。我要说，我还会再来的，哈哈哈！ 最后也归还身上的一个牌子到前台后，省的被拉入到黑名单（好吓人的样子）。\n\n以后有时间多看看原理性的东西，最好整理一个自己的博客，写上自己的一些看法和感悟，这样记得最深刻，即使几年后也不会遗忘，只是看看别人总结的东西，真的就不怎么记得住。\n\n关于博客可以使用 Hexo, 我的博客也是如此，可以整理一些自己的东西与心得。\n\n### 2.阿里\n\n这次去的是一个阿里的高德部门，在望京 Soho 附近的 首开广场。去了以后首先找厕所，你们知道么？厕所竟然从大厦楼层的的一个角转了一大半圈才找到，回来后进入找不到前台了...... 瞬间无语了。问了好一个美女才回到前台，然后接待我的 HR美女貌似等得不太耐烦了（宝宝心里苦，厕所好远，都找不到回来的路了）。在一个小型会议室等待面试官，看了下布置氛围和环境，感觉太棒了，很多东西都体贴入微。\n\n> 回顾上次阿里的悲痛遭遇\n> <br>\n> 其实这是我第二次来这边面试了，上一次过来的时候，是刚过完年。提到这里我就苦不堪言，为何如此说呢？当时是2016年2月15日，因为我参加好朋友的婚礼（不得不说，我这个年纪的人都开始结婚了，这次回去有4个好朋友都结婚，可想而知，一场完了以后还有另一场，虽然累，但是值得）推迟了好几天才回北京，在参加同学婚礼的时候接收到阿里高德部门的面试邀请。回到北京的当天是12点多，然后回家，一个关系非常好的朋友说今天她们要宴请公司的人吃饭，因为她们结婚了，让我帮忙弄个 MTV。我想这是朋友的终身大事，因此必须要好好干。\n> <br>\n> 我下午4点是阿里高德的面试，因此时间很紧促。我凭借我大学的技能在两个小时内搞定这个 MTV，总体来说还不错，就迅速发给朋友，弄完已经3点了，然后打车立刻去首开广场。\n> <br>\n> 高德的面试是4点钟，匆匆赶到后，就等待面试官。面试很不理想，因为什么都没有准备，而且心力憔悴。面试官问的是一些基础的 Java 问题，很可惜我没怎么回答好。于是就深深的浪费了一次机会，之后和朋友提起此事，无比后悔，当时其实是可以和 HR 电话再约一个时间的。\n> <br>\n> 这次对我的打击很大很大，因为这是我这么多年第一次面试 BAT 的职位，一上来就受挫，很不是滋味。**我在这里失利后我就各种准备资料，增强自己的能力，面试前必须要刷题，虽然简单，但是不失为一种方法，虽然不一定有用，但是会加深印象，尤其是去 BAT 这些公司，一定要准备好，否则就别浪费机会，这就是我的教训和经验。**\n> <br>\n> 为了6月份的这次面试策划了很久。以前对什么可能都不是很上心，但是这个事件深深的刺激我了。\n\n第一个面试官来了后问了一些基本问题，很顺利就进入到第二轮面试。\n\n第二轮也基本是技术面试，问了一些 Android 基础和 Java 基础以及内存管理。\n\n第三轮的面试官应是部门负责人，看起来很好说话的，问了一些经历和基本情况后，问我薪资要多少以及之后的发展方向。我说要 XX，之后希望在架构方面发展，但是也可以从业务开始。貌似这里回答的不怎么好。然后让我留了他的联系方式，我知道很有戏哦。\n\n因为我在进入 K 公司的时候也是这样的，老大感觉我很不错，于是留了微信后，我基本就顺利入职。\n\n回去后的一两天还是很焦虑的，但是我知道大公司都是有流程的，因此我告诉自己不要焦急。过了一两天后他主动加我微信，然后问了些基本情况后，就说他要做最后的总结，让我等着，最迟一周后就有消息。我感觉希望超大的，开心了好久，本以为就可以这样过去。但是一周时间过去了，没人通知我，我开始焦急了，于是我开始主动和他说话，反思自己是否有什么地方做的不好。\n\n经过很多面试后我总结出了结论就是要薪资太高了，于是我在微信里面给他说，只要能过去，薪资低点也是可以的。但是问了他好几次，他都没有回话，看着微信消息记录，都是我发给他，而他没有回复，已经过去好多天了，我知道没希望了，他说不管怎么样都会给我回复的，但是我真绝望了。\n\n就像相亲一样，遇到一个不错的美女，开始都一起聊得很不错，她开始加你好友，并且和你说看好你，不管能不能做女朋友，她之后一定会回复，但是苦苦等待一段时间后，不管你怎么给她说话，但是她就是不理你。可能她真的忙，但是也不可能连续一两天都这么忙吧。于是你知道没结果，因为无言等同于没有希望。为了避免一些幻想的存在，你会将她删除掉，不想留下任何关于他的信息。\n\n同样我也是把这个阿里高德的老大的联系方式删掉，微信也删掉。在我失去希望的时候，过了几天看见他要主动加我，但是我想可能只是安慰的话语，最多告诉我，我不适合他们的职位，因此我为了避免尴尬，直接删除那个加我好友的请求（如果说真的合适的话，应该会很重视你的，不可能好几天都回复，怎么有一种备胎的感觉，呜呜呜，我不想被发好人卡，宁愿做高傲的兔子，也不想做纸老虎，虽然尽管只是纸老虎，但是也会拥有属于它的一片森林）。\n\n于是阿里的这次机会就失去了。\n\n总结后的结论就是：去大公司要的薪资不要太高，否则对方只能感谢你的到来，因为比你优秀的人太多了。\n  \n\n### 聚美优品\n\n聚美优品 位于东四十条地铁站附近。路过一个竹亭子后，进入大厦里面需要用身份证在前台那块登记后给我一个纸条，上面写着我的身份证信息，然后在门禁卡附近刷二维码进入（真担心个人信息泄露哦，当然一般情况下没人会关注你是谁的，千万别干坏事哦，会被查出来的，哈哈哈）。\n\n推荐我去聚美优品的同事接我上去后，带我到前台填写基本信息。我只写了最基本的信息，然后她说，你就写这么点啊。我说，其实这些信息够用了，写那么多没用，还会暴露你的个人信息。面试成功后，如果有需要可以写详细些，但是一般去面试最好别写身份证信息。工作经历基本也只是最近两个，之前的就不用写了，写那么多没什么用，简历中都会有的。\n\n记得刚工作那会，傻傻的全写了，真耽误了不少时间。过了一会，她把我交给 漂亮的HR 温柔姐，然后就先忙去了。温柔姐告诉我一般情况下有两轮基本就过了，先让架构师老大直接面我，让我先等候。\n\n过了一会温柔姐不好意思的跟我说架构老大先让一个技术面我，问我是否有意见，我当然没意见了，这是很标准的面试流程（如果你有意见，建议还是别说太多的话，基本都这样的，要淡定）。\n\n一面技术给我一种很成熟的感觉，开始问了我一些基础技术问题，外加 Java 内存管理知识。后给我出了一道算法题，说有一个数组最多存储6个数，如果有普通用户的话，存储四个 vip的客户，另外两个是普通用户（留出一定的空间给普通用户），让考虑全面点（一般都是结合实际场景，让你写出一个算法，要具备的能力就是抽象，处理问题的思路与细节，还有最基本的编码功底）。\n\n然后我就考虑各种情况，第一种是非空情况，然后下面就是几个大的 if else, 至少四个条件，基本涵盖了全部情况，然后每个条件里面写上对应的存储数据的过程。由于我的四个大条件都把距离占的差不多了，在写里面细节的时候，用中文描述。过了一会他回来后，看了下说：『你这个还有中文啊！』 我尴尬的笑着说：『我先写条件的，最后发现没有空位了，只能用文字代替了，你看我正在另外一个纸上写全部的完整算法。』指了指纸上刚写一小半的代码。他也会心一笑，并指出算法上应该改进的地方，基本 ok 啦。\n\n然后等第二轮的面试，看起来更成熟，但是说话有一种很亲近的感觉。问了基本情况，然后拿出他们的 app 让我看看首页的实现效果，说说怎么实现的。对于这种情况，基本就是考察你的抽象能力，以及分析问题的能力。我先说出使用 ListView 的 header，footview,然后使用 ListView 的 type 来实现。然后简单说了一些性能优化的东西，该面试官提出我的做法可能会存在性能瓶颈。其实他说出这块是在指导我说这块会有问题，我当然明白他的意思，于是说这块采用 recyclerview + fresco 来实现，可以有效的改善问题（其实提到这些，就说明你看过很多新技术了，有时间最好还是要自己练练这些东西，毕竟孰能生巧）。\n\n他也没深究，基本就感觉不错，开始谈了谈他们的目前状况，以及即将遇到的问题。他在只言片语中都把我当做内部人看，我也心里感觉很舒服。最后告诉我如果我愿意，他就向上报备了，意思是可以继续下一轮。当时他问到我的薪资的时候，因为之前已经说了 N 多次，有的成功，有的感觉很亏，于是这次我并没有说，只是笑笑，而对方说：『那就按照年薪算吧，你打算要多少呢？』我当时什么也没有多想，然后就说：『我希望在我现有的薪资基础上，能上涨15% - 20%。』他经过在手机上一阵比划后，告诉我可以达到我的预期效果。整个过程感觉很愉悦。\n\n因为面过了一些，并有offer，但是还是想多看看，结果把自己搞的疲惫不堪。但是最后的最后，温柔姐给我打电话说面试通过。\n\n### 最终结果\n\n最终我辞职后在家休息几天，没事的时候去咖啡馆看看书，上上网，好好过几天轻松的日子，然后再说定去哪里工作。\n\n### 总结：面试和必备的技能\n\n这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。\n\n1. 一般情况下第一轮都是基础面试，需要扎实的基础\n\t- 最常用的Android 基础知识\n\t- Java 基础知识\n\t- 了解一些 常用东西的原理，例如：handler， thread 等\n\t- 项目中的技术点\n2. 第二轮的时候需要了解更深层次的东西\n\t- Android 事件分发机制原理\n\t- Android 绘图机制原理\n\t- WindowManager 的相关知识\n\t- 进程间传输方式\n\t- Java 内存管理机制\n\t- 一些常用的 list,map 原理，以及子类之间的差别\n3. 能进入第三轮基本没什么问题，但是要注意以下问题\n\t- 该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度\n\t- 当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。\n\t- 我们的面试原则就是拿到合理薪资，得到 offer\n\t- 个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。\n\t- 你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。\n\n如果你有面试的疑问或者困惑，可以加我的微信公众账号:[mianshishuo](http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg \"面试说\"), 可以扫描下方二维码，一起来吐槽面试中的感受。我将不定期分享最新的 Android 面试题与面试经验。也可以将你们的面试经验与问题发给我一同讨论，非常感谢。\n\n![](http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg \"微信公众账号：面试说\")\n\n\n\n\n\n","slug":"一个五年Android开发者百度、阿里、聚美、映客的面试心经","published":1,"updated":"2016-07-09T01:55:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agt001ixzexrkaly5h3","content":"<h3 id=\"花絮\"><a href=\"#花絮\" class=\"headerlink\" title=\"花絮\"></a>花絮</h3><p>本文为完整版，加了一些彩蛋哦！文末有面试和必备的技能点总结。</p>\n<blockquote>\n<p>也许会有人感叹某些人的运气比较好，但是他们不曾知道对方吃过多少苦，受过多少委屈。某些时候就是需要我们用心去发现突破点，然后顺势而上，抓住机遇，那么你将会走向另外一条大道，成就另外一个全新的自我。</p>\n</blockquote>\n<p>先简单说说我最近的面试经历吧。面试的公司很多，其中有让我心血沸腾的经历，也有让我感到失望到无助的经历，我将这些体会都记录下来，细想之后很值得，面了这么多公司，要是最后什么也没有留下来，那就太浪费了。至少对于我来说有些东西在整理总结之后才能得到一个肯定的答案。希望这些能对即将换工作或者打算看看机会的你有一些帮助。</p>\n<blockquote>\n<p>下文真的很长，你可以把这篇文章当做看小说一样，快速浏览一下，但是希望你能将文中提到的那些技能掌握。那也就不枉费我花了一两天时间专门整理这些。我的这些经验仅供参考，希望你能做的比我好，同时希望你在以后的面试中能轻松应对。</p>\n</blockquote>\n<h3 id=\"为何离职？\"><a href=\"#为何离职？\" class=\"headerlink\" title=\"为何离职？\"></a>为何离职？</h3><p>先从我的换工作的动机开始说吧。</p>\n<p>公司裁员的时候老大说:『你就留下好好干吧，以后不管公司怎么分股票、期权，肯定少不了你』。我非常信任我的老大，跟着老大一起工作，感觉是一种享受。</p>\n<p>但是没想到裁员后，公司内部大动荡，主业务线从客户端A 业务线转移到另外的B 业务线上。我主要负责A客户端的架构，这下可真闲下来了。B 业务线那边的业务量还是很忙的，没时间配合我做一些架构上的事情。于是我每天就看看资料，补充点能量。</p>\n<p>呆了几天后，就后悔当初没有拿 N+1 走，有一种被老大忽悠的感觉。 因为公司接下来的操作让我很是不爽，先是晚上打车不能超过30，然后福利大减，瞬间没有工作的心情了。再过了一两周后公司宣布新一轮融资成功，可惜只融到了 2千多万美元（按照预期应会更高），然后接着招新人。</p>\n<p>我特么无语了，站在公司的角度是没有任何问题的，可以节省开销，也可以容纳新鲜血液。但是我作为一个老员工，心寒，走的员工都拿到了 N+1，我们这些老员工什么也没有得到，反而福利大减，伤人啊! 现在即使我想走，什么也得不到，一种莫名的恼火涌上心头（只怪本人经历尚浅，看不清一些大的趋势，还是老鸟们聪明，拿钱走人，然后换一个新工作，好不自在啊）。</p>\n<p>不过理智分析一些这样确实有好处，可以给自己留很多的时间来选择更好的公司。就如此刻的我一样，在公司悠闲的上着班，骑驴找马，遇到合适的，可以立刻走。其实细想一下，如果我当时拿了 N+1 走了后，可能会迫切的需要一份合适的工作，然后迅速入职。至于新公司怎么样，还真不敢确定。</p>\n<p>已经动了想走的心，意味着再也不可能在这里很安分的待下去了。</p>\n<h3 id=\"面试分级\"><a href=\"#面试分级\" class=\"headerlink\" title=\"面试分级\"></a>面试分级</h3><p>于是我决定开始投递简历（世界那么大，我想去外面的世界看看）。这次看机会与往常不同，我决定好好准备一番，然后开始投递简历，主要渠道是 “X钩”，辅助渠道是猎头。</p>\n<p>这次看机会我将所有公司分为三类： </p>\n<ol>\n<li>A类： BAT公司，非常靠谱，各项待遇都是很优厚的</li>\n<li>B类：一些知名的互联网公司（基本都在C轮以上），基本很靠谱，该有的都少不了</li>\n<li>C类：就是那些正在招聘的公司，没啥名气，虽然钱多但是事也多。靠不靠谱真还不知道，只能碰运气</li>\n</ol>\n<h3 id=\"基础知识不可少\"><a href=\"#基础知识不可少\" class=\"headerlink\" title=\"基础知识不可少\"></a>基础知识不可少</h3><p>以前我基本都是直接去面试，总以为Android工作好几年了，出去面试基本没啥问题，因此带着那份傲娇的自信 总是碰壁，尤其遇到很多基础性的问题，一时真不知道怎么回答？还有一些问题之前都记得很准确，但是在面试官问的时候，就一个大写的懵逼表情。</p>\n<p>在我出去面试之前，我已经把 《大话数据结构》 基本看完了（想想我之前的生活，每天早上七点多起床，然后看几页，洗漱完就去公司）。虽然没怎么记住，但是遇到这些相关问题，还是能很容易回答出来的。因为有了以前的教训，而且这次我也是很认真的准备了好久（可以说蓄谋已久啦，我心里其实很明白互联网公司可能存在很多风险，尤其是没有盈利的公司，唯有技术这东西必须牢牢掌握住，才能立于不败之地），因此我准备把Java基础巩固下，但是手头没啥合适的书籍和资料。</p>\n<p>还好民间有很多厉害的开发者，他们不以盈利为目的，只为完成某种需求，开发一款 app,然后发布到应用市场，给需要的人。于是我就找到一个 “Java面试训练” 的App,下载量还可以，就安装到手机上，开启刷题模式，应该刷了10来天吧（都是在上班，下班时间看一点，虽然时间比较零散，但是这样记得最深刻）。在之后的面试中，基本很少遇见一些奇葩的java基础。</p>\n<blockquote>\n<p>这里不得不提一件事，那就是从 app 崛起的那一刻起，就有很多的 中间商，一个小作坊的屋子里有很多电脑或者不知名的设备，屋子里慢慢的数据线，犹如蜘蛛网一样连接着很多设备，做着一些神秘的事情。不用我说你们应该也知道他们做着一些很肮脏的事情，我就不细说干什么了，简单举个例子：这群人的老大看中某个市场上某款游戏非常火爆，或者 app 特别的火，于是通过反编译等技术修改这些 app,然后重新打包上线到一些不是很知名的app 渠道或者小型应用时长，还有一些论坛，一旦有用户下载，就会在 app中弹出广告，在游戏中做各种充值操作，甚至在你无意间点到一个按钮就会自动扣除你的话费。这是前几年干的事情，新闻中也纰漏了很多，这里只能说监管不力。</p>\n<p><br><br>但是随后各个公司都意识到这样的安全问题于是有了 app加固的技术，无法修改 app,即便修改了，但是也运行不起来，所以一定要注重安全性问题。</p>\n</blockquote>\n<h3 id=\"刚踏入架构师之路的经历\"><a href=\"#刚踏入架构师之路的经历\" class=\"headerlink\" title=\"刚踏入架构师之路的经历\"></a>刚踏入架构师之路的经历</h3><p>这次我给自己的规划是做一个架构师，但是我深知架构师可不是闹着玩的，必须要有很强的一面，因此我在简历里面写的只是“架构师方向”。我在K公司 做得是架构师方向，因此我觉得有必要朝着这个方向发力，虽然现在不是很厉害，但是坚持一两年后，即使不是非常厉害，但是也距离非常厉害很近（这里使用了《孙子兵法》的一句：“求其上,得其中;求其中,得其下,求其下,必败。” ）。</p>\n<p>这个想法来源于在K 公司我第一任leader曾经跟我说过的话：『对于新东西，如果你觉得掌握了，但是不应用到项目里面来，是没有什么意义的，时间长了还是会忘记的。』我很庆幸我有一个好老大（我是属于双领导型的，K 公司 A项目的负责人是我的leader，但是我的直接汇报对象是 K 公司的副技术总监，下文就成为老大），用他的话来说就是经常踢着我的屁股走。</p>\n<p>当我在网上了解到很多实用的新技术时，跟他随意吐露一句话，他就能非常用心的倾听我的想法，并鼓励我将这些东西带入到项目中来。从那以后我就开始看很多新技术，感觉合适的会引进到我们的项目中。从之后的证明中来看，是非常有价值的。</p>\n<p>曾经遇到的情况是这样的：当我刚进入K公司后，打杂一个多月，就被关到了 小黑屋（呜呜呜，好可怕的小黑屋，996的制度）。然后才开始正常的架构师之路，第一步就是统一开发环境，在我来公司后，我发现公司的android同事用的开发工具种类真是繁多啊，神马 Eclipse、IntelliJ IDEA、Android Studio、Windows、Ubuntu、Mac。刚进公司的时候我曾经用鄙夷的眼神看过那些 Eclipse 的童鞋，真是无力吐槽了。于是我给 老大说：『咱们的开发环境最好统一起来，现在各式各样的工具，弄个东西真费劲。』于是老大二话不说，就在群里跟大家吼，都务必切换到 Android Studio（以下简称 AS），由我来监督并执行。于是我拿着鸡毛当令箭，给大伙把地址什么的都找好，发到群里去，让他们自己下载（后期我们就搭建了 ftp服务器将这些常用的工具都放在里面，省的再去下载了）。 翻墙工具我使用 goagent（不怎么稳定），给其他人分享也太费劲了，因此让他们自己搞定。老大自己有一个 VPS，于是给大伙共享后，环境基本就统一了。</p>\n<blockquote>\n<p>期间有一个小插曲：<br>一个年龄 比我大的同事在用 Eclipse，在我推广我的 AS 时，他说比较忙，没时间弄。我就急了，因为我刚到公司不久，老大分配给我的任务，推行不下去，这可不行啊，没说几句吵起来了。最后我也知道不能太着急，但是已经吵了，关系肯定不咋样，老大当时开会去了，我知道自己太心虚了，因此主动给老大承认错误，说我和那谁谁吵架了，因为他不用AS。最后在老大的劝说下，这个人就勉强切换到 AS了。<br>其实这个人就是我之后的新Leader，每每想到这里我就全身发冷汗，Leader要虐你，你还能有好活路么？还好这个Leader人比较好，人也比较大气会处事，不怎么跟我计较。我已经对着佛祖忏悔了N多次。</p>\n</blockquote>\n<h3 id=\"第一天面试\"><a href=\"#第一天面试\" class=\"headerlink\" title=\"第一天面试\"></a>第一天面试</h3><p>我用 “X钩” 开始捡一些不怎么有名的C 类公司投递，很快就收到了很多的 面试邀请。</p>\n<h5 id=\"首次面试——国外输入法\"><a href=\"#首次面试——国外输入法\" class=\"headerlink\" title=\"首次面试——国外输入法\"></a>首次面试——国外输入法</h5><p>记得当时去的第一家公司是做国外做输入法的，做的还不错。从外面能看见一栋略微有点老的大厦，办公环境很一般。</p>\n<p>进去后很巧的是遇见了一个熟人，第一位面试官竟然认识我之前在X游的一个同事，然后我们就聊开了，他也没怎么难为我，就问了我几个很简单的问题，例如：handler的原理，多线程。我按照记忆中的样子说给他听，然后就第一关就轻松过了。</p>\n<p>等了一会，另外一个面试官进来了，问了一长串问题，基本就是 Android的相关的基础，然后第二个又轻松过了。</p>\n<p>等到第三关的时候，一个年龄稍微大的人进来了，很容易能看出，这个人应是该技术团队的负责人，问了一些工作经历后，然后问了一个最让我印象深刻的问题是：『你了解过Android上的黑科技么？比如Android 5.0 之上有一个辅助功能，如果用户开启后，就能像豌豆荚那样自动安装app,等同于拥有了root权限，但是手机重启后，这个就自动关闭了，有没有办法可以自动打开呢？』据他了解，有很多不知名的小App 都实现了，但是很多大公司都没用。 我想好好一会，说可能这些app 被厂商列入了白名单，因此重启手机后还能自动打开那个辅助功能。我实在想不出如何能实现这样的效果。最后他告诉我，其实他们也是分析了好久，才发现，那些小App, 都是开启了一个进程（或者是service，具体记不清了，有兴趣的童鞋可以试试）来守护，因此能够开启。这么一说，我也瞬间明白了。</p>\n<p>但同时我提到这样做会可能会导致耗电量增加啊，对方的一句话把我真雷住了。“那能费多少电。。。” ，我瞬间无语了。但是他们可能因为某些需求必须如此做，因此要实现这样的功能，相对于电量来说应该也能接受，不至于比什么都玩不了的强，体验也确实提升了很多。不用用户每次去开启那个开关，虽然有点风险，但是相对于Android上的风险来说，确实低很多。</p>\n<p>等第三轮面试完成后，然后Hr 小妹妹带我到一个很大的会议室，见到一个很年轻的人，听Hr说，这个人应是CEO之类的，反正职称很高。他就问了些职业规划，平时有什么兴趣爱好，以后有什么打算，薪资要多少？我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。平时就看看书，参加沙龙活动，没事打打游戏。他也简单回答我一些问题。之后就是让我先走，等通知。</p>\n<p>傻傻的我还就这样高兴的走了，因为我总体感觉还是很棒的，毕竟连过4轮哈。从最后的结果中能明白，其实应该是要的薪资太高了。为什么这么说呢？因为一般情况下，最后一轮就是简单看看你这个人怎么样，技术关肯定没问题，否则前三关就 pass 了。可能对方觉得你要的薪资和你的实力不符合，也可能他们想再对比看看，选择一个更合适的人选。</p>\n<h5 id=\"58到家\"><a href=\"#58到家\" class=\"headerlink\" title=\"58到家\"></a>58到家</h5><p>从上一家公司面过后，我就紧接着去第二家公司 58到家，在大屯路东地铁站附近。到了后刚好12点，电话联系后，他们说班车司机都午休去了，要等到2点才能过去（58到家面试需要从地铁站做班车过去，路程还算能接受的）。然后我就吃了点饭，在附近网吧 撸一局，看时间点差不多了，我就去那块坐车了，差不多走了5分钟做就到了。</p>\n<p>北苑路北美国际商务中心，这块有很多公司，什么珍爱网之类的都在那附近。</p>\n<p>第一轮面试我的是一个小伙，问了一些基本的Android基础，然后问了一下 android的绘图原理，我说： onMeasure, onLayout, onDraw。 然后他说每一个什么作用？ 那个onMeasuer主要做什么的？并举了一个例子：一个自定义的滚动View A里面如何放另外一个滚动的View B？我说把 View B将 onMeasure 里面的高设置成最大，这样就能解决冲突问题。最后他简单说了一些 onMeasure 里面的几个参数，我对此加深了解了。</p>\n<p>第一关也就这样过去了，等到第二关的时候看起来一个挺帅气的男人带着一个很显眼的婚戒跟我说一些项目流程上的东西，因为我在K 公司这块跟老大接触的比较多，因此一般问题难不住我，轻松就过了。</p>\n<p>等到第三关的时候，问我一些工作经历，然后问问职业发展规划，平时的兴趣爱好，以及你觉得得你和其他人有什么优势。我挺好奇的，为什么最后的这些面试官都要问类似的问题，之后从一个关系还不错的猎头那里了解到，其实他们也就是了解下以后的动向，以及看看这个人的人品。关于优势我是这么说的：我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。其实和上面的回答一样，这基本就是所说的套路。他们可以用套路，我们为何不可呢？ 嘿嘿，别学我，自己根据实际情况来。</p>\n<p>本以为就结束了，没想到他们说 CTO不在，可能还有复试，先让HR大美女跟我谈谈。HR慢条斯理的跟我说了一些待遇什么的，了解了下我的状况，问我要多少。我基本和上一个公司说的一个样。</p>\n<p>之后再来复试的时候，这个大美女HR给我了一些建议，说这个CTO是阿里出来的，喜欢会说话的人，想到什么就说什么，别紧张。在这面的时候，我就很放松，该怎么说就怎说，他也问了一些职业发展规划，以及我的经历，基本10来分钟就结束。我只想说大美女 HR 真真是体贴入微，感觉很 Nice, 这轮基本也顺利过了。之后这个HR直接说我被评为T5，但是以后可以继续努力，我也欣然接受了。不管怎么样，反正拿到offer再说，之后慢慢对比。</p>\n<h5 id=\"楚楚街\"><a href=\"#楚楚街\" class=\"headerlink\" title=\"楚楚街\"></a>楚楚街</h5><p>说起这第三家 楚楚街 我就一肚子火，也不是说第三家不好，只是在去的路上让我备受折磨。从大屯路东 到 知春路，坐地铁应该几十分钟就到了。当时已经快四点了，5点面试，然后我就打算坐车去（不想再挤地铁了，想轻轻松松的过去），特么的为了省那几块钱，我选择拼车，在路上本以为只需要最多一个小时就到，没想到花了我1个半小时(只能感叹北京的车真多，路上堵的不行不行的)。哎，到他们公司的时候都快6点了，还好我提前在电话里和HR说过，他们说6点也是可以的。于是第三个面试就开始了。</p>\n<p>首先过来第一位面试官，看样子应该是 Android 技术 leader，开始问了我一些基础的面试题，比如：View 的事件分发机制，View的绘图，ListView 的实现原理（这个应该是几年前面试的时候经常问题，没想到现在也能遇见）。聊了好一会，然后他拿出他们的客户端给我演示了一个页面，说这个界面比较卡顿，让我分析下原因。我看过后，提出了几个有效的检测卡顿的方案，他们的这个界面主要是Listview 的 item 里面包含了一个 viewpager，然后 viewpager 的 item 里面有一个大view, 上面有N 多图片 + 动画效果，因此实现起来很麻烦,最后导致性能卡顿（不得不说产品同学，你的想象力真丰富啊，有没有考虑过研发同学的心情）。然后，他感觉得到了共鸣，因此接下来说话就比较放松了，他说和我年龄差不多，感觉我还是很厉害的（我不禁惶恐不安，我感觉还行，但是应该不是他说的很厉害，可能只是工作时间长了，该积累下来的东西大部分都有了），互留了微信，方便以后的交流（事实是没有啥交流的，只是当你面试通过后，可以有一个拉你入伙的渠道，嘿嘿，不晓得对不）。</p>\n<p>第二个进来的面试官长得挺帅气的，手上戴着戒指（之所以提到这个，是因为在我在我的印象中这个最亮眼，很多次在和他交流的过程中，我都比较紧张，我就盯着这块看用来放松，说真的如果看着对方的眼睛，双方可能都不会自在，当然除非你很有自信的时候是可以的）。开始简单问了下工作经历，然后就开始聊技术，第一个就是问我知道不知道 二分法，我当时楞了一下，猛然间反应不过来，最后专门确认问了下是不是 二分查找。然后我说在一个数组里面每次查找的时候从中间点开始对比，大于就右边找，小于就左边找，顺带提了一句这要在一个顺序的数组里面。然后面试官就说，二分查找还得每次先排一次序？我当时说是的，结果就感觉很2，可能没理解清楚面试官表达的是什么或者说我的表达有问题，其实我想说最开始的数组就是一个有序数组，但是面试官可能误解了我的意思，以为每次查到后，都要先排一次序（只能说悲催啊）。</p>\n<p>这个问题过了后就再问了我一个问题：『你来说说 Java 的内存管理。』这个问题在一两年前上就栽过跟头，所以当时专门看过相关文章。但是当我回答的时候，由于长时间没怎么看过了，记忆有点松动，大体的说出来了，但是不够准确（回去后就好好补充了下，在之后的面试过程中遇到的概率还是非常大的，尤其在第二面的时候）。然后他问我要多少薪资，我当时说 XX，然后他就问我是不是可以低一些呢？我开始说可以低一点，但是当他问低多少的时候，我心想上面两个公司的 offer 基本感觉到手了，这个可以适当的要高点，能给就来，给不了那就算了（我事后想想才明白，这种2B 的想法绝对不能有，要时刻保持低调，把握住任何一次机会）。最后他说，我得对得起兄弟们（怎么说呢？估计是刚回答的时候不是特别的满意，还有感觉我要的太高了），你这个薪资我没法跟上面谈。然后可想而知，当然肯定没有结果了。</p>\n<p>因此奉劝各位，要时刻保持低调，谦虚谨慎，莫要装B，否则肯定遭雷劈，我这就是一个活生生的例子。</p>\n<h3 id=\"第二轮B-类公司面试：\"><a href=\"#第二轮B-类公司面试：\" class=\"headerlink\" title=\"第二轮B 类公司面试：\"></a>第二轮B 类公司面试：</h3><p>面试有很多，说起来可能会长篇大论，以下就总结性的说说，不再说明具体细节，只说我们之后在面试的时候应该注意的地方，以及他们对应聘者的要求。</p>\n<h5 id=\"映客-amp-amp-蘑菇街\"><a href=\"#映客-amp-amp-蘑菇街\" class=\"headerlink\" title=\"映客 &amp;&amp; 蘑菇街\"></a>映客 &amp;&amp; 蘑菇街</h5><p>映客直播在望京soho,很高大上的地方，t1,t2,t3分别对应从低到高的大楼。到公司后，感觉还可以，第一个面我的人是一个技术，基本就问到一些Android 的面试题，没有任何悬念就过了，第二面的时候，感觉那个人还是比较随和的，问了 Java 内存管理的东西，以及一些其他的问题，最后还都聊得挺开心，第三面的时候直接就是 HR谈薪资，很容易就过了。</p>\n<p>在望京 soho 还去过 蘑菇街，里面的人技术比较好，我当时过去的时候已经6点了。那个面试官就跟我聊人生理想，提到一些 Android系统原理性的东西，但是感觉回答的不是很好。面试官感觉还是很不错的，然后给我说你以后要多看看例如 handler 原理，windowManager 的东西，并且从源码上去分析，网络上的理论知识还是要结合实践的，真是受教了。这部分我有点弱，虽然知道原理，但是看过源码的东西还是很少的，以后需要注重补充。他说他才是高级，我要应聘的这个 架构师肯定是不行的，问我是否愿意做其他的，我当然表示愿意了，现在要综合提升能力，才能往更高层走。</p>\n<p>最后的最后，他很搞笑的跟我说：『我这人真不骗人』。我还纳闷啥意思，最后他说：『今天已经很晚了，第二轮的面试官不在，我明天给你向上反馈下（从之后的一个同事的口中才明白，一般说第二轮的面试官不在，基本就是说你没戏，很委婉的一种说法而已）』。</p>\n<p>结束后我看了一下表，我晕，一面就面试我了一个半小时，真特么无语了。不过收获还是很大的，知道自己的不足后，就知道需要补充哪些东西了。</p>\n<h5 id=\"乐视\"><a href=\"#乐视\" class=\"headerlink\" title=\"乐视\"></a>乐视</h5><p>去了一趟姚家园的乐视，只能说看着挺风光的，但是进去后，特么的真虐人。</p>\n<p>电梯分区，还只能在一边的乘坐，很不赶巧的是我去的时间刚好是10点，对于他们公司来说这就是高峰期，电梯根本排不上队，而且乱糟糟的（之前在X游的时候，大家都是排队的，这边没有，可能地方太小了，排不开吧）。电梯上不去了，看来只能跟一些人爬楼梯，一直爬到9层，感觉都喘不过气了。</p>\n<p>上去后一个很美的 HR（长腿姐）带我找面试官，然后表示没有会议室，原来的会议室都变成工位了，所以让我先在一个小角落呆着（保洁阿姨的专属位置），过了好一会面试官姗姗来迟，也是一些非常基础性的东西，最主要的是他们提到了推送，怎么实现，已经存活情况说了一些。</p>\n<p>第二个面试官也是特么来得晚，等了 N 久，闲的无聊就和保洁阿姨聊天，顺带看看他们的办公环境，只能说真心挤得慌。第二位面试官来了后就看看我的经历，因为第一轮的技术面都过了，因此简单聊了下，就说说他们的发展前景，要做海外产品。听我的兴致勃勃，很开心，然后让我等会。</p>\n<p>他们基本都去吃饭了，留下了我在那里干等，然后来了一个HR 的小妹妹，跟我谈薪资以及经历，貌似对我一两年换工作有很大意见，哥就好好给她普及了一番互联网界的基础知识。没想到就在快要搞定的时候，这个小妹妹的老大过来了，然后就看见一个身材超棒，腿很长的漂亮姐姐 HR（长腿姐），坐在我的对面（小妹妹示意我这是她的老大）。瞬间不爽了，都马上谈完了，结果换人再来，真无语了。只能将刚刚的辉煌时刻再来装 B一次，然后谈薪资神马的，给的也不是很多，我要 XX，她说那么多，只能给我薪资范围最低的一个档次。好吧，就接着吧，然后非要我先填写一份背景调查表，如果没有问题后，才给我发 offer，我看到美女拿着那份很大的 纸张，瞬间无语了。</p>\n<p>我当时就不怎么开心，然后长腿姐毕竟老练的很问到：『说你是不是有事？』。我说是的，待会1点还有其他地方的面试，然后她说：『那你先回去吧，这个表格发你邮箱，你写好后发给我。』然后长腿姐就送我出去，我又特么的一路爬楼梯下去（9层啊），电梯等了 N 久都下不去。</p>\n<h3 id=\"接下来说说几个有意思的公司\"><a href=\"#接下来说说几个有意思的公司\" class=\"headerlink\" title=\"接下来说说几个有意思的公司\"></a>接下来说说几个有意思的公司</h3><h5 id=\"新浪\"><a href=\"#新浪\" class=\"headerlink\" title=\"新浪\"></a>新浪</h5><p>新浪位于理想国际大厦，记得几年前去新浪面试的时候，傻傻的都没准备就去了，结果第一关就挂了。</p>\n<p>这次是下午去，外面还飘着毛毛细雨。去了后竟然特么的让我做面试题，哥已经不做面试题很多年。但是想起了之前的经历，还是老老实实写写，据我估计面试的哥们应该会问上面的东西。还好这次做了万全的准备，刷了 N 多面试题，补充了基础的数据结构理论知识。写起来如行云流水，嗖嗖嗖的没几分钟就完了。</p>\n<p>第一个面试的哥们看看卷子，没啥意见，然后问最后一道纠错编程题有没有什么问题，我虽然指出了几个错误，但是感觉他还不是特别满意。因此我仔细看了下，原来是一个静态变量引用了 Activity 的上下文,然后指出，他再问了一些偏底层的东西以及性能优化的地方，轻轻松松就过了。</p>\n<p>等到第二面的时候，这个人一看就是技术大牛，问了很多 Java 层面的东西，多态，抽象类，多线程，内存管理等等。我感觉回答的不是太好，多态那有点问题，其他的应该还可以。</p>\n<p>然后就进入了第三面，第三面的面试官应该是部门负责人，问了工作经历上的事情以及兴趣爱好，之后的发展方向，想做什么层面的。最后很不幸的是在等待第四面的时候，最开始给我题的美眉告诉我时间很晚了，让我先回去，之后等消息。</p>\n<p>至少这次来比第一次高级了很多，不至于第一轮就被刷下去。最后分析了下原因，还是薪资要的太高了，尤其是这类公司。</p>\n<h5 id=\"滴滴\"><a href=\"#滴滴\" class=\"headerlink\" title=\"滴滴\"></a>滴滴</h5><p>滴滴位于西二旗，应该有两个办公地点，其实我一直很想去滴滴，福利待遇很不错。一年前去过一次，很可惜在第一轮的时候，因为在某些适配方面回答的不是太好，因此失去了机会。</p>\n<p>这次已经准备很多了，进来后还是在去年的位置上坐下等面试官。说实话感觉滴滴成长的很快，办公环境都变的更漂亮了，哈哈哈。</p>\n<p>这个面试官一看就是一个技术宅，开始对我各种炮轰。面试题一个接一个的，在我连续回答十来个题后，看见他还在问，记得在提及到 volatile 的作用的时候，我就开始不爽了，这个东西记得之前在源码里面见过，但是具体的一时说不上来，看着他那样子，埋头在纸上给我出题，我就不怎么配合了。面试了那么多家，就你问了 N 多问题，还有完没完了（其实这也算是抗压的一种面试方式）？我直接说不知道，然后他再问了几个基础性的东西，我想都不想直接说不知道，他貌似已经看出来我已经很不爽了，然后说，那你说说你项目中有没有比较 NB 或者比较有亮点的地方。我的回答直接是：没有。然后他也就不怎么问了，说那先这样。我说：好，就这样，我先走了。 然后潇洒的离开滴滴。</p>\n<p>现在想想真特么的很2B，应该低调低调再低调。也可能是那天下午太累了，上午面试了两家，而且已经拿到两家的 offer 了，还都不错，在这特么憋屈，才表现的如此差劲。其实对于问题，知道的话就好好说，不知道的话，可以说说思路和想法，然后说说以后会怎么做，利用迂回包抄策略去应答，准没错。至少给面试官知道你还是可以动脑子的人。</p>\n<p>在此我真心后悔当时的冲动，向滴滴那位面试官表示歉意。其实不用那样的，我们只需在面试的时候尽力表现自我就可以，以后切莫带着情绪去看待或者回答问题。</p>\n<p>对于人生中的很多问题也是这样的，这次栽倒坑里去了（用我老大的话来说，你不在这里踩坑，总有一天也会在另外一个地方踩到，到时候的损失就不可估计，趁着年轻多多历练自己），总结之后才能更近一步。</p>\n<h5 id=\"百度外卖\"><a href=\"#百度外卖\" class=\"headerlink\" title=\"百度外卖\"></a>百度外卖</h5><p>百度外卖现在已经不属于百度了，而是单独分出来。</p>\n<p>我的一个同事去了百度外卖，我感觉他的能力和我差不多，我就让他推荐了。</p>\n<p>去后，上了一个很长的台阶（感觉很庄重的样子），要刷卡才能进去。等了好长时间，面试官把我领到楼下的公共办公桌，就是那种中间空地，周围都是楼层，能看见其他人在楼层间走动。一个年龄见长的面试官，开始感觉挺随和的，然后说跟我聊聊 Android 基础。</p>\n<p>第一个问就是：『咱们先来谈谈 Android 的四大组件。』我彻底懵逼了，尼玛，跟我谈四大组件，有意思么? 没想到一直到最后都跟我谈这些，一个接一个的问。说到广播那块，关于一个 app 被杀掉进程后，是否还能收到广播的问题纠结了好久。</p>\n<p>然后让我画我之前设计的架构图，我就随便画了画，但是没想到这个看起来很好的面试官让我大跌眼镜，他用鄙夷的笑容告诉我：『你这也太初级了。』我当时心里有几万只草泥马在崩腾，你都30+了，就不知道鼓励新人啊，我都说过我刚做架构的时间不长，而且鄙视我，有本事你也弄一个架构给我看看啊，一点不尊重我们年轻一辈的劳动成果。也许就怪我当时我真就按照他说的草草画几笔吧，没怎么认真对待。我去其他公司面试的时候，虽然这个图不怎么样，但是至少能解决 某些领域的问题，其他面试官都很谦虚。这个百度外卖的面试官，真不是我喜欢的领导，如果以后真让他来带我，那就真完蛋了，很多时候我们都是因为某些人扼杀了我们最初美好的萌芽，而从此失去了创新的意识。</p>\n<p>很庆幸的是我在 K 公司的时候，老大一直鼓励我创新，遇到想做的就去做，所以一路下来，虽然很累，但是干的很开心。</p>\n<p>所以每当有人问当初为什么选择K 公司的时候，我都会自豪的说：『我的老大很不错，我在那里很很舒服，很开心』。记得在我离开的时候老大给我最后劝告就是：『你要时刻反思自己此刻是不是已经被别人洗脑了。』</p>\n<h3 id=\"第三轮：\"><a href=\"#第三轮：\" class=\"headerlink\" title=\"第三轮：\"></a>第三轮：</h3><h5 id=\"1-百度\"><a href=\"#1-百度\" class=\"headerlink\" title=\"1.百度\"></a>1.百度</h5><p>百度位于海淀区上地十街附近，有很多大厦。 我去的是一个做国外工具的部门，去了后，被百度的环境和氛围震惊到了，在一个很大的技术园区，有网易，百度，腾讯公司，对面还有一个大楼正在修建，估计会是另外一个互联网公司的场地。</p>\n<p>进入大厦里面后，由于还没来得及吃饭，边吃手里的饼，边浏览下百度的外围办公区。进入百度的大楼后，两个入口都设有刷卡机。</p>\n<p>在空闲区等了好一会，然后一个人带我进入大厦。在进去之前，到前台那块面试官输入自己的邮箱账号，然后让我填写其他登记信息，我印象最深的是显示器上边贴着一个纸条，说：请离开的时候在此登记，否则会进入百度的黑名单（意思就这样，具体记不清了）。当时震惊了半天，没想到竟然这个严格。</p>\n<p>和面试官进入大楼里面后，只记得的印象是：很整洁，高大。出楼梯后，脚踩着厚厚的地毯，稍微走快点，都感觉很松弛，脚下如踩棉花一样。</p>\n<p>为什么有地毯，而不是地板砖————到了夏天很多漂亮的长腿美女穿着高跟鞋踩在地板砖上是一个怎么样的体验呢？噔噔噔…… </p>\n<p>我在等候区等到第一个面试官，然后我们简单聊了下 Android技术，其中有两点有必要提下：</p>\n<ul>\n<li><p>其中一点是：说说 View 的事件分发机制。然后我就说了好多，从 WindowManager->window->Decorview->子 view。最后我说当所有的 view 都不处理事件，事件会最后会传递到 Activity 的 onTouchEvent 上。然后面试官立刻说：『哈？你这是颠覆我的三观啊？』 然后我意识到可能有问题，但是记得 《Android 艺术开发探索》上确实写过到 Activity，但是不是到 onTouchEvent还真没底。面试官很自信的样子，让我颤抖了。但是随着我的坚信，面试官说：『不行，我不能冤枉你是不！』立刻在手边的 MBP 上看了一下，自言自语感叹道：『还真有啊！』 我顿时无语了。</p>\n</li>\n<li><p>另外一点是：问我 Service 上能不能弹出对话框。对于这个问题，我印象最深刻了，记得一年前的时候，在另外一个公司就因为这个问题让我尴尬万分，回去后专门对这块进行补充。我的回答是可以的，但是面试官面带差异的表情告诉我这是不行的，Dialog 必须要依附于 Window 才能显示出来。然后我的解释会让面试官郁闷一会：我说这个是可以弹出的，我之前也专门试过，不过他弹出是有条件的。 条件是：</p>\n<ul>\n<li>必须在 Manifest 里面注册系统权限</li>\n<li>在显示 dialog 的时候必须要加一个 flag.<br>我的理由是：系统对话框可以在低电量的时候弹出对话框，我们同样也可以采用该方式来实现。</li>\n</ul>\n</li>\n</ul>\n<p>面试官语塞，然后给我说 Dialog 是必须要依附在 Window 上，Toast 其实也是一个 Window。我听着这些话，就想起以前看过的一篇文章上也确实是这么说的。估计该面试官回去要好好补充下一些知识了哦。 然后该面试官让我不能用 Arraylist,用数组 写一个队列。这块刚好我在之前项目中特意用了一下，写的时候，主要有三个方法： put(), get(),peek(). 然后考虑下队列的特性，一端进入，一端出去。我当时遇到了盲点，没怎么写完，最后给面试官说了下思路，大体是对的。但是关于选择位置那块没怎么想好。不过这不阻碍我进入第二轮。</p>\n<p>第二轮面试的时候，面试官带了很多纸张，我瞬间压力山大，知道不太妙。不出所料，这个面试官，从动画实现原理，到 handler 实现原理，一步步深入各种原理，当我感觉回答的不错的时候，然后他就顺着我的问题继续深入。我只能说我尽力了，有些东西，平时开发的时候真心不注意，但是就因为没有留意，所以就没法继续回答他的问题。</p>\n<p>面试官把我带出大厦的那一刻，我心情很不好，很可惜没进入百度，之后应该需要准备很多东西。我要说，我还会再来的，哈哈哈！ 最后也归还身上的一个牌子到前台后，省的被拉入到黑名单（好吓人的样子）。</p>\n<p>以后有时间多看看原理性的东西，最好整理一个自己的博客，写上自己的一些看法和感悟，这样记得最深刻，即使几年后也不会遗忘，只是看看别人总结的东西，真的就不怎么记得住。</p>\n<p>关于博客可以使用 Hexo, 我的博客也是如此，可以整理一些自己的东西与心得。</p>\n<h3 id=\"2-阿里\"><a href=\"#2-阿里\" class=\"headerlink\" title=\"2.阿里\"></a>2.阿里</h3><p>这次去的是一个阿里的高德部门，在望京 Soho 附近的 首开广场。去了以后首先找厕所，你们知道么？厕所竟然从大厦楼层的的一个角转了一大半圈才找到，回来后进入找不到前台了…… 瞬间无语了。问了好一个美女才回到前台，然后接待我的 HR美女貌似等得不太耐烦了（宝宝心里苦，厕所好远，都找不到回来的路了）。在一个小型会议室等待面试官，看了下布置氛围和环境，感觉太棒了，很多东西都体贴入微。</p>\n<blockquote>\n<p>回顾上次阿里的悲痛遭遇<br><br><br>其实这是我第二次来这边面试了，上一次过来的时候，是刚过完年。提到这里我就苦不堪言，为何如此说呢？当时是2016年2月15日，因为我参加好朋友的婚礼（不得不说，我这个年纪的人都开始结婚了，这次回去有4个好朋友都结婚，可想而知，一场完了以后还有另一场，虽然累，但是值得）推迟了好几天才回北京，在参加同学婚礼的时候接收到阿里高德部门的面试邀请。回到北京的当天是12点多，然后回家，一个关系非常好的朋友说今天她们要宴请公司的人吃饭，因为她们结婚了，让我帮忙弄个 MTV。我想这是朋友的终身大事，因此必须要好好干。<br><br><br>我下午4点是阿里高德的面试，因此时间很紧促。我凭借我大学的技能在两个小时内搞定这个 MTV，总体来说还不错，就迅速发给朋友，弄完已经3点了，然后打车立刻去首开广场。<br><br><br>高德的面试是4点钟，匆匆赶到后，就等待面试官。面试很不理想，因为什么都没有准备，而且心力憔悴。面试官问的是一些基础的 Java 问题，很可惜我没怎么回答好。于是就深深的浪费了一次机会，之后和朋友提起此事，无比后悔，当时其实是可以和 HR 电话再约一个时间的。<br><br><br>这次对我的打击很大很大，因为这是我这么多年第一次面试 BAT 的职位，一上来就受挫，很不是滋味。<strong>我在这里失利后我就各种准备资料，增强自己的能力，面试前必须要刷题，虽然简单，但是不失为一种方法，虽然不一定有用，但是会加深印象，尤其是去 BAT 这些公司，一定要准备好，否则就别浪费机会，这就是我的教训和经验。</strong><br><br><br>为了6月份的这次面试策划了很久。以前对什么可能都不是很上心，但是这个事件深深的刺激我了。</p>\n</blockquote>\n<p>第一个面试官来了后问了一些基本问题，很顺利就进入到第二轮面试。</p>\n<p>第二轮也基本是技术面试，问了一些 Android 基础和 Java 基础以及内存管理。</p>\n<p>第三轮的面试官应是部门负责人，看起来很好说话的，问了一些经历和基本情况后，问我薪资要多少以及之后的发展方向。我说要 XX，之后希望在架构方面发展，但是也可以从业务开始。貌似这里回答的不怎么好。然后让我留了他的联系方式，我知道很有戏哦。</p>\n<p>因为我在进入 K 公司的时候也是这样的，老大感觉我很不错，于是留了微信后，我基本就顺利入职。</p>\n<p>回去后的一两天还是很焦虑的，但是我知道大公司都是有流程的，因此我告诉自己不要焦急。过了一两天后他主动加我微信，然后问了些基本情况后，就说他要做最后的总结，让我等着，最迟一周后就有消息。我感觉希望超大的，开心了好久，本以为就可以这样过去。但是一周时间过去了，没人通知我，我开始焦急了，于是我开始主动和他说话，反思自己是否有什么地方做的不好。</p>\n<p>经过很多面试后我总结出了结论就是要薪资太高了，于是我在微信里面给他说，只要能过去，薪资低点也是可以的。但是问了他好几次，他都没有回话，看着微信消息记录，都是我发给他，而他没有回复，已经过去好多天了，我知道没希望了，他说不管怎么样都会给我回复的，但是我真绝望了。</p>\n<p>就像相亲一样，遇到一个不错的美女，开始都一起聊得很不错，她开始加你好友，并且和你说看好你，不管能不能做女朋友，她之后一定会回复，但是苦苦等待一段时间后，不管你怎么给她说话，但是她就是不理你。可能她真的忙，但是也不可能连续一两天都这么忙吧。于是你知道没结果，因为无言等同于没有希望。为了避免一些幻想的存在，你会将她删除掉，不想留下任何关于他的信息。</p>\n<p>同样我也是把这个阿里高德的老大的联系方式删掉，微信也删掉。在我失去希望的时候，过了几天看见他要主动加我，但是我想可能只是安慰的话语，最多告诉我，我不适合他们的职位，因此我为了避免尴尬，直接删除那个加我好友的请求（如果说真的合适的话，应该会很重视你的，不可能好几天都回复，怎么有一种备胎的感觉，呜呜呜，我不想被发好人卡，宁愿做高傲的兔子，也不想做纸老虎，虽然尽管只是纸老虎，但是也会拥有属于它的一片森林）。</p>\n<p>于是阿里的这次机会就失去了。</p>\n<p>总结后的结论就是：去大公司要的薪资不要太高，否则对方只能感谢你的到来，因为比你优秀的人太多了。</p>\n<h3 id=\"聚美优品\"><a href=\"#聚美优品\" class=\"headerlink\" title=\"聚美优品\"></a>聚美优品</h3><p>聚美优品 位于东四十条地铁站附近。路过一个竹亭子后，进入大厦里面需要用身份证在前台那块登记后给我一个纸条，上面写着我的身份证信息，然后在门禁卡附近刷二维码进入（真担心个人信息泄露哦，当然一般情况下没人会关注你是谁的，千万别干坏事哦，会被查出来的，哈哈哈）。</p>\n<p>推荐我去聚美优品的同事接我上去后，带我到前台填写基本信息。我只写了最基本的信息，然后她说，你就写这么点啊。我说，其实这些信息够用了，写那么多没用，还会暴露你的个人信息。面试成功后，如果有需要可以写详细些，但是一般去面试最好别写身份证信息。工作经历基本也只是最近两个，之前的就不用写了，写那么多没什么用，简历中都会有的。</p>\n<p>记得刚工作那会，傻傻的全写了，真耽误了不少时间。过了一会，她把我交给 漂亮的HR 温柔姐，然后就先忙去了。温柔姐告诉我一般情况下有两轮基本就过了，先让架构师老大直接面我，让我先等候。</p>\n<p>过了一会温柔姐不好意思的跟我说架构老大先让一个技术面我，问我是否有意见，我当然没意见了，这是很标准的面试流程（如果你有意见，建议还是别说太多的话，基本都这样的，要淡定）。</p>\n<p>一面技术给我一种很成熟的感觉，开始问了我一些基础技术问题，外加 Java 内存管理知识。后给我出了一道算法题，说有一个数组最多存储6个数，如果有普通用户的话，存储四个 vip的客户，另外两个是普通用户（留出一定的空间给普通用户），让考虑全面点（一般都是结合实际场景，让你写出一个算法，要具备的能力就是抽象，处理问题的思路与细节，还有最基本的编码功底）。</p>\n<p>然后我就考虑各种情况，第一种是非空情况，然后下面就是几个大的 if else, 至少四个条件，基本涵盖了全部情况，然后每个条件里面写上对应的存储数据的过程。由于我的四个大条件都把距离占的差不多了，在写里面细节的时候，用中文描述。过了一会他回来后，看了下说：『你这个还有中文啊！』 我尴尬的笑着说：『我先写条件的，最后发现没有空位了，只能用文字代替了，你看我正在另外一个纸上写全部的完整算法。』指了指纸上刚写一小半的代码。他也会心一笑，并指出算法上应该改进的地方，基本 ok 啦。</p>\n<p>然后等第二轮的面试，看起来更成熟，但是说话有一种很亲近的感觉。问了基本情况，然后拿出他们的 app 让我看看首页的实现效果，说说怎么实现的。对于这种情况，基本就是考察你的抽象能力，以及分析问题的能力。我先说出使用 ListView 的 header，footview,然后使用 ListView 的 type 来实现。然后简单说了一些性能优化的东西，该面试官提出我的做法可能会存在性能瓶颈。其实他说出这块是在指导我说这块会有问题，我当然明白他的意思，于是说这块采用 recyclerview + fresco 来实现，可以有效的改善问题（其实提到这些，就说明你看过很多新技术了，有时间最好还是要自己练练这些东西，毕竟孰能生巧）。</p>\n<p>他也没深究，基本就感觉不错，开始谈了谈他们的目前状况，以及即将遇到的问题。他在只言片语中都把我当做内部人看，我也心里感觉很舒服。最后告诉我如果我愿意，他就向上报备了，意思是可以继续下一轮。当时他问到我的薪资的时候，因为之前已经说了 N 多次，有的成功，有的感觉很亏，于是这次我并没有说，只是笑笑，而对方说：『那就按照年薪算吧，你打算要多少呢？』我当时什么也没有多想，然后就说：『我希望在我现有的薪资基础上，能上涨15% - 20%。』他经过在手机上一阵比划后，告诉我可以达到我的预期效果。整个过程感觉很愉悦。</p>\n<p>因为面过了一些，并有offer，但是还是想多看看，结果把自己搞的疲惫不堪。但是最后的最后，温柔姐给我打电话说面试通过。</p>\n<h3 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h3><p>最终我辞职后在家休息几天，没事的时候去咖啡馆看看书，上上网，好好过几天轻松的日子，然后再说定去哪里工作。</p>\n<h3 id=\"总结：面试和必备的技能\"><a href=\"#总结：面试和必备的技能\" class=\"headerlink\" title=\"总结：面试和必备的技能\"></a>总结：面试和必备的技能</h3><p>这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。</p>\n<ol>\n<li>一般情况下第一轮都是基础面试，需要扎实的基础<ul>\n<li>最常用的Android 基础知识</li>\n<li>Java 基础知识</li>\n<li>了解一些 常用东西的原理，例如：handler， thread 等</li>\n<li>项目中的技术点</li>\n</ul>\n</li>\n<li>第二轮的时候需要了解更深层次的东西<ul>\n<li>Android 事件分发机制原理</li>\n<li>Android 绘图机制原理</li>\n<li>WindowManager 的相关知识</li>\n<li>进程间传输方式</li>\n<li>Java 内存管理机制</li>\n<li>一些常用的 list,map 原理，以及子类之间的差别</li>\n</ul>\n</li>\n<li>能进入第三轮基本没什么问题，但是要注意以下问题<ul>\n<li>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度</li>\n<li>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</li>\n<li>我们的面试原则就是拿到合理薪资，得到 offer</li>\n<li>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。</li>\n<li>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</li>\n</ul>\n</li>\n</ol>\n<p>如果你有面试的疑问或者困惑，可以加我的微信公众账号:<a href=\"http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg\" title=\"面试说\" target=\"_blank\" rel=\"external\">mianshishuo</a>, 可以扫描下方二维码，一起来吐槽面试中的感受。我将不定期分享最新的 Android 面试题与面试经验。也可以将你们的面试经验与问题发给我一同讨论，非常感谢。</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg\" alt=\"\" title=\"微信公众账号：面试说\"></p>\n","excerpt":"","more":"<h3 id=\"花絮\"><a href=\"#花絮\" class=\"headerlink\" title=\"花絮\"></a>花絮</h3><p>本文为完整版，加了一些彩蛋哦！文末有面试和必备的技能点总结。</p>\n<blockquote>\n<p>也许会有人感叹某些人的运气比较好，但是他们不曾知道对方吃过多少苦，受过多少委屈。某些时候就是需要我们用心去发现突破点，然后顺势而上，抓住机遇，那么你将会走向另外一条大道，成就另外一个全新的自我。</p>\n</blockquote>\n<p>先简单说说我最近的面试经历吧。面试的公司很多，其中有让我心血沸腾的经历，也有让我感到失望到无助的经历，我将这些体会都记录下来，细想之后很值得，面了这么多公司，要是最后什么也没有留下来，那就太浪费了。至少对于我来说有些东西在整理总结之后才能得到一个肯定的答案。希望这些能对即将换工作或者打算看看机会的你有一些帮助。</p>\n<blockquote>\n<p>下文真的很长，你可以把这篇文章当做看小说一样，快速浏览一下，但是希望你能将文中提到的那些技能掌握。那也就不枉费我花了一两天时间专门整理这些。我的这些经验仅供参考，希望你能做的比我好，同时希望你在以后的面试中能轻松应对。</p>\n</blockquote>\n<h3 id=\"为何离职？\"><a href=\"#为何离职？\" class=\"headerlink\" title=\"为何离职？\"></a>为何离职？</h3><p>先从我的换工作的动机开始说吧。</p>\n<p>公司裁员的时候老大说:『你就留下好好干吧，以后不管公司怎么分股票、期权，肯定少不了你』。我非常信任我的老大，跟着老大一起工作，感觉是一种享受。</p>\n<p>但是没想到裁员后，公司内部大动荡，主业务线从客户端A 业务线转移到另外的B 业务线上。我主要负责A客户端的架构，这下可真闲下来了。B 业务线那边的业务量还是很忙的，没时间配合我做一些架构上的事情。于是我每天就看看资料，补充点能量。</p>\n<p>呆了几天后，就后悔当初没有拿 N+1 走，有一种被老大忽悠的感觉。 因为公司接下来的操作让我很是不爽，先是晚上打车不能超过30，然后福利大减，瞬间没有工作的心情了。再过了一两周后公司宣布新一轮融资成功，可惜只融到了 2千多万美元（按照预期应会更高），然后接着招新人。</p>\n<p>我特么无语了，站在公司的角度是没有任何问题的，可以节省开销，也可以容纳新鲜血液。但是我作为一个老员工，心寒，走的员工都拿到了 N+1，我们这些老员工什么也没有得到，反而福利大减，伤人啊! 现在即使我想走，什么也得不到，一种莫名的恼火涌上心头（只怪本人经历尚浅，看不清一些大的趋势，还是老鸟们聪明，拿钱走人，然后换一个新工作，好不自在啊）。</p>\n<p>不过理智分析一些这样确实有好处，可以给自己留很多的时间来选择更好的公司。就如此刻的我一样，在公司悠闲的上着班，骑驴找马，遇到合适的，可以立刻走。其实细想一下，如果我当时拿了 N+1 走了后，可能会迫切的需要一份合适的工作，然后迅速入职。至于新公司怎么样，还真不敢确定。</p>\n<p>已经动了想走的心，意味着再也不可能在这里很安分的待下去了。</p>\n<h3 id=\"面试分级\"><a href=\"#面试分级\" class=\"headerlink\" title=\"面试分级\"></a>面试分级</h3><p>于是我决定开始投递简历（世界那么大，我想去外面的世界看看）。这次看机会与往常不同，我决定好好准备一番，然后开始投递简历，主要渠道是 “X钩”，辅助渠道是猎头。</p>\n<p>这次看机会我将所有公司分为三类： </p>\n<ol>\n<li>A类： BAT公司，非常靠谱，各项待遇都是很优厚的</li>\n<li>B类：一些知名的互联网公司（基本都在C轮以上），基本很靠谱，该有的都少不了</li>\n<li>C类：就是那些正在招聘的公司，没啥名气，虽然钱多但是事也多。靠不靠谱真还不知道，只能碰运气</li>\n</ol>\n<h3 id=\"基础知识不可少\"><a href=\"#基础知识不可少\" class=\"headerlink\" title=\"基础知识不可少\"></a>基础知识不可少</h3><p>以前我基本都是直接去面试，总以为Android工作好几年了，出去面试基本没啥问题，因此带着那份傲娇的自信 总是碰壁，尤其遇到很多基础性的问题，一时真不知道怎么回答？还有一些问题之前都记得很准确，但是在面试官问的时候，就一个大写的懵逼表情。</p>\n<p>在我出去面试之前，我已经把 《大话数据结构》 基本看完了（想想我之前的生活，每天早上七点多起床，然后看几页，洗漱完就去公司）。虽然没怎么记住，但是遇到这些相关问题，还是能很容易回答出来的。因为有了以前的教训，而且这次我也是很认真的准备了好久（可以说蓄谋已久啦，我心里其实很明白互联网公司可能存在很多风险，尤其是没有盈利的公司，唯有技术这东西必须牢牢掌握住，才能立于不败之地），因此我准备把Java基础巩固下，但是手头没啥合适的书籍和资料。</p>\n<p>还好民间有很多厉害的开发者，他们不以盈利为目的，只为完成某种需求，开发一款 app,然后发布到应用市场，给需要的人。于是我就找到一个 “Java面试训练” 的App,下载量还可以，就安装到手机上，开启刷题模式，应该刷了10来天吧（都是在上班，下班时间看一点，虽然时间比较零散，但是这样记得最深刻）。在之后的面试中，基本很少遇见一些奇葩的java基础。</p>\n<blockquote>\n<p>这里不得不提一件事，那就是从 app 崛起的那一刻起，就有很多的 中间商，一个小作坊的屋子里有很多电脑或者不知名的设备，屋子里慢慢的数据线，犹如蜘蛛网一样连接着很多设备，做着一些神秘的事情。不用我说你们应该也知道他们做着一些很肮脏的事情，我就不细说干什么了，简单举个例子：这群人的老大看中某个市场上某款游戏非常火爆，或者 app 特别的火，于是通过反编译等技术修改这些 app,然后重新打包上线到一些不是很知名的app 渠道或者小型应用时长，还有一些论坛，一旦有用户下载，就会在 app中弹出广告，在游戏中做各种充值操作，甚至在你无意间点到一个按钮就会自动扣除你的话费。这是前几年干的事情，新闻中也纰漏了很多，这里只能说监管不力。</p>\n<p><br><br>但是随后各个公司都意识到这样的安全问题于是有了 app加固的技术，无法修改 app,即便修改了，但是也运行不起来，所以一定要注重安全性问题。</p>\n</blockquote>\n<h3 id=\"刚踏入架构师之路的经历\"><a href=\"#刚踏入架构师之路的经历\" class=\"headerlink\" title=\"刚踏入架构师之路的经历\"></a>刚踏入架构师之路的经历</h3><p>这次我给自己的规划是做一个架构师，但是我深知架构师可不是闹着玩的，必须要有很强的一面，因此我在简历里面写的只是“架构师方向”。我在K公司 做得是架构师方向，因此我觉得有必要朝着这个方向发力，虽然现在不是很厉害，但是坚持一两年后，即使不是非常厉害，但是也距离非常厉害很近（这里使用了《孙子兵法》的一句：“求其上,得其中;求其中,得其下,求其下,必败。” ）。</p>\n<p>这个想法来源于在K 公司我第一任leader曾经跟我说过的话：『对于新东西，如果你觉得掌握了，但是不应用到项目里面来，是没有什么意义的，时间长了还是会忘记的。』我很庆幸我有一个好老大（我是属于双领导型的，K 公司 A项目的负责人是我的leader，但是我的直接汇报对象是 K 公司的副技术总监，下文就成为老大），用他的话来说就是经常踢着我的屁股走。</p>\n<p>当我在网上了解到很多实用的新技术时，跟他随意吐露一句话，他就能非常用心的倾听我的想法，并鼓励我将这些东西带入到项目中来。从那以后我就开始看很多新技术，感觉合适的会引进到我们的项目中。从之后的证明中来看，是非常有价值的。</p>\n<p>曾经遇到的情况是这样的：当我刚进入K公司后，打杂一个多月，就被关到了 小黑屋（呜呜呜，好可怕的小黑屋，996的制度）。然后才开始正常的架构师之路，第一步就是统一开发环境，在我来公司后，我发现公司的android同事用的开发工具种类真是繁多啊，神马 Eclipse、IntelliJ IDEA、Android Studio、Windows、Ubuntu、Mac。刚进公司的时候我曾经用鄙夷的眼神看过那些 Eclipse 的童鞋，真是无力吐槽了。于是我给 老大说：『咱们的开发环境最好统一起来，现在各式各样的工具，弄个东西真费劲。』于是老大二话不说，就在群里跟大家吼，都务必切换到 Android Studio（以下简称 AS），由我来监督并执行。于是我拿着鸡毛当令箭，给大伙把地址什么的都找好，发到群里去，让他们自己下载（后期我们就搭建了 ftp服务器将这些常用的工具都放在里面，省的再去下载了）。 翻墙工具我使用 goagent（不怎么稳定），给其他人分享也太费劲了，因此让他们自己搞定。老大自己有一个 VPS，于是给大伙共享后，环境基本就统一了。</p>\n<blockquote>\n<p>期间有一个小插曲：<br>一个年龄 比我大的同事在用 Eclipse，在我推广我的 AS 时，他说比较忙，没时间弄。我就急了，因为我刚到公司不久，老大分配给我的任务，推行不下去，这可不行啊，没说几句吵起来了。最后我也知道不能太着急，但是已经吵了，关系肯定不咋样，老大当时开会去了，我知道自己太心虚了，因此主动给老大承认错误，说我和那谁谁吵架了，因为他不用AS。最后在老大的劝说下，这个人就勉强切换到 AS了。<br>其实这个人就是我之后的新Leader，每每想到这里我就全身发冷汗，Leader要虐你，你还能有好活路么？还好这个Leader人比较好，人也比较大气会处事，不怎么跟我计较。我已经对着佛祖忏悔了N多次。</p>\n</blockquote>\n<h3 id=\"第一天面试\"><a href=\"#第一天面试\" class=\"headerlink\" title=\"第一天面试\"></a>第一天面试</h3><p>我用 “X钩” 开始捡一些不怎么有名的C 类公司投递，很快就收到了很多的 面试邀请。</p>\n<h5 id=\"首次面试——国外输入法\"><a href=\"#首次面试——国外输入法\" class=\"headerlink\" title=\"首次面试——国外输入法\"></a>首次面试——国外输入法</h5><p>记得当时去的第一家公司是做国外做输入法的，做的还不错。从外面能看见一栋略微有点老的大厦，办公环境很一般。</p>\n<p>进去后很巧的是遇见了一个熟人，第一位面试官竟然认识我之前在X游的一个同事，然后我们就聊开了，他也没怎么难为我，就问了我几个很简单的问题，例如：handler的原理，多线程。我按照记忆中的样子说给他听，然后就第一关就轻松过了。</p>\n<p>等了一会，另外一个面试官进来了，问了一长串问题，基本就是 Android的相关的基础，然后第二个又轻松过了。</p>\n<p>等到第三关的时候，一个年龄稍微大的人进来了，很容易能看出，这个人应是该技术团队的负责人，问了一些工作经历后，然后问了一个最让我印象深刻的问题是：『你了解过Android上的黑科技么？比如Android 5.0 之上有一个辅助功能，如果用户开启后，就能像豌豆荚那样自动安装app,等同于拥有了root权限，但是手机重启后，这个就自动关闭了，有没有办法可以自动打开呢？』据他了解，有很多不知名的小App 都实现了，但是很多大公司都没用。 我想好好一会，说可能这些app 被厂商列入了白名单，因此重启手机后还能自动打开那个辅助功能。我实在想不出如何能实现这样的效果。最后他告诉我，其实他们也是分析了好久，才发现，那些小App, 都是开启了一个进程（或者是service，具体记不清了，有兴趣的童鞋可以试试）来守护，因此能够开启。这么一说，我也瞬间明白了。</p>\n<p>但同时我提到这样做会可能会导致耗电量增加啊，对方的一句话把我真雷住了。“那能费多少电。。。” ，我瞬间无语了。但是他们可能因为某些需求必须如此做，因此要实现这样的功能，相对于电量来说应该也能接受，不至于比什么都玩不了的强，体验也确实提升了很多。不用用户每次去开启那个开关，虽然有点风险，但是相对于Android上的风险来说，确实低很多。</p>\n<p>等第三轮面试完成后，然后Hr 小妹妹带我到一个很大的会议室，见到一个很年轻的人，听Hr说，这个人应是CEO之类的，反正职称很高。他就问了些职业规划，平时有什么兴趣爱好，以后有什么打算，薪资要多少？我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。平时就看看书，参加沙龙活动，没事打打游戏。他也简单回答我一些问题。之后就是让我先走，等通知。</p>\n<p>傻傻的我还就这样高兴的走了，因为我总体感觉还是很棒的，毕竟连过4轮哈。从最后的结果中能明白，其实应该是要的薪资太高了。为什么这么说呢？因为一般情况下，最后一轮就是简单看看你这个人怎么样，技术关肯定没问题，否则前三关就 pass 了。可能对方觉得你要的薪资和你的实力不符合，也可能他们想再对比看看，选择一个更合适的人选。</p>\n<h5 id=\"58到家\"><a href=\"#58到家\" class=\"headerlink\" title=\"58到家\"></a>58到家</h5><p>从上一家公司面过后，我就紧接着去第二家公司 58到家，在大屯路东地铁站附近。到了后刚好12点，电话联系后，他们说班车司机都午休去了，要等到2点才能过去（58到家面试需要从地铁站做班车过去，路程还算能接受的）。然后我就吃了点饭，在附近网吧 撸一局，看时间点差不多了，我就去那块坐车了，差不多走了5分钟做就到了。</p>\n<p>北苑路北美国际商务中心，这块有很多公司，什么珍爱网之类的都在那附近。</p>\n<p>第一轮面试我的是一个小伙，问了一些基本的Android基础，然后问了一下 android的绘图原理，我说： onMeasure, onLayout, onDraw。 然后他说每一个什么作用？ 那个onMeasuer主要做什么的？并举了一个例子：一个自定义的滚动View A里面如何放另外一个滚动的View B？我说把 View B将 onMeasure 里面的高设置成最大，这样就能解决冲突问题。最后他简单说了一些 onMeasure 里面的几个参数，我对此加深了解了。</p>\n<p>第一关也就这样过去了，等到第二关的时候看起来一个挺帅气的男人带着一个很显眼的婚戒跟我说一些项目流程上的东西，因为我在K 公司这块跟老大接触的比较多，因此一般问题难不住我，轻松就过了。</p>\n<p>等到第三关的时候，问我一些工作经历，然后问问职业发展规划，平时的兴趣爱好，以及你觉得得你和其他人有什么优势。我挺好奇的，为什么最后的这些面试官都要问类似的问题，之后从一个关系还不错的猎头那里了解到，其实他们也就是了解下以后的动向，以及看看这个人的人品。关于优势我是这么说的：我说到公司后可以先接触一些业务层面的东西，然后慢慢再走架构路线，之后可以负责主要核心模块。其实和上面的回答一样，这基本就是所说的套路。他们可以用套路，我们为何不可呢？ 嘿嘿，别学我，自己根据实际情况来。</p>\n<p>本以为就结束了，没想到他们说 CTO不在，可能还有复试，先让HR大美女跟我谈谈。HR慢条斯理的跟我说了一些待遇什么的，了解了下我的状况，问我要多少。我基本和上一个公司说的一个样。</p>\n<p>之后再来复试的时候，这个大美女HR给我了一些建议，说这个CTO是阿里出来的，喜欢会说话的人，想到什么就说什么，别紧张。在这面的时候，我就很放松，该怎么说就怎说，他也问了一些职业发展规划，以及我的经历，基本10来分钟就结束。我只想说大美女 HR 真真是体贴入微，感觉很 Nice, 这轮基本也顺利过了。之后这个HR直接说我被评为T5，但是以后可以继续努力，我也欣然接受了。不管怎么样，反正拿到offer再说，之后慢慢对比。</p>\n<h5 id=\"楚楚街\"><a href=\"#楚楚街\" class=\"headerlink\" title=\"楚楚街\"></a>楚楚街</h5><p>说起这第三家 楚楚街 我就一肚子火，也不是说第三家不好，只是在去的路上让我备受折磨。从大屯路东 到 知春路，坐地铁应该几十分钟就到了。当时已经快四点了，5点面试，然后我就打算坐车去（不想再挤地铁了，想轻轻松松的过去），特么的为了省那几块钱，我选择拼车，在路上本以为只需要最多一个小时就到，没想到花了我1个半小时(只能感叹北京的车真多，路上堵的不行不行的)。哎，到他们公司的时候都快6点了，还好我提前在电话里和HR说过，他们说6点也是可以的。于是第三个面试就开始了。</p>\n<p>首先过来第一位面试官，看样子应该是 Android 技术 leader，开始问了我一些基础的面试题，比如：View 的事件分发机制，View的绘图，ListView 的实现原理（这个应该是几年前面试的时候经常问题，没想到现在也能遇见）。聊了好一会，然后他拿出他们的客户端给我演示了一个页面，说这个界面比较卡顿，让我分析下原因。我看过后，提出了几个有效的检测卡顿的方案，他们的这个界面主要是Listview 的 item 里面包含了一个 viewpager，然后 viewpager 的 item 里面有一个大view, 上面有N 多图片 + 动画效果，因此实现起来很麻烦,最后导致性能卡顿（不得不说产品同学，你的想象力真丰富啊，有没有考虑过研发同学的心情）。然后，他感觉得到了共鸣，因此接下来说话就比较放松了，他说和我年龄差不多，感觉我还是很厉害的（我不禁惶恐不安，我感觉还行，但是应该不是他说的很厉害，可能只是工作时间长了，该积累下来的东西大部分都有了），互留了微信，方便以后的交流（事实是没有啥交流的，只是当你面试通过后，可以有一个拉你入伙的渠道，嘿嘿，不晓得对不）。</p>\n<p>第二个进来的面试官长得挺帅气的，手上戴着戒指（之所以提到这个，是因为在我在我的印象中这个最亮眼，很多次在和他交流的过程中，我都比较紧张，我就盯着这块看用来放松，说真的如果看着对方的眼睛，双方可能都不会自在，当然除非你很有自信的时候是可以的）。开始简单问了下工作经历，然后就开始聊技术，第一个就是问我知道不知道 二分法，我当时楞了一下，猛然间反应不过来，最后专门确认问了下是不是 二分查找。然后我说在一个数组里面每次查找的时候从中间点开始对比，大于就右边找，小于就左边找，顺带提了一句这要在一个顺序的数组里面。然后面试官就说，二分查找还得每次先排一次序？我当时说是的，结果就感觉很2，可能没理解清楚面试官表达的是什么或者说我的表达有问题，其实我想说最开始的数组就是一个有序数组，但是面试官可能误解了我的意思，以为每次查到后，都要先排一次序（只能说悲催啊）。</p>\n<p>这个问题过了后就再问了我一个问题：『你来说说 Java 的内存管理。』这个问题在一两年前上就栽过跟头，所以当时专门看过相关文章。但是当我回答的时候，由于长时间没怎么看过了，记忆有点松动，大体的说出来了，但是不够准确（回去后就好好补充了下，在之后的面试过程中遇到的概率还是非常大的，尤其在第二面的时候）。然后他问我要多少薪资，我当时说 XX，然后他就问我是不是可以低一些呢？我开始说可以低一点，但是当他问低多少的时候，我心想上面两个公司的 offer 基本感觉到手了，这个可以适当的要高点，能给就来，给不了那就算了（我事后想想才明白，这种2B 的想法绝对不能有，要时刻保持低调，把握住任何一次机会）。最后他说，我得对得起兄弟们（怎么说呢？估计是刚回答的时候不是特别的满意，还有感觉我要的太高了），你这个薪资我没法跟上面谈。然后可想而知，当然肯定没有结果了。</p>\n<p>因此奉劝各位，要时刻保持低调，谦虚谨慎，莫要装B，否则肯定遭雷劈，我这就是一个活生生的例子。</p>\n<h3 id=\"第二轮B-类公司面试：\"><a href=\"#第二轮B-类公司面试：\" class=\"headerlink\" title=\"第二轮B 类公司面试：\"></a>第二轮B 类公司面试：</h3><p>面试有很多，说起来可能会长篇大论，以下就总结性的说说，不再说明具体细节，只说我们之后在面试的时候应该注意的地方，以及他们对应聘者的要求。</p>\n<h5 id=\"映客-amp-amp-蘑菇街\"><a href=\"#映客-amp-amp-蘑菇街\" class=\"headerlink\" title=\"映客 &amp;&amp; 蘑菇街\"></a>映客 &amp;&amp; 蘑菇街</h5><p>映客直播在望京soho,很高大上的地方，t1,t2,t3分别对应从低到高的大楼。到公司后，感觉还可以，第一个面我的人是一个技术，基本就问到一些Android 的面试题，没有任何悬念就过了，第二面的时候，感觉那个人还是比较随和的，问了 Java 内存管理的东西，以及一些其他的问题，最后还都聊得挺开心，第三面的时候直接就是 HR谈薪资，很容易就过了。</p>\n<p>在望京 soho 还去过 蘑菇街，里面的人技术比较好，我当时过去的时候已经6点了。那个面试官就跟我聊人生理想，提到一些 Android系统原理性的东西，但是感觉回答的不是很好。面试官感觉还是很不错的，然后给我说你以后要多看看例如 handler 原理，windowManager 的东西，并且从源码上去分析，网络上的理论知识还是要结合实践的，真是受教了。这部分我有点弱，虽然知道原理，但是看过源码的东西还是很少的，以后需要注重补充。他说他才是高级，我要应聘的这个 架构师肯定是不行的，问我是否愿意做其他的，我当然表示愿意了，现在要综合提升能力，才能往更高层走。</p>\n<p>最后的最后，他很搞笑的跟我说：『我这人真不骗人』。我还纳闷啥意思，最后他说：『今天已经很晚了，第二轮的面试官不在，我明天给你向上反馈下（从之后的一个同事的口中才明白，一般说第二轮的面试官不在，基本就是说你没戏，很委婉的一种说法而已）』。</p>\n<p>结束后我看了一下表，我晕，一面就面试我了一个半小时，真特么无语了。不过收获还是很大的，知道自己的不足后，就知道需要补充哪些东西了。</p>\n<h5 id=\"乐视\"><a href=\"#乐视\" class=\"headerlink\" title=\"乐视\"></a>乐视</h5><p>去了一趟姚家园的乐视，只能说看着挺风光的，但是进去后，特么的真虐人。</p>\n<p>电梯分区，还只能在一边的乘坐，很不赶巧的是我去的时间刚好是10点，对于他们公司来说这就是高峰期，电梯根本排不上队，而且乱糟糟的（之前在X游的时候，大家都是排队的，这边没有，可能地方太小了，排不开吧）。电梯上不去了，看来只能跟一些人爬楼梯，一直爬到9层，感觉都喘不过气了。</p>\n<p>上去后一个很美的 HR（长腿姐）带我找面试官，然后表示没有会议室，原来的会议室都变成工位了，所以让我先在一个小角落呆着（保洁阿姨的专属位置），过了好一会面试官姗姗来迟，也是一些非常基础性的东西，最主要的是他们提到了推送，怎么实现，已经存活情况说了一些。</p>\n<p>第二个面试官也是特么来得晚，等了 N 久，闲的无聊就和保洁阿姨聊天，顺带看看他们的办公环境，只能说真心挤得慌。第二位面试官来了后就看看我的经历，因为第一轮的技术面都过了，因此简单聊了下，就说说他们的发展前景，要做海外产品。听我的兴致勃勃，很开心，然后让我等会。</p>\n<p>他们基本都去吃饭了，留下了我在那里干等，然后来了一个HR 的小妹妹，跟我谈薪资以及经历，貌似对我一两年换工作有很大意见，哥就好好给她普及了一番互联网界的基础知识。没想到就在快要搞定的时候，这个小妹妹的老大过来了，然后就看见一个身材超棒，腿很长的漂亮姐姐 HR（长腿姐），坐在我的对面（小妹妹示意我这是她的老大）。瞬间不爽了，都马上谈完了，结果换人再来，真无语了。只能将刚刚的辉煌时刻再来装 B一次，然后谈薪资神马的，给的也不是很多，我要 XX，她说那么多，只能给我薪资范围最低的一个档次。好吧，就接着吧，然后非要我先填写一份背景调查表，如果没有问题后，才给我发 offer，我看到美女拿着那份很大的 纸张，瞬间无语了。</p>\n<p>我当时就不怎么开心，然后长腿姐毕竟老练的很问到：『说你是不是有事？』。我说是的，待会1点还有其他地方的面试，然后她说：『那你先回去吧，这个表格发你邮箱，你写好后发给我。』然后长腿姐就送我出去，我又特么的一路爬楼梯下去（9层啊），电梯等了 N 久都下不去。</p>\n<h3 id=\"接下来说说几个有意思的公司\"><a href=\"#接下来说说几个有意思的公司\" class=\"headerlink\" title=\"接下来说说几个有意思的公司\"></a>接下来说说几个有意思的公司</h3><h5 id=\"新浪\"><a href=\"#新浪\" class=\"headerlink\" title=\"新浪\"></a>新浪</h5><p>新浪位于理想国际大厦，记得几年前去新浪面试的时候，傻傻的都没准备就去了，结果第一关就挂了。</p>\n<p>这次是下午去，外面还飘着毛毛细雨。去了后竟然特么的让我做面试题，哥已经不做面试题很多年。但是想起了之前的经历，还是老老实实写写，据我估计面试的哥们应该会问上面的东西。还好这次做了万全的准备，刷了 N 多面试题，补充了基础的数据结构理论知识。写起来如行云流水，嗖嗖嗖的没几分钟就完了。</p>\n<p>第一个面试的哥们看看卷子，没啥意见，然后问最后一道纠错编程题有没有什么问题，我虽然指出了几个错误，但是感觉他还不是特别满意。因此我仔细看了下，原来是一个静态变量引用了 Activity 的上下文,然后指出，他再问了一些偏底层的东西以及性能优化的地方，轻轻松松就过了。</p>\n<p>等到第二面的时候，这个人一看就是技术大牛，问了很多 Java 层面的东西，多态，抽象类，多线程，内存管理等等。我感觉回答的不是太好，多态那有点问题，其他的应该还可以。</p>\n<p>然后就进入了第三面，第三面的面试官应该是部门负责人，问了工作经历上的事情以及兴趣爱好，之后的发展方向，想做什么层面的。最后很不幸的是在等待第四面的时候，最开始给我题的美眉告诉我时间很晚了，让我先回去，之后等消息。</p>\n<p>至少这次来比第一次高级了很多，不至于第一轮就被刷下去。最后分析了下原因，还是薪资要的太高了，尤其是这类公司。</p>\n<h5 id=\"滴滴\"><a href=\"#滴滴\" class=\"headerlink\" title=\"滴滴\"></a>滴滴</h5><p>滴滴位于西二旗，应该有两个办公地点，其实我一直很想去滴滴，福利待遇很不错。一年前去过一次，很可惜在第一轮的时候，因为在某些适配方面回答的不是太好，因此失去了机会。</p>\n<p>这次已经准备很多了，进来后还是在去年的位置上坐下等面试官。说实话感觉滴滴成长的很快，办公环境都变的更漂亮了，哈哈哈。</p>\n<p>这个面试官一看就是一个技术宅，开始对我各种炮轰。面试题一个接一个的，在我连续回答十来个题后，看见他还在问，记得在提及到 volatile 的作用的时候，我就开始不爽了，这个东西记得之前在源码里面见过，但是具体的一时说不上来，看着他那样子，埋头在纸上给我出题，我就不怎么配合了。面试了那么多家，就你问了 N 多问题，还有完没完了（其实这也算是抗压的一种面试方式）？我直接说不知道，然后他再问了几个基础性的东西，我想都不想直接说不知道，他貌似已经看出来我已经很不爽了，然后说，那你说说你项目中有没有比较 NB 或者比较有亮点的地方。我的回答直接是：没有。然后他也就不怎么问了，说那先这样。我说：好，就这样，我先走了。 然后潇洒的离开滴滴。</p>\n<p>现在想想真特么的很2B，应该低调低调再低调。也可能是那天下午太累了，上午面试了两家，而且已经拿到两家的 offer 了，还都不错，在这特么憋屈，才表现的如此差劲。其实对于问题，知道的话就好好说，不知道的话，可以说说思路和想法，然后说说以后会怎么做，利用迂回包抄策略去应答，准没错。至少给面试官知道你还是可以动脑子的人。</p>\n<p>在此我真心后悔当时的冲动，向滴滴那位面试官表示歉意。其实不用那样的，我们只需在面试的时候尽力表现自我就可以，以后切莫带着情绪去看待或者回答问题。</p>\n<p>对于人生中的很多问题也是这样的，这次栽倒坑里去了（用我老大的话来说，你不在这里踩坑，总有一天也会在另外一个地方踩到，到时候的损失就不可估计，趁着年轻多多历练自己），总结之后才能更近一步。</p>\n<h5 id=\"百度外卖\"><a href=\"#百度外卖\" class=\"headerlink\" title=\"百度外卖\"></a>百度外卖</h5><p>百度外卖现在已经不属于百度了，而是单独分出来。</p>\n<p>我的一个同事去了百度外卖，我感觉他的能力和我差不多，我就让他推荐了。</p>\n<p>去后，上了一个很长的台阶（感觉很庄重的样子），要刷卡才能进去。等了好长时间，面试官把我领到楼下的公共办公桌，就是那种中间空地，周围都是楼层，能看见其他人在楼层间走动。一个年龄见长的面试官，开始感觉挺随和的，然后说跟我聊聊 Android 基础。</p>\n<p>第一个问就是：『咱们先来谈谈 Android 的四大组件。』我彻底懵逼了，尼玛，跟我谈四大组件，有意思么? 没想到一直到最后都跟我谈这些，一个接一个的问。说到广播那块，关于一个 app 被杀掉进程后，是否还能收到广播的问题纠结了好久。</p>\n<p>然后让我画我之前设计的架构图，我就随便画了画，但是没想到这个看起来很好的面试官让我大跌眼镜，他用鄙夷的笑容告诉我：『你这也太初级了。』我当时心里有几万只草泥马在崩腾，你都30+了，就不知道鼓励新人啊，我都说过我刚做架构的时间不长，而且鄙视我，有本事你也弄一个架构给我看看啊，一点不尊重我们年轻一辈的劳动成果。也许就怪我当时我真就按照他说的草草画几笔吧，没怎么认真对待。我去其他公司面试的时候，虽然这个图不怎么样，但是至少能解决 某些领域的问题，其他面试官都很谦虚。这个百度外卖的面试官，真不是我喜欢的领导，如果以后真让他来带我，那就真完蛋了，很多时候我们都是因为某些人扼杀了我们最初美好的萌芽，而从此失去了创新的意识。</p>\n<p>很庆幸的是我在 K 公司的时候，老大一直鼓励我创新，遇到想做的就去做，所以一路下来，虽然很累，但是干的很开心。</p>\n<p>所以每当有人问当初为什么选择K 公司的时候，我都会自豪的说：『我的老大很不错，我在那里很很舒服，很开心』。记得在我离开的时候老大给我最后劝告就是：『你要时刻反思自己此刻是不是已经被别人洗脑了。』</p>\n<h3 id=\"第三轮：\"><a href=\"#第三轮：\" class=\"headerlink\" title=\"第三轮：\"></a>第三轮：</h3><h5 id=\"1-百度\"><a href=\"#1-百度\" class=\"headerlink\" title=\"1.百度\"></a>1.百度</h5><p>百度位于海淀区上地十街附近，有很多大厦。 我去的是一个做国外工具的部门，去了后，被百度的环境和氛围震惊到了，在一个很大的技术园区，有网易，百度，腾讯公司，对面还有一个大楼正在修建，估计会是另外一个互联网公司的场地。</p>\n<p>进入大厦里面后，由于还没来得及吃饭，边吃手里的饼，边浏览下百度的外围办公区。进入百度的大楼后，两个入口都设有刷卡机。</p>\n<p>在空闲区等了好一会，然后一个人带我进入大厦。在进去之前，到前台那块面试官输入自己的邮箱账号，然后让我填写其他登记信息，我印象最深的是显示器上边贴着一个纸条，说：请离开的时候在此登记，否则会进入百度的黑名单（意思就这样，具体记不清了）。当时震惊了半天，没想到竟然这个严格。</p>\n<p>和面试官进入大楼里面后，只记得的印象是：很整洁，高大。出楼梯后，脚踩着厚厚的地毯，稍微走快点，都感觉很松弛，脚下如踩棉花一样。</p>\n<p>为什么有地毯，而不是地板砖————到了夏天很多漂亮的长腿美女穿着高跟鞋踩在地板砖上是一个怎么样的体验呢？噔噔噔…… </p>\n<p>我在等候区等到第一个面试官，然后我们简单聊了下 Android技术，其中有两点有必要提下：</p>\n<ul>\n<li><p>其中一点是：说说 View 的事件分发机制。然后我就说了好多，从 WindowManager->window->Decorview->子 view。最后我说当所有的 view 都不处理事件，事件会最后会传递到 Activity 的 onTouchEvent 上。然后面试官立刻说：『哈？你这是颠覆我的三观啊？』 然后我意识到可能有问题，但是记得 《Android 艺术开发探索》上确实写过到 Activity，但是不是到 onTouchEvent还真没底。面试官很自信的样子，让我颤抖了。但是随着我的坚信，面试官说：『不行，我不能冤枉你是不！』立刻在手边的 MBP 上看了一下，自言自语感叹道：『还真有啊！』 我顿时无语了。</p>\n</li>\n<li><p>另外一点是：问我 Service 上能不能弹出对话框。对于这个问题，我印象最深刻了，记得一年前的时候，在另外一个公司就因为这个问题让我尴尬万分，回去后专门对这块进行补充。我的回答是可以的，但是面试官面带差异的表情告诉我这是不行的，Dialog 必须要依附于 Window 才能显示出来。然后我的解释会让面试官郁闷一会：我说这个是可以弹出的，我之前也专门试过，不过他弹出是有条件的。 条件是：</p>\n<ul>\n<li>必须在 Manifest 里面注册系统权限</li>\n<li>在显示 dialog 的时候必须要加一个 flag.<br>我的理由是：系统对话框可以在低电量的时候弹出对话框，我们同样也可以采用该方式来实现。</li>\n</ul>\n</li>\n</ul>\n<p>面试官语塞，然后给我说 Dialog 是必须要依附在 Window 上，Toast 其实也是一个 Window。我听着这些话，就想起以前看过的一篇文章上也确实是这么说的。估计该面试官回去要好好补充下一些知识了哦。 然后该面试官让我不能用 Arraylist,用数组 写一个队列。这块刚好我在之前项目中特意用了一下，写的时候，主要有三个方法： put(), get(),peek(). 然后考虑下队列的特性，一端进入，一端出去。我当时遇到了盲点，没怎么写完，最后给面试官说了下思路，大体是对的。但是关于选择位置那块没怎么想好。不过这不阻碍我进入第二轮。</p>\n<p>第二轮面试的时候，面试官带了很多纸张，我瞬间压力山大，知道不太妙。不出所料，这个面试官，从动画实现原理，到 handler 实现原理，一步步深入各种原理，当我感觉回答的不错的时候，然后他就顺着我的问题继续深入。我只能说我尽力了，有些东西，平时开发的时候真心不注意，但是就因为没有留意，所以就没法继续回答他的问题。</p>\n<p>面试官把我带出大厦的那一刻，我心情很不好，很可惜没进入百度，之后应该需要准备很多东西。我要说，我还会再来的，哈哈哈！ 最后也归还身上的一个牌子到前台后，省的被拉入到黑名单（好吓人的样子）。</p>\n<p>以后有时间多看看原理性的东西，最好整理一个自己的博客，写上自己的一些看法和感悟，这样记得最深刻，即使几年后也不会遗忘，只是看看别人总结的东西，真的就不怎么记得住。</p>\n<p>关于博客可以使用 Hexo, 我的博客也是如此，可以整理一些自己的东西与心得。</p>\n<h3 id=\"2-阿里\"><a href=\"#2-阿里\" class=\"headerlink\" title=\"2.阿里\"></a>2.阿里</h3><p>这次去的是一个阿里的高德部门，在望京 Soho 附近的 首开广场。去了以后首先找厕所，你们知道么？厕所竟然从大厦楼层的的一个角转了一大半圈才找到，回来后进入找不到前台了…… 瞬间无语了。问了好一个美女才回到前台，然后接待我的 HR美女貌似等得不太耐烦了（宝宝心里苦，厕所好远，都找不到回来的路了）。在一个小型会议室等待面试官，看了下布置氛围和环境，感觉太棒了，很多东西都体贴入微。</p>\n<blockquote>\n<p>回顾上次阿里的悲痛遭遇<br><br><br>其实这是我第二次来这边面试了，上一次过来的时候，是刚过完年。提到这里我就苦不堪言，为何如此说呢？当时是2016年2月15日，因为我参加好朋友的婚礼（不得不说，我这个年纪的人都开始结婚了，这次回去有4个好朋友都结婚，可想而知，一场完了以后还有另一场，虽然累，但是值得）推迟了好几天才回北京，在参加同学婚礼的时候接收到阿里高德部门的面试邀请。回到北京的当天是12点多，然后回家，一个关系非常好的朋友说今天她们要宴请公司的人吃饭，因为她们结婚了，让我帮忙弄个 MTV。我想这是朋友的终身大事，因此必须要好好干。<br><br><br>我下午4点是阿里高德的面试，因此时间很紧促。我凭借我大学的技能在两个小时内搞定这个 MTV，总体来说还不错，就迅速发给朋友，弄完已经3点了，然后打车立刻去首开广场。<br><br><br>高德的面试是4点钟，匆匆赶到后，就等待面试官。面试很不理想，因为什么都没有准备，而且心力憔悴。面试官问的是一些基础的 Java 问题，很可惜我没怎么回答好。于是就深深的浪费了一次机会，之后和朋友提起此事，无比后悔，当时其实是可以和 HR 电话再约一个时间的。<br><br><br>这次对我的打击很大很大，因为这是我这么多年第一次面试 BAT 的职位，一上来就受挫，很不是滋味。<strong>我在这里失利后我就各种准备资料，增强自己的能力，面试前必须要刷题，虽然简单，但是不失为一种方法，虽然不一定有用，但是会加深印象，尤其是去 BAT 这些公司，一定要准备好，否则就别浪费机会，这就是我的教训和经验。</strong><br><br><br>为了6月份的这次面试策划了很久。以前对什么可能都不是很上心，但是这个事件深深的刺激我了。</p>\n</blockquote>\n<p>第一个面试官来了后问了一些基本问题，很顺利就进入到第二轮面试。</p>\n<p>第二轮也基本是技术面试，问了一些 Android 基础和 Java 基础以及内存管理。</p>\n<p>第三轮的面试官应是部门负责人，看起来很好说话的，问了一些经历和基本情况后，问我薪资要多少以及之后的发展方向。我说要 XX，之后希望在架构方面发展，但是也可以从业务开始。貌似这里回答的不怎么好。然后让我留了他的联系方式，我知道很有戏哦。</p>\n<p>因为我在进入 K 公司的时候也是这样的，老大感觉我很不错，于是留了微信后，我基本就顺利入职。</p>\n<p>回去后的一两天还是很焦虑的，但是我知道大公司都是有流程的，因此我告诉自己不要焦急。过了一两天后他主动加我微信，然后问了些基本情况后，就说他要做最后的总结，让我等着，最迟一周后就有消息。我感觉希望超大的，开心了好久，本以为就可以这样过去。但是一周时间过去了，没人通知我，我开始焦急了，于是我开始主动和他说话，反思自己是否有什么地方做的不好。</p>\n<p>经过很多面试后我总结出了结论就是要薪资太高了，于是我在微信里面给他说，只要能过去，薪资低点也是可以的。但是问了他好几次，他都没有回话，看着微信消息记录，都是我发给他，而他没有回复，已经过去好多天了，我知道没希望了，他说不管怎么样都会给我回复的，但是我真绝望了。</p>\n<p>就像相亲一样，遇到一个不错的美女，开始都一起聊得很不错，她开始加你好友，并且和你说看好你，不管能不能做女朋友，她之后一定会回复，但是苦苦等待一段时间后，不管你怎么给她说话，但是她就是不理你。可能她真的忙，但是也不可能连续一两天都这么忙吧。于是你知道没结果，因为无言等同于没有希望。为了避免一些幻想的存在，你会将她删除掉，不想留下任何关于他的信息。</p>\n<p>同样我也是把这个阿里高德的老大的联系方式删掉，微信也删掉。在我失去希望的时候，过了几天看见他要主动加我，但是我想可能只是安慰的话语，最多告诉我，我不适合他们的职位，因此我为了避免尴尬，直接删除那个加我好友的请求（如果说真的合适的话，应该会很重视你的，不可能好几天都回复，怎么有一种备胎的感觉，呜呜呜，我不想被发好人卡，宁愿做高傲的兔子，也不想做纸老虎，虽然尽管只是纸老虎，但是也会拥有属于它的一片森林）。</p>\n<p>于是阿里的这次机会就失去了。</p>\n<p>总结后的结论就是：去大公司要的薪资不要太高，否则对方只能感谢你的到来，因为比你优秀的人太多了。</p>\n<h3 id=\"聚美优品\"><a href=\"#聚美优品\" class=\"headerlink\" title=\"聚美优品\"></a>聚美优品</h3><p>聚美优品 位于东四十条地铁站附近。路过一个竹亭子后，进入大厦里面需要用身份证在前台那块登记后给我一个纸条，上面写着我的身份证信息，然后在门禁卡附近刷二维码进入（真担心个人信息泄露哦，当然一般情况下没人会关注你是谁的，千万别干坏事哦，会被查出来的，哈哈哈）。</p>\n<p>推荐我去聚美优品的同事接我上去后，带我到前台填写基本信息。我只写了最基本的信息，然后她说，你就写这么点啊。我说，其实这些信息够用了，写那么多没用，还会暴露你的个人信息。面试成功后，如果有需要可以写详细些，但是一般去面试最好别写身份证信息。工作经历基本也只是最近两个，之前的就不用写了，写那么多没什么用，简历中都会有的。</p>\n<p>记得刚工作那会，傻傻的全写了，真耽误了不少时间。过了一会，她把我交给 漂亮的HR 温柔姐，然后就先忙去了。温柔姐告诉我一般情况下有两轮基本就过了，先让架构师老大直接面我，让我先等候。</p>\n<p>过了一会温柔姐不好意思的跟我说架构老大先让一个技术面我，问我是否有意见，我当然没意见了，这是很标准的面试流程（如果你有意见，建议还是别说太多的话，基本都这样的，要淡定）。</p>\n<p>一面技术给我一种很成熟的感觉，开始问了我一些基础技术问题，外加 Java 内存管理知识。后给我出了一道算法题，说有一个数组最多存储6个数，如果有普通用户的话，存储四个 vip的客户，另外两个是普通用户（留出一定的空间给普通用户），让考虑全面点（一般都是结合实际场景，让你写出一个算法，要具备的能力就是抽象，处理问题的思路与细节，还有最基本的编码功底）。</p>\n<p>然后我就考虑各种情况，第一种是非空情况，然后下面就是几个大的 if else, 至少四个条件，基本涵盖了全部情况，然后每个条件里面写上对应的存储数据的过程。由于我的四个大条件都把距离占的差不多了，在写里面细节的时候，用中文描述。过了一会他回来后，看了下说：『你这个还有中文啊！』 我尴尬的笑着说：『我先写条件的，最后发现没有空位了，只能用文字代替了，你看我正在另外一个纸上写全部的完整算法。』指了指纸上刚写一小半的代码。他也会心一笑，并指出算法上应该改进的地方，基本 ok 啦。</p>\n<p>然后等第二轮的面试，看起来更成熟，但是说话有一种很亲近的感觉。问了基本情况，然后拿出他们的 app 让我看看首页的实现效果，说说怎么实现的。对于这种情况，基本就是考察你的抽象能力，以及分析问题的能力。我先说出使用 ListView 的 header，footview,然后使用 ListView 的 type 来实现。然后简单说了一些性能优化的东西，该面试官提出我的做法可能会存在性能瓶颈。其实他说出这块是在指导我说这块会有问题，我当然明白他的意思，于是说这块采用 recyclerview + fresco 来实现，可以有效的改善问题（其实提到这些，就说明你看过很多新技术了，有时间最好还是要自己练练这些东西，毕竟孰能生巧）。</p>\n<p>他也没深究，基本就感觉不错，开始谈了谈他们的目前状况，以及即将遇到的问题。他在只言片语中都把我当做内部人看，我也心里感觉很舒服。最后告诉我如果我愿意，他就向上报备了，意思是可以继续下一轮。当时他问到我的薪资的时候，因为之前已经说了 N 多次，有的成功，有的感觉很亏，于是这次我并没有说，只是笑笑，而对方说：『那就按照年薪算吧，你打算要多少呢？』我当时什么也没有多想，然后就说：『我希望在我现有的薪资基础上，能上涨15% - 20%。』他经过在手机上一阵比划后，告诉我可以达到我的预期效果。整个过程感觉很愉悦。</p>\n<p>因为面过了一些，并有offer，但是还是想多看看，结果把自己搞的疲惫不堪。但是最后的最后，温柔姐给我打电话说面试通过。</p>\n<h3 id=\"最终结果\"><a href=\"#最终结果\" class=\"headerlink\" title=\"最终结果\"></a>最终结果</h3><p>最终我辞职后在家休息几天，没事的时候去咖啡馆看看书，上上网，好好过几天轻松的日子，然后再说定去哪里工作。</p>\n<h3 id=\"总结：面试和必备的技能\"><a href=\"#总结：面试和必备的技能\" class=\"headerlink\" title=\"总结：面试和必备的技能\"></a>总结：面试和必备的技能</h3><p>这里只简单列举一些东西，可能不是特别全，但是却特别适用，也不一定按照下面的流程，有可能是穿插的，也有可能都有，根据公司的规模以及面试官的心情而定（哈哈哈 ，你们就自求多福吧）。建议大家还是要将下面的东西全部掌握，没事写写代码，练练手，在项目中能用到的地方一定要用，有可能会遇到很多坑，一定要自己想办法填坑，之后回忆起这段经历，肯定可以敢理直气壮的跟别人讨论。如果你说的头头是道，那么对方会先输一层，然后在心里对你佩服。</p>\n<ol>\n<li>一般情况下第一轮都是基础面试，需要扎实的基础<ul>\n<li>最常用的Android 基础知识</li>\n<li>Java 基础知识</li>\n<li>了解一些 常用东西的原理，例如：handler， thread 等</li>\n<li>项目中的技术点</li>\n</ul>\n</li>\n<li>第二轮的时候需要了解更深层次的东西<ul>\n<li>Android 事件分发机制原理</li>\n<li>Android 绘图机制原理</li>\n<li>WindowManager 的相关知识</li>\n<li>进程间传输方式</li>\n<li>Java 内存管理机制</li>\n<li>一些常用的 list,map 原理，以及子类之间的差别</li>\n</ul>\n</li>\n<li>能进入第三轮基本没什么问题，但是要注意以下问题<ul>\n<li>该轮一般是 老大或者部门负责人，问的问题一般都看 深度与广度</li>\n<li>当问及薪水的时候，要说一个合适的，小公司随意，大公司一定要慎重，当心里没底的时候，可以告诉对方，让对方给一个合理的薪资。一般都是在原工资基础之上增长，听猎头说一般涨幅都在15%-30%，超 NB 的可以要30%及以上，如果感觉自己还不错的，挺厉害的，建议最高20%，一般人就定在15% 左右最靠谱。公司内部一般有一套机制，根据公司情况而定。</li>\n<li>我们的面试原则就是拿到合理薪资，得到 offer</li>\n<li>个人发展情况，这个问题很难回答，如果和公司方向不符合，极有可能和公司无缘。建议多试探性的问问公司缺少什么，你能否给予公司对应的东西。当然对于有自我追求的人，那可以放心大胆的提。我的方向就是架构师，哈哈哈，挺极端的，别学我哦。我感觉选择都是双向的，因此我知道自己需要的是什么。</li>\n<li>你最擅长什么UI 还是其他什么？这个问题更不好回答。你要说你擅长 UI，是不是意味着你其他能力就不行？虽然我不知道面试官的用意，但是我能感觉到，这个问题不是那么好回答，我会回答说自己都行，来什么业务接什么需求。可能回答不太好，总之和公司的职位吻合就行，这样总不至于出错吧。</li>\n</ul>\n</li>\n</ol>\n<p>如果你有面试的疑问或者困惑，可以加我的微信公众账号:<a href=\"http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg\" title=\"面试说\">mianshishuo</a>, 可以扫描下方二维码，一起来吐槽面试中的感受。我将不定期分享最新的 Android 面试题与面试经验。也可以将你们的面试经验与问题发给我一同讨论，非常感谢。</p>\n<p><img src=\"http://7xlcno.com1.z0.glb.clouddn.com/weixingdky005_mianshishuo.jpg\" alt=\"\" title=\"微信公众账号：面试说\"></p>\n"},{"title":"圆角图片处理","date":"2015-10-10T07:17:43.000Z","keywords":null,"_content":"\n\n\t//图片圆角处理\n    public Bitmap getRoundedBitmap(Bitmap mBitmap) {\n        //创建新的位图\n        Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        //把创建的位图作为画板\n        Canvas mCanvas = new Canvas(bgBitmap);\n\n        Paint mPaint = new Paint();\n        Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n        RectF mRectF = new RectF(mRect);\n        //设置圆角半径为20\n        float roundPx = 10;\n        mPaint.setAntiAlias(true);\n        //先绘制圆角矩形\n        mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n        //设置图像的叠加模式\n        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        //绘制图像\n        mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n        return bgBitmap;\n    }","source":"_posts/圆角图片处理.md","raw":"title: 圆角图片处理\ndate: 2015-10-10 15:17:43\ncategories:\nkeywords:\ntags:\n---\n\n\n\t//图片圆角处理\n    public Bitmap getRoundedBitmap(Bitmap mBitmap) {\n        //创建新的位图\n        Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        //把创建的位图作为画板\n        Canvas mCanvas = new Canvas(bgBitmap);\n\n        Paint mPaint = new Paint();\n        Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n        RectF mRectF = new RectF(mRect);\n        //设置圆角半径为20\n        float roundPx = 10;\n        mPaint.setAntiAlias(true);\n        //先绘制圆角矩形\n        mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n        //设置图像的叠加模式\n        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        //绘制图像\n        mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n        return bgBitmap;\n    }","slug":"圆角图片处理","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2agx001lxzex81fif074","content":"<pre><code>//图片圆角处理\npublic Bitmap getRoundedBitmap(Bitmap mBitmap) {\n    //创建新的位图\n    Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n    //把创建的位图作为画板\n    Canvas mCanvas = new Canvas(bgBitmap);\n\n    Paint mPaint = new Paint();\n    Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n    RectF mRectF = new RectF(mRect);\n    //设置圆角半径为20\n    float roundPx = 10;\n    mPaint.setAntiAlias(true);\n    //先绘制圆角矩形\n    mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n    //设置图像的叠加模式\n    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n    //绘制图像\n    mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n    return bgBitmap;\n}\n</code></pre>","excerpt":"","more":"<pre><code>//图片圆角处理\npublic Bitmap getRoundedBitmap(Bitmap mBitmap) {\n    //创建新的位图\n    Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n    //把创建的位图作为画板\n    Canvas mCanvas = new Canvas(bgBitmap);\n\n    Paint mPaint = new Paint();\n    Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n    RectF mRectF = new RectF(mRect);\n    //设置圆角半径为20\n    float roundPx = 10;\n    mPaint.setAntiAlias(true);\n    //先绘制圆角矩形\n    mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n    //设置图像的叠加模式\n    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n    //绘制图像\n    mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n    return bgBitmap;\n}\n</code></pre>"},{"title":"比较好的Android网站","date":"2015-09-26T06:53:07.000Z","keywords":"干货","_content":"\n\n\n这是分享一些比较靠谱的干货，可以参考下面的链接：<br>\n\n\n\n- [12大Android开发资源，你有几种会用？][1]\n\n- [快速提高Android开发效率的Web工具][2]\n\n- [Android酷炫实用的开源框架（UI框架）][3]\n\n- [Android开发六个建议（经验之谈）][4]\n\n- [Android Studio常用插件] [5]\n\n- [Android App 性能优化实践] [6]\n\n- [Android Support 库百分比布局] [7]\n\n- [Android 项目部署之Nexus私服搭建和应用][8]\n\n- [移动应用 Bug 快速反馈利器][9] \n\n\n\n后续将整理一些比较又实用价值的文章分享给大家\n\n---\n[1]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=1&sn=4102a3f1d369ba79abeb85e77e4c380d&scene=1&srcid=0926h7Wvn1gzNIiKmoZAutR7&key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[2]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=2&sn=e6bf1c5afb0e09147484a61c68583b3e&scene=1&srcid=0926n9p8bsx5NQNAg274lTGy&key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207916695&idx=4&sn=69a69ba7986eeb9fda0054354db828a4&scene=1&srcid=0926JcG6UjZuN7LEu7giAoR9&key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[4]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207581833&idx=3&sn=97bfca775b657f19f990a80fa401392e&scene=1&srcid=09265F2U0UdTJJXCpg11k4ll&key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[5]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208540095&idx=1&sn=8a4c7e4d5d9a64839992462f27b4bb95&scene=1&srcid=09266oDuhW22HgxDuGmM0WYC&key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[6]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208525243&idx=1&sn=8afc00211b37af68f1995a3e8ad45111&scene=1&srcid=0926NrC0khf5Fa9fJEwRfRPY&key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n\n[7]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208510253&idx=2&sn=28598cc02ad39b73ca615e886c8eb24c&scene=1&srcid=0926DwVYFw4g4Od2AAnu6iHa&key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[8]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208554056&idx=1&sn=b98bfef690e316fa5dc0fccef8dae198&scene=1&srcid=0926PFrnACpa0rgVOJL2BLlc&key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[9]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n","source":"_posts/比较好的Android网站.md","raw":"title: 比较好的Android网站\ndate: 2015-09-26 14:53:07\ncategories:\nkeywords: 干货\ntags: 干货\n---\n\n\n\n这是分享一些比较靠谱的干货，可以参考下面的链接：<br>\n\n\n\n- [12大Android开发资源，你有几种会用？][1]\n\n- [快速提高Android开发效率的Web工具][2]\n\n- [Android酷炫实用的开源框架（UI框架）][3]\n\n- [Android开发六个建议（经验之谈）][4]\n\n- [Android Studio常用插件] [5]\n\n- [Android App 性能优化实践] [6]\n\n- [Android Support 库百分比布局] [7]\n\n- [Android 项目部署之Nexus私服搭建和应用][8]\n\n- [移动应用 Bug 快速反馈利器][9] \n\n\n\n后续将整理一些比较又实用价值的文章分享给大家\n\n---\n[1]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=1&sn=4102a3f1d369ba79abeb85e77e4c380d&scene=1&srcid=0926h7Wvn1gzNIiKmoZAutR7&key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[2]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=2&sn=e6bf1c5afb0e09147484a61c68583b3e&scene=1&srcid=0926n9p8bsx5NQNAg274lTGy&key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207916695&idx=4&sn=69a69ba7986eeb9fda0054354db828a4&scene=1&srcid=0926JcG6UjZuN7LEu7giAoR9&key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[4]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207581833&idx=3&sn=97bfca775b657f19f990a80fa401392e&scene=1&srcid=09265F2U0UdTJJXCpg11k4ll&key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[5]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208540095&idx=1&sn=8a4c7e4d5d9a64839992462f27b4bb95&scene=1&srcid=09266oDuhW22HgxDuGmM0WYC&key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[6]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208525243&idx=1&sn=8afc00211b37af68f1995a3e8ad45111&scene=1&srcid=0926NrC0khf5Fa9fJEwRfRPY&key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n\n[7]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208510253&idx=2&sn=28598cc02ad39b73ca615e886c8eb24c&scene=1&srcid=0926DwVYFw4g4Od2AAnu6iHa&key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[8]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208554056&idx=1&sn=b98bfef690e316fa5dc0fccef8dae198&scene=1&srcid=0926PFrnACpa0rgVOJL2BLlc&key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[9]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n","slug":"比较好的Android网站","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ah1001pxzex3cjm1my1","content":"<p>这是分享一些比较靠谱的干货，可以参考下面的链接：<br></p>\n<ul>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=1&amp;sn=4102a3f1d369ba79abeb85e77e4c380d&amp;scene=1&amp;srcid=0926h7Wvn1gzNIiKmoZAutR7&amp;key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">12大Android开发资源，你有几种会用？</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=2&amp;sn=e6bf1c5afb0e09147484a61c68583b3e&amp;scene=1&amp;srcid=0926n9p8bsx5NQNAg274lTGy&amp;key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">快速提高Android开发效率的Web工具</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207916695&amp;idx=4&amp;sn=69a69ba7986eeb9fda0054354db828a4&amp;scene=1&amp;srcid=0926JcG6UjZuN7LEu7giAoR9&amp;key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android酷炫实用的开源框架（UI框架）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207581833&amp;idx=3&amp;sn=97bfca775b657f19f990a80fa401392e&amp;scene=1&amp;srcid=09265F2U0UdTJJXCpg11k4ll&amp;key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android开发六个建议（经验之谈）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208540095&amp;idx=1&amp;sn=8a4c7e4d5d9a64839992462f27b4bb95&amp;scene=1&amp;srcid=09266oDuhW22HgxDuGmM0WYC&amp;key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android Studio常用插件</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208525243&amp;idx=1&amp;sn=8afc00211b37af68f1995a3e8ad45111&amp;scene=1&amp;srcid=0926NrC0khf5Fa9fJEwRfRPY&amp;key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android App 性能优化实践</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208510253&amp;idx=2&amp;sn=28598cc02ad39b73ca615e886c8eb24c&amp;scene=1&amp;srcid=0926DwVYFw4g4Od2AAnu6iHa&amp;key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android Support 库百分比布局</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208554056&amp;idx=1&amp;sn=b98bfef690e316fa5dc0fccef8dae198&amp;scene=1&amp;srcid=0926PFrnACpa0rgVOJL2BLlc&amp;key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android 项目部署之Nexus私服搭建和应用</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">移动应用 Bug 快速反馈利器</a> </p>\n</li>\n</ul>\n<p>后续将整理一些比较又实用价值的文章分享给大家</p>\n<hr>\n","excerpt":"","more":"<p>这是分享一些比较靠谱的干货，可以参考下面的链接：<br></p>\n<ul>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=1&amp;sn=4102a3f1d369ba79abeb85e77e4c380d&amp;scene=1&amp;srcid=0926h7Wvn1gzNIiKmoZAutR7&amp;key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">12大Android开发资源，你有几种会用？</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=2&amp;sn=e6bf1c5afb0e09147484a61c68583b3e&amp;scene=1&amp;srcid=0926n9p8bsx5NQNAg274lTGy&amp;key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">快速提高Android开发效率的Web工具</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207916695&amp;idx=4&amp;sn=69a69ba7986eeb9fda0054354db828a4&amp;scene=1&amp;srcid=0926JcG6UjZuN7LEu7giAoR9&amp;key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android酷炫实用的开源框架（UI框架）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207581833&amp;idx=3&amp;sn=97bfca775b657f19f990a80fa401392e&amp;scene=1&amp;srcid=09265F2U0UdTJJXCpg11k4ll&amp;key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android开发六个建议（经验之谈）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208540095&amp;idx=1&amp;sn=8a4c7e4d5d9a64839992462f27b4bb95&amp;scene=1&amp;srcid=09266oDuhW22HgxDuGmM0WYC&amp;key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android Studio常用插件</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208525243&amp;idx=1&amp;sn=8afc00211b37af68f1995a3e8ad45111&amp;scene=1&amp;srcid=0926NrC0khf5Fa9fJEwRfRPY&amp;key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android App 性能优化实践</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208510253&amp;idx=2&amp;sn=28598cc02ad39b73ca615e886c8eb24c&amp;scene=1&amp;srcid=0926DwVYFw4g4Od2AAnu6iHa&amp;key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android Support 库百分比布局</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208554056&amp;idx=1&amp;sn=b98bfef690e316fa5dc0fccef8dae198&amp;scene=1&amp;srcid=0926PFrnACpa0rgVOJL2BLlc&amp;key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android 项目部署之Nexus私服搭建和应用</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">移动应用 Bug 快速反馈利器</a> </p>\n</li>\n</ul>\n<p>后续将整理一些比较又实用价值的文章分享给大家</p>\n<hr>\n"},{"title":"推荐processon 让流程图也可以共享","date":"2016-02-25T02:32:02.000Z","keywords":null,"_content":"\n推荐一个流程图共享的网站：\n[https://www.processon.com/popular](https://www.processon.com/popular)\n\n一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用\n\n![https://www.processon.com/view/56ca927ce4b0362f22d848b5](http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg)\n[原样图](https://www.processon.com/view/56ca927ce4b0362f22d848b5 \"原样图\")\n\n然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。\n### 例如：\n- [IOS开发](https://www.processon.com/view/557051bee4b0d6a77d619124)\n- [前端技能树](https://www.processon.com/view/55783184e4b0d6a77d9f9560)\n- [Android Service总结1](https://www.processon.com/view/555097e7e4b09739f4652bf3)\n- [Android Service总结2](https://www.processon.com/view/5550a05ee4b09739f46585b0)\n- [Android测试工具](https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08)\n- [Android中主要类的关系图 Activity Class](https://www.processon.com/view/55f69023e4b0a8c6fae84984)\n- [APP开发人员技能树](https://www.processon.com/view/55110a6ee4b00af64b0c3cba)\n- [EventBus源码分析简要图](https://www.processon.com/view/568bc9eae4b002e52c0fb427)\n- [Android小说阅读器部分计划及流程](https://www.processon.com/view/561ccd9de4b07efc017ca19b)\n- [View绘制流程](https://www.processon.com/view/562847b4e4b04931dccccbfe)\n- [Android Drawable分类汇总](https://www.processon.com/view/550cf083e4b0b74dae7c2c7d)","source":"_posts/推荐processon-让流程图也可以共享.md","raw":"title: 推荐processon 让流程图也可以共享\ndate: 2016-02-25 10:32:02\ncategories:\nkeywords:\ntags:\n---\n\n推荐一个流程图共享的网站：\n[https://www.processon.com/popular](https://www.processon.com/popular)\n\n一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用\n\n![https://www.processon.com/view/56ca927ce4b0362f22d848b5](http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg)\n[原样图](https://www.processon.com/view/56ca927ce4b0362f22d848b5 \"原样图\")\n\n然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。\n### 例如：\n- [IOS开发](https://www.processon.com/view/557051bee4b0d6a77d619124)\n- [前端技能树](https://www.processon.com/view/55783184e4b0d6a77d9f9560)\n- [Android Service总结1](https://www.processon.com/view/555097e7e4b09739f4652bf3)\n- [Android Service总结2](https://www.processon.com/view/5550a05ee4b09739f46585b0)\n- [Android测试工具](https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08)\n- [Android中主要类的关系图 Activity Class](https://www.processon.com/view/55f69023e4b0a8c6fae84984)\n- [APP开发人员技能树](https://www.processon.com/view/55110a6ee4b00af64b0c3cba)\n- [EventBus源码分析简要图](https://www.processon.com/view/568bc9eae4b002e52c0fb427)\n- [Android小说阅读器部分计划及流程](https://www.processon.com/view/561ccd9de4b07efc017ca19b)\n- [View绘制流程](https://www.processon.com/view/562847b4e4b04931dccccbfe)\n- [Android Drawable分类汇总](https://www.processon.com/view/550cf083e4b0b74dae7c2c7d)","slug":"推荐processon-让流程图也可以共享","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ah3001rxzexhxz3pxmb","content":"<p>推荐一个流程图共享的网站：<br><a href=\"https://www.processon.com/popular\" target=\"_blank\" rel=\"external\">https://www.processon.com/popular</a></p>\n<p>一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg\" alt=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\"><br><a href=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\" title=\"原样图\" target=\"_blank\" rel=\"external\">原样图</a></p>\n<p>然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。</p>\n<h3 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h3><ul>\n<li><a href=\"https://www.processon.com/view/557051bee4b0d6a77d619124\" target=\"_blank\" rel=\"external\">IOS开发</a></li>\n<li><a href=\"https://www.processon.com/view/55783184e4b0d6a77d9f9560\" target=\"_blank\" rel=\"external\">前端技能树</a></li>\n<li><a href=\"https://www.processon.com/view/555097e7e4b09739f4652bf3\" target=\"_blank\" rel=\"external\">Android Service总结1</a></li>\n<li><a href=\"https://www.processon.com/view/5550a05ee4b09739f46585b0\" target=\"_blank\" rel=\"external\">Android Service总结2</a></li>\n<li><a href=\"https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08\" target=\"_blank\" rel=\"external\">Android测试工具</a></li>\n<li><a href=\"https://www.processon.com/view/55f69023e4b0a8c6fae84984\" target=\"_blank\" rel=\"external\">Android中主要类的关系图 Activity Class</a></li>\n<li><a href=\"https://www.processon.com/view/55110a6ee4b00af64b0c3cba\" target=\"_blank\" rel=\"external\">APP开发人员技能树</a></li>\n<li><a href=\"https://www.processon.com/view/568bc9eae4b002e52c0fb427\" target=\"_blank\" rel=\"external\">EventBus源码分析简要图</a></li>\n<li><a href=\"https://www.processon.com/view/561ccd9de4b07efc017ca19b\" target=\"_blank\" rel=\"external\">Android小说阅读器部分计划及流程</a></li>\n<li><a href=\"https://www.processon.com/view/562847b4e4b04931dccccbfe\" target=\"_blank\" rel=\"external\">View绘制流程</a></li>\n<li><a href=\"https://www.processon.com/view/550cf083e4b0b74dae7c2c7d\" target=\"_blank\" rel=\"external\">Android Drawable分类汇总</a></li>\n</ul>\n","excerpt":"","more":"<p>推荐一个流程图共享的网站：<br><a href=\"https://www.processon.com/popular\">https://www.processon.com/popular</a></p>\n<p>一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg\" alt=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\"><br><a href=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\" title=\"原样图\">原样图</a></p>\n<p>然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。</p>\n<h3 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h3><ul>\n<li><a href=\"https://www.processon.com/view/557051bee4b0d6a77d619124\">IOS开发</a></li>\n<li><a href=\"https://www.processon.com/view/55783184e4b0d6a77d9f9560\">前端技能树</a></li>\n<li><a href=\"https://www.processon.com/view/555097e7e4b09739f4652bf3\">Android Service总结1</a></li>\n<li><a href=\"https://www.processon.com/view/5550a05ee4b09739f46585b0\">Android Service总结2</a></li>\n<li><a href=\"https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08\">Android测试工具</a></li>\n<li><a href=\"https://www.processon.com/view/55f69023e4b0a8c6fae84984\">Android中主要类的关系图 Activity Class</a></li>\n<li><a href=\"https://www.processon.com/view/55110a6ee4b00af64b0c3cba\">APP开发人员技能树</a></li>\n<li><a href=\"https://www.processon.com/view/568bc9eae4b002e52c0fb427\">EventBus源码分析简要图</a></li>\n<li><a href=\"https://www.processon.com/view/561ccd9de4b07efc017ca19b\">Android小说阅读器部分计划及流程</a></li>\n<li><a href=\"https://www.processon.com/view/562847b4e4b04931dccccbfe\">View绘制流程</a></li>\n<li><a href=\"https://www.processon.com/view/550cf083e4b0b74dae7c2c7d\">Android Drawable分类汇总</a></li>\n</ul>\n"},{"title":"日志指南","date":"2015-09-11T02:12:24.000Z","_content":"\n\n参考：[最佳日志实践][2]\n\n<br>\n### 前言\n<br>\n\n\t\t几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\t\t\n        日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n        \n        日志作用：\n        - 好的日志记录系统出现问题时能快速定位\n        - 可以通过对日志的观察和分析\n        - 提前发现系统可能的风险\n        - 避免线上事故的发生\n\n<br>\n## 一、日志级别\n<br>\n###### 通常使用的日志库（如**log4j**, **logback** 等）\n\n\n\n**日志基本分为以下几类（从低到高）：**\n\n**VERBOSE** – *The VERBOSE Level designates finer-grained informational events than the DEBUG*\n\n**DEBUG** – *The DEBUG Level designates fine-grained informational events that are most useful to debug an application.*\n\n**INFO** – *The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.*\n\n**WARN** – *The WARN level designates potentially harmful situations.*\n\n**ERROR** – *The ERROR level designates error events that might still allow the application to continue running.*\n\n**FATAL** – *The FATAL level designates very severe error events that will presumably lead the application to abort.*\n\n\n- 一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；\n- 即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;\n- 对于日志级别的分类，有以下参考：\n\n```\nFATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；\n\nERROR — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；\n\nWARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；\n\nINFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；\n\nDEBUG or TRACE — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过DEBUG（或TRACE）日志来定位问题；\n\n```\n\n**Rule 1**：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等\n\n<br>\n## 二、对记录的日志要进行更新维护\n<br>\n\n由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：\n\n- 定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；\n- 整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；\n\n**Rule 2**：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题\n\n<br>\n## 三、关于日志分类\n<br>\n\n日志从功能来说，可分为诊断日志、统计日志、审计日志。\n\n诊断日志， 典型的有：\n\n- 请求入口和出口\n- 外部服务调用和返回\n- 资源消耗操作: 打开文件等\n- 容错行为： 譬如云硬盘的副本修复操作\n- 程序异常： 譬如数据库无法连接\n- 后台操作：清理程序\n- 启动、关闭、配置加载\n- 抛出异常时，不记录日志\n\n统计日志：\n\n- 用户访问统计\n- 计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）\n\n审计日志：\n\n- 管理操作\n\n\t将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。\n\n**Rule 3**：要明确不同日志的用途，对日志内容进行分类\n\n<br>\n## 四、日志中不要记录无用信息\n<br>\n\n例如一些测试的log: log.i(\"tag\", \"数据加载成功\")，可以打印一些比较有实用价值的Log， 例如：\nlog.i(\"tag\", \"数据加载成功，数据是：{}\"， “XXXX”)\n\n**Rule 4**: 绝不要打印没有用的日志，防止无用日志淹没重要信息\n\n<br>\n## 五、5. 日志记录信息要完整\n<br>\n\n问题描述：\n\n```\nNOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：\n\n- InitMultiUpload（生成一个UploadID）\n- UploadPart\n- UploadPart\n-  ……\n- UploadPart\n- CompleteMultiUpload（AbortMultiUpload）\n\n之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。\n\n然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。\n\n类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。\n\n因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：\n\n- 在系统启动或初始化时记录重要的系统初始化参数\n- 记录系统运行过程中的所有的错误\n- 记录系统运行过程中的所有的警告\n- 在持久化数据修改时记录修改前和修改后的值\n- 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）\n- 重要的状态变化（如NOS中对系统白名单的修改等）\n- 系统中一些长期执行的任务的执行进度\n```\n\n**不推荐记录日志的内容有：**\n\n- 函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志\n- 文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志\n- “良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理\n\n**Rule 5**：日志信息要准确全面，能做到仅凭日志就可以定位问题\n\n*解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。*\n\n<br>\n## 六、测试的日志\n<br>\n\n测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。\n\n测试日志应该包含以下内容：\n\n- 测试执行的环境\n- 测试执行前的初始状态\n- 测试的详细步骤\n- 测试和系统的交互信息\n- 测试期望的返回结果\n- 测试实际的返回结果\n\n**Rule 6**：要以同样严格的要求对待测试程序的日志\n\n<br>\n## 七、从问题中完善日志\n<br>\n\n在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：\n\n- 如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化\n- 需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）\n\n通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。\n\n**Rule 7**：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习\n\n<br>\n## 八、对日志进行监控报警，比客户先发现系统问题\n<br>\n\ncrash关键字报警：\n\n程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志\n\n类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。\n\n**Rule 8**：对日志进行监控报警，比客户先发现系统问题\n\n<br>\n## 九、关于日志格式\n<br>\n\n日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：\n\n```\n第一种：\nlogger.error(“Gearman timeout exception for request ” + getRequestID() + ” value: ” + value, e);\n\n第二种：\nlogger.error(“RequestID: ” + getRequestID() + “, Error Message: Gearman timeout exception: ” + e);\n\n第三种：\nlogger.error(getErrorMessage(getRequestID(), getErrorMessage(), e));\n```\n\n\n第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：\n\n- 系统中日志格式不统一，不利于自动化处理\n- 有些日志可能只有开发人员自己才能看懂\n- 代码规范性不好\n\n而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。\n\n**Rule 9**：日志格式要统一规范\n\n<br>\n## 十、错误日志输出到不同文件\n<br>\n\n在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。\n\n这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。\n\n**Rule 10**：将错误日志输出到一个单独的文件中进行分析\n\n<br>\n## 十一、关于日志文件大小\n<br>\n\n日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。\n\n为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：\n\n- 将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；\n- 每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志\n\n**Rule 11**：要把日志的大小，如何切分，如何删除等作为规范建立起来\n\n\n\n\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n\n\n\n\n\n---\n\n[1]:http://img.blog.csdn.net/20140502002840109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhneGh1YWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\n\n[2]:http://www.bitstech.net/2014/01/07/log-best-practice/\n\n\n\n\n\n","source":"_posts/日志指南.md","raw":"title: 日志指南\ndate: 2015-09-11 10:12:24\n\ntags: Android日志规范\n---\n\n\n参考：[最佳日志实践][2]\n\n<br>\n### 前言\n<br>\n\n\t\t几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\t\t\n        日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n        \n        日志作用：\n        - 好的日志记录系统出现问题时能快速定位\n        - 可以通过对日志的观察和分析\n        - 提前发现系统可能的风险\n        - 避免线上事故的发生\n\n<br>\n## 一、日志级别\n<br>\n###### 通常使用的日志库（如**log4j**, **logback** 等）\n\n\n\n**日志基本分为以下几类（从低到高）：**\n\n**VERBOSE** – *The VERBOSE Level designates finer-grained informational events than the DEBUG*\n\n**DEBUG** – *The DEBUG Level designates fine-grained informational events that are most useful to debug an application.*\n\n**INFO** – *The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.*\n\n**WARN** – *The WARN level designates potentially harmful situations.*\n\n**ERROR** – *The ERROR level designates error events that might still allow the application to continue running.*\n\n**FATAL** – *The FATAL level designates very severe error events that will presumably lead the application to abort.*\n\n\n- 一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；\n- 即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;\n- 对于日志级别的分类，有以下参考：\n\n```\nFATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；\n\nERROR — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；\n\nWARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；\n\nINFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；\n\nDEBUG or TRACE — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过DEBUG（或TRACE）日志来定位问题；\n\n```\n\n**Rule 1**：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等\n\n<br>\n## 二、对记录的日志要进行更新维护\n<br>\n\n由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：\n\n- 定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；\n- 整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；\n\n**Rule 2**：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题\n\n<br>\n## 三、关于日志分类\n<br>\n\n日志从功能来说，可分为诊断日志、统计日志、审计日志。\n\n诊断日志， 典型的有：\n\n- 请求入口和出口\n- 外部服务调用和返回\n- 资源消耗操作: 打开文件等\n- 容错行为： 譬如云硬盘的副本修复操作\n- 程序异常： 譬如数据库无法连接\n- 后台操作：清理程序\n- 启动、关闭、配置加载\n- 抛出异常时，不记录日志\n\n统计日志：\n\n- 用户访问统计\n- 计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）\n\n审计日志：\n\n- 管理操作\n\n\t将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。\n\n**Rule 3**：要明确不同日志的用途，对日志内容进行分类\n\n<br>\n## 四、日志中不要记录无用信息\n<br>\n\n例如一些测试的log: log.i(\"tag\", \"数据加载成功\")，可以打印一些比较有实用价值的Log， 例如：\nlog.i(\"tag\", \"数据加载成功，数据是：{}\"， “XXXX”)\n\n**Rule 4**: 绝不要打印没有用的日志，防止无用日志淹没重要信息\n\n<br>\n## 五、5. 日志记录信息要完整\n<br>\n\n问题描述：\n\n```\nNOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：\n\n- InitMultiUpload（生成一个UploadID）\n- UploadPart\n- UploadPart\n-  ……\n- UploadPart\n- CompleteMultiUpload（AbortMultiUpload）\n\n之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。\n\n然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。\n\n类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。\n\n因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：\n\n- 在系统启动或初始化时记录重要的系统初始化参数\n- 记录系统运行过程中的所有的错误\n- 记录系统运行过程中的所有的警告\n- 在持久化数据修改时记录修改前和修改后的值\n- 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）\n- 重要的状态变化（如NOS中对系统白名单的修改等）\n- 系统中一些长期执行的任务的执行进度\n```\n\n**不推荐记录日志的内容有：**\n\n- 函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志\n- 文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志\n- “良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理\n\n**Rule 5**：日志信息要准确全面，能做到仅凭日志就可以定位问题\n\n*解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。*\n\n<br>\n## 六、测试的日志\n<br>\n\n测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。\n\n测试日志应该包含以下内容：\n\n- 测试执行的环境\n- 测试执行前的初始状态\n- 测试的详细步骤\n- 测试和系统的交互信息\n- 测试期望的返回结果\n- 测试实际的返回结果\n\n**Rule 6**：要以同样严格的要求对待测试程序的日志\n\n<br>\n## 七、从问题中完善日志\n<br>\n\n在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：\n\n- 如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化\n- 需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）\n\n通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。\n\n**Rule 7**：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习\n\n<br>\n## 八、对日志进行监控报警，比客户先发现系统问题\n<br>\n\ncrash关键字报警：\n\n程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志\n\n类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。\n\n**Rule 8**：对日志进行监控报警，比客户先发现系统问题\n\n<br>\n## 九、关于日志格式\n<br>\n\n日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：\n\n```\n第一种：\nlogger.error(“Gearman timeout exception for request ” + getRequestID() + ” value: ” + value, e);\n\n第二种：\nlogger.error(“RequestID: ” + getRequestID() + “, Error Message: Gearman timeout exception: ” + e);\n\n第三种：\nlogger.error(getErrorMessage(getRequestID(), getErrorMessage(), e));\n```\n\n\n第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：\n\n- 系统中日志格式不统一，不利于自动化处理\n- 有些日志可能只有开发人员自己才能看懂\n- 代码规范性不好\n\n而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。\n\n**Rule 9**：日志格式要统一规范\n\n<br>\n## 十、错误日志输出到不同文件\n<br>\n\n在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。\n\n这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。\n\n**Rule 10**：将错误日志输出到一个单独的文件中进行分析\n\n<br>\n## 十一、关于日志文件大小\n<br>\n\n日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。\n\n为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：\n\n- 将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；\n- 每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志\n\n**Rule 11**：要把日志的大小，如何切分，如何删除等作为规范建立起来\n\n\n\n\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n\n\n\n\n\n---\n\n[1]:http://img.blog.csdn.net/20140502002840109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhneGh1YWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\n\n[2]:http://www.bitstech.net/2014/01/07/log-best-practice/\n\n\n\n\n\n","slug":"日志指南","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ah5001vxzextqbg4rs1","content":"<p>参考：<a href=\"http://www.bitstech.net/2014/01/07/log-best-practice/\" target=\"_blank\" rel=\"external\">最佳日志实践</a></p>\n<p><br></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><br></p>\n<pre><code>几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\n日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n\n日志作用：\n- 好的日志记录系统出现问题时能快速定位\n- 可以通过对日志的观察和分析\n- 提前发现系统可能的风险\n- 避免线上事故的发生\n</code></pre><p><br></p>\n<h2 id=\"一、日志级别\"><a href=\"#一、日志级别\" class=\"headerlink\" title=\"一、日志级别\"></a>一、日志级别</h2><p><br></p>\n<h6 id=\"通常使用的日志库（如log4j-logback-等）\"><a href=\"#通常使用的日志库（如log4j-logback-等）\" class=\"headerlink\" title=\"通常使用的日志库（如log4j, logback 等）\"></a>通常使用的日志库（如<strong>log4j</strong>, <strong>logback</strong> 等）</h6><p><strong>日志基本分为以下几类（从低到高）：</strong></p>\n<p><strong>VERBOSE</strong> – <em>The VERBOSE Level designates finer-grained informational events than the DEBUG</em></p>\n<p><strong>DEBUG</strong> – <em>The DEBUG Level designates fine-grained informational events that are most useful to debug an application.</em></p>\n<p><strong>INFO</strong> – <em>The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.</em></p>\n<p><strong>WARN</strong> – <em>The WARN level designates potentially harmful situations.</em></p>\n<p><strong>ERROR</strong> – <em>The ERROR level designates error events that might still allow the application to continue running.</em></p>\n<p><strong>FATAL</strong> – <em>The FATAL level designates very severe error events that will presumably lead the application to abort.</em></p>\n<ul>\n<li>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；</li>\n<li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;</li>\n<li>对于日志级别的分类，有以下参考：</li>\n</ul>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ERROR</span> — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当<span class=\"built_in\">ERROR</span>错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上<span class=\"built_in\">ERROR</span>错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而<span class=\"built_in\">ERROR</span>相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印<span class=\"built_in\">ERROR</span>日志。特别需要注意的是，<span class=\"built_in\">ERROR</span>和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为<span class=\"built_in\">ERROR</span>日志的；</span><br><span class=\"line\"></span><br><span class=\"line\">WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；</span><br><span class=\"line\"></span><br><span class=\"line\">INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,<span class=\"built_in\">ERROR</span>,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于<span class=\"keyword\">TRACE</span>日志的<span class=\"number\">10</span>%；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DEBUG</span> <span class=\"keyword\">or</span> <span class=\"keyword\">TRACE</span> — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）级别的日志对问题进行诊断。需要注意的是，<span class=\"keyword\">DEBUG</span>日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）日志来定位问题；</span><br></pre></td></tr></table></figure>\n<p><strong>Rule 1</strong>：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p>\n<p><br></p>\n<h2 id=\"二、对记录的日志要进行更新维护\"><a href=\"#二、对记录的日志要进行更新维护\" class=\"headerlink\" title=\"二、对记录的日志要进行更新维护\"></a>二、对记录的日志要进行更新维护</h2><p><br></p>\n<p>由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：</p>\n<ul>\n<li>定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；</li>\n<li>整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；</li>\n</ul>\n<p><strong>Rule 2</strong>：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p>\n<p><br></p>\n<h2 id=\"三、关于日志分类\"><a href=\"#三、关于日志分类\" class=\"headerlink\" title=\"三、关于日志分类\"></a>三、关于日志分类</h2><p><br></p>\n<p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p>\n<p>诊断日志， 典型的有：</p>\n<ul>\n<li>请求入口和出口</li>\n<li>外部服务调用和返回</li>\n<li>资源消耗操作: 打开文件等</li>\n<li>容错行为： 譬如云硬盘的副本修复操作</li>\n<li>程序异常： 譬如数据库无法连接</li>\n<li>后台操作：清理程序</li>\n<li>启动、关闭、配置加载</li>\n<li>抛出异常时，不记录日志</li>\n</ul>\n<p>统计日志：</p>\n<ul>\n<li>用户访问统计</li>\n<li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li>\n</ul>\n<p>审计日志：</p>\n<ul>\n<li><p>管理操作</p>\n<p>  将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p>\n</li>\n</ul>\n<p><strong>Rule 3</strong>：要明确不同日志的用途，对日志内容进行分类</p>\n<p><br></p>\n<h2 id=\"四、日志中不要记录无用信息\"><a href=\"#四、日志中不要记录无用信息\" class=\"headerlink\" title=\"四、日志中不要记录无用信息\"></a>四、日志中不要记录无用信息</h2><p><br></p>\n<p>例如一些测试的log: log.i(“tag”, “数据加载成功”)，可以打印一些比较有实用价值的Log， 例如：<br>log.i(“tag”, “数据加载成功，数据是：{}”， “XXXX”)</p>\n<p><strong>Rule 4</strong>: 绝不要打印没有用的日志，防止无用日志淹没重要信息</p>\n<p><br></p>\n<h2 id=\"五、5-日志记录信息要完整\"><a href=\"#五、5-日志记录信息要完整\" class=\"headerlink\" title=\"五、5. 日志记录信息要完整\"></a>五、5. 日志记录信息要完整</h2><p><br></p>\n<p>问题描述：</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> InitMultiUpload（生成一个UploadID）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\">  ……</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> CompleteMultiUpload（AbortMultiUpload）</span><br><span class=\"line\"></span></span><br><span class=\"line\">之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。</span><br><span class=\"line\"></span><br><span class=\"line\">然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。</span><br><span class=\"line\"></span><br><span class=\"line\">类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。</span><br><span class=\"line\"></span><br><span class=\"line\">因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> 在系统启动或初始化时记录重要的系统初始化参数</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的错误</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的警告</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 在持久化数据修改时记录修改前和修改后的值</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 重要的状态变化（如NOS中对系统白名单的修改等）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 系统中一些长期执行的任务的执行进度</span></span><br></pre></td></tr></table></figure>\n<p><strong>不推荐记录日志的内容有：</strong></p>\n<ul>\n<li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li>\n<li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li>\n<li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li>\n</ul>\n<p><strong>Rule 5</strong>：日志信息要准确全面，能做到仅凭日志就可以定位问题</p>\n<p><em>解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。</em></p>\n<p><br></p>\n<h2 id=\"六、测试的日志\"><a href=\"#六、测试的日志\" class=\"headerlink\" title=\"六、测试的日志\"></a>六、测试的日志</h2><p><br></p>\n<p>测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。</p>\n<p>测试日志应该包含以下内容：</p>\n<ul>\n<li>测试执行的环境</li>\n<li>测试执行前的初始状态</li>\n<li>测试的详细步骤</li>\n<li>测试和系统的交互信息</li>\n<li>测试期望的返回结果</li>\n<li>测试实际的返回结果</li>\n</ul>\n<p><strong>Rule 6</strong>：要以同样严格的要求对待测试程序的日志</p>\n<p><br></p>\n<h2 id=\"七、从问题中完善日志\"><a href=\"#七、从问题中完善日志\" class=\"headerlink\" title=\"七、从问题中完善日志\"></a>七、从问题中完善日志</h2><p><br></p>\n<p>在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：</p>\n<ul>\n<li>如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化</li>\n<li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li>\n</ul>\n<p>通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。</p>\n<p><strong>Rule 7</strong>：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p>\n<p><br></p>\n<h2 id=\"八、对日志进行监控报警，比客户先发现系统问题\"><a href=\"#八、对日志进行监控报警，比客户先发现系统问题\" class=\"headerlink\" title=\"八、对日志进行监控报警，比客户先发现系统问题\"></a>八、对日志进行监控报警，比客户先发现系统问题</h2><p><br></p>\n<p>crash关键字报警：</p>\n<p>程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志</p>\n<p>类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。</p>\n<p><strong>Rule 8</strong>：对日志进行监控报警，比客户先发现系统问题</p>\n<p><br></p>\n<h2 id=\"九、关于日志格式\"><a href=\"#九、关于日志格式\" class=\"headerlink\" title=\"九、关于日志格式\"></a>九、关于日志格式</h2><p><br></p>\n<p>日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“Gearman timeout exception for request ” + getRequestID() + ” <span class=\"attribute\">value</span>: ” + value, e);</span><br><span class=\"line\"></span><br><span class=\"line\">第二种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“<span class=\"attribute\">RequestID</span>: ” + getRequestID() + “, Error <span class=\"attribute\">Message</span>: Gearman timeout <span class=\"attribute\">exception</span>: ” + e);</span><br><span class=\"line\"></span><br><span class=\"line\">第三种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(getErrorMessage(getRequestID(), getErrorMessage(), e));</span><br></pre></td></tr></table></figure>\n<p>第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：</p>\n<ul>\n<li>系统中日志格式不统一，不利于自动化处理</li>\n<li>有些日志可能只有开发人员自己才能看懂</li>\n<li>代码规范性不好</li>\n</ul>\n<p>而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。</p>\n<p><strong>Rule 9</strong>：日志格式要统一规范</p>\n<p><br></p>\n<h2 id=\"十、错误日志输出到不同文件\"><a href=\"#十、错误日志输出到不同文件\" class=\"headerlink\" title=\"十、错误日志输出到不同文件\"></a>十、错误日志输出到不同文件</h2><p><br></p>\n<p>在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。</p>\n<p>这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。</p>\n<p><strong>Rule 10</strong>：将错误日志输出到一个单独的文件中进行分析</p>\n<p><br></p>\n<h2 id=\"十一、关于日志文件大小\"><a href=\"#十一、关于日志文件大小\" class=\"headerlink\" title=\"十一、关于日志文件大小\"></a>十一、关于日志文件大小</h2><p><br></p>\n<p>日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。</p>\n<p>为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：</p>\n<ul>\n<li>将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；</li>\n<li>每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志</li>\n</ul>\n<p><strong>Rule 11</strong>：要把日志的大小，如何切分，如何删除等作为规范建立起来</p>\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n<hr>\n","excerpt":"","more":"<p>参考：<a href=\"http://www.bitstech.net/2014/01/07/log-best-practice/\">最佳日志实践</a></p>\n<p><br></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><br></p>\n<pre><code>几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\n日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n\n日志作用：\n- 好的日志记录系统出现问题时能快速定位\n- 可以通过对日志的观察和分析\n- 提前发现系统可能的风险\n- 避免线上事故的发生\n</code></pre><p><br></p>\n<h2 id=\"一、日志级别\"><a href=\"#一、日志级别\" class=\"headerlink\" title=\"一、日志级别\"></a>一、日志级别</h2><p><br></p>\n<h6 id=\"通常使用的日志库（如log4j-logback-等）\"><a href=\"#通常使用的日志库（如log4j-logback-等）\" class=\"headerlink\" title=\"通常使用的日志库（如log4j, logback 等）\"></a>通常使用的日志库（如<strong>log4j</strong>, <strong>logback</strong> 等）</h6><p><strong>日志基本分为以下几类（从低到高）：</strong></p>\n<p><strong>VERBOSE</strong> – <em>The VERBOSE Level designates finer-grained informational events than the DEBUG</em></p>\n<p><strong>DEBUG</strong> – <em>The DEBUG Level designates fine-grained informational events that are most useful to debug an application.</em></p>\n<p><strong>INFO</strong> – <em>The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.</em></p>\n<p><strong>WARN</strong> – <em>The WARN level designates potentially harmful situations.</em></p>\n<p><strong>ERROR</strong> – <em>The ERROR level designates error events that might still allow the application to continue running.</em></p>\n<p><strong>FATAL</strong> – <em>The FATAL level designates very severe error events that will presumably lead the application to abort.</em></p>\n<ul>\n<li>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；</li>\n<li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;</li>\n<li>对于日志级别的分类，有以下参考：</li>\n</ul>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ERROR</span> — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当<span class=\"built_in\">ERROR</span>错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上<span class=\"built_in\">ERROR</span>错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而<span class=\"built_in\">ERROR</span>相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印<span class=\"built_in\">ERROR</span>日志。特别需要注意的是，<span class=\"built_in\">ERROR</span>和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为<span class=\"built_in\">ERROR</span>日志的；</span><br><span class=\"line\"></span><br><span class=\"line\">WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；</span><br><span class=\"line\"></span><br><span class=\"line\">INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,<span class=\"built_in\">ERROR</span>,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于<span class=\"keyword\">TRACE</span>日志的<span class=\"number\">10</span>%；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DEBUG</span> <span class=\"keyword\">or</span> <span class=\"keyword\">TRACE</span> — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）级别的日志对问题进行诊断。需要注意的是，<span class=\"keyword\">DEBUG</span>日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）日志来定位问题；</span><br></pre></td></tr></table></figure>\n<p><strong>Rule 1</strong>：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p>\n<p><br></p>\n<h2 id=\"二、对记录的日志要进行更新维护\"><a href=\"#二、对记录的日志要进行更新维护\" class=\"headerlink\" title=\"二、对记录的日志要进行更新维护\"></a>二、对记录的日志要进行更新维护</h2><p><br></p>\n<p>由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：</p>\n<ul>\n<li>定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；</li>\n<li>整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；</li>\n</ul>\n<p><strong>Rule 2</strong>：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p>\n<p><br></p>\n<h2 id=\"三、关于日志分类\"><a href=\"#三、关于日志分类\" class=\"headerlink\" title=\"三、关于日志分类\"></a>三、关于日志分类</h2><p><br></p>\n<p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p>\n<p>诊断日志， 典型的有：</p>\n<ul>\n<li>请求入口和出口</li>\n<li>外部服务调用和返回</li>\n<li>资源消耗操作: 打开文件等</li>\n<li>容错行为： 譬如云硬盘的副本修复操作</li>\n<li>程序异常： 譬如数据库无法连接</li>\n<li>后台操作：清理程序</li>\n<li>启动、关闭、配置加载</li>\n<li>抛出异常时，不记录日志</li>\n</ul>\n<p>统计日志：</p>\n<ul>\n<li>用户访问统计</li>\n<li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li>\n</ul>\n<p>审计日志：</p>\n<ul>\n<li><p>管理操作</p>\n<p>  将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p>\n</li>\n</ul>\n<p><strong>Rule 3</strong>：要明确不同日志的用途，对日志内容进行分类</p>\n<p><br></p>\n<h2 id=\"四、日志中不要记录无用信息\"><a href=\"#四、日志中不要记录无用信息\" class=\"headerlink\" title=\"四、日志中不要记录无用信息\"></a>四、日志中不要记录无用信息</h2><p><br></p>\n<p>例如一些测试的log: log.i(“tag”, “数据加载成功”)，可以打印一些比较有实用价值的Log， 例如：<br>log.i(“tag”, “数据加载成功，数据是：{}”， “XXXX”)</p>\n<p><strong>Rule 4</strong>: 绝不要打印没有用的日志，防止无用日志淹没重要信息</p>\n<p><br></p>\n<h2 id=\"五、5-日志记录信息要完整\"><a href=\"#五、5-日志记录信息要完整\" class=\"headerlink\" title=\"五、5. 日志记录信息要完整\"></a>五、5. 日志记录信息要完整</h2><p><br></p>\n<p>问题描述：</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> InitMultiUpload（生成一个UploadID）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\">  ……</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> CompleteMultiUpload（AbortMultiUpload）</span><br><span class=\"line\"></span></span><br><span class=\"line\">之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。</span><br><span class=\"line\"></span><br><span class=\"line\">然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。</span><br><span class=\"line\"></span><br><span class=\"line\">类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。</span><br><span class=\"line\"></span><br><span class=\"line\">因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> 在系统启动或初始化时记录重要的系统初始化参数</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的错误</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的警告</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 在持久化数据修改时记录修改前和修改后的值</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 重要的状态变化（如NOS中对系统白名单的修改等）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 系统中一些长期执行的任务的执行进度</span></span><br></pre></td></tr></table></figure>\n<p><strong>不推荐记录日志的内容有：</strong></p>\n<ul>\n<li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li>\n<li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li>\n<li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li>\n</ul>\n<p><strong>Rule 5</strong>：日志信息要准确全面，能做到仅凭日志就可以定位问题</p>\n<p><em>解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。</em></p>\n<p><br></p>\n<h2 id=\"六、测试的日志\"><a href=\"#六、测试的日志\" class=\"headerlink\" title=\"六、测试的日志\"></a>六、测试的日志</h2><p><br></p>\n<p>测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。</p>\n<p>测试日志应该包含以下内容：</p>\n<ul>\n<li>测试执行的环境</li>\n<li>测试执行前的初始状态</li>\n<li>测试的详细步骤</li>\n<li>测试和系统的交互信息</li>\n<li>测试期望的返回结果</li>\n<li>测试实际的返回结果</li>\n</ul>\n<p><strong>Rule 6</strong>：要以同样严格的要求对待测试程序的日志</p>\n<p><br></p>\n<h2 id=\"七、从问题中完善日志\"><a href=\"#七、从问题中完善日志\" class=\"headerlink\" title=\"七、从问题中完善日志\"></a>七、从问题中完善日志</h2><p><br></p>\n<p>在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：</p>\n<ul>\n<li>如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化</li>\n<li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li>\n</ul>\n<p>通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。</p>\n<p><strong>Rule 7</strong>：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p>\n<p><br></p>\n<h2 id=\"八、对日志进行监控报警，比客户先发现系统问题\"><a href=\"#八、对日志进行监控报警，比客户先发现系统问题\" class=\"headerlink\" title=\"八、对日志进行监控报警，比客户先发现系统问题\"></a>八、对日志进行监控报警，比客户先发现系统问题</h2><p><br></p>\n<p>crash关键字报警：</p>\n<p>程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志</p>\n<p>类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。</p>\n<p><strong>Rule 8</strong>：对日志进行监控报警，比客户先发现系统问题</p>\n<p><br></p>\n<h2 id=\"九、关于日志格式\"><a href=\"#九、关于日志格式\" class=\"headerlink\" title=\"九、关于日志格式\"></a>九、关于日志格式</h2><p><br></p>\n<p>日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“Gearman timeout exception for request ” + getRequestID() + ” <span class=\"attribute\">value</span>: ” + value, e);</span><br><span class=\"line\"></span><br><span class=\"line\">第二种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“<span class=\"attribute\">RequestID</span>: ” + getRequestID() + “, Error <span class=\"attribute\">Message</span>: Gearman timeout <span class=\"attribute\">exception</span>: ” + e);</span><br><span class=\"line\"></span><br><span class=\"line\">第三种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(getErrorMessage(getRequestID(), getErrorMessage(), e));</span><br></pre></td></tr></table></figure>\n<p>第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：</p>\n<ul>\n<li>系统中日志格式不统一，不利于自动化处理</li>\n<li>有些日志可能只有开发人员自己才能看懂</li>\n<li>代码规范性不好</li>\n</ul>\n<p>而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。</p>\n<p><strong>Rule 9</strong>：日志格式要统一规范</p>\n<p><br></p>\n<h2 id=\"十、错误日志输出到不同文件\"><a href=\"#十、错误日志输出到不同文件\" class=\"headerlink\" title=\"十、错误日志输出到不同文件\"></a>十、错误日志输出到不同文件</h2><p><br></p>\n<p>在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。</p>\n<p>这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。</p>\n<p><strong>Rule 10</strong>：将错误日志输出到一个单独的文件中进行分析</p>\n<p><br></p>\n<h2 id=\"十一、关于日志文件大小\"><a href=\"#十一、关于日志文件大小\" class=\"headerlink\" title=\"十一、关于日志文件大小\"></a>十一、关于日志文件大小</h2><p><br></p>\n<p>日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。</p>\n<p>为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：</p>\n<ul>\n<li>将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；</li>\n<li>每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志</li>\n</ul>\n<p><strong>Rule 11</strong>：要把日志的大小，如何切分，如何删除等作为规范建立起来</p>\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n<hr>\n"},{"title":"是什么使你无法完成工作？——番茄告诉你","date":"2015-09-13T04:28:36.000Z","_content":"# 是什么让你无法完成胜任的工作呢？\n\n- 面对复杂，望而却步\n- 无聊琐事，越拖越久\n- 小事忙活一天，大事一样没办\n- 最后期限，步步紧逼\n- 从休息回到工作，心智调整不过来\n- 一错再错，不长记性\n- 没想到一件事越做越复杂\n- 头脑被各种想法占据\n- 时间都用来学习适应复杂的工作了\n- 只顾埋头工作，忘了抬头看路\n- 把预估当做承诺\n- 流程管理，纸上谈兵\n- 牵着不走，打着倒退\n- 完美主义，碍手碍脚\n- 前怕虎，后怕狼，害怕失败和评论\n\n如有以上烦恼，请看下图：\n\n### 番茄工作法\n\t\t番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n\t\t使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n\n如有以上烦恼，没事多看看 下图：\n\n\n![番茄工作法][1]\n\n\n必要的时候请使用 戴明循环（PDCA）工作法。\n\n---\n[1]: http://i3.tietuku.com/ab907523c2054c41.png","source":"_posts/是什么使你无法完成工作？——番茄告诉你.md","raw":"title: 是什么使你无法完成工作？——番茄告诉你\ndate: 2015-09-13 12:28:36\ntags: 番茄工作法\n---\n# 是什么让你无法完成胜任的工作呢？\n\n- 面对复杂，望而却步\n- 无聊琐事，越拖越久\n- 小事忙活一天，大事一样没办\n- 最后期限，步步紧逼\n- 从休息回到工作，心智调整不过来\n- 一错再错，不长记性\n- 没想到一件事越做越复杂\n- 头脑被各种想法占据\n- 时间都用来学习适应复杂的工作了\n- 只顾埋头工作，忘了抬头看路\n- 把预估当做承诺\n- 流程管理，纸上谈兵\n- 牵着不走，打着倒退\n- 完美主义，碍手碍脚\n- 前怕虎，后怕狼，害怕失败和评论\n\n如有以上烦恼，请看下图：\n\n### 番茄工作法\n\t\t番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n\t\t使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n\n如有以上烦恼，没事多看看 下图：\n\n\n![番茄工作法][1]\n\n\n必要的时候请使用 戴明循环（PDCA）工作法。\n\n---\n[1]: http://i3.tietuku.com/ab907523c2054c41.png","slug":"是什么使你无法完成工作？——番茄告诉你","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ah7001xxzex0uka5zw4","content":"<h1 id=\"是什么让你无法完成胜任的工作呢？\"><a href=\"#是什么让你无法完成胜任的工作呢？\" class=\"headerlink\" title=\"是什么让你无法完成胜任的工作呢？\"></a>是什么让你无法完成胜任的工作呢？</h1><ul>\n<li>面对复杂，望而却步</li>\n<li>无聊琐事，越拖越久</li>\n<li>小事忙活一天，大事一样没办</li>\n<li>最后期限，步步紧逼</li>\n<li>从休息回到工作，心智调整不过来</li>\n<li>一错再错，不长记性</li>\n<li>没想到一件事越做越复杂</li>\n<li>头脑被各种想法占据</li>\n<li>时间都用来学习适应复杂的工作了</li>\n<li>只顾埋头工作，忘了抬头看路</li>\n<li>把预估当做承诺</li>\n<li>流程管理，纸上谈兵</li>\n<li>牵着不走，打着倒退</li>\n<li>完美主义，碍手碍脚</li>\n<li>前怕虎，后怕狼，害怕失败和评论</li>\n</ul>\n<p>如有以上烦恼，请看下图：</p>\n<h3 id=\"番茄工作法\"><a href=\"#番茄工作法\" class=\"headerlink\" title=\"番茄工作法\"></a>番茄工作法</h3><pre><code>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n</code></pre><p>如有以上烦恼，没事多看看 下图：</p>\n<p><img src=\"http://i3.tietuku.com/ab907523c2054c41.png\" alt=\"番茄工作法\"></p>\n<p>必要的时候请使用 戴明循环（PDCA）工作法。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"是什么让你无法完成胜任的工作呢？\"><a href=\"#是什么让你无法完成胜任的工作呢？\" class=\"headerlink\" title=\"是什么让你无法完成胜任的工作呢？\"></a>是什么让你无法完成胜任的工作呢？</h1><ul>\n<li>面对复杂，望而却步</li>\n<li>无聊琐事，越拖越久</li>\n<li>小事忙活一天，大事一样没办</li>\n<li>最后期限，步步紧逼</li>\n<li>从休息回到工作，心智调整不过来</li>\n<li>一错再错，不长记性</li>\n<li>没想到一件事越做越复杂</li>\n<li>头脑被各种想法占据</li>\n<li>时间都用来学习适应复杂的工作了</li>\n<li>只顾埋头工作，忘了抬头看路</li>\n<li>把预估当做承诺</li>\n<li>流程管理，纸上谈兵</li>\n<li>牵着不走，打着倒退</li>\n<li>完美主义，碍手碍脚</li>\n<li>前怕虎，后怕狼，害怕失败和评论</li>\n</ul>\n<p>如有以上烦恼，请看下图：</p>\n<h3 id=\"番茄工作法\"><a href=\"#番茄工作法\" class=\"headerlink\" title=\"番茄工作法\"></a>番茄工作法</h3><pre><code>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n</code></pre><p>如有以上烦恼，没事多看看 下图：</p>\n<p><img src=\"http://i3.tietuku.com/ab907523c2054c41.png\" alt=\"番茄工作法\"></p>\n<p>必要的时候请使用 戴明循环（PDCA）工作法。</p>\n<hr>\n"},{"title":"凯哥高质量文章系列","date":"2015-11-20T04:17:18.000Z","keywords":null,"_content":"\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n\n# 凯哥系列：\n## 1. [Activity启动过程全解析](http://www.devtf.cn/?p=1101)\n## 2. [framework-Activity界面显示全解析](http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287)\n\n\n注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念\n\n\n### 看文章的记录：\n1.App启动\n2.App入口\n3.Launcher?\n4.AMS??\n5.Binder是神马？怎么进行IPC通信？\n6.Activity生命周期是被谁 什么时候调用的？\n\n### 目的：\n1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度\n2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系\n\n3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合\n\n4.Activity相关的framework问题\n\n### 主要对象功能介绍：\n1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；\n2.ActivityThread:App的真正入口。打开App-\\>main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；\n3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。\n4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。\n5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。\n6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。\n7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。\n8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。\n\n### 主要流程介绍\n\n- zygote 是神马？\n程序 Crash 的时候，打印红色的log通常带有这个\nAndroid基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！\n\nAndroid 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程\n\n我们都知道，每一个App其实都是：\n- 一个单独的dalvik 虚拟机\n\t- 单独的进程\n\n当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！\n\n### SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\n\n首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！\n\n这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。\n\n为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？\n\n那么这些服务是怎么开启起来的呢?\n\n在zygote 开启的时候，会调用 ZygoteInit.main初始化\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n关键代码：\n\tif (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t}\n\t~~~\n\t//开始fork我们的SystemServer进程\n\tif (startSystemServer) {\n\t       startSystemServer(abiList, socketName);\n\t}\n\n\n我们看下startSystemServer()做了些什么:\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n\n我们看下startSystemServer()做了些什么\n\t\n\t    /**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n\t     * Prepare the arguments and fork for the system server process.\n\t     */\n\t    private static boolean startSystemServer(String abiList, String socketName)\n\t            throws MethodAndArgsCaller, RuntimeException {\n\t\n\t         ...ignore some code...\n\t\n\t        //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n\t        /* Hardcoded command line to start the system server */\n\t        String args[] = {\n\t            \"--setuid=1000\",\n\t            \"--setgid=1000\",\n\t            \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007\",\n\t            \"--capabilities=\" + capabilities + \",\" + capabilities,\n\t            \"--runtime-init\",\n\t            \"--nice-name=system_server\",\n\t            \"com.android.server.SystemServer\",\n\t        };\n\t\n\t        int pid;\n\t        try {\n\t            parsedArgs = new ZygoteConnection.Arguments(args);\n\t            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n\t            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\t\n\t        //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n\t            /* Request to fork the system server process */\n\t            pid = Zygote.forkSystemServer(\n\t                    parsedArgs.uid, parsedArgs.gid,\n\t                    parsedArgs.gids,\n\t                    parsedArgs.debugFlags,\n\t                    null,\n\t                    parsedArgs.permittedCapabilities,\n\t                    parsedArgs.effectiveCapabilities);\n\t        } catch (IllegalArgumentException ex) {\n\t            throw new RuntimeException(ex);\n\t        }\n\t\n\t        /* For child process */\n\t        if (pid == 0) {\n\t            if (hasSecondZygote(abiList)) {\n\t                waitForSecondaryZygote(socketName);\n\t            }\n\t\n\t            handleSystemServerProcess(parsedArgs);\n\t        }\n\t\n\t        return true;\n\t    }\n\n### ActivityManagerService是什么？什么时候创建？作用?\n\nActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。\n\nAMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService \n\n\tpublic final class SystemServer {\n\t\n\t    //zygote的主入口\n\t    public static void main(String[] args) {\n\t        new SystemServer().run();\n\t    }\n\t\n\t    public SystemServer() {\n\t        // Check for factory test mode.\n\t        mFactoryTestMode = FactoryTest.getMode();\n\t    }\n\t\n\t    private void run() {\n\t\n\t        ...ignore some code...\n\t\n\t        //加载本地系统服务库，并进行初始化 \n\t        System.loadLibrary(\"android_servers\");\n\t        nativeInit();\n\t\n\t        // 创建系统上下文\n\t        createSystemContext();\n\t\n\t        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class<T>)，这个方法通过反射来启动对应的服务\n\t        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\t\n\t        //开启服务\n\t        try {\n\t            startBootstrapServices();\n\t            startCoreServices();\n\t            startOtherServices();\n\t        } catch (Throwable ex) {\n\t            Slog.e(\"System\", \"******************************************\");\n\t            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n\t            throw ex;\n\t        }\n\t\n\t        ...ignore some code...\n\t\n\t    }\n\t\n\t    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n\t    private void createSystemContext() {\n\t        ActivityThread activityThread = ActivityThread.systemMain();\n\t        mSystemContext = activityThread.getSystemContext();\n\t        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n\t    }\n\t\n\t    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n\t    private void startBootstrapServices() {\n\t\n\t        ...ignore some code...\n\t\n\t        //初始化ActivityManagerService\n\t        mActivityManagerService = mSystemServiceManager.startService(\n\t                ActivityManagerService.Lifecycle.class).getService();\n\t        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\t\n\t        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n\t        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\t\n\t        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n\t        mActivityManagerService.initPowerManagement();\n\t\n\t        // 初始化DisplayManagerService\n\t        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\t\n\t    //初始化PackageManagerService\n\t    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n\t       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\t\n\t    ...ignore some code...\n\t\n\t    }\n\t\n\t}\n\n经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。\n\n你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。\n\n其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开\n\n\tIntent intent = new Intent(Intent.ACTION_MAIN);  \n\tintent.addCategory(Intent.CATEGORY_LAUNCHER);              \n\tComponentName cn = new ComponentName(packageName, className);              \n\tintent.setComponent(cn);  \n\tstartActivity(intent); \n\n但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。\n\n知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？\n\nApp与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。\n\n那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。\n\n在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。\n\n这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。\n\n### Launche是什么？ 什么时候启动？\n\n当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？\n\nLauncher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。\n\n\npackages/apps/Launcher2/src/com/android/launcher2/Launcher.java\n\tpublic final class Launcher extends Activity\n\t        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,\n\t                   View.OnTouchListener {\n\t                   }\n\nLauncher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。\n\n![](DraggedImage.png)\n\n程序列表里面：\n![](DraggedImage-1.png)\n\n可以看到的是，调用的是：\n\tmLauncher.startActivitySafely(v, appInfo.intent, appInfo);\n\n和上面的一样，这叫什么？ 这叫殊途同归！\n\n所以现在我们明白了一件事：不管从哪里点击图标，调用的都是 \n\tLauncher.startActivitySafely()\n\n下面来看看 Launcher.startActivitySafely()到底做了什么事情\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n调用了startAcitivity(v,intent,tag)\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：\n\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n### Instrumentation是什么？和ActivityThread 是什么关系？\n每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()\n\n\tboolean startActivity(View v, Intent intent, Object tag) {\n\t\n\t        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t        try {\n\t            boolean useLaunchAnimation = (v != null) &&\n\t                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\t\n\t            if (useLaunchAnimation) {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent, opts.toBundle());\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(),\n\t                            opts.toBundle());\n\t                }\n\t            } else {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent);\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(), null);\n\t                }\n\t            }\n\t            return true;\n\t        } catch (SecurityException e) {\n\t        ...\n\t        }\n\t        return false;\n\t    }\n\n\n有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？\n\n是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！\n\n那你可能要问老板是who?\n老板当然是 大名鼎鼎的 ActivityThread了\n\nActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。\n\nASM说：『ActivityThread， 你给我暂停一个Activity！』\n\nActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』\n\n于是，Instrumentation 就去把事儿搞定了。\n所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。\n\n### 如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\n前面提到 调用 startActivity()的时候，时间调用了 \n\tmInstrumentation.execStartActivity()\n\n里面又调用了：\n\tActivityManagerNative.getDefault()\n\t                .startActivity\n\n这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。\n\nBinder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。\n\n为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：\n\nAMS， 和 AMP 都实现利率同一个接口： IActivityManager。\n\tclass ActivityManagerProxy implements IActivityManager{}\n\t\n\tpublic final class ActivityManagerService extends ActivityManagerNative{}\n\t\n\tpublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n\n虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。\n\n\n但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。\n\n但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如\n\tpublic int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n\t            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n\t        Parcel data = Parcel.obtain();\n\t        Parcel reply = Parcel.obtain();\n\t\n\t        ...ignore some code...\n\t\n\t        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n\t        reply.readException();\n\t        int result = reply.readInt();\n\t        reply.recycle();\n\t        data.recycle();\n\t        return result;\n\t    }\n\n上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。\n\n即：\n客户度：ActivityManagerProxy ====\\> Binder驱动 ====》ActivityManagerService：服务器\n\n而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。\n\n但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ \n\n还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。\n\n客户端：ApplicationThread \\<=== Binder驱动 \\<=== ApplicationThreadProxy：服务器\n\n他们也实现了相同的接口 IApplicationThread:\n\tprivate class ApplicationThread extends ApplicationThreadNative {}\n\t\n\t  public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\t\n\t  class ApplicationThreadProxy implements IApplicationThread {}\n\n\n### AMS 接收到 客户端的请求后，如果开启一个Activity？\n\nOK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？\n\n注：前方高能，方法调用链接很强！\n\n调用startActivity（）\n\t@Override\n\t    public final int startActivity(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) {\n\t        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n\t            resultWho, requestCode, startFlags, profilerInfo, options,\n\t            UserHandle.getCallingUserId());\n\t    }\n\n调用startActivityAsUser（）\n\t@Override\n\t    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n\t\n\t            ...ignore some code...\n\t\n\t        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n\t                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n\t                profilerInfo, null, null, options, userId, null, null);\n\t    }\n\n这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作\n\t final int startActivityMayWait(IApplicationThread caller, int callingUid,\n\t            String callingPackage, Intent intent, String resolvedType,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n\t            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,\n\t            Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t              int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n\t                    voiceSession, voiceInteractor, resultTo, resultWho,\n\t                    requestCode, callingPid, callingUid, callingPackage,\n\t                    realCallingPid, realCallingUid, startFlags, options,\n\t                    componentSpecified, null, container, inTask);\n\t\n\t            ...ignore some code...\n\t\n\t            }\n\n继续调用 startActivityLocked()\n\n\tfinal int startActivityLocked(IApplicationThread caller,\n\t            Intent intent, String resolvedType, ActivityInfo aInfo,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode,\n\t            int callingPid, int callingUid, String callingPackage,\n\t            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n\t            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n\t            TaskRecord inTask) {\n\t\n\t              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n\t              startFlags, true, options, inTask);\n\t        if (err < 0) {\n\t            notifyActivityDrawnForKeyguard();\n\t        }\n\t        return err;\n\t    }\n\n调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。\n\n终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)\n\nActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，\n\n\tfinal int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n\t            boolean doResume, Bundle options, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\t\n\t            ...ignore some code...\n\t\n\t             return ActivityManager.START_SUCCESS;\n\t            }\n\n调用 ActivityStack.startActivityLocked()\n\n\tfinal void startActivityLocked(ActivityRecord r, boolean newTask,\n\t            boolean doResume, boolean keepCurTransition, Bundle options) {\n\t\n\t        //ActivityRecord中存储的TaskRecord信息\n\t        TaskRecord rTask = r.task;\n\t\n\t         ...ignore some code...\n\t\n\t        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n\t     TaskRecord task = null;\n\t        if (!newTask) {\n\t            boolean startIt = true;\n\t            for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n\t                task = mTaskHistory.get(taskNdx);\n\t                if (task.getTopActivity() == null) {\n\t                    // task中的所有Activity都结束了\n\t                    continue;\n\t                }\n\t                if (task == r.task) {\n\t                    // 找到了\n\t                    if (!startIt) {\n\t                        task.addActivityToTop(r);\n\t                        r.putInHistory();\n\t                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n\t                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n\t                                (r.info.flags & ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n\t                                r.userId, r.info.configChanges, task.voiceSession != null,\n\t                                r.mLaunchTaskBehind);\n\t                        if (VALIDATE_TOKENS) {\n\t                            validateAppTokensLocked();\n\t                        }\n\t                        ActivityOptions.abort(options);\n\t                        return;\n\t                    }\n\t                    break;\n\t                } else if (task.numFullscreen > 0) {\n\t                    startIt = false;\n\t                }\n\t            }\n\t        }\n\t\n\t      ...ignore some code...\n\t\n\t        // Place a new activity at top of stack, so it is next to interact\n\t        // with the user.\n\t        task = r.task;\n\t        task.addActivityToTop(r);\n\t        task.setFrontOfTask();\n\t\n\t        ...ignore some code...\n\t\n\t         if (doResume) {\n\t            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n\t        }\n\t    }\n\n折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor \n\n淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。\n\n一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：\n\tboolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,\n\t            Bundle targetOptions) {\n\t        if (targetStack == null) {\n\t            targetStack = getFocusedStack();\n\t        }\n\t        // Do targetStack first.\n\t        boolean result = false;\n\t        if (isFrontStack(targetStack)) {\n\t            result = targetStack.resumeTopActivityLocked(target, targetOptions);\n\t        }\n\t\n\t          ...ignore some code...\n\t\n\t        return result;\n\t    }\n\n又回到 ActivityStack了。。。\n\nActivityStack.resumeTopActivityLocked()\n\tfinal boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {\n\t        if (inResumeTopActivity) {\n\t            // Don't even start recursing.\n\t            return false;\n\t        }\n\t\n\t        boolean result = false;\n\t        try {\n\t            // Protect against recursion.\n\t            inResumeTopActivity = true;\n\t            result = resumeTopActivityInnerLocked(prev, options);\n\t        } finally {\n\t            inResumeTopActivity = false;\n\t        }\n\t        return result;\n\t    }\n\n坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？\n\n\tfinal boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\t\n\t          ...ignore some code...\n\t      //找出还没结束的首个ActivityRecord\n\t     ActivityRecord next = topRunningActivityLocked(null);\n\t\n\t    //如果一个没结束的Activity都没有，就开启Launcher程序\n\t    if (next == null) {\n\t            ActivityOptions.abort(options);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: No more activities go home\");\n\t            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n\t            // Only resume home if on home display\n\t            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n\t                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n\t            return isOnHomeDisplay() &&\n\t                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n\t        }\n\t\n\t        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n\t          if (mResumedActivity != null) {\n\t            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: Pausing \" + mResumedActivity);\n\t        }\n\t\n\t  }\n\n\n在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。\n\tActivityManagerNative.getDefault().activityPaused(token).\n\n上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。\n\n最后 来一张高清五码的大图，方便记忆\n\n![](Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png)\n\n### 一个App的程序入口是什么？\n是ActivityThread.main()\n\n### 整个App的主线程的消息循环是在哪里创建的?\n是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。\n\n\tpublic static void main(String[] args) {\n\t\n\t          ...ignore some code...    \n\t\n\t      Looper.prepareMainLooper();\n\t\n\t        ActivityThread thread = new ActivityThread();\n\t        thread.attach(false);\n\t\n\t        if (sMainThreadHandler == null) {\n\t            sMainThreadHandler = thread.getHandler();\n\t        }\n\t\n\t        AsyncTask.init();\n\t\n\t        if (false) {\n\t            Looper.myLooper().setMessageLogging(new\n\t                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n\t        }\n\t\n\t        Looper.loop();\n\t\n\t          ...ignore some code...    \n\t\n\t }\n\nLooper.prepareMainLooper();\n准备完成后：\n\nLooper.loop()\n\n\n### Application 是在什么时候创建的？onCreate()什么时候调用的？\n也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。\n\n不相信，一起看看去!\n\n先看下ActivityThead.attach()\n\tprivate void attach(boolean system) {\n\t        sCurrentActivityThread = this;\n\t        mSystemThread = system;\n\t        //普通App进这里\n\t        if (!system) {\n\t\n\t            ...ignore some code...    \n\t\n\t            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n\t            final IActivityManager mgr = ActivityManagerNative.getDefault();\n\t            try {\n\t                mgr.attachApplication(mAppThread);\n\t            } catch (RemoteException ex) {\n\t                // Ignore\n\t            }\n\t           } else {\n\t             //这个分支在SystemServer加载的时候会进入，通过调用\n\t             // private void createSystemContext() {\n\t             //    ActivityThread activityThread = ActivityThread.systemMain()；\n\t             //} \n\t\n\t             // public static ActivityThread systemMain() {\n\t        //        if (!ActivityManager.isHighEndGfx()) {\n\t        //            HardwareRenderer.disable(true);\n\t        //        } else {\n\t        //            HardwareRenderer.enableForegroundTrimming();\n\t        //        }\n\t        //        ActivityThread thread = new ActivityThread();\n\t        //        thread.attach(true);\n\t        //        return thread;\n\t        //    }       \n\t           }\n\t    }\n\n这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法\n\n\t@Override\n\t    public final void attachApplication(IApplicationThread thread) {\n\t        synchronized (this) {\n\t            int callingPid = Binder.getCallingPid();\n\t            final long origId = Binder.clearCallingIdentity();\n\t            attachApplicationLocked(thread, callingPid);\n\t            Binder.restoreCallingIdentity(origId);\n\t        }\n\t    }\n\n然后：\n\n\tprivate final boolean attachApplicationLocked(IApplicationThread thread,\n\t            int pid) {\n\t\n\t\n\t             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n\t                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n\t                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n\t                    isRestrictedBackupMode || !normalMode, app.persistent,\n\t                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n\t                    mCoreSettingsObserver.getCoreSettingsLocked());\n\t\n\t\n\t            }\n\nthread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法\n\tpublic final void bindApplication(String processName, ApplicationInfo appInfo,\n\t                List<ProviderInfo> providers, ComponentName instrumentationName,\n\t                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\n\t                IInstrumentationWatcher instrumentationWatcher,\n\t                IUiAutomationConnection instrumentationUiConnection, int debugMode,\n\t                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,\n\t                Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,\n\t                Bundle coreSettings) {\n\t\n\t                 ...ignore some code...    \n\t\n\t             AppBindData data = new AppBindData();\n\t            data.processName = processName;\n\t            data.appInfo = appInfo;\n\t            data.providers = providers;\n\t            data.instrumentationName = instrumentationName;\n\t            data.instrumentationArgs = instrumentationArgs;\n\t            data.instrumentationWatcher = instrumentationWatcher;\n\t            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n\t            data.debugMode = debugMode;\n\t            data.enableOpenGlTrace = enableOpenGlTrace;\n\t            data.restrictedBackupMode = isRestrictedBackupMode;\n\t            data.persistent = persistent;\n\t            data.config = config;\n\t            data.compatInfo = compatInfo;\n\t            data.initProfilerInfo = profilerInfo;\n\t            sendMessage(H.BIND_APPLICATION, data);\n\t\n\t           }\n\t\n\t}\n\n\n其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理\n\tprivate class H extends Handler {\n\t\n\t      ...ignore some code... \n\t\n\t     public static final int BIND_APPLICATION        = 110;\n\t\n\t    ...ignore some code... \n\t\n\t     public void handleMessage(Message msg) {\n\t          switch (msg.what) {\n\t        ...ignore some code... \n\t         case BIND_APPLICATION:\n\t                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n\t                    AppBindData data = (AppBindData)msg.obj;\n\t                    handleBindApplication(data);\n\t                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\t                    break;\n\t        ...ignore some code... \n\t        }\n\t }\n\n最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。\n\n\tprivate void handleBindApplication(AppBindData data) {\n\t\n\t try {\n\t\n\t           ...ignore some code... \n\t\n\t            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n\t            mInitialApplication = app;\n\t\n\t           ...ignore some code... \n\t\n\t            try {\n\t                mInstrumentation.onCreate(data.instrumentationArgs);\n\t            }\n\t            catch (Exception e) {\n\t            }\n\t            try {\n\t                mInstrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {            }\n\t        } finally {\n\t            StrictMode.setThreadPolicy(savedPolicy);\n\t        }\n\t }\n\t\n\ndata.info 是一个LoadeApk 对象\n\nLoadeApk.data.info.makeApplication()\n\n\tpublic Application makeApplication(boolean forceDefaultAppClass,\n\t            Instrumentation instrumentation) {\n\t        if (mApplication != null) {\n\t            return mApplication;\n\t        }\n\t\n\t        Application app = null;\n\t\n\t        String appClass = mApplicationInfo.className;\n\t        if (forceDefaultAppClass || (appClass == null)) {\n\t            appClass = \"android.app.Application\";\n\t        }\n\t\n\t        try {\n\t            java.lang.ClassLoader cl = getClassLoader();\n\t            if (!mPackageName.equals(\"android\")) {\n\t                initializeJavaContextClassLoader();\n\t            }\n\t            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n\t            app = mActivityThread.mInstrumentation.newApplication(\n\t                    cl, appClass, appContext);\n\t            appContext.setOuterContext(app);\n\t        } catch (Exception e) {        }\n\t        mActivityThread.mAllApplications.add(app);\n\t        mApplication = app;\n\t\n\t    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n\t        if (instrumentation != null) {\n\t            try {\n\t                instrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {\n\t\n\t            }\n\t        }\n\t        ...ignore some code... \n\t\n\t       }\n\t\n\t        return app;\n\t    }\n\n最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！\n\n\tstatic public Application newApplication(Class<?> clazz, Context context)\n\t            throws InstantiationException, IllegalAccessException, \n\t            ClassNotFoundException {\n\t        Application app = (Application)clazz.newInstance();\n\t        app.attach(context);\n\t        return app;\n\t    }\n\n而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。\n\n参考文章\n\n下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。\n\nBinder:\n- [Android Bander设计与实现 - 设计篇](http://blog.csdn.net/universus/article/details/6211589)\n\nzygote\n•\t[Android系统进程Zygote启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6768304)\n•\t[Android 之 zygote 与进程创建](http://blog.csdn.net/xieqibao/article/details/6581975)\n•\t[Zygote浅谈](http://www.th7.cn/Program/Android/201404/187670.shtml)\nActivityThread、Instrumentation、AMS\n•\t[Android Activity.startActivity流程简介](http://blog.csdn.net/myarrow/article/details/14224273)\n•\t[Android应用程序进程启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6747696#comments)\n•\t[框架层理解Activity生命周期(APP启动过程)](http://laokaddk.blog.51cto.com/368606/1206840)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\n•\t[ActivityManagerService分析一：AMS的启动](http://www.xuebuyuan.com/2172927.html)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\nLauncher\n•\t[Android 4.0 Launcher源码分析系列(一)](http://mobile.51cto.com/hot-312129.htm)\n•\t[Android Launcher分析和修改9——Launcher启动APP流程](http://www.cnblogs.com/mythou/p/3187881.html)\n\n结束语：\n到了这里，我们回来看下开头的几个问题：\n- ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期\n- ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作\n- ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。\n- ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的\n- Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作\n- ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射\n- TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。\n\n如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/凯哥高质量文章系列.md","raw":"title: 凯哥高质量文章系列\ndate: 2015-11-20 12:17:18\ncategories:\nkeywords:\ntags: Android\n---\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n\n# 凯哥系列：\n## 1. [Activity启动过程全解析](http://www.devtf.cn/?p=1101)\n## 2. [framework-Activity界面显示全解析](http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287)\n\n\n注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念\n\n\n### 看文章的记录：\n1.App启动\n2.App入口\n3.Launcher?\n4.AMS??\n5.Binder是神马？怎么进行IPC通信？\n6.Activity生命周期是被谁 什么时候调用的？\n\n### 目的：\n1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度\n2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系\n\n3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合\n\n4.Activity相关的framework问题\n\n### 主要对象功能介绍：\n1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；\n2.ActivityThread:App的真正入口。打开App-\\>main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；\n3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。\n4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。\n5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。\n6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。\n7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。\n8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。\n\n### 主要流程介绍\n\n- zygote 是神马？\n程序 Crash 的时候，打印红色的log通常带有这个\nAndroid基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！\n\nAndroid 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程\n\n我们都知道，每一个App其实都是：\n- 一个单独的dalvik 虚拟机\n\t- 单独的进程\n\n当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！\n\n### SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\n\n首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！\n\n这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。\n\n为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？\n\n那么这些服务是怎么开启起来的呢?\n\n在zygote 开启的时候，会调用 ZygoteInit.main初始化\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n关键代码：\n\tif (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t}\n\t~~~\n\t//开始fork我们的SystemServer进程\n\tif (startSystemServer) {\n\t       startSystemServer(abiList, socketName);\n\t}\n\n\n我们看下startSystemServer()做了些什么:\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n\n我们看下startSystemServer()做了些什么\n\t\n\t    /**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n\t     * Prepare the arguments and fork for the system server process.\n\t     */\n\t    private static boolean startSystemServer(String abiList, String socketName)\n\t            throws MethodAndArgsCaller, RuntimeException {\n\t\n\t         ...ignore some code...\n\t\n\t        //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n\t        /* Hardcoded command line to start the system server */\n\t        String args[] = {\n\t            \"--setuid=1000\",\n\t            \"--setgid=1000\",\n\t            \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007\",\n\t            \"--capabilities=\" + capabilities + \",\" + capabilities,\n\t            \"--runtime-init\",\n\t            \"--nice-name=system_server\",\n\t            \"com.android.server.SystemServer\",\n\t        };\n\t\n\t        int pid;\n\t        try {\n\t            parsedArgs = new ZygoteConnection.Arguments(args);\n\t            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n\t            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\t\n\t        //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n\t            /* Request to fork the system server process */\n\t            pid = Zygote.forkSystemServer(\n\t                    parsedArgs.uid, parsedArgs.gid,\n\t                    parsedArgs.gids,\n\t                    parsedArgs.debugFlags,\n\t                    null,\n\t                    parsedArgs.permittedCapabilities,\n\t                    parsedArgs.effectiveCapabilities);\n\t        } catch (IllegalArgumentException ex) {\n\t            throw new RuntimeException(ex);\n\t        }\n\t\n\t        /* For child process */\n\t        if (pid == 0) {\n\t            if (hasSecondZygote(abiList)) {\n\t                waitForSecondaryZygote(socketName);\n\t            }\n\t\n\t            handleSystemServerProcess(parsedArgs);\n\t        }\n\t\n\t        return true;\n\t    }\n\n### ActivityManagerService是什么？什么时候创建？作用?\n\nActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。\n\nAMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService \n\n\tpublic final class SystemServer {\n\t\n\t    //zygote的主入口\n\t    public static void main(String[] args) {\n\t        new SystemServer().run();\n\t    }\n\t\n\t    public SystemServer() {\n\t        // Check for factory test mode.\n\t        mFactoryTestMode = FactoryTest.getMode();\n\t    }\n\t\n\t    private void run() {\n\t\n\t        ...ignore some code...\n\t\n\t        //加载本地系统服务库，并进行初始化 \n\t        System.loadLibrary(\"android_servers\");\n\t        nativeInit();\n\t\n\t        // 创建系统上下文\n\t        createSystemContext();\n\t\n\t        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class<T>)，这个方法通过反射来启动对应的服务\n\t        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\t\n\t        //开启服务\n\t        try {\n\t            startBootstrapServices();\n\t            startCoreServices();\n\t            startOtherServices();\n\t        } catch (Throwable ex) {\n\t            Slog.e(\"System\", \"******************************************\");\n\t            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n\t            throw ex;\n\t        }\n\t\n\t        ...ignore some code...\n\t\n\t    }\n\t\n\t    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n\t    private void createSystemContext() {\n\t        ActivityThread activityThread = ActivityThread.systemMain();\n\t        mSystemContext = activityThread.getSystemContext();\n\t        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n\t    }\n\t\n\t    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n\t    private void startBootstrapServices() {\n\t\n\t        ...ignore some code...\n\t\n\t        //初始化ActivityManagerService\n\t        mActivityManagerService = mSystemServiceManager.startService(\n\t                ActivityManagerService.Lifecycle.class).getService();\n\t        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\t\n\t        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n\t        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\t\n\t        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n\t        mActivityManagerService.initPowerManagement();\n\t\n\t        // 初始化DisplayManagerService\n\t        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\t\n\t    //初始化PackageManagerService\n\t    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n\t       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\t\n\t    ...ignore some code...\n\t\n\t    }\n\t\n\t}\n\n经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。\n\n你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。\n\n其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开\n\n\tIntent intent = new Intent(Intent.ACTION_MAIN);  \n\tintent.addCategory(Intent.CATEGORY_LAUNCHER);              \n\tComponentName cn = new ComponentName(packageName, className);              \n\tintent.setComponent(cn);  \n\tstartActivity(intent); \n\n但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。\n\n知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？\n\nApp与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。\n\n那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。\n\n在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。\n\n这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。\n\n### Launche是什么？ 什么时候启动？\n\n当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？\n\nLauncher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。\n\n\npackages/apps/Launcher2/src/com/android/launcher2/Launcher.java\n\tpublic final class Launcher extends Activity\n\t        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,\n\t                   View.OnTouchListener {\n\t                   }\n\nLauncher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。\n\n![](DraggedImage.png)\n\n程序列表里面：\n![](DraggedImage-1.png)\n\n可以看到的是，调用的是：\n\tmLauncher.startActivitySafely(v, appInfo.intent, appInfo);\n\n和上面的一样，这叫什么？ 这叫殊途同归！\n\n所以现在我们明白了一件事：不管从哪里点击图标，调用的都是 \n\tLauncher.startActivitySafely()\n\n下面来看看 Launcher.startActivitySafely()到底做了什么事情\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n调用了startAcitivity(v,intent,tag)\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：\n\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n### Instrumentation是什么？和ActivityThread 是什么关系？\n每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()\n\n\tboolean startActivity(View v, Intent intent, Object tag) {\n\t\n\t        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t        try {\n\t            boolean useLaunchAnimation = (v != null) &&\n\t                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\t\n\t            if (useLaunchAnimation) {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent, opts.toBundle());\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(),\n\t                            opts.toBundle());\n\t                }\n\t            } else {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent);\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(), null);\n\t                }\n\t            }\n\t            return true;\n\t        } catch (SecurityException e) {\n\t        ...\n\t        }\n\t        return false;\n\t    }\n\n\n有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？\n\n是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！\n\n那你可能要问老板是who?\n老板当然是 大名鼎鼎的 ActivityThread了\n\nActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。\n\nASM说：『ActivityThread， 你给我暂停一个Activity！』\n\nActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』\n\n于是，Instrumentation 就去把事儿搞定了。\n所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。\n\n### 如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\n前面提到 调用 startActivity()的时候，时间调用了 \n\tmInstrumentation.execStartActivity()\n\n里面又调用了：\n\tActivityManagerNative.getDefault()\n\t                .startActivity\n\n这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。\n\nBinder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。\n\n为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：\n\nAMS， 和 AMP 都实现利率同一个接口： IActivityManager。\n\tclass ActivityManagerProxy implements IActivityManager{}\n\t\n\tpublic final class ActivityManagerService extends ActivityManagerNative{}\n\t\n\tpublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n\n虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。\n\n\n但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。\n\n但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如\n\tpublic int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n\t            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n\t        Parcel data = Parcel.obtain();\n\t        Parcel reply = Parcel.obtain();\n\t\n\t        ...ignore some code...\n\t\n\t        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n\t        reply.readException();\n\t        int result = reply.readInt();\n\t        reply.recycle();\n\t        data.recycle();\n\t        return result;\n\t    }\n\n上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。\n\n即：\n客户度：ActivityManagerProxy ====\\> Binder驱动 ====》ActivityManagerService：服务器\n\n而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。\n\n但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ \n\n还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。\n\n客户端：ApplicationThread \\<=== Binder驱动 \\<=== ApplicationThreadProxy：服务器\n\n他们也实现了相同的接口 IApplicationThread:\n\tprivate class ApplicationThread extends ApplicationThreadNative {}\n\t\n\t  public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\t\n\t  class ApplicationThreadProxy implements IApplicationThread {}\n\n\n### AMS 接收到 客户端的请求后，如果开启一个Activity？\n\nOK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？\n\n注：前方高能，方法调用链接很强！\n\n调用startActivity（）\n\t@Override\n\t    public final int startActivity(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) {\n\t        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n\t            resultWho, requestCode, startFlags, profilerInfo, options,\n\t            UserHandle.getCallingUserId());\n\t    }\n\n调用startActivityAsUser（）\n\t@Override\n\t    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n\t\n\t            ...ignore some code...\n\t\n\t        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n\t                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n\t                profilerInfo, null, null, options, userId, null, null);\n\t    }\n\n这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作\n\t final int startActivityMayWait(IApplicationThread caller, int callingUid,\n\t            String callingPackage, Intent intent, String resolvedType,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n\t            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,\n\t            Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t              int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n\t                    voiceSession, voiceInteractor, resultTo, resultWho,\n\t                    requestCode, callingPid, callingUid, callingPackage,\n\t                    realCallingPid, realCallingUid, startFlags, options,\n\t                    componentSpecified, null, container, inTask);\n\t\n\t            ...ignore some code...\n\t\n\t            }\n\n继续调用 startActivityLocked()\n\n\tfinal int startActivityLocked(IApplicationThread caller,\n\t            Intent intent, String resolvedType, ActivityInfo aInfo,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode,\n\t            int callingPid, int callingUid, String callingPackage,\n\t            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n\t            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n\t            TaskRecord inTask) {\n\t\n\t              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n\t              startFlags, true, options, inTask);\n\t        if (err < 0) {\n\t            notifyActivityDrawnForKeyguard();\n\t        }\n\t        return err;\n\t    }\n\n调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。\n\n终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)\n\nActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，\n\n\tfinal int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n\t            boolean doResume, Bundle options, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\t\n\t            ...ignore some code...\n\t\n\t             return ActivityManager.START_SUCCESS;\n\t            }\n\n调用 ActivityStack.startActivityLocked()\n\n\tfinal void startActivityLocked(ActivityRecord r, boolean newTask,\n\t            boolean doResume, boolean keepCurTransition, Bundle options) {\n\t\n\t        //ActivityRecord中存储的TaskRecord信息\n\t        TaskRecord rTask = r.task;\n\t\n\t         ...ignore some code...\n\t\n\t        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n\t     TaskRecord task = null;\n\t        if (!newTask) {\n\t            boolean startIt = true;\n\t            for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n\t                task = mTaskHistory.get(taskNdx);\n\t                if (task.getTopActivity() == null) {\n\t                    // task中的所有Activity都结束了\n\t                    continue;\n\t                }\n\t                if (task == r.task) {\n\t                    // 找到了\n\t                    if (!startIt) {\n\t                        task.addActivityToTop(r);\n\t                        r.putInHistory();\n\t                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n\t                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n\t                                (r.info.flags & ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n\t                                r.userId, r.info.configChanges, task.voiceSession != null,\n\t                                r.mLaunchTaskBehind);\n\t                        if (VALIDATE_TOKENS) {\n\t                            validateAppTokensLocked();\n\t                        }\n\t                        ActivityOptions.abort(options);\n\t                        return;\n\t                    }\n\t                    break;\n\t                } else if (task.numFullscreen > 0) {\n\t                    startIt = false;\n\t                }\n\t            }\n\t        }\n\t\n\t      ...ignore some code...\n\t\n\t        // Place a new activity at top of stack, so it is next to interact\n\t        // with the user.\n\t        task = r.task;\n\t        task.addActivityToTop(r);\n\t        task.setFrontOfTask();\n\t\n\t        ...ignore some code...\n\t\n\t         if (doResume) {\n\t            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n\t        }\n\t    }\n\n折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor \n\n淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。\n\n一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：\n\tboolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,\n\t            Bundle targetOptions) {\n\t        if (targetStack == null) {\n\t            targetStack = getFocusedStack();\n\t        }\n\t        // Do targetStack first.\n\t        boolean result = false;\n\t        if (isFrontStack(targetStack)) {\n\t            result = targetStack.resumeTopActivityLocked(target, targetOptions);\n\t        }\n\t\n\t          ...ignore some code...\n\t\n\t        return result;\n\t    }\n\n又回到 ActivityStack了。。。\n\nActivityStack.resumeTopActivityLocked()\n\tfinal boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {\n\t        if (inResumeTopActivity) {\n\t            // Don't even start recursing.\n\t            return false;\n\t        }\n\t\n\t        boolean result = false;\n\t        try {\n\t            // Protect against recursion.\n\t            inResumeTopActivity = true;\n\t            result = resumeTopActivityInnerLocked(prev, options);\n\t        } finally {\n\t            inResumeTopActivity = false;\n\t        }\n\t        return result;\n\t    }\n\n坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？\n\n\tfinal boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\t\n\t          ...ignore some code...\n\t      //找出还没结束的首个ActivityRecord\n\t     ActivityRecord next = topRunningActivityLocked(null);\n\t\n\t    //如果一个没结束的Activity都没有，就开启Launcher程序\n\t    if (next == null) {\n\t            ActivityOptions.abort(options);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: No more activities go home\");\n\t            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n\t            // Only resume home if on home display\n\t            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n\t                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n\t            return isOnHomeDisplay() &&\n\t                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n\t        }\n\t\n\t        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n\t          if (mResumedActivity != null) {\n\t            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: Pausing \" + mResumedActivity);\n\t        }\n\t\n\t  }\n\n\n在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。\n\tActivityManagerNative.getDefault().activityPaused(token).\n\n上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。\n\n最后 来一张高清五码的大图，方便记忆\n\n![](Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png)\n\n### 一个App的程序入口是什么？\n是ActivityThread.main()\n\n### 整个App的主线程的消息循环是在哪里创建的?\n是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。\n\n\tpublic static void main(String[] args) {\n\t\n\t          ...ignore some code...    \n\t\n\t      Looper.prepareMainLooper();\n\t\n\t        ActivityThread thread = new ActivityThread();\n\t        thread.attach(false);\n\t\n\t        if (sMainThreadHandler == null) {\n\t            sMainThreadHandler = thread.getHandler();\n\t        }\n\t\n\t        AsyncTask.init();\n\t\n\t        if (false) {\n\t            Looper.myLooper().setMessageLogging(new\n\t                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n\t        }\n\t\n\t        Looper.loop();\n\t\n\t          ...ignore some code...    \n\t\n\t }\n\nLooper.prepareMainLooper();\n准备完成后：\n\nLooper.loop()\n\n\n### Application 是在什么时候创建的？onCreate()什么时候调用的？\n也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。\n\n不相信，一起看看去!\n\n先看下ActivityThead.attach()\n\tprivate void attach(boolean system) {\n\t        sCurrentActivityThread = this;\n\t        mSystemThread = system;\n\t        //普通App进这里\n\t        if (!system) {\n\t\n\t            ...ignore some code...    \n\t\n\t            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n\t            final IActivityManager mgr = ActivityManagerNative.getDefault();\n\t            try {\n\t                mgr.attachApplication(mAppThread);\n\t            } catch (RemoteException ex) {\n\t                // Ignore\n\t            }\n\t           } else {\n\t             //这个分支在SystemServer加载的时候会进入，通过调用\n\t             // private void createSystemContext() {\n\t             //    ActivityThread activityThread = ActivityThread.systemMain()；\n\t             //} \n\t\n\t             // public static ActivityThread systemMain() {\n\t        //        if (!ActivityManager.isHighEndGfx()) {\n\t        //            HardwareRenderer.disable(true);\n\t        //        } else {\n\t        //            HardwareRenderer.enableForegroundTrimming();\n\t        //        }\n\t        //        ActivityThread thread = new ActivityThread();\n\t        //        thread.attach(true);\n\t        //        return thread;\n\t        //    }       \n\t           }\n\t    }\n\n这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法\n\n\t@Override\n\t    public final void attachApplication(IApplicationThread thread) {\n\t        synchronized (this) {\n\t            int callingPid = Binder.getCallingPid();\n\t            final long origId = Binder.clearCallingIdentity();\n\t            attachApplicationLocked(thread, callingPid);\n\t            Binder.restoreCallingIdentity(origId);\n\t        }\n\t    }\n\n然后：\n\n\tprivate final boolean attachApplicationLocked(IApplicationThread thread,\n\t            int pid) {\n\t\n\t\n\t             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n\t                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n\t                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n\t                    isRestrictedBackupMode || !normalMode, app.persistent,\n\t                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n\t                    mCoreSettingsObserver.getCoreSettingsLocked());\n\t\n\t\n\t            }\n\nthread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法\n\tpublic final void bindApplication(String processName, ApplicationInfo appInfo,\n\t                List<ProviderInfo> providers, ComponentName instrumentationName,\n\t                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\n\t                IInstrumentationWatcher instrumentationWatcher,\n\t                IUiAutomationConnection instrumentationUiConnection, int debugMode,\n\t                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,\n\t                Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,\n\t                Bundle coreSettings) {\n\t\n\t                 ...ignore some code...    \n\t\n\t             AppBindData data = new AppBindData();\n\t            data.processName = processName;\n\t            data.appInfo = appInfo;\n\t            data.providers = providers;\n\t            data.instrumentationName = instrumentationName;\n\t            data.instrumentationArgs = instrumentationArgs;\n\t            data.instrumentationWatcher = instrumentationWatcher;\n\t            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n\t            data.debugMode = debugMode;\n\t            data.enableOpenGlTrace = enableOpenGlTrace;\n\t            data.restrictedBackupMode = isRestrictedBackupMode;\n\t            data.persistent = persistent;\n\t            data.config = config;\n\t            data.compatInfo = compatInfo;\n\t            data.initProfilerInfo = profilerInfo;\n\t            sendMessage(H.BIND_APPLICATION, data);\n\t\n\t           }\n\t\n\t}\n\n\n其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理\n\tprivate class H extends Handler {\n\t\n\t      ...ignore some code... \n\t\n\t     public static final int BIND_APPLICATION        = 110;\n\t\n\t    ...ignore some code... \n\t\n\t     public void handleMessage(Message msg) {\n\t          switch (msg.what) {\n\t        ...ignore some code... \n\t         case BIND_APPLICATION:\n\t                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n\t                    AppBindData data = (AppBindData)msg.obj;\n\t                    handleBindApplication(data);\n\t                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\t                    break;\n\t        ...ignore some code... \n\t        }\n\t }\n\n最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。\n\n\tprivate void handleBindApplication(AppBindData data) {\n\t\n\t try {\n\t\n\t           ...ignore some code... \n\t\n\t            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n\t            mInitialApplication = app;\n\t\n\t           ...ignore some code... \n\t\n\t            try {\n\t                mInstrumentation.onCreate(data.instrumentationArgs);\n\t            }\n\t            catch (Exception e) {\n\t            }\n\t            try {\n\t                mInstrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {            }\n\t        } finally {\n\t            StrictMode.setThreadPolicy(savedPolicy);\n\t        }\n\t }\n\t\n\ndata.info 是一个LoadeApk 对象\n\nLoadeApk.data.info.makeApplication()\n\n\tpublic Application makeApplication(boolean forceDefaultAppClass,\n\t            Instrumentation instrumentation) {\n\t        if (mApplication != null) {\n\t            return mApplication;\n\t        }\n\t\n\t        Application app = null;\n\t\n\t        String appClass = mApplicationInfo.className;\n\t        if (forceDefaultAppClass || (appClass == null)) {\n\t            appClass = \"android.app.Application\";\n\t        }\n\t\n\t        try {\n\t            java.lang.ClassLoader cl = getClassLoader();\n\t            if (!mPackageName.equals(\"android\")) {\n\t                initializeJavaContextClassLoader();\n\t            }\n\t            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n\t            app = mActivityThread.mInstrumentation.newApplication(\n\t                    cl, appClass, appContext);\n\t            appContext.setOuterContext(app);\n\t        } catch (Exception e) {        }\n\t        mActivityThread.mAllApplications.add(app);\n\t        mApplication = app;\n\t\n\t    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n\t        if (instrumentation != null) {\n\t            try {\n\t                instrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {\n\t\n\t            }\n\t        }\n\t        ...ignore some code... \n\t\n\t       }\n\t\n\t        return app;\n\t    }\n\n最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！\n\n\tstatic public Application newApplication(Class<?> clazz, Context context)\n\t            throws InstantiationException, IllegalAccessException, \n\t            ClassNotFoundException {\n\t        Application app = (Application)clazz.newInstance();\n\t        app.attach(context);\n\t        return app;\n\t    }\n\n而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。\n\n参考文章\n\n下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。\n\nBinder:\n- [Android Bander设计与实现 - 设计篇](http://blog.csdn.net/universus/article/details/6211589)\n\nzygote\n•\t[Android系统进程Zygote启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6768304)\n•\t[Android 之 zygote 与进程创建](http://blog.csdn.net/xieqibao/article/details/6581975)\n•\t[Zygote浅谈](http://www.th7.cn/Program/Android/201404/187670.shtml)\nActivityThread、Instrumentation、AMS\n•\t[Android Activity.startActivity流程简介](http://blog.csdn.net/myarrow/article/details/14224273)\n•\t[Android应用程序进程启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6747696#comments)\n•\t[框架层理解Activity生命周期(APP启动过程)](http://laokaddk.blog.51cto.com/368606/1206840)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\n•\t[ActivityManagerService分析一：AMS的启动](http://www.xuebuyuan.com/2172927.html)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\nLauncher\n•\t[Android 4.0 Launcher源码分析系列(一)](http://mobile.51cto.com/hot-312129.htm)\n•\t[Android Launcher分析和修改9——Launcher启动APP流程](http://www.cnblogs.com/mythou/p/3187881.html)\n\n结束语：\n到了这里，我们回来看下开头的几个问题：\n- ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期\n- ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作\n- ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。\n- ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的\n- Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作\n- ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射\n- TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。\n\n如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"凯哥高质量文章系列","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ah90020xzexa9180w8r","content":"<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<h1 id=\"凯哥系列：\"><a href=\"#凯哥系列：\" class=\"headerlink\" title=\"凯哥系列：\"></a>凯哥系列：</h1><h2 id=\"1-Activity启动过程全解析\"><a href=\"#1-Activity启动过程全解析\" class=\"headerlink\" title=\"1. Activity启动过程全解析\"></a>1. <a href=\"http://www.devtf.cn/?p=1101\" target=\"_blank\" rel=\"external\">Activity启动过程全解析</a></h2><h2 id=\"2-framework-Activity界面显示全解析\"><a href=\"#2-framework-Activity界面显示全解析\" class=\"headerlink\" title=\"2. framework-Activity界面显示全解析\"></a>2. <a href=\"http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287\" target=\"_blank\" rel=\"external\">framework-Activity界面显示全解析</a></h2><p>注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念</p>\n<h3 id=\"看文章的记录：\"><a href=\"#看文章的记录：\" class=\"headerlink\" title=\"看文章的记录：\"></a>看文章的记录：</h3><p>1.App启动<br>2.App入口<br>3.Launcher?<br>4.AMS??<br>5.Binder是神马？怎么进行IPC通信？<br>6.Activity生命周期是被谁 什么时候调用的？</p>\n<h3 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h3><p>1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度<br>2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系</p>\n<p>3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合</p>\n<p>4.Activity相关的framework问题</p>\n<h3 id=\"主要对象功能介绍：\"><a href=\"#主要对象功能介绍：\" class=\"headerlink\" title=\"主要对象功能介绍：\"></a>主要对象功能介绍：</h3><p>1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；<br>2.ActivityThread:App的真正入口。打开App->main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；<br>3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。<br>4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。<br>5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。<br>6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。<br>7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。<br>8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。</p>\n<h3 id=\"主要流程介绍\"><a href=\"#主要流程介绍\" class=\"headerlink\" title=\"主要流程介绍\"></a>主要流程介绍</h3><ul>\n<li>zygote 是神马？<br>程序 Crash 的时候，打印红色的log通常带有这个<br>Android基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！</li>\n</ul>\n<p>Android 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程</p>\n<p>我们都知道，每一个App其实都是：</p>\n<ul>\n<li>一个单独的dalvik 虚拟机<ul>\n<li>单独的进程</li>\n</ul>\n</li>\n</ul>\n<p>当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！</p>\n<h3 id=\"SystemServer是什么？-作用？它与zygote有什么样的一重关系？\"><a href=\"#SystemServer是什么？-作用？它与zygote有什么样的一重关系？\" class=\"headerlink\" title=\"SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\"></a>SystemServer是什么？ 作用？它与zygote有什么样的一重关系？</h3><p>首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！</p>\n<p>这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。</p>\n<p>为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？</p>\n<p>那么这些服务是怎么开启起来的呢?</p>\n<p>在zygote 开启的时候，会调用 ZygoteInit.main初始化</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>关键代码：<br>    if (“start-system-server”.equals(argv[i])) {<br>                        startSystemServer = true;<br>    }<br>    ~~~<br>    //开始fork我们的SystemServer进程<br>    if (startSystemServer) {<br>           startSystemServer(abiList, socketName);<br>    }</p>\n<p>我们看下startSystemServer()做了些什么:</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>我们看下startSystemServer()做了些什么</p>\n<pre><code>/**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n * Prepare the arguments and fork for the system server process.\n */\nprivate static boolean startSystemServer(String abiList, String socketName)\n        throws MethodAndArgsCaller, RuntimeException {\n\n     ...ignore some code...\n\n    //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n    /* Hardcoded command line to start the system server */\n    String args[] = {\n        &quot;--setuid=1000&quot;,\n        &quot;--setgid=1000&quot;,\n        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,\n        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,\n        &quot;--runtime-init&quot;,\n        &quot;--nice-name=system_server&quot;,\n        &quot;com.android.server.SystemServer&quot;,\n    };\n\n    int pid;\n    try {\n        parsedArgs = new ZygoteConnection.Arguments(args);\n        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n    //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n        /* Request to fork the system server process */\n        pid = Zygote.forkSystemServer(\n                parsedArgs.uid, parsedArgs.gid,\n                parsedArgs.gids,\n                parsedArgs.debugFlags,\n                null,\n                parsedArgs.permittedCapabilities,\n                parsedArgs.effectiveCapabilities);\n    } catch (IllegalArgumentException ex) {\n        throw new RuntimeException(ex);\n    }\n\n    /* For child process */\n    if (pid == 0) {\n        if (hasSecondZygote(abiList)) {\n            waitForSecondaryZygote(socketName);\n        }\n\n        handleSystemServerProcess(parsedArgs);\n    }\n\n    return true;\n}\n</code></pre><h3 id=\"ActivityManagerService是什么？什么时候创建？作用\"><a href=\"#ActivityManagerService是什么？什么时候创建？作用\" class=\"headerlink\" title=\"ActivityManagerService是什么？什么时候创建？作用?\"></a>ActivityManagerService是什么？什么时候创建？作用?</h3><p>ActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。</p>\n<p>AMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService </p>\n<pre><code>public final class SystemServer {\n\n    //zygote的主入口\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n\n    public SystemServer() {\n        // Check for factory test mode.\n        mFactoryTestMode = FactoryTest.getMode();\n    }\n\n    private void run() {\n\n        ...ignore some code...\n\n        //加载本地系统服务库，并进行初始化 \n        System.loadLibrary(&quot;android_servers&quot;);\n        nativeInit();\n\n        // 创建系统上下文\n        createSystemContext();\n\n        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\n        //开启服务\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);\n            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);\n            throw ex;\n        }\n\n        ...ignore some code...\n\n    }\n\n    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n    private void createSystemContext() {\n        ActivityThread activityThread = ActivityThread.systemMain();\n        mSystemContext = activityThread.getSystemContext();\n        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n    }\n\n    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n    private void startBootstrapServices() {\n\n        ...ignore some code...\n\n        //初始化ActivityManagerService\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\n        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n        mActivityManagerService.initPowerManagement();\n\n        // 初始化DisplayManagerService\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n    //初始化PackageManagerService\n    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\n    ...ignore some code...\n\n    }\n\n}\n</code></pre><p>经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。</p>\n<p>你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。</p>\n<p>其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开</p>\n<pre><code>Intent intent = new Intent(Intent.ACTION_MAIN);  \nintent.addCategory(Intent.CATEGORY_LAUNCHER);              \nComponentName cn = new ComponentName(packageName, className);              \nintent.setComponent(cn);  \nstartActivity(intent); \n</code></pre><p>但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。</p>\n<p>知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？</p>\n<p>App与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。</p>\n<p>那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。</p>\n<p>在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。</p>\n<p>这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。</p>\n<h3 id=\"Launche是什么？-什么时候启动？\"><a href=\"#Launche是什么？-什么时候启动？\" class=\"headerlink\" title=\"Launche是什么？ 什么时候启动？\"></a>Launche是什么？ 什么时候启动？</h3><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？</p>\n<p>Launcher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。</p>\n<p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java<br>    public final class Launcher extends Activity<br>            implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,<br>                       View.OnTouchListener {<br>                       }</p>\n<p>Launcher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。</p>\n<p><img src=\"DraggedImage.png\" alt=\"\"></p>\n<p>程序列表里面：<br><img src=\"DraggedImage-1.png\" alt=\"\"></p>\n<p>可以看到的是，调用的是：<br>    mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</p>\n<p>和上面的一样，这叫什么？ 这叫殊途同归！</p>\n<p>所以现在我们明白了一件事：不管从哪里点击图标，调用的都是<br>    Launcher.startActivitySafely()</p>\n<p>下面来看看 Launcher.startActivitySafely()到底做了什么事情<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>调用了startAcitivity(v,intent,tag)<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：<br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>\n<h3 id=\"Instrumentation是什么？和ActivityThread-是什么关系？\"><a href=\"#Instrumentation是什么？和ActivityThread-是什么关系？\" class=\"headerlink\" title=\"Instrumentation是什么？和ActivityThread 是什么关系？\"></a>Instrumentation是什么？和ActivityThread 是什么关系？</h3><p>每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()</p>\n<pre><code>boolean startActivity(View v, Intent intent, Object tag) {\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        try {\n            boolean useLaunchAnimation = (v != null) &amp;&amp;\n                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\n            if (useLaunchAnimation) {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent, opts.toBundle());\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(),\n                            opts.toBundle());\n                }\n            } else {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent);\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(), null);\n                }\n            }\n            return true;\n        } catch (SecurityException e) {\n        ...\n        }\n        return false;\n    }\n</code></pre><p>有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？</p>\n<p>是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！</p>\n<p>那你可能要问老板是who?<br>老板当然是 大名鼎鼎的 ActivityThread了</p>\n<p>ActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。</p>\n<p>ASM说：『ActivityThread， 你给我暂停一个Activity！』</p>\n<p>ActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』</p>\n<p>于是，Instrumentation 就去把事儿搞定了。<br>所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。</p>\n<h3 id=\"如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\"><a href=\"#如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\" class=\"headerlink\" title=\"如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\"></a>如何理解 AMS 和 ActivityThread 之间的 Binder 通信？</h3><p>前面提到 调用 startActivity()的时候，时间调用了<br>    mInstrumentation.execStartActivity()</p>\n<p>里面又调用了：<br>    ActivityManagerNative.getDefault()<br>                    .startActivity</p>\n<p>这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。</p>\n<p>Binder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。</p>\n<p>为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：</p>\n<p>AMS， 和 AMP 都实现利率同一个接口： IActivityManager。<br>    class ActivityManagerProxy implements IActivityManager{}</p>\n<pre><code>public final class ActivityManagerService extends ActivityManagerNative{}\n\npublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n</code></pre><p>虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。</p>\n<p>但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。</p>\n<p>但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如<br>    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,<br>                String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {<br>            Parcel data = Parcel.obtain();<br>            Parcel reply = Parcel.obtain();</p>\n<pre><code>    ...ignore some code...\n\n    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n    reply.readException();\n    int result = reply.readInt();\n    reply.recycle();\n    data.recycle();\n    return result;\n}\n</code></pre><p>上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。</p>\n<p>即：<br>客户度：ActivityManagerProxy ====> Binder驱动 ====》ActivityManagerService：服务器</p>\n<p>而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。</p>\n<p>但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ </p>\n<p>还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。</p>\n<p>客户端：ApplicationThread \\&lt;=== Binder驱动 \\&lt;=== ApplicationThreadProxy：服务器</p>\n<p>他们也实现了相同的接口 IApplicationThread:<br>    private class ApplicationThread extends ApplicationThreadNative {}</p>\n<pre><code>public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\nclass ApplicationThreadProxy implements IApplicationThread {}\n</code></pre><h3 id=\"AMS-接收到-客户端的请求后，如果开启一个Activity？\"><a href=\"#AMS-接收到-客户端的请求后，如果开启一个Activity？\" class=\"headerlink\" title=\"AMS 接收到 客户端的请求后，如果开启一个Activity？\"></a>AMS 接收到 客户端的请求后，如果开启一个Activity？</h3><p>OK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？</p>\n<p>注：前方高能，方法调用链接很强！</p>\n<p>调用startActivity（）<br>    @Override<br>        public final int startActivity(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) {<br>            return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>                resultWho, requestCode, startFlags, profilerInfo, options,<br>                UserHandle.getCallingUserId());<br>        }</p>\n<p>调用startActivityAsUser（）<br>    @Override<br>        public final int startActivityAsUser(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {</p>\n<pre><code>        ...ignore some code...\n\n    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, options, userId, null, null);\n}\n</code></pre><p>这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作<br>     final int startActivityMayWait(IApplicationThread caller, int callingUid,<br>                String callingPackage, Intent intent, String resolvedType,<br>                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>                IBinder resultTo, String resultWho, int requestCode, int startFlags,<br>                ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,<br>                Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {</p>\n<pre><code>...ignore some code...\n\n  int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n        voiceSession, voiceInteractor, resultTo, resultWho,\n        requestCode, callingPid, callingUid, callingPackage,\n        realCallingPid, realCallingUid, startFlags, options,\n        componentSpecified, null, container, inTask);\n\n...ignore some code...\n\n}\n</code></pre><p>继续调用 startActivityLocked()</p>\n<pre><code>final int startActivityLocked(IApplicationThread caller,\n            Intent intent, String resolvedType, ActivityInfo aInfo,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n            IBinder resultTo, String resultWho, int requestCode,\n            int callingPid, int callingUid, String callingPackage,\n            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n            TaskRecord inTask) {\n\n              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n              startFlags, true, options, inTask);\n        if (err &lt; 0) {\n            notifyActivityDrawnForKeyguard();\n        }\n        return err;\n    }\n</code></pre><p>调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。</p>\n<p>终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)</p>\n<p>ActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，</p>\n<pre><code>final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n            boolean doResume, Bundle options, TaskRecord inTask) {\n\n            ...ignore some code...\n\n            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\n            ...ignore some code...\n\n             return ActivityManager.START_SUCCESS;\n            }\n</code></pre><p>调用 ActivityStack.startActivityLocked()</p>\n<pre><code>final void startActivityLocked(ActivityRecord r, boolean newTask,\n            boolean doResume, boolean keepCurTransition, Bundle options) {\n\n        //ActivityRecord中存储的TaskRecord信息\n        TaskRecord rTask = r.task;\n\n         ...ignore some code...\n\n        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n     TaskRecord task = null;\n        if (!newTask) {\n            boolean startIt = true;\n            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) {\n                task = mTaskHistory.get(taskNdx);\n                if (task.getTopActivity() == null) {\n                    // task中的所有Activity都结束了\n                    continue;\n                }\n                if (task == r.task) {\n                    // 找到了\n                    if (!startIt) {\n                        task.addActivityToTop(r);\n                        r.putInHistory();\n                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n                                r.userId, r.info.configChanges, task.voiceSession != null,\n                                r.mLaunchTaskBehind);\n                        if (VALIDATE_TOKENS) {\n                            validateAppTokensLocked();\n                        }\n                        ActivityOptions.abort(options);\n                        return;\n                    }\n                    break;\n                } else if (task.numFullscreen &gt; 0) {\n                    startIt = false;\n                }\n            }\n        }\n\n      ...ignore some code...\n\n        // Place a new activity at top of stack, so it is next to interact\n        // with the user.\n        task = r.task;\n        task.addActivityToTop(r);\n        task.setFrontOfTask();\n\n        ...ignore some code...\n\n         if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n    }\n</code></pre><p>折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor </p>\n<p>淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。</p>\n<p>一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：<br>    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,<br>                Bundle targetOptions) {<br>            if (targetStack == null) {<br>                targetStack = getFocusedStack();<br>            }<br>            // Do targetStack first.<br>            boolean result = false;<br>            if (isFrontStack(targetStack)) {<br>                result = targetStack.resumeTopActivityLocked(target, targetOptions);<br>            }</p>\n<pre><code>      ...ignore some code...\n\n    return result;\n}\n</code></pre><p>又回到 ActivityStack了。。。</p>\n<p>ActivityStack.resumeTopActivityLocked()<br>    final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {<br>            if (inResumeTopActivity) {<br>                // Don’t even start recursing.<br>                return false;<br>            }</p>\n<pre><code>    boolean result = false;\n    try {\n        // Protect against recursion.\n        inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        inResumeTopActivity = false;\n    }\n    return result;\n}\n</code></pre><p>坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？</p>\n<pre><code>final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\n          ...ignore some code...\n      //找出还没结束的首个ActivityRecord\n     ActivityRecord next = topRunningActivityLocked(null);\n\n    //如果一个没结束的Activity都没有，就开启Launcher程序\n    if (next == null) {\n            ActivityOptions.abort(options);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);\n            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n            // Only resume home if on home display\n            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n            return isOnHomeDisplay() &amp;&amp;\n                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n        }\n\n        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n          if (mResumedActivity != null) {\n            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);\n        }\n\n  }\n</code></pre><p>在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。<br>    ActivityManagerNative.getDefault().activityPaused(token).</p>\n<p>上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。</p>\n<p>最后 来一张高清五码的大图，方便记忆</p>\n<p><img src=\"Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png\" alt=\"\"></p>\n<h3 id=\"一个App的程序入口是什么？\"><a href=\"#一个App的程序入口是什么？\" class=\"headerlink\" title=\"一个App的程序入口是什么？\"></a>一个App的程序入口是什么？</h3><p>是ActivityThread.main()</p>\n<h3 id=\"整个App的主线程的消息循环是在哪里创建的\"><a href=\"#整个App的主线程的消息循环是在哪里创建的\" class=\"headerlink\" title=\"整个App的主线程的消息循环是在哪里创建的?\"></a>整个App的主线程的消息循环是在哪里创建的?</h3><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。</p>\n<pre><code>public static void main(String[] args) {\n\n          ...ignore some code...    \n\n      Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n        }\n\n        Looper.loop();\n\n          ...ignore some code...    \n\n }\n</code></pre><p>Looper.prepareMainLooper();<br>准备完成后：</p>\n<p>Looper.loop()</p>\n<h3 id=\"Application-是在什么时候创建的？onCreate-什么时候调用的？\"><a href=\"#Application-是在什么时候创建的？onCreate-什么时候调用的？\" class=\"headerlink\" title=\"Application 是在什么时候创建的？onCreate()什么时候调用的？\"></a>Application 是在什么时候创建的？onCreate()什么时候调用的？</h3><p>也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。</p>\n<p>不相信，一起看看去!</p>\n<p>先看下ActivityThead.attach()<br>    private void attach(boolean system) {<br>            sCurrentActivityThread = this;<br>            mSystemThread = system;<br>            //普通App进这里<br>            if (!system) {</p>\n<pre><code>        ...ignore some code...    \n\n        RuntimeInit.setApplicationObject(mAppThread.asBinder());\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            // Ignore\n        }\n       } else {\n         //这个分支在SystemServer加载的时候会进入，通过调用\n         // private void createSystemContext() {\n         //    ActivityThread activityThread = ActivityThread.systemMain()；\n         //} \n\n         // public static ActivityThread systemMain() {\n    //        if (!ActivityManager.isHighEndGfx()) {\n    //            HardwareRenderer.disable(true);\n    //        } else {\n    //            HardwareRenderer.enableForegroundTrimming();\n    //        }\n    //        ActivityThread thread = new ActivityThread();\n    //        thread.attach(true);\n    //        return thread;\n    //    }       \n       }\n}\n</code></pre><p>这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法</p>\n<pre><code>@Override\n    public final void attachApplication(IApplicationThread thread) {\n        synchronized (this) {\n            int callingPid = Binder.getCallingPid();\n            final long origId = Binder.clearCallingIdentity();\n            attachApplicationLocked(thread, callingPid);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n</code></pre><p>然后：</p>\n<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,\n            int pid) {\n\n\n             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                    isRestrictedBackupMode || !normalMode, app.persistent,\n                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n                    mCoreSettingsObserver.getCoreSettingsLocked());\n\n\n            }\n</code></pre><p>thread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法<br>    public final void bindApplication(String processName, ApplicationInfo appInfo,<br>                    List<providerinfo> providers, ComponentName instrumentationName,<br>                    ProfilerInfo profilerInfo, Bundle instrumentationArgs,<br>                    IInstrumentationWatcher instrumentationWatcher,<br>                    IUiAutomationConnection instrumentationUiConnection, int debugMode,<br>                    boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,<br>                    Configuration config, CompatibilityInfo compatInfo, Map<string, ibinder=\"\"> services,<br>                    Bundle coreSettings) {</string,></providerinfo></p>\n<pre><code>                 ...ignore some code...    \n\n             AppBindData data = new AppBindData();\n            data.processName = processName;\n            data.appInfo = appInfo;\n            data.providers = providers;\n            data.instrumentationName = instrumentationName;\n            data.instrumentationArgs = instrumentationArgs;\n            data.instrumentationWatcher = instrumentationWatcher;\n            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n            data.debugMode = debugMode;\n            data.enableOpenGlTrace = enableOpenGlTrace;\n            data.restrictedBackupMode = isRestrictedBackupMode;\n            data.persistent = persistent;\n            data.config = config;\n            data.compatInfo = compatInfo;\n            data.initProfilerInfo = profilerInfo;\n            sendMessage(H.BIND_APPLICATION, data);\n\n           }\n\n}\n</code></pre><p>其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理<br>    private class H extends Handler {</p>\n<pre><code>     ...ignore some code... \n\n    public static final int BIND_APPLICATION        = 110;\n\n   ...ignore some code... \n\n    public void handleMessage(Message msg) {\n         switch (msg.what) {\n       ...ignore some code... \n        case BIND_APPLICATION:\n                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);\n                   AppBindData data = (AppBindData)msg.obj;\n                   handleBindApplication(data);\n                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                   break;\n       ...ignore some code... \n       }\n}\n</code></pre><p>最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。</p>\n<pre><code>private void handleBindApplication(AppBindData data) {\n\n try {\n\n           ...ignore some code... \n\n            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n            mInitialApplication = app;\n\n           ...ignore some code... \n\n            try {\n                mInstrumentation.onCreate(data.instrumentationArgs);\n            }\n            catch (Exception e) {\n            }\n            try {\n                mInstrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {            }\n        } finally {\n            StrictMode.setThreadPolicy(savedPolicy);\n        }\n }\n</code></pre><p>data.info 是一个LoadeApk 对象</p>\n<p>LoadeApk.data.info.makeApplication()</p>\n<pre><code>public Application makeApplication(boolean forceDefaultAppClass,\n            Instrumentation instrumentation) {\n        if (mApplication != null) {\n            return mApplication;\n        }\n\n        Application app = null;\n\n        String appClass = mApplicationInfo.className;\n        if (forceDefaultAppClass || (appClass == null)) {\n            appClass = &quot;android.app.Application&quot;;\n        }\n\n        try {\n            java.lang.ClassLoader cl = getClassLoader();\n            if (!mPackageName.equals(&quot;android&quot;)) {\n                initializeJavaContextClassLoader();\n            }\n            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n            app = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n            appContext.setOuterContext(app);\n        } catch (Exception e) {        }\n        mActivityThread.mAllApplications.add(app);\n        mApplication = app;\n\n    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n        if (instrumentation != null) {\n            try {\n                instrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {\n\n            }\n        }\n        ...ignore some code... \n\n       }\n\n        return app;\n    }\n</code></pre><p>最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！</p>\n<pre><code>static public Application newApplication(Class&lt;?&gt; clazz, Context context)\n            throws InstantiationException, IllegalAccessException, \n            ClassNotFoundException {\n        Application app = (Application)clazz.newInstance();\n        app.attach(context);\n        return app;\n    }\n</code></pre><p>而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。</p>\n<p>参考文章</p>\n<p>下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。</p>\n<p>Binder:</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/universus/article/details/6211589\" target=\"_blank\" rel=\"external\">Android Bander设计与实现 - 设计篇</a></li>\n</ul>\n<p>zygote<br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6768304\" target=\"_blank\" rel=\"external\">Android系统进程Zygote启动过程的源代码分析</a><br>•    <a href=\"http://blog.csdn.net/xieqibao/article/details/6581975\" target=\"_blank\" rel=\"external\">Android 之 zygote 与进程创建</a><br>•    <a href=\"http://www.th7.cn/Program/Android/201404/187670.shtml\" target=\"_blank\" rel=\"external\">Zygote浅谈</a><br>ActivityThread、Instrumentation、AMS<br>•    <a href=\"http://blog.csdn.net/myarrow/article/details/14224273\" target=\"_blank\" rel=\"external\">Android Activity.startActivity流程简介</a><br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6747696#comments\" target=\"_blank\" rel=\"external\">Android应用程序进程启动过程的源代码分析</a><br>•    <a href=\"http://laokaddk.blog.51cto.com/368606/1206840\" target=\"_blank\" rel=\"external\">框架层理解Activity生命周期(APP启动过程)</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\" target=\"_blank\" rel=\"external\">Android应用程序窗口设计框架介绍</a><br>•    <a href=\"http://www.xuebuyuan.com/2172927.html\" target=\"_blank\" rel=\"external\">ActivityManagerService分析一：AMS的启动</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\" target=\"_blank\" rel=\"external\">Android应用程序窗口设计框架介绍</a><br>Launcher<br>•    <a href=\"http://mobile.51cto.com/hot-312129.htm\" target=\"_blank\" rel=\"external\">Android 4.0 Launcher源码分析系列(一)</a><br>•    <a href=\"http://www.cnblogs.com/mythou/p/3187881.html\" target=\"_blank\" rel=\"external\">Android Launcher分析和修改9——Launcher启动APP流程</a></p>\n<p>结束语：<br>到了这里，我们回来看下开头的几个问题：</p>\n<ul>\n<li>ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>\n<li>ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作</li>\n<li>ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。</li>\n<li>ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的</li>\n<li>Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作</li>\n<li>ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射</li>\n<li>TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。</li>\n</ul>\n<p>如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 </p>\n","excerpt":"","more":"<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<h1 id=\"凯哥系列：\"><a href=\"#凯哥系列：\" class=\"headerlink\" title=\"凯哥系列：\"></a>凯哥系列：</h1><h2 id=\"1-Activity启动过程全解析\"><a href=\"#1-Activity启动过程全解析\" class=\"headerlink\" title=\"1. Activity启动过程全解析\"></a>1. <a href=\"http://www.devtf.cn/?p=1101\">Activity启动过程全解析</a></h2><h2 id=\"2-framework-Activity界面显示全解析\"><a href=\"#2-framework-Activity界面显示全解析\" class=\"headerlink\" title=\"2. framework-Activity界面显示全解析\"></a>2. <a href=\"http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287\">framework-Activity界面显示全解析</a></h2><p>注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念</p>\n<h3 id=\"看文章的记录：\"><a href=\"#看文章的记录：\" class=\"headerlink\" title=\"看文章的记录：\"></a>看文章的记录：</h3><p>1.App启动<br>2.App入口<br>3.Launcher?<br>4.AMS??<br>5.Binder是神马？怎么进行IPC通信？<br>6.Activity生命周期是被谁 什么时候调用的？</p>\n<h3 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h3><p>1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度<br>2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系</p>\n<p>3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合</p>\n<p>4.Activity相关的framework问题</p>\n<h3 id=\"主要对象功能介绍：\"><a href=\"#主要对象功能介绍：\" class=\"headerlink\" title=\"主要对象功能介绍：\"></a>主要对象功能介绍：</h3><p>1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；<br>2.ActivityThread:App的真正入口。打开App->main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；<br>3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。<br>4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。<br>5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。<br>6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。<br>7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。<br>8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。</p>\n<h3 id=\"主要流程介绍\"><a href=\"#主要流程介绍\" class=\"headerlink\" title=\"主要流程介绍\"></a>主要流程介绍</h3><ul>\n<li>zygote 是神马？<br>程序 Crash 的时候，打印红色的log通常带有这个<br>Android基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！</li>\n</ul>\n<p>Android 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程</p>\n<p>我们都知道，每一个App其实都是：</p>\n<ul>\n<li>一个单独的dalvik 虚拟机<ul>\n<li>单独的进程</li>\n</ul>\n</li>\n</ul>\n<p>当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！</p>\n<h3 id=\"SystemServer是什么？-作用？它与zygote有什么样的一重关系？\"><a href=\"#SystemServer是什么？-作用？它与zygote有什么样的一重关系？\" class=\"headerlink\" title=\"SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\"></a>SystemServer是什么？ 作用？它与zygote有什么样的一重关系？</h3><p>首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！</p>\n<p>这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。</p>\n<p>为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？</p>\n<p>那么这些服务是怎么开启起来的呢?</p>\n<p>在zygote 开启的时候，会调用 ZygoteInit.main初始化</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>关键代码：<br>    if (“start-system-server”.equals(argv[i])) {<br>                        startSystemServer = true;<br>    }<br>    ~~~<br>    //开始fork我们的SystemServer进程<br>    if (startSystemServer) {<br>           startSystemServer(abiList, socketName);<br>    }</p>\n<p>我们看下startSystemServer()做了些什么:</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>我们看下startSystemServer()做了些什么</p>\n<pre><code>/**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n * Prepare the arguments and fork for the system server process.\n */\nprivate static boolean startSystemServer(String abiList, String socketName)\n        throws MethodAndArgsCaller, RuntimeException {\n\n     ...ignore some code...\n\n    //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n    /* Hardcoded command line to start the system server */\n    String args[] = {\n        &quot;--setuid=1000&quot;,\n        &quot;--setgid=1000&quot;,\n        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,\n        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,\n        &quot;--runtime-init&quot;,\n        &quot;--nice-name=system_server&quot;,\n        &quot;com.android.server.SystemServer&quot;,\n    };\n\n    int pid;\n    try {\n        parsedArgs = new ZygoteConnection.Arguments(args);\n        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n    //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n        /* Request to fork the system server process */\n        pid = Zygote.forkSystemServer(\n                parsedArgs.uid, parsedArgs.gid,\n                parsedArgs.gids,\n                parsedArgs.debugFlags,\n                null,\n                parsedArgs.permittedCapabilities,\n                parsedArgs.effectiveCapabilities);\n    } catch (IllegalArgumentException ex) {\n        throw new RuntimeException(ex);\n    }\n\n    /* For child process */\n    if (pid == 0) {\n        if (hasSecondZygote(abiList)) {\n            waitForSecondaryZygote(socketName);\n        }\n\n        handleSystemServerProcess(parsedArgs);\n    }\n\n    return true;\n}\n</code></pre><h3 id=\"ActivityManagerService是什么？什么时候创建？作用\"><a href=\"#ActivityManagerService是什么？什么时候创建？作用\" class=\"headerlink\" title=\"ActivityManagerService是什么？什么时候创建？作用?\"></a>ActivityManagerService是什么？什么时候创建？作用?</h3><p>ActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。</p>\n<p>AMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService </p>\n<pre><code>public final class SystemServer {\n\n    //zygote的主入口\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n\n    public SystemServer() {\n        // Check for factory test mode.\n        mFactoryTestMode = FactoryTest.getMode();\n    }\n\n    private void run() {\n\n        ...ignore some code...\n\n        //加载本地系统服务库，并进行初始化 \n        System.loadLibrary(&quot;android_servers&quot;);\n        nativeInit();\n\n        // 创建系统上下文\n        createSystemContext();\n\n        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\n        //开启服务\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);\n            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);\n            throw ex;\n        }\n\n        ...ignore some code...\n\n    }\n\n    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n    private void createSystemContext() {\n        ActivityThread activityThread = ActivityThread.systemMain();\n        mSystemContext = activityThread.getSystemContext();\n        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n    }\n\n    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n    private void startBootstrapServices() {\n\n        ...ignore some code...\n\n        //初始化ActivityManagerService\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\n        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n        mActivityManagerService.initPowerManagement();\n\n        // 初始化DisplayManagerService\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n    //初始化PackageManagerService\n    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\n    ...ignore some code...\n\n    }\n\n}\n</code></pre><p>经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。</p>\n<p>你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。</p>\n<p>其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开</p>\n<pre><code>Intent intent = new Intent(Intent.ACTION_MAIN);  \nintent.addCategory(Intent.CATEGORY_LAUNCHER);              \nComponentName cn = new ComponentName(packageName, className);              \nintent.setComponent(cn);  \nstartActivity(intent); \n</code></pre><p>但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。</p>\n<p>知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？</p>\n<p>App与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。</p>\n<p>那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。</p>\n<p>在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。</p>\n<p>这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。</p>\n<h3 id=\"Launche是什么？-什么时候启动？\"><a href=\"#Launche是什么？-什么时候启动？\" class=\"headerlink\" title=\"Launche是什么？ 什么时候启动？\"></a>Launche是什么？ 什么时候启动？</h3><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？</p>\n<p>Launcher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。</p>\n<p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java<br>    public final class Launcher extends Activity<br>            implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,<br>                       View.OnTouchListener {<br>                       }</p>\n<p>Launcher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。</p>\n<p><img src=\"DraggedImage.png\" alt=\"\"></p>\n<p>程序列表里面：<br><img src=\"DraggedImage-1.png\" alt=\"\"></p>\n<p>可以看到的是，调用的是：<br>    mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</p>\n<p>和上面的一样，这叫什么？ 这叫殊途同归！</p>\n<p>所以现在我们明白了一件事：不管从哪里点击图标，调用的都是<br>    Launcher.startActivitySafely()</p>\n<p>下面来看看 Launcher.startActivitySafely()到底做了什么事情<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>调用了startAcitivity(v,intent,tag)<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：<br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>\n<h3 id=\"Instrumentation是什么？和ActivityThread-是什么关系？\"><a href=\"#Instrumentation是什么？和ActivityThread-是什么关系？\" class=\"headerlink\" title=\"Instrumentation是什么？和ActivityThread 是什么关系？\"></a>Instrumentation是什么？和ActivityThread 是什么关系？</h3><p>每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()</p>\n<pre><code>boolean startActivity(View v, Intent intent, Object tag) {\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        try {\n            boolean useLaunchAnimation = (v != null) &amp;&amp;\n                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\n            if (useLaunchAnimation) {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent, opts.toBundle());\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(),\n                            opts.toBundle());\n                }\n            } else {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent);\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(), null);\n                }\n            }\n            return true;\n        } catch (SecurityException e) {\n        ...\n        }\n        return false;\n    }\n</code></pre><p>有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？</p>\n<p>是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！</p>\n<p>那你可能要问老板是who?<br>老板当然是 大名鼎鼎的 ActivityThread了</p>\n<p>ActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。</p>\n<p>ASM说：『ActivityThread， 你给我暂停一个Activity！』</p>\n<p>ActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』</p>\n<p>于是，Instrumentation 就去把事儿搞定了。<br>所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。</p>\n<h3 id=\"如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\"><a href=\"#如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\" class=\"headerlink\" title=\"如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\"></a>如何理解 AMS 和 ActivityThread 之间的 Binder 通信？</h3><p>前面提到 调用 startActivity()的时候，时间调用了<br>    mInstrumentation.execStartActivity()</p>\n<p>里面又调用了：<br>    ActivityManagerNative.getDefault()<br>                    .startActivity</p>\n<p>这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。</p>\n<p>Binder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。</p>\n<p>为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：</p>\n<p>AMS， 和 AMP 都实现利率同一个接口： IActivityManager。<br>    class ActivityManagerProxy implements IActivityManager{}</p>\n<pre><code>public final class ActivityManagerService extends ActivityManagerNative{}\n\npublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n</code></pre><p>虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。</p>\n<p>但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。</p>\n<p>但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如<br>    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,<br>                String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {<br>            Parcel data = Parcel.obtain();<br>            Parcel reply = Parcel.obtain();</p>\n<pre><code>    ...ignore some code...\n\n    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n    reply.readException();\n    int result = reply.readInt();\n    reply.recycle();\n    data.recycle();\n    return result;\n}\n</code></pre><p>上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。</p>\n<p>即：<br>客户度：ActivityManagerProxy ====> Binder驱动 ====》ActivityManagerService：服务器</p>\n<p>而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。</p>\n<p>但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ </p>\n<p>还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。</p>\n<p>客户端：ApplicationThread \\&lt;=== Binder驱动 \\&lt;=== ApplicationThreadProxy：服务器</p>\n<p>他们也实现了相同的接口 IApplicationThread:<br>    private class ApplicationThread extends ApplicationThreadNative {}</p>\n<pre><code>public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\nclass ApplicationThreadProxy implements IApplicationThread {}\n</code></pre><h3 id=\"AMS-接收到-客户端的请求后，如果开启一个Activity？\"><a href=\"#AMS-接收到-客户端的请求后，如果开启一个Activity？\" class=\"headerlink\" title=\"AMS 接收到 客户端的请求后，如果开启一个Activity？\"></a>AMS 接收到 客户端的请求后，如果开启一个Activity？</h3><p>OK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？</p>\n<p>注：前方高能，方法调用链接很强！</p>\n<p>调用startActivity（）<br>    @Override<br>        public final int startActivity(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) {<br>            return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>                resultWho, requestCode, startFlags, profilerInfo, options,<br>                UserHandle.getCallingUserId());<br>        }</p>\n<p>调用startActivityAsUser（）<br>    @Override<br>        public final int startActivityAsUser(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {</p>\n<pre><code>        ...ignore some code...\n\n    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, options, userId, null, null);\n}\n</code></pre><p>这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作<br>     final int startActivityMayWait(IApplicationThread caller, int callingUid,<br>                String callingPackage, Intent intent, String resolvedType,<br>                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>                IBinder resultTo, String resultWho, int requestCode, int startFlags,<br>                ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,<br>                Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {</p>\n<pre><code>...ignore some code...\n\n  int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n        voiceSession, voiceInteractor, resultTo, resultWho,\n        requestCode, callingPid, callingUid, callingPackage,\n        realCallingPid, realCallingUid, startFlags, options,\n        componentSpecified, null, container, inTask);\n\n...ignore some code...\n\n}\n</code></pre><p>继续调用 startActivityLocked()</p>\n<pre><code>final int startActivityLocked(IApplicationThread caller,\n            Intent intent, String resolvedType, ActivityInfo aInfo,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n            IBinder resultTo, String resultWho, int requestCode,\n            int callingPid, int callingUid, String callingPackage,\n            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n            TaskRecord inTask) {\n\n              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n              startFlags, true, options, inTask);\n        if (err &lt; 0) {\n            notifyActivityDrawnForKeyguard();\n        }\n        return err;\n    }\n</code></pre><p>调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。</p>\n<p>终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)</p>\n<p>ActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，</p>\n<pre><code>final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n            boolean doResume, Bundle options, TaskRecord inTask) {\n\n            ...ignore some code...\n\n            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\n            ...ignore some code...\n\n             return ActivityManager.START_SUCCESS;\n            }\n</code></pre><p>调用 ActivityStack.startActivityLocked()</p>\n<pre><code>final void startActivityLocked(ActivityRecord r, boolean newTask,\n            boolean doResume, boolean keepCurTransition, Bundle options) {\n\n        //ActivityRecord中存储的TaskRecord信息\n        TaskRecord rTask = r.task;\n\n         ...ignore some code...\n\n        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n     TaskRecord task = null;\n        if (!newTask) {\n            boolean startIt = true;\n            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) {\n                task = mTaskHistory.get(taskNdx);\n                if (task.getTopActivity() == null) {\n                    // task中的所有Activity都结束了\n                    continue;\n                }\n                if (task == r.task) {\n                    // 找到了\n                    if (!startIt) {\n                        task.addActivityToTop(r);\n                        r.putInHistory();\n                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n                                r.userId, r.info.configChanges, task.voiceSession != null,\n                                r.mLaunchTaskBehind);\n                        if (VALIDATE_TOKENS) {\n                            validateAppTokensLocked();\n                        }\n                        ActivityOptions.abort(options);\n                        return;\n                    }\n                    break;\n                } else if (task.numFullscreen &gt; 0) {\n                    startIt = false;\n                }\n            }\n        }\n\n      ...ignore some code...\n\n        // Place a new activity at top of stack, so it is next to interact\n        // with the user.\n        task = r.task;\n        task.addActivityToTop(r);\n        task.setFrontOfTask();\n\n        ...ignore some code...\n\n         if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n    }\n</code></pre><p>折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor </p>\n<p>淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。</p>\n<p>一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：<br>    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,<br>                Bundle targetOptions) {<br>            if (targetStack == null) {<br>                targetStack = getFocusedStack();<br>            }<br>            // Do targetStack first.<br>            boolean result = false;<br>            if (isFrontStack(targetStack)) {<br>                result = targetStack.resumeTopActivityLocked(target, targetOptions);<br>            }</p>\n<pre><code>      ...ignore some code...\n\n    return result;\n}\n</code></pre><p>又回到 ActivityStack了。。。</p>\n<p>ActivityStack.resumeTopActivityLocked()<br>    final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {<br>            if (inResumeTopActivity) {<br>                // Don’t even start recursing.<br>                return false;<br>            }</p>\n<pre><code>    boolean result = false;\n    try {\n        // Protect against recursion.\n        inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        inResumeTopActivity = false;\n    }\n    return result;\n}\n</code></pre><p>坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？</p>\n<pre><code>final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\n          ...ignore some code...\n      //找出还没结束的首个ActivityRecord\n     ActivityRecord next = topRunningActivityLocked(null);\n\n    //如果一个没结束的Activity都没有，就开启Launcher程序\n    if (next == null) {\n            ActivityOptions.abort(options);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);\n            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n            // Only resume home if on home display\n            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n            return isOnHomeDisplay() &amp;&amp;\n                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n        }\n\n        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n          if (mResumedActivity != null) {\n            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);\n        }\n\n  }\n</code></pre><p>在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。<br>    ActivityManagerNative.getDefault().activityPaused(token).</p>\n<p>上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。</p>\n<p>最后 来一张高清五码的大图，方便记忆</p>\n<p><img src=\"Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png\" alt=\"\"></p>\n<h3 id=\"一个App的程序入口是什么？\"><a href=\"#一个App的程序入口是什么？\" class=\"headerlink\" title=\"一个App的程序入口是什么？\"></a>一个App的程序入口是什么？</h3><p>是ActivityThread.main()</p>\n<h3 id=\"整个App的主线程的消息循环是在哪里创建的\"><a href=\"#整个App的主线程的消息循环是在哪里创建的\" class=\"headerlink\" title=\"整个App的主线程的消息循环是在哪里创建的?\"></a>整个App的主线程的消息循环是在哪里创建的?</h3><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。</p>\n<pre><code>public static void main(String[] args) {\n\n          ...ignore some code...    \n\n      Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n        }\n\n        Looper.loop();\n\n          ...ignore some code...    \n\n }\n</code></pre><p>Looper.prepareMainLooper();<br>准备完成后：</p>\n<p>Looper.loop()</p>\n<h3 id=\"Application-是在什么时候创建的？onCreate-什么时候调用的？\"><a href=\"#Application-是在什么时候创建的？onCreate-什么时候调用的？\" class=\"headerlink\" title=\"Application 是在什么时候创建的？onCreate()什么时候调用的？\"></a>Application 是在什么时候创建的？onCreate()什么时候调用的？</h3><p>也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。</p>\n<p>不相信，一起看看去!</p>\n<p>先看下ActivityThead.attach()<br>    private void attach(boolean system) {<br>            sCurrentActivityThread = this;<br>            mSystemThread = system;<br>            //普通App进这里<br>            if (!system) {</p>\n<pre><code>        ...ignore some code...    \n\n        RuntimeInit.setApplicationObject(mAppThread.asBinder());\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            // Ignore\n        }\n       } else {\n         //这个分支在SystemServer加载的时候会进入，通过调用\n         // private void createSystemContext() {\n         //    ActivityThread activityThread = ActivityThread.systemMain()；\n         //} \n\n         // public static ActivityThread systemMain() {\n    //        if (!ActivityManager.isHighEndGfx()) {\n    //            HardwareRenderer.disable(true);\n    //        } else {\n    //            HardwareRenderer.enableForegroundTrimming();\n    //        }\n    //        ActivityThread thread = new ActivityThread();\n    //        thread.attach(true);\n    //        return thread;\n    //    }       \n       }\n}\n</code></pre><p>这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法</p>\n<pre><code>@Override\n    public final void attachApplication(IApplicationThread thread) {\n        synchronized (this) {\n            int callingPid = Binder.getCallingPid();\n            final long origId = Binder.clearCallingIdentity();\n            attachApplicationLocked(thread, callingPid);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n</code></pre><p>然后：</p>\n<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,\n            int pid) {\n\n\n             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                    isRestrictedBackupMode || !normalMode, app.persistent,\n                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n                    mCoreSettingsObserver.getCoreSettingsLocked());\n\n\n            }\n</code></pre><p>thread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法<br>    public final void bindApplication(String processName, ApplicationInfo appInfo,<br>                    List<ProviderInfo> providers, ComponentName instrumentationName,<br>                    ProfilerInfo profilerInfo, Bundle instrumentationArgs,<br>                    IInstrumentationWatcher instrumentationWatcher,<br>                    IUiAutomationConnection instrumentationUiConnection, int debugMode,<br>                    boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,<br>                    Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,<br>                    Bundle coreSettings) {</p>\n<pre><code>                 ...ignore some code...    \n\n             AppBindData data = new AppBindData();\n            data.processName = processName;\n            data.appInfo = appInfo;\n            data.providers = providers;\n            data.instrumentationName = instrumentationName;\n            data.instrumentationArgs = instrumentationArgs;\n            data.instrumentationWatcher = instrumentationWatcher;\n            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n            data.debugMode = debugMode;\n            data.enableOpenGlTrace = enableOpenGlTrace;\n            data.restrictedBackupMode = isRestrictedBackupMode;\n            data.persistent = persistent;\n            data.config = config;\n            data.compatInfo = compatInfo;\n            data.initProfilerInfo = profilerInfo;\n            sendMessage(H.BIND_APPLICATION, data);\n\n           }\n\n}\n</code></pre><p>其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理<br>    private class H extends Handler {</p>\n<pre><code>     ...ignore some code... \n\n    public static final int BIND_APPLICATION        = 110;\n\n   ...ignore some code... \n\n    public void handleMessage(Message msg) {\n         switch (msg.what) {\n       ...ignore some code... \n        case BIND_APPLICATION:\n                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);\n                   AppBindData data = (AppBindData)msg.obj;\n                   handleBindApplication(data);\n                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                   break;\n       ...ignore some code... \n       }\n}\n</code></pre><p>最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。</p>\n<pre><code>private void handleBindApplication(AppBindData data) {\n\n try {\n\n           ...ignore some code... \n\n            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n            mInitialApplication = app;\n\n           ...ignore some code... \n\n            try {\n                mInstrumentation.onCreate(data.instrumentationArgs);\n            }\n            catch (Exception e) {\n            }\n            try {\n                mInstrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {            }\n        } finally {\n            StrictMode.setThreadPolicy(savedPolicy);\n        }\n }\n</code></pre><p>data.info 是一个LoadeApk 对象</p>\n<p>LoadeApk.data.info.makeApplication()</p>\n<pre><code>public Application makeApplication(boolean forceDefaultAppClass,\n            Instrumentation instrumentation) {\n        if (mApplication != null) {\n            return mApplication;\n        }\n\n        Application app = null;\n\n        String appClass = mApplicationInfo.className;\n        if (forceDefaultAppClass || (appClass == null)) {\n            appClass = &quot;android.app.Application&quot;;\n        }\n\n        try {\n            java.lang.ClassLoader cl = getClassLoader();\n            if (!mPackageName.equals(&quot;android&quot;)) {\n                initializeJavaContextClassLoader();\n            }\n            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n            app = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n            appContext.setOuterContext(app);\n        } catch (Exception e) {        }\n        mActivityThread.mAllApplications.add(app);\n        mApplication = app;\n\n    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n        if (instrumentation != null) {\n            try {\n                instrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {\n\n            }\n        }\n        ...ignore some code... \n\n       }\n\n        return app;\n    }\n</code></pre><p>最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！</p>\n<pre><code>static public Application newApplication(Class&lt;?&gt; clazz, Context context)\n            throws InstantiationException, IllegalAccessException, \n            ClassNotFoundException {\n        Application app = (Application)clazz.newInstance();\n        app.attach(context);\n        return app;\n    }\n</code></pre><p>而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。</p>\n<p>参考文章</p>\n<p>下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。</p>\n<p>Binder:</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/universus/article/details/6211589\">Android Bander设计与实现 - 设计篇</a></li>\n</ul>\n<p>zygote<br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6768304\">Android系统进程Zygote启动过程的源代码分析</a><br>•    <a href=\"http://blog.csdn.net/xieqibao/article/details/6581975\">Android 之 zygote 与进程创建</a><br>•    <a href=\"http://www.th7.cn/Program/Android/201404/187670.shtml\">Zygote浅谈</a><br>ActivityThread、Instrumentation、AMS<br>•    <a href=\"http://blog.csdn.net/myarrow/article/details/14224273\">Android Activity.startActivity流程简介</a><br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6747696#comments\">Android应用程序进程启动过程的源代码分析</a><br>•    <a href=\"http://laokaddk.blog.51cto.com/368606/1206840\">框架层理解Activity生命周期(APP启动过程)</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\">Android应用程序窗口设计框架介绍</a><br>•    <a href=\"http://www.xuebuyuan.com/2172927.html\">ActivityManagerService分析一：AMS的启动</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\">Android应用程序窗口设计框架介绍</a><br>Launcher<br>•    <a href=\"http://mobile.51cto.com/hot-312129.htm\">Android 4.0 Launcher源码分析系列(一)</a><br>•    <a href=\"http://www.cnblogs.com/mythou/p/3187881.html\">Android Launcher分析和修改9——Launcher启动APP流程</a></p>\n<p>结束语：<br>到了这里，我们回来看下开头的几个问题：</p>\n<ul>\n<li>ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>\n<li>ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作</li>\n<li>ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。</li>\n<li>ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的</li>\n<li>Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作</li>\n<li>ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射</li>\n<li>TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。</li>\n</ul>\n<p>如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 </p>\n"},{"title":"网络请求的 UA","date":"2016-06-20T10:27:54.000Z","keywords":"okhttp3","_content":"\n一般我们的客户端请求头里面都会有一个 User Agent 的参数，默认请求下 会直接获取系统里面的一些参数信息，然后发送到服务器。服务器就知道这个设备 大体情况，也可以根据这个来处理，或者禁用某些设备。\n一般定义的 UA 应该包含下面这些东西（当前也可以删减或去掉的）：\n\n`appName + versionName + versonCode + 渠道号 + 设备基本信息\n`\n\n这里写一些大体的代码，其他可以自行封装：\n\n拼接数据：\n\n`appName: mContext.getString(R.string.appname)\n`\n\n`versionName:  DeviceUtil.getVersionName(mContext)\n`\n\n`versonCode: DeviceUtil.getVersionCode(mContext)\n`\n\n`渠道号：DeviceUtil.getChannelTag(mContext)\n`\n\n设备基本信息: \n`build.MODEL \t\tNexus 6\n`\n\n`build.MANUFACTURER  motorola\n`\n\n`build.BRAND\t\t\tgoogle\n`\n\n`build.FINGERPRINT\tgoogle/shamu/shamu:6.0.1/MMB29S/2489379:user/release-keys\n`\n\n`Build.VERSION.RELEASE 6.0.1\n`\n\n`Build.VERSION.SDKINT 23`","source":"_posts/网络请求的-UA.md","raw":"title: 网络请求的 UA\ndate: 2016-06-20 18:27:54\ncategories: okhttp3\nkeywords: okhttp3\ntags: okhttp3\n---\n\n一般我们的客户端请求头里面都会有一个 User Agent 的参数，默认请求下 会直接获取系统里面的一些参数信息，然后发送到服务器。服务器就知道这个设备 大体情况，也可以根据这个来处理，或者禁用某些设备。\n一般定义的 UA 应该包含下面这些东西（当前也可以删减或去掉的）：\n\n`appName + versionName + versonCode + 渠道号 + 设备基本信息\n`\n\n这里写一些大体的代码，其他可以自行封装：\n\n拼接数据：\n\n`appName: mContext.getString(R.string.appname)\n`\n\n`versionName:  DeviceUtil.getVersionName(mContext)\n`\n\n`versonCode: DeviceUtil.getVersionCode(mContext)\n`\n\n`渠道号：DeviceUtil.getChannelTag(mContext)\n`\n\n设备基本信息: \n`build.MODEL \t\tNexus 6\n`\n\n`build.MANUFACTURER  motorola\n`\n\n`build.BRAND\t\t\tgoogle\n`\n\n`build.FINGERPRINT\tgoogle/shamu/shamu:6.0.1/MMB29S/2489379:user/release-keys\n`\n\n`Build.VERSION.RELEASE 6.0.1\n`\n\n`Build.VERSION.SDKINT 23`","slug":"网络请求的-UA","published":1,"updated":"2016-06-20T10:29:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ahc0022xzexbf678hd4","content":"<p>一般我们的客户端请求头里面都会有一个 User Agent 的参数，默认请求下 会直接获取系统里面的一些参数信息，然后发送到服务器。服务器就知道这个设备 大体情况，也可以根据这个来处理，或者禁用某些设备。<br>一般定义的 UA 应该包含下面这些东西（当前也可以删减或去掉的）：</p>\n<p><code>appName + versionName + versonCode + 渠道号 + 设备基本信息</code></p>\n<p>这里写一些大体的代码，其他可以自行封装：</p>\n<p>拼接数据：</p>\n<p><code>appName: mContext.getString(R.string.appname)</code></p>\n<p><code>versionName:  DeviceUtil.getVersionName(mContext)</code></p>\n<p><code>versonCode: DeviceUtil.getVersionCode(mContext)</code></p>\n<p><code>渠道号：DeviceUtil.getChannelTag(mContext)</code></p>\n<p>设备基本信息:<br><code>build.MODEL         Nexus 6</code></p>\n<p><code>build.MANUFACTURER  motorola</code></p>\n<p><code>build.BRAND            google</code></p>\n<p><code>build.FINGERPRINT    google/shamu/shamu:6.0.1/MMB29S/2489379:user/release-keys</code></p>\n<p><code>Build.VERSION.RELEASE 6.0.1</code></p>\n<p><code>Build.VERSION.SDKINT 23</code></p>\n","excerpt":"","more":"<p>一般我们的客户端请求头里面都会有一个 User Agent 的参数，默认请求下 会直接获取系统里面的一些参数信息，然后发送到服务器。服务器就知道这个设备 大体情况，也可以根据这个来处理，或者禁用某些设备。<br>一般定义的 UA 应该包含下面这些东西（当前也可以删减或去掉的）：</p>\n<p><code>appName + versionName + versonCode + 渠道号 + 设备基本信息</code></p>\n<p>这里写一些大体的代码，其他可以自行封装：</p>\n<p>拼接数据：</p>\n<p><code>appName: mContext.getString(R.string.appname)</code></p>\n<p><code>versionName:  DeviceUtil.getVersionName(mContext)</code></p>\n<p><code>versonCode: DeviceUtil.getVersionCode(mContext)</code></p>\n<p><code>渠道号：DeviceUtil.getChannelTag(mContext)</code></p>\n<p>设备基本信息:<br><code>build.MODEL         Nexus 6</code></p>\n<p><code>build.MANUFACTURER  motorola</code></p>\n<p><code>build.BRAND            google</code></p>\n<p><code>build.FINGERPRINT    google/shamu/shamu:6.0.1/MMB29S/2489379:user/release-keys</code></p>\n<p><code>Build.VERSION.RELEASE 6.0.1</code></p>\n<p><code>Build.VERSION.SDKINT 23</code></p>\n"},{"title":"程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析","date":"2015-11-12T04:01:59.000Z","keywords":"android崩溃异常","_content":"\n### 程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\n<br>\n\n遇到该问题，程序会直接崩溃\n\n1.具体问题：\n\n\tjava.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\n\tat android.widget.ListView.layoutChildren(ListView.java:1562)\n\tat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\n\tat android.os.Handler.handleCallback(Handler.java:739)\n\tat android.os.Handler.dispatchMessage(Handler.java:95)\n\tat android.os.Looper.loop(Looper.java:135)\n\tat android.app.ActivityThread.main(ActivityThread.java:5254)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat java.lang.reflect.Method.invoke(Method.java:372)\n\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\n\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n\n2.出现的过程：\n\n程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。\n\n具体源码是：\n\twhile (mDataList != null && mDataList.size() > MAX_MESSAGE_NUM) {\n\t                        mDataList.remove(0);\n\t                    }\n\t                    MessageBean data = (MessageBean) msg.obj;\n\t                    if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {\n\t                        messageBeanList.add(data);\n\t                    }\n\t\n\t                    //调整 在线人数很多，发消息很频繁的bug.\n\t                    isOnlinePeopleLock = true;\n\t                    if (isOnlinePeopleLock) {\n\t                        mHandler.postDelayed(new Runnable() {\n\t                            @Override\n\t                            public void run() {\n\t                                mDataList.addAll(messageBeanList);\n\t                                messageBeanList.clear();\n\t                                isOnlinePeopleLock = false;\n\t                                listViewSelectEnd(mListView, isTouchListView);\n\t                            }\n\t                        }, ONE_SECOND);\n\t                    }\n\n当人数很多的时候会偶然出现：\n\tjava.lang.IllegalStateException\n\n3.分析问题:\n\n**Exception解读：**\n**        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。**\n\n<br>\n从Android源码上看看：\n\n\t// Handle the empty set by removing all views that are visible\n\t// and calling it a day\n\tif (mItemCount == 0) {\n\t    resetList();\n\t    invokeOnItemScrollListener();\n\t    return;\n\t} else if (mItemCount != mAdapter.getCount()) {\n\t    throw new IllegalStateException(\"The content of the adapter has changed but \"\n\t            + \"ListView did not receive a notification. Make sure the content of \"\n\t            + \"your adapter is not modified from a background thread, but only \"\n\t            + \"from the UI thread. [in ListView(\" + getId() + \", \" + getClass()\n\t            + \") with Adapter(\" + mAdapter.getClass() + \")]\");\n\t}\n\n#### **当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。**\n\n<br>\n可以分析出来的是：\n\n当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。\n\n4.解决办法：\n\n**把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。**\n\n5.注意事项：\n\n为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：\n\n- 确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView\n- 数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步\n- 仔细检查确认getCount()方法返回值是否正确\n\n参考：\n[http://www.cnblogs.com/monodin/p/3874147.html](http://www.cnblogs.com/monodin/p/3874147.html)","source":"_posts/程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析.md","raw":"title: 程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\ndate: 2015-11-12 12:01:59\ncategories:\nkeywords: android崩溃异常\ntags: android\n---\n\n### 程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\n<br>\n\n遇到该问题，程序会直接崩溃\n\n1.具体问题：\n\n\tjava.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\n\tat android.widget.ListView.layoutChildren(ListView.java:1562)\n\tat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\n\tat android.os.Handler.handleCallback(Handler.java:739)\n\tat android.os.Handler.dispatchMessage(Handler.java:95)\n\tat android.os.Looper.loop(Looper.java:135)\n\tat android.app.ActivityThread.main(ActivityThread.java:5254)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat java.lang.reflect.Method.invoke(Method.java:372)\n\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\n\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n\n2.出现的过程：\n\n程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。\n\n具体源码是：\n\twhile (mDataList != null && mDataList.size() > MAX_MESSAGE_NUM) {\n\t                        mDataList.remove(0);\n\t                    }\n\t                    MessageBean data = (MessageBean) msg.obj;\n\t                    if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {\n\t                        messageBeanList.add(data);\n\t                    }\n\t\n\t                    //调整 在线人数很多，发消息很频繁的bug.\n\t                    isOnlinePeopleLock = true;\n\t                    if (isOnlinePeopleLock) {\n\t                        mHandler.postDelayed(new Runnable() {\n\t                            @Override\n\t                            public void run() {\n\t                                mDataList.addAll(messageBeanList);\n\t                                messageBeanList.clear();\n\t                                isOnlinePeopleLock = false;\n\t                                listViewSelectEnd(mListView, isTouchListView);\n\t                            }\n\t                        }, ONE_SECOND);\n\t                    }\n\n当人数很多的时候会偶然出现：\n\tjava.lang.IllegalStateException\n\n3.分析问题:\n\n**Exception解读：**\n**        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。**\n\n<br>\n从Android源码上看看：\n\n\t// Handle the empty set by removing all views that are visible\n\t// and calling it a day\n\tif (mItemCount == 0) {\n\t    resetList();\n\t    invokeOnItemScrollListener();\n\t    return;\n\t} else if (mItemCount != mAdapter.getCount()) {\n\t    throw new IllegalStateException(\"The content of the adapter has changed but \"\n\t            + \"ListView did not receive a notification. Make sure the content of \"\n\t            + \"your adapter is not modified from a background thread, but only \"\n\t            + \"from the UI thread. [in ListView(\" + getId() + \", \" + getClass()\n\t            + \") with Adapter(\" + mAdapter.getClass() + \")]\");\n\t}\n\n#### **当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。**\n\n<br>\n可以分析出来的是：\n\n当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。\n\n4.解决办法：\n\n**把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。**\n\n5.注意事项：\n\n为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：\n\n- 确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView\n- 数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步\n- 仔细检查确认getCount()方法返回值是否正确\n\n参考：\n[http://www.cnblogs.com/monodin/p/3874147.html](http://www.cnblogs.com/monodin/p/3874147.html)","slug":"程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析","published":1,"updated":"2016-04-19T13:17:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlx2ahe0026xzex2slnm0qm","content":"<h3 id=\"程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\"><a href=\"#程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\" class=\"headerlink\" title=\"程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\"></a>程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析</h3><p><br></p>\n<p>遇到该问题，程序会直接崩溃</p>\n<p>1.具体问题：</p>\n<pre><code>java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\nat android.widget.ListView.layoutChildren(ListView.java:1562)\nat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\nat android.os.Handler.handleCallback(Handler.java:739)\nat android.os.Handler.dispatchMessage(Handler.java:95)\nat android.os.Looper.loop(Looper.java:135)\nat android.app.ActivityThread.main(ActivityThread.java:5254)\nat java.lang.reflect.Method.invoke(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:372)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n</code></pre><p>2.出现的过程：</p>\n<p>程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。</p>\n<p>具体源码是：<br>    while (mDataList != null &amp;&amp; mDataList.size() &gt; MAX_MESSAGE_NUM) {<br>                            mDataList.remove(0);<br>                        }<br>                        MessageBean data = (MessageBean) msg.obj;<br>                        if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {<br>                            messageBeanList.add(data);<br>                        }</p>\n<pre><code>//调整 在线人数很多，发消息很频繁的bug.\nisOnlinePeopleLock = true;\nif (isOnlinePeopleLock) {\n    mHandler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            mDataList.addAll(messageBeanList);\n            messageBeanList.clear();\n            isOnlinePeopleLock = false;\n            listViewSelectEnd(mListView, isTouchListView);\n        }\n    }, ONE_SECOND);\n}\n</code></pre><p>当人数很多的时候会偶然出现：<br>    java.lang.IllegalStateException</p>\n<p>3.分析问题:</p>\n<p><strong>Exception解读：</strong><br><strong>        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。</strong></p>\n<p><br><br>从Android源码上看看：</p>\n<pre><code>// Handle the empty set by removing all views that are visible\n// and calling it a day\nif (mItemCount == 0) {\n    resetList();\n    invokeOnItemScrollListener();\n    return;\n} else if (mItemCount != mAdapter.getCount()) {\n    throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;\n            + &quot;ListView did not receive a notification. Make sure the content of &quot;\n            + &quot;your adapter is not modified from a background thread, but only &quot;\n            + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()\n            + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);\n}\n</code></pre><h4 id=\"当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\"><a href=\"#当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\" class=\"headerlink\" title=\"当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。\"></a><strong>当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。</strong></h4><p><br><br>可以分析出来的是：</p>\n<p>当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。</p>\n<p>4.解决办法：</p>\n<p><strong>把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。</strong></p>\n<p>5.注意事项：</p>\n<p>为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：</p>\n<ul>\n<li>确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView</li>\n<li>数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步</li>\n<li>仔细检查确认getCount()方法返回值是否正确</li>\n</ul>\n<p>参考：<br><a href=\"http://www.cnblogs.com/monodin/p/3874147.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/monodin/p/3874147.html</a></p>\n","excerpt":"","more":"<h3 id=\"程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\"><a href=\"#程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\" class=\"headerlink\" title=\"程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\"></a>程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析</h3><p><br></p>\n<p>遇到该问题，程序会直接崩溃</p>\n<p>1.具体问题：</p>\n<pre><code>java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\nat android.widget.ListView.layoutChildren(ListView.java:1562)\nat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\nat android.os.Handler.handleCallback(Handler.java:739)\nat android.os.Handler.dispatchMessage(Handler.java:95)\nat android.os.Looper.loop(Looper.java:135)\nat android.app.ActivityThread.main(ActivityThread.java:5254)\nat java.lang.reflect.Method.invoke(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:372)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n</code></pre><p>2.出现的过程：</p>\n<p>程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。</p>\n<p>具体源码是：<br>    while (mDataList != null &amp;&amp; mDataList.size() &gt; MAX_MESSAGE_NUM) {<br>                            mDataList.remove(0);<br>                        }<br>                        MessageBean data = (MessageBean) msg.obj;<br>                        if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {<br>                            messageBeanList.add(data);<br>                        }</p>\n<pre><code>//调整 在线人数很多，发消息很频繁的bug.\nisOnlinePeopleLock = true;\nif (isOnlinePeopleLock) {\n    mHandler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            mDataList.addAll(messageBeanList);\n            messageBeanList.clear();\n            isOnlinePeopleLock = false;\n            listViewSelectEnd(mListView, isTouchListView);\n        }\n    }, ONE_SECOND);\n}\n</code></pre><p>当人数很多的时候会偶然出现：<br>    java.lang.IllegalStateException</p>\n<p>3.分析问题:</p>\n<p><strong>Exception解读：</strong><br><strong>        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。</strong></p>\n<p><br><br>从Android源码上看看：</p>\n<pre><code>// Handle the empty set by removing all views that are visible\n// and calling it a day\nif (mItemCount == 0) {\n    resetList();\n    invokeOnItemScrollListener();\n    return;\n} else if (mItemCount != mAdapter.getCount()) {\n    throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;\n            + &quot;ListView did not receive a notification. Make sure the content of &quot;\n            + &quot;your adapter is not modified from a background thread, but only &quot;\n            + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()\n            + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);\n}\n</code></pre><h4 id=\"当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\"><a href=\"#当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\" class=\"headerlink\" title=\"当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。\"></a><strong>当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。</strong></h4><p><br><br>可以分析出来的是：</p>\n<p>当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。</p>\n<p>4.解决办法：</p>\n<p><strong>把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。</strong></p>\n<p>5.注意事项：</p>\n<p>为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：</p>\n<ul>\n<li>确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView</li>\n<li>数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步</li>\n<li>仔细检查确认getCount()方法返回值是否正确</li>\n</ul>\n<p>参考：<br><a href=\"http://www.cnblogs.com/monodin/p/3874147.html\">http://www.cnblogs.com/monodin/p/3874147.html</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cirlx2ag1000mxzexvb7jte33","category_id":"cirlx2ag7000qxzexcu4sfsfo","_id":"cirlx2agj0010xzexlh8zem12"},{"post_id":"cirlx2ag5000oxzexyq7x5kaz","category_id":"cirlx2ag7000qxzexcu4sfsfo","_id":"cirlx2agm0017xzex9mebyxps"},{"post_id":"cirlx2agl0014xzexy6l7528t","category_id":"cirlx2ag7000qxzexcu4sfsfo","_id":"cirlx2agr001dxzex5hsrxlji"},{"post_id":"cirlx2ag7000rxzex14rw4ujf","category_id":"cirlx2ag7000qxzexcu4sfsfo","_id":"cirlx2ags001hxzexwzd1nifo"},{"post_id":"cirlx2agb000txzextb2o5xr6","category_id":"cirlx2agn0019xzexlod9kuu4","_id":"cirlx2agz001mxzex4nfk8ve7"},{"post_id":"cirlx2agg000xxzexb7imz0c9","category_id":"cirlx2ags001fxzexo8249whg","_id":"cirlx2ah4001sxzexmxlbqmhf"},{"post_id":"cirlx2agj0011xzex8yisz7gl","category_id":"cirlx2ah0001nxzexfluidy8z","_id":"cirlx2ah8001yxzexg3yhddue"},{"post_id":"cirlx2ago001bxzex1bcbgny3","category_id":"cirlx2ah5001uxzeximkt42ej","_id":"cirlx2ahe0024xzex1pnam21l"},{"post_id":"cirlx2ahc0022xzexbf678hd4","category_id":"cirlx2ag7000qxzexcu4sfsfo","_id":"cirlx2ahh002axzexvk9smb54"},{"post_id":"cirlx2agr001exzex8gitrmq9","category_id":"cirlx2aha0021xzeximis373m","_id":"cirlx2ahi002cxzexurjfwq23"},{"post_id":"cirlx2agt001ixzexrkaly5h3","category_id":"cirlx2ahf0027xzexlf9qys27","_id":"cirlx2ahj002gxzexi2nnxx0v"}],"PostTag":[{"post_id":"cirlx2afk0007xzexhid9ssyq","tag_id":"cirlx2aff0005xzexfee7va37","_id":"cirlx2aft000axzexrubxffex"},{"post_id":"cirlx2afb0003xzexlmm9cj1k","tag_id":"cirlx2aff0005xzexfee7va37","_id":"cirlx2afw000cxzexgcvvhrr2"},{"post_id":"cirlx2afd0004xzex0daqz1wd","tag_id":"cirlx2afp0008xzexe14ni9f0","_id":"cirlx2afy000fxzexxzcc3qa5"},{"post_id":"cirlx2afw000dxzex4jzjeb1b","tag_id":"cirlx2aff0005xzexfee7va37","_id":"cirlx2afz000hxzexarm1hv2r"},{"post_id":"cirlx2afh0006xzex1nusqmzs","tag_id":"cirlx2afx000exzex5ky4k98c","_id":"cirlx2ag1000lxzexpj3vqzyf"},{"post_id":"cirlx2afq0009xzex28wpn04f","tag_id":"cirlx2ag0000jxzexsm7zmnce","_id":"cirlx2ag7000pxzexwxvox6j2"},{"post_id":"cirlx2afu000bxzex4ba7btpo","tag_id":"cirlx2ag5000nxzexbhj06aac","_id":"cirlx2agd000uxzexyae9s83k"},{"post_id":"cirlx2agd000vxzexzu71bxr9","tag_id":"cirlx2aff0005xzexfee7va37","_id":"cirlx2agj000zxzexkhqlcmgn"},{"post_id":"cirlx2afy000gxzexap2bt7pl","tag_id":"cirlx2agb000sxzex6k45n9z7","_id":"cirlx2agl0013xzexagkvtccl"},{"post_id":"cirlx2agj0011xzex8yisz7gl","tag_id":"cirlx2aff0005xzexfee7va37","_id":"cirlx2agm0016xzex7tcl54ly"},{"post_id":"cirlx2afz000ixzexktluokbv","tag_id":"cirlx2agi000yxzexrya2jke6","_id":"cirlx2ago001axzexro7peg4b"},{"post_id":"cirlx2ag0000kxzex9009o8bw","tag_id":"cirlx2agm0015xzexgdiu8udb","_id":"cirlx2ags001gxzexfbi5icnc"},{"post_id":"cirlx2ago001bxzex1bcbgny3","tag_id":"cirlx2afp0008xzexe14ni9f0","_id":"cirlx2agx001jxzexg19dw9az"},{"post_id":"cirlx2ag1000mxzexvb7jte33","tag_id":"cirlx2agq001cxzexh7tet8c8","_id":"cirlx2ah1001oxzex8mcuryhd"},{"post_id":"cirlx2ag5000oxzexyq7x5kaz","tag_id":"cirlx2agq001cxzexh7tet8c8","_id":"cirlx2ah4001txzexhuq6qwro"},{"post_id":"cirlx2ag7000rxzex14rw4ujf","tag_id":"cirlx2agq001cxzexh7tet8c8","_id":"cirlx2ah8001zxzexbng6b89r"},{"post_id":"cirlx2agb000txzextb2o5xr6","tag_id":"cirlx2ah6001wxzexvuavepjh","_id":"cirlx2ahe0025xzexqsvicnsb"},{"post_id":"cirlx2ahc0022xzexbf678hd4","tag_id":"cirlx2agq001cxzexh7tet8c8","_id":"cirlx2ahg0028xzexutf5jog7"},{"post_id":"cirlx2ahe0026xzex2slnm0qm","tag_id":"cirlx2aff0005xzexfee7va37","_id":"cirlx2ahi002bxzexixn15507"},{"post_id":"cirlx2agg000xxzexb7imz0c9","tag_id":"cirlx2ahd0023xzex5i6u9z1x","_id":"cirlx2ahi002dxzex626slrhg"},{"post_id":"cirlx2agl0014xzexy6l7528t","tag_id":"cirlx2agq001cxzexh7tet8c8","_id":"cirlx2ahj002fxzexobnya0vd"},{"post_id":"cirlx2agm0018xzexg5xgtuxk","tag_id":"cirlx2ahi002exzexv62xirpr","_id":"cirlx2ahj002ixzexr862bh1a"},{"post_id":"cirlx2agr001exzex8gitrmq9","tag_id":"cirlx2ahj002hxzexwca8pmf5","_id":"cirlx2ahj002kxzexh3juleaa"},{"post_id":"cirlx2agt001ixzexrkaly5h3","tag_id":"cirlx2ahj002jxzexa3377t0v","_id":"cirlx2ahk002mxzexxzz7xjd6"},{"post_id":"cirlx2ah1001pxzex3cjm1my1","tag_id":"cirlx2ahj002lxzex67t1nfl9","_id":"cirlx2ahk002oxzexop0y8vtc"},{"post_id":"cirlx2ah5001vxzextqbg4rs1","tag_id":"cirlx2ahk002nxzexwxrhhg9p","_id":"cirlx2ahk002qxzexvt559d0z"},{"post_id":"cirlx2ah7001xxzex0uka5zw4","tag_id":"cirlx2ahk002pxzexd3xqfo68","_id":"cirlx2ahl002sxzex7rbdszbn"},{"post_id":"cirlx2ah90020xzexa9180w8r","tag_id":"cirlx2ahl002rxzexrp558s50","_id":"cirlx2ahl002txzexml6r9jmm"}],"Tag":[{"name":"android","_id":"cirlx2aff0005xzexfee7va37"},{"name":"AndroidStudio","_id":"cirlx2afp0008xzexe14ni9f0"},{"name":"android gradle工作原理","_id":"cirlx2afx000exzex5ky4k98c"},{"name":"技能提升","_id":"cirlx2ag0000jxzexsm7zmnce"},{"name":"ios","_id":"cirlx2ag5000nxzexbhj06aac"},{"name":"https","_id":"cirlx2agb000sxzex6k45n9z7"},{"name":"android录音","_id":"cirlx2agi000yxzexrya2jke6"},{"name":"OkHttp,Okio","_id":"cirlx2agm0015xzexgdiu8udb"},{"name":"okhttp3","_id":"cirlx2agq001cxzexh7tet8c8"},{"name":"Java","_id":"cirlx2ah6001wxzexvuavepjh"},{"name":"okio","_id":"cirlx2ahd0023xzex5i6u9z1x"},{"name":"算法","_id":"cirlx2ahi002exzexv62xirpr"},{"name":"groovy","_id":"cirlx2ahj002hxzexwca8pmf5"},{"name":"面试心经","_id":"cirlx2ahj002jxzexa3377t0v"},{"name":"干货","_id":"cirlx2ahj002lxzex67t1nfl9"},{"name":"Android日志规范","_id":"cirlx2ahk002nxzexwxrhhg9p"},{"name":"番茄工作法","_id":"cirlx2ahk002pxzexd3xqfo68"},{"name":"Android","_id":"cirlx2ahl002rxzexrp558s50"}]}}