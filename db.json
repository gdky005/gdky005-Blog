{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"8fa6f9233c9408c6d03eac8eea16cd11fa31464a","modified":1441596643000},{"_id":"source/.DS_Store","hash":"65edc64f99a50f521ec56edfca08a6e767f7fb4b","modified":1461041961000},{"_id":"source/CNAME","hash":"9bdabd8bcdb91cd4e83d2b19ff784fa8cc69385c","modified":1441596643000},{"_id":"source/baidu_verify_qFvkELVQ5j.html","hash":"a1e7cdb3fce036a32a099cb924ef0594f031d44a","modified":1441696386000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1461039839000},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1461039839000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1461039839000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1461039839000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1461039839000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1461039839000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1461041961000},{"_id":"source/_posts/APK反编译Jadx.md","hash":"f3b8d23652d944ebfc11c32c583097f25fff10c8","modified":1456286468000},{"_id":"source/_posts/Android-gradle工作原理.md","hash":"64790a725b1c66a839702b78f227235307e45028","modified":1442119940000},{"_id":"source/_posts/Android-和-IOS-应用查找bug-利器.md","hash":"c5fcf624fe37568159dd38540135d66ae4f17e84","modified":1443252803000},{"_id":"source/_posts/AndroidStudio.md","hash":"204287c70cc4ab51c0bc26613b55506e98232902","modified":1446517312000},{"_id":"source/_posts/Android在图形界面UI方面的工具.md","hash":"6d42a3f5216932031d4d321fbb7566682fab77f3","modified":1444374886000},{"_id":"source/_posts/Android开发者提升技能水平的大招.md","hash":"3c431a74fa57d4a8f29e61d2d12e9a2043b24851","modified":1456108800000},{"_id":"source/_posts/Android录音使用-byte-类型获取分贝或声音振幅.md","hash":"eed81caf5e96a7af5dbaacb76b8d330e557ec9da","modified":1444299572000},{"_id":"source/_posts/Bug小记-贵金属.md","hash":"62b9b96dc28a47ce5c9d7d1216daebe556b1ada5","modified":1448015542000},{"_id":"source/_posts/Fragment-not-attached-to-Activity-异常.md","hash":"27f30381348af6d5114dbf1a51e3e1342b2eb16e","modified":1448592725000},{"_id":"source/_posts/RecyclerView的基类写法.md","hash":"6819dddfef0bdde41f791d33757ac64ce53e757d","modified":1447729408000},{"_id":"source/_posts/android-monkey.md","hash":"e3423866d1eaf7aa69d5d28708b4d277a0c80e19","modified":1442661597000},{"_id":"source/_posts/test.md","hash":"071e850c30c09b381d3e3dd4d5aaaf83663f5aa7","modified":1461042106000},{"_id":"source/_posts/代码面试最常用的10大算法.md","hash":"c14ff81432e98d718ad9f5fb6f3456d5189c74c3","modified":1457743628000},{"_id":"source/_posts/使用groovy读取excel里面内容.md","hash":"9077b2c3a5e6a8b389e2ced0458f0f7619ab21aa","modified":1448008103000},{"_id":"source/_posts/圆角图片处理.md","hash":"4a833991dfa47836ff6a20c0546bf00f7d1439b2","modified":1444461503000},{"_id":"source/_posts/推荐processon-让流程图也可以共享.md","hash":"abd1dbb94f68a18063f18e54e338d0ecb45cc8db","modified":1456368586000},{"_id":"source/_posts/凯哥高质量文章系列.md","hash":"ffc19058bb08538a11f53aff96a0fc820e5d8f2d","modified":1448008257000},{"_id":"source/_posts/日志指南.md","hash":"9c5103d6b90e6ac42820d001bbf4afe4760ca667","modified":1441939135000},{"_id":"source/_posts/是什么使你无法完成工作？——番茄告诉你.md","hash":"113a823828c71d72f6e4c0a2184e8b7ac394007b","modified":1442119969000},{"_id":"source/_posts/比较好的Android网站.md","hash":"76a42f9557831d60a49930863318f6020dc435dc","modified":1443250542000},{"_id":"source/_posts/程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析.md","hash":"b61e7ee2cdc0b607d352dea72ab3607b3a945e20","modified":1447301078000},{"_id":"source/about/.DS_Store","hash":"a802868e144a4515040090c88f65c5dd3b6c1618","modified":1461038288000},{"_id":"source/about/index.md","hash":"80a198036535499f762834b94ebb0e15b039400d","modified":1441700771000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1461039839000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1461039839000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1461039839000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1461039839000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1461039839000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1461039839000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1461039839000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1461039839000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1461039839000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1461039839000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1461039839000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1461039839000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1461039839000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1461039839000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1461039839000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1461039839000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1461039839000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1461039839000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1461039839000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1461039839000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1461039839000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1461039839000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1461039839000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1461039839000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1461039839000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"36eefe6332b86b66023a9884b754d305235846b4","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1461039839000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1461039839000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1461039839000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1461039839000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1461039839000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1461039839000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1461039839000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1461039839000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1461039839000},{"_id":"public/404.html","hash":"53d4de8412bf03ba108b51cc585cc8d49f602dde","modified":1461042211426},{"_id":"public/baidu_verify_qFvkELVQ5j.html","hash":"a8fb45e26c06d1d427ea2dbc6f680a2ab5ddc096","modified":1461042211426},{"_id":"public/about/index.html","hash":"cee9452bc971c23f89d79224ef96b94f074c727b","modified":1461042211427},{"_id":"public/2016/02/25/推荐processon-让流程图也可以共享/index.html","hash":"0d155dbd2d6260b3137730b2947210eed91bbe80","modified":1461042211427},{"_id":"public/2016/02/24/APK反编译Jadx/index.html","hash":"851fe1a5c608236eb635ca93c2926d41b1d67663","modified":1461042211427},{"_id":"public/2015/11/27/Fragment-not-attached-to-Activity-异常/index.html","hash":"7d1420ee019853610ec5791200a7d99459b16cf2","modified":1461042211427},{"_id":"public/2015/11/20/Bug小记-贵金属/index.html","hash":"4b7467127c89edc81372cb84ee6023421cfb5fc2","modified":1461042211427},{"_id":"public/2015/11/20/使用groovy读取excel里面内容/index.html","hash":"3c6ab8ef7deb7fdf2d72263ef95fb4328d41f54d","modified":1461042211427},{"_id":"public/2015/11/17/RecyclerView的基类写法/index.html","hash":"0c06a6116c09bb8cfee19520e96a3a32352bbd4b","modified":1461042211427},{"_id":"public/2015/11/12/程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析/index.html","hash":"7aaad3c05497fc256ca702dad21c9c30b61b0f08","modified":1461042211427},{"_id":"public/2015/10/10/圆角图片处理/index.html","hash":"87a44a3bf35a08f5cf070d45d253f88402ea14ee","modified":1461042211427},{"_id":"public/2015/10/09/Android在图形界面UI方面的工具/index.html","hash":"ab81e0fdf337aa0d6f35e95401097ee82d279f58","modified":1461042211427},{"_id":"public/2015/09/26/比较好的Android网站/index.html","hash":"c6f6acc01791cdaf59b70cdd5bf899970344f2eb","modified":1461042211428},{"_id":"public/2015/09/19/android-monkey/index.html","hash":"071b67d1f9c67db9047d79f829ee11cdb59fb244","modified":1461042211428},{"_id":"public/2015/09/19/AndroidStudio/index.html","hash":"7e2d67b7cd6386506d71ec0081f1d82f3277150d","modified":1461042211428},{"_id":"public/2015/09/13/Android-gradle工作原理/index.html","hash":"5c77b7db058077738d3a1c5e89dbce9b2cc70c34","modified":1461042211428},{"_id":"public/2015/09/13/是什么使你无法完成工作？——番茄告诉你/index.html","hash":"f7e42105b31cc8139e8bcf1a1a4db9c18cd9318d","modified":1461042211428},{"_id":"public/archives/index.html","hash":"236c07ea1fcfada9ae2054599f10ad3a370f6b01","modified":1461042211428},{"_id":"public/archives/page/2/index.html","hash":"df5863236d26c3ce2fd16dd45c7cd4e5fea439dc","modified":1461042211428},{"_id":"public/archives/2015/index.html","hash":"9aaff41489fbc8937557bc5f5687ce8d04f0eb04","modified":1461042211428},{"_id":"public/archives/2015/page/2/index.html","hash":"e7fb89b09729ad8f08ee7779197d90918f59ff63","modified":1461042211428},{"_id":"public/archives/2015/09/index.html","hash":"5298729684f6288b80ca892c91c2753e0d3359de","modified":1461042211428},{"_id":"public/archives/2015/10/index.html","hash":"b823facbd13ddf630bd42b4415254917f4d8ebbc","modified":1461042211429},{"_id":"public/archives/2015/11/index.html","hash":"7f767f5bcbc1cfedfc7b9cc1c0a17e5845849ef8","modified":1461042211429},{"_id":"public/archives/2016/index.html","hash":"6c896f0ab3e31dd243ce3f19e0100b152bc42405","modified":1461042211429},{"_id":"public/archives/2016/02/index.html","hash":"ac2a4d0dd6a9eba5f7c1247a3fc7fbf90e7423d5","modified":1461042211429},{"_id":"public/archives/2016/03/index.html","hash":"b2f8fd991e460346fd98e5a703bf7f4527ebab49","modified":1461042211429},{"_id":"public/categories/android/index.html","hash":"ff6d17747b783fdea071aaee486fbb114102ffb5","modified":1461042211429},{"_id":"public/tags/android/index.html","hash":"8a0dcaa23442933e6da8f350a187029daf6304ec","modified":1461042211429},{"_id":"public/tags/android-gradle工作原理/index.html","hash":"8285402c77dce4ba8e7eaab4f48a20650f5de0ef","modified":1461042211429},{"_id":"public/tags/AndroidStudio/index.html","hash":"faca3b391456c41295ce495178fb47e1a8766e0f","modified":1461042211429},{"_id":"public/tags/技能提升/index.html","hash":"9cc1ad6e7b6e6f296a22a225792f5a5b5941ca39","modified":1461042211429},{"_id":"public/tags/ios/index.html","hash":"1ee40924f6c7bf7a7b4797a845c561d20721de8a","modified":1461042211429},{"_id":"public/tags/android录音/index.html","hash":"dc1ca5cae26f91db326c126368066cafd83395bf","modified":1461042211429},{"_id":"public/tags/算法/index.html","hash":"7eae54cc3d31aa3f149c7af66f251f10c697e1de","modified":1461042211429},{"_id":"public/tags/groovy/index.html","hash":"1e295399865908b9f937b5c8fc5c471edde1ee7b","modified":1461042211429},{"_id":"public/tags/Android/index.html","hash":"83f4212450000ab210680a0f7dc1380e22f7b1cd","modified":1461042211429},{"_id":"public/tags/Android日志规范/index.html","hash":"6243accf45f8da2621819f8202ceec8102a29e62","modified":1461042211429},{"_id":"public/tags/番茄工作法/index.html","hash":"91248c804e4eeca9339511a51785d817c681ee15","modified":1461042211429},{"_id":"public/tags/干货/index.html","hash":"103d91a3ae75cabcf7013fce8e74bc9ddb0d3220","modified":1461042211429},{"_id":"public/2016/03/12/代码面试最常用的10大算法/index.html","hash":"0208917105bd5334a63fd32e7e31f56ff100edf0","modified":1461042211429},{"_id":"public/2016/02/19/Android开发者提升技能水平的大招/index.html","hash":"0c386ef1237f18e2e27a353c2ef375b996e7d520","modified":1461042211430},{"_id":"public/2015/11/20/凯哥高质量文章系列/index.html","hash":"cbc5a236ae92fe2ef15a27a15b761010b2539549","modified":1461042211430},{"_id":"public/2015/10/08/Android录音使用-byte-类型获取分贝或声音振幅/index.html","hash":"2670085cd7e4c3bc81d80c430d439cacaa635ac2","modified":1461042211430},{"_id":"public/2015/09/26/Android-和-IOS-应用查找bug-利器/index.html","hash":"5cd347ba0aee96cbb792d8d0b41ad6c6cb279860","modified":1461042211431},{"_id":"public/2015/09/11/日志指南/index.html","hash":"7a8879fcde31c8a8e5fa22700d6ee2ebc9ff54c5","modified":1461042211431},{"_id":"public/index.html","hash":"cd31cfa0baf06ddc202923620b516d3e9468beb5","modified":1461042211431},{"_id":"public/page/2/index.html","hash":"d84f1d5281bf55b9660c01470804f56c3bb2eac9","modified":1461042211431},{"_id":"public/2016/04/19/test/index.html","hash":"78ee2b0406aaa7d53efca6789db54df054183abe","modified":1461042115569},{"_id":"public/archives/page/3/index.html","hash":"05b858c55e5f43dcd6750146eb26009feaedbdd4","modified":1461042115569},{"_id":"public/archives/2016/04/index.html","hash":"a555e196ae0d48d36b702b6533fa03d6581e7a4f","modified":1461042115570},{"_id":"public/page/3/index.html","hash":"90e3b2c38448f8ba211c8d543246765a20570174","modified":1461042115570},{"_id":"public/CNAME","hash":"9bdabd8bcdb91cd4e83d2b19ff784fa8cc69385c","modified":1461042115579},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1461042115579},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1461042115579},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1461042115579},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1461042115580},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1461042115580},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1461042115580},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1461042115580},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1461042115580},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1461042115580},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1461042115580},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1461042116317},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1461042116321},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1461042116321},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1461042116321},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1461042116321},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1461042116321},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1461042116321},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1461042116321},{"_id":"public/css/style.css","hash":"6817576d6f76b42b7e2881fc8adba16169ff3c18","modified":1461042116321},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1461042116321},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1461042116321},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1461042116322},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1461042116322}],"Category":[{"name":"android","_id":"cin6yr1yx000srgexbtifw7yk"}],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2016-04-19T04:54:04.000Z","updated":"2015-09-07T03:30:43.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cin6yr1wt0000rgexme4mylcj","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>","excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\n</body>\n</html>"},{"_content":"qFvkELVQ5j","source":"baidu_verify_qFvkELVQ5j.html","raw":"qFvkELVQ5j","date":"2016-04-19T04:54:04.000Z","updated":"2015-09-08T07:13:06.000Z","path":"baidu_verify_qFvkELVQ5j.html","title":"","comments":1,"layout":"page","_id":"cin6yr1x10001rgexbnxa2rjo","content":"qFvkELVQ5j","excerpt":"","more":"qFvkELVQ5j"},{"_content":"### 王卿，目前做Android\n- 现居北京，就职于考拉FM，专注移动开发。\n- 喜欢研究一些新技术\n\n**近期研究的技术主要是:**\n\n- groovy (是gradle 的基础)\n- DSL (领域语言，有了groovy 的基础后，容易理解)\n- gradle (学习了groovy, DSL 后看gradle 就容易很多了)\n\n###### 联系方式\nQQ：**741227905**\n\nEmail：**741227905@qq.com** Or **gdky005@126.com**","source":"about/index.md","raw":"### 王卿，目前做Android\n- 现居北京，就职于考拉FM，专注移动开发。\n- 喜欢研究一些新技术\n\n**近期研究的技术主要是:**\n\n- groovy (是gradle 的基础)\n- DSL (领域语言，有了groovy 的基础后，容易理解)\n- gradle (学习了groovy, DSL 后看gradle 就容易很多了)\n\n###### 联系方式\nQQ：**741227905**\n\nEmail：**741227905@qq.com** Or **gdky005@126.com**","date":"2016-04-19T04:54:04.000Z","updated":"2015-09-08T08:26:11.000Z","path":"about/index.html","title":"","comments":1,"layout":"page","_id":"cin6yr1xs0003rgexvnlf2xnc","content":"<h3 id=\"王卿，目前做Android\"><a href=\"#王卿，目前做Android\" class=\"headerlink\" title=\"王卿，目前做Android\"></a>王卿，目前做Android</h3><ul>\n<li>现居北京，就职于考拉FM，专注移动开发。</li>\n<li>喜欢研究一些新技术</li>\n</ul>\n<p><strong>近期研究的技术主要是:</strong></p>\n<ul>\n<li>groovy (是gradle 的基础)</li>\n<li>DSL (领域语言，有了groovy 的基础后，容易理解)</li>\n<li>gradle (学习了groovy, DSL 后看gradle 就容易很多了)</li>\n</ul>\n<h6 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h6><p>QQ：<strong>741227905</strong></p>\n<p>Email：<strong>741227905@qq.com</strong> Or <strong>gdky005@126.com</strong></p>\n","excerpt":"","more":"<h3 id=\"王卿，目前做Android\"><a href=\"#王卿，目前做Android\" class=\"headerlink\" title=\"王卿，目前做Android\"></a>王卿，目前做Android</h3><ul>\n<li>现居北京，就职于考拉FM，专注移动开发。</li>\n<li>喜欢研究一些新技术</li>\n</ul>\n<p><strong>近期研究的技术主要是:</strong></p>\n<ul>\n<li>groovy (是gradle 的基础)</li>\n<li>DSL (领域语言，有了groovy 的基础后，容易理解)</li>\n<li>gradle (学习了groovy, DSL 后看gradle 就容易很多了)</li>\n</ul>\n<h6 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h6><p>QQ：<strong>741227905</strong></p>\n<p>Email：<strong>741227905@qq.com</strong> Or <strong>gdky005@126.com</strong></p>\n"}],"Post":[{"title":"Android 和 IOS 应用查找bug 利器","date":"2015-09-26T07:12:50.000Z","keywords":null,"_content":"\n[来源: Trinea codeKK][3]\n\n\n查找bug 的神器： [bugtags][1]\n\n\n\n快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br>\n\n\n\t\t  Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n\t\t \n\t\t \n\n\n\n\n![][2]\n\n### 它在移动端是的主要功能包括：\n\n1. 任何地方快速标记 Bug，分配给对应开发\n跟他们官网说的一样，测试从未如此简单！\n\n2. 自动记录 App Crash Bug\nApp Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。\n\n3. 无网下次重传\n\n4. 摇一摇作为彩蛋\nBugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。\n\n\n\n\n### 传统的 App Bug 发现过程是这样的：\n\n> 测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发\n\n> 产品经理跑过来“这个这个地方有问题，你改下”\n\n> 老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug\n\n\n### 使用方式：\n1. 在 [bugtags][1] 里面集成开发对应的SDK，\n2. 添加依赖\n\t`compile 'com.bugtags.library:bugtags-lib:latest.integration'`\n3. 在 Application 初始化\n\n```\t\n\npublic class MyApplication extends Application {\n　@Override\n　public void onCreate() {\n　　super.onCreate();\n\n　　// 在这里初始化\n　　Bugtags.start(\"App key\", this, Bugtags.BTGInvocationEventBubble);\n　}\n}\n\n```\n\n### 添加回调\n\n```\npublic class BaseActivity extends Activity{\n　@Override\n　protected void onResume() {\n　　super.onResume();\n　　// 注：回调 1\n　　Bugtags.onResume(this);\n　}\n　@Override\n　protected void onPause() {\n　　super.onPause();\n　　// 注：回调 2\n　　Bugtags.onPause(this);\n　}\n　@Override\n　public boolean dispatchTouchEvent(MotionEvent event) {\n　　// 注：回调 3\n　　Bugtags.onDispatchTouchEvent(this, event);\n　　return super.dispatchTouchEvent(event);\n　}\n}\n\n```\n\n如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。\n\nPS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-> 授权管理->应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。\n\n<br>\n\n<br>\n\n<br>\n\n###### 目前他们也在计划开放 API，方便其他系统接入。\n\n\n\n\n\n---\n[1]: https://bugtags.com\n[2]: http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir","source":"_posts/Android-和-IOS-应用查找bug-利器.md","raw":"title: Android 和 IOS 应用查找bug 利器\ndate: 2015-09-26 15:12:50\ncategories:\nkeywords:\ntags: android\n---\n\n[来源: Trinea codeKK][3]\n\n\n查找bug 的神器： [bugtags][1]\n\n\n\n快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br>\n\n\n\t\t  Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n\t\t \n\t\t \n\n\n\n\n![][2]\n\n### 它在移动端是的主要功能包括：\n\n1. 任何地方快速标记 Bug，分配给对应开发\n跟他们官网说的一样，测试从未如此简单！\n\n2. 自动记录 App Crash Bug\nApp Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。\n\n3. 无网下次重传\n\n4. 摇一摇作为彩蛋\nBugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。\n\n\n\n\n### 传统的 App Bug 发现过程是这样的：\n\n> 测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发\n\n> 产品经理跑过来“这个这个地方有问题，你改下”\n\n> 老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug\n\n\n### 使用方式：\n1. 在 [bugtags][1] 里面集成开发对应的SDK，\n2. 添加依赖\n\t`compile 'com.bugtags.library:bugtags-lib:latest.integration'`\n3. 在 Application 初始化\n\n```\t\n\npublic class MyApplication extends Application {\n　@Override\n　public void onCreate() {\n　　super.onCreate();\n\n　　// 在这里初始化\n　　Bugtags.start(\"App key\", this, Bugtags.BTGInvocationEventBubble);\n　}\n}\n\n```\n\n### 添加回调\n\n```\npublic class BaseActivity extends Activity{\n　@Override\n　protected void onResume() {\n　　super.onResume();\n　　// 注：回调 1\n　　Bugtags.onResume(this);\n　}\n　@Override\n　protected void onPause() {\n　　super.onPause();\n　　// 注：回调 2\n　　Bugtags.onPause(this);\n　}\n　@Override\n　public boolean dispatchTouchEvent(MotionEvent event) {\n　　// 注：回调 3\n　　Bugtags.onDispatchTouchEvent(this, event);\n　　return super.dispatchTouchEvent(event);\n　}\n}\n\n```\n\n如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。\n\nPS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-> 授权管理->应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。\n\n<br>\n\n<br>\n\n<br>\n\n###### 目前他们也在计划开放 API，方便其他系统接入。\n\n\n\n\n\n---\n[1]: https://bugtags.com\n[2]: http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir","slug":"Android-和-IOS-应用查找bug-利器","published":1,"updated":"2015-09-26T07:33:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1xo0002rgexqx5iwk57","content":"<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">来源: Trinea codeKK</a></p>\n<p>查找bug 的神器： <a href=\"https://bugtags.com\" target=\"_blank\" rel=\"external\">bugtags</a></p>\n<p>快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br></p>\n<pre><code>Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n</code></pre><p><img src=\"http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"\"></p>\n<h3 id=\"它在移动端是的主要功能包括：\"><a href=\"#它在移动端是的主要功能包括：\" class=\"headerlink\" title=\"它在移动端是的主要功能包括：\"></a>它在移动端是的主要功能包括：</h3><ol>\n<li><p>任何地方快速标记 Bug，分配给对应开发<br>跟他们官网说的一样，测试从未如此简单！</p>\n</li>\n<li><p>自动记录 App Crash Bug<br>App Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。</p>\n</li>\n<li><p>无网下次重传</p>\n</li>\n<li><p>摇一摇作为彩蛋<br>Bugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。</p>\n</li>\n</ol>\n<h3 id=\"传统的-App-Bug-发现过程是这样的：\"><a href=\"#传统的-App-Bug-发现过程是这样的：\" class=\"headerlink\" title=\"传统的 App Bug 发现过程是这样的：\"></a>传统的 App Bug 发现过程是这样的：</h3><blockquote>\n<p>测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发</p>\n<p>产品经理跑过来“这个这个地方有问题，你改下”</p>\n<p>老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug</p>\n</blockquote>\n<h3 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h3><ol>\n<li>在 <a href=\"https://bugtags.com\" target=\"_blank\" rel=\"external\">bugtags</a> 里面集成开发对应的SDK，</li>\n<li>添加依赖<br> <code>compile &#39;com.bugtags.library:bugtags-lib:latest.integration&#39;</code></li>\n<li>在 Application 初始化</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">　<span class=\"meta\">@Override</span></span><br><span class=\"line\">　public void onCreate() &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"comment\">// 在这里初始化</span></span><br><span class=\"line\">　　<span class=\"type\">Bugtags</span>.start(<span class=\"string\">\"App key\"</span>, <span class=\"keyword\">this</span>, <span class=\"type\">Bugtags</span>.<span class=\"type\">BTGInvocationEventBubble</span>);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加回调\"><a href=\"#添加回调\" class=\"headerlink\" title=\"添加回调\"></a>添加回调</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">class</span> <span class=\"selector-tag\">BaseActivity</span> <span class=\"selector-tag\">extends</span> <span class=\"selector-tag\">Activity</span>&#123;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onResume() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onResume</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 1</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onResume</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onPause() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onPause</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 2</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onPause</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 3</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onDispatchTouchEvent</span>(this, event);</span><br><span class=\"line\">　　return super<span class=\"selector-class\">.dispatchTouchEvent</span>(event);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。</p>\n<p>PS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-&gt; 授权管理-&gt;应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。</p>\n<p><br></p>\n<p><br></p>\n<p><br></p>\n<h6 id=\"目前他们也在计划开放-API，方便其他系统接入。\"><a href=\"#目前他们也在计划开放-API，方便其他系统接入。\" class=\"headerlink\" title=\"目前他们也在计划开放 API，方便其他系统接入。\"></a>目前他们也在计划开放 API，方便其他系统接入。</h6><hr>\n","excerpt":"","more":"<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">来源: Trinea codeKK</a></p>\n<p>查找bug 的神器： <a href=\"https://bugtags.com\">bugtags</a></p>\n<p>快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br></p>\n<pre><code>Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。\n</code></pre><p><img src=\"http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"\"></p>\n<h3 id=\"它在移动端是的主要功能包括：\"><a href=\"#它在移动端是的主要功能包括：\" class=\"headerlink\" title=\"它在移动端是的主要功能包括：\"></a>它在移动端是的主要功能包括：</h3><ol>\n<li><p>任何地方快速标记 Bug，分配给对应开发<br>跟他们官网说的一样，测试从未如此简单！</p>\n</li>\n<li><p>自动记录 App Crash Bug<br>App Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。</p>\n</li>\n<li><p>无网下次重传</p>\n</li>\n<li><p>摇一摇作为彩蛋<br>Bugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。</p>\n</li>\n</ol>\n<h3 id=\"传统的-App-Bug-发现过程是这样的：\"><a href=\"#传统的-App-Bug-发现过程是这样的：\" class=\"headerlink\" title=\"传统的 App Bug 发现过程是这样的：\"></a>传统的 App Bug 发现过程是这样的：</h3><blockquote>\n<p>测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发</p>\n<p>产品经理跑过来“这个这个地方有问题，你改下”</p>\n<p>老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug</p>\n</blockquote>\n<h3 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h3><ol>\n<li>在 <a href=\"https://bugtags.com\">bugtags</a> 里面集成开发对应的SDK，</li>\n<li>添加依赖<br> <code>compile &#39;com.bugtags.library:bugtags-lib:latest.integration&#39;</code></li>\n<li>在 Application 初始化</li>\n</ol>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">Application</span> </span>&#123;</span><br><span class=\"line\">　<span class=\"meta\">@Override</span></span><br><span class=\"line\">　public void onCreate() &#123;</span><br><span class=\"line\">　　<span class=\"keyword\">super</span>.onCreate();</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"comment\">// 在这里初始化</span></span><br><span class=\"line\">　　<span class=\"type\">Bugtags</span>.start(<span class=\"string\">\"App key\"</span>, <span class=\"keyword\">this</span>, <span class=\"type\">Bugtags</span>.<span class=\"type\">BTGInvocationEventBubble</span>);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"添加回调\"><a href=\"#添加回调\" class=\"headerlink\" title=\"添加回调\"></a>添加回调</h3><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">class</span> <span class=\"selector-tag\">BaseActivity</span> <span class=\"selector-tag\">extends</span> <span class=\"selector-tag\">Activity</span>&#123;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onResume() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onResume</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 1</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onResume</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　protected void onPause() &#123;</span><br><span class=\"line\">　　super<span class=\"selector-class\">.onPause</span>();</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 2</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onPause</span>(this);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">　<span class=\"variable\">@Override</span></span><br><span class=\"line\">　public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class=\"line\">　　<span class=\"comment\">// 注：回调 3</span></span><br><span class=\"line\">　　Bugtags<span class=\"selector-class\">.onDispatchTouchEvent</span>(this, event);</span><br><span class=\"line\">　　return super<span class=\"selector-class\">.dispatchTouchEvent</span>(event);</span><br><span class=\"line\">　&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。</p>\n<p>PS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-&gt; 授权管理-&gt;应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。</p>\n<p><br></p>\n<p><br></p>\n<p><br></p>\n<h6 id=\"目前他们也在计划开放-API，方便其他系统接入。\"><a href=\"#目前他们也在计划开放-API，方便其他系统接入。\" class=\"headerlink\" title=\"目前他们也在计划开放 API，方便其他系统接入。\"></a>目前他们也在计划开放 API，方便其他系统接入。</h6><hr>\n"},{"title":"Android_gradle工作原理","date":"2015-09-13T04:47:49.000Z","_content":"\n在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（*不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式*）。\n\n\n### gradle 构建流程：\n\n下图是google官方的构建流程图\n\n![andoroid gradle工作原理图][1]\n\n### 简单可以分为以下几类：\n\n1. AndroidManifest.xml 合并\n2. Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并\n3. Asserts 合并\n\n**以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。**\n\n\n\n\n\n\n---\n[1]: http://i1.tietuku.com/4fa0701d09e5704a.png","source":"_posts/Android-gradle工作原理.md","raw":"title: Android_gradle工作原理\ndate: 2015-09-13 12:47:49\ntags: android gradle工作原理\n---\n\n在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（*不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式*）。\n\n\n### gradle 构建流程：\n\n下图是google官方的构建流程图\n\n![andoroid gradle工作原理图][1]\n\n### 简单可以分为以下几类：\n\n1. AndroidManifest.xml 合并\n2. Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并\n3. Asserts 合并\n\n**以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。**\n\n\n\n\n\n\n---\n[1]: http://i1.tietuku.com/4fa0701d09e5704a.png","slug":"Android-gradle工作原理","published":1,"updated":"2015-09-13T04:52:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1xu0004rgexwt6wp622","content":"<p>在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（<em>不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式</em>）。</p>\n<h3 id=\"gradle-构建流程：\"><a href=\"#gradle-构建流程：\" class=\"headerlink\" title=\"gradle 构建流程：\"></a>gradle 构建流程：</h3><p>下图是google官方的构建流程图</p>\n<p><img src=\"http://i1.tietuku.com/4fa0701d09e5704a.png\" alt=\"andoroid gradle工作原理图\"></p>\n<h3 id=\"简单可以分为以下几类：\"><a href=\"#简单可以分为以下几类：\" class=\"headerlink\" title=\"简单可以分为以下几类：\"></a>简单可以分为以下几类：</h3><ol>\n<li>AndroidManifest.xml 合并</li>\n<li>Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并</li>\n<li>Asserts 合并</li>\n</ol>\n<p><strong>以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。</strong></p>\n<hr>\n","excerpt":"","more":"<p>在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（<em>不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式</em>）。</p>\n<h3 id=\"gradle-构建流程：\"><a href=\"#gradle-构建流程：\" class=\"headerlink\" title=\"gradle 构建流程：\"></a>gradle 构建流程：</h3><p>下图是google官方的构建流程图</p>\n<p><img src=\"http://i1.tietuku.com/4fa0701d09e5704a.png\" alt=\"andoroid gradle工作原理图\"></p>\n<h3 id=\"简单可以分为以下几类：\"><a href=\"#简单可以分为以下几类：\" class=\"headerlink\" title=\"简单可以分为以下几类：\"></a>简单可以分为以下几类：</h3><ol>\n<li>AndroidManifest.xml 合并</li>\n<li>Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并</li>\n<li>Asserts 合并</li>\n</ol>\n<p><strong>以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。</strong></p>\n<hr>\n"},{"title":"JADX反编译源码更easy","date":"2016-02-24T03:54:09.000Z","keywords":null,"_content":"\n\n### JADX反编译源码更easy\n\n> 一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高\n\nCommand line and GUI tools for produce Java source code from Android Dex and Apk files\n\n![](https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67)\n\n\nDownloads\n\n- [unstable](https://drone.io/github.com/skylot/jadx/files)\n- from [github](https://github.com/skylot/jadx/releases)\n- from [sourceforge](http://sourceforge.net/projects/jadx/files/)\n\n\n\n\n参考地址：[ https://github.com/skylot/jadx ](#)","source":"_posts/APK反编译Jadx.md","raw":"title: JADX反编译源码更easy\ndate: 2016-02-24 11:54:09\ncategories:\nkeywords:\ntags:\n---\n\n\n### JADX反编译源码更easy\n\n> 一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高\n\nCommand line and GUI tools for produce Java source code from Android Dex and Apk files\n\n![](https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67)\n\n\nDownloads\n\n- [unstable](https://drone.io/github.com/skylot/jadx/files)\n- from [github](https://github.com/skylot/jadx/releases)\n- from [sourceforge](http://sourceforge.net/projects/jadx/files/)\n\n\n\n\n参考地址：[ https://github.com/skylot/jadx ](#)","slug":"APK反编译Jadx","published":1,"updated":"2016-02-24T04:01:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1y00006rgexsaw5tdn8","content":"<h3 id=\"JADX反编译源码更easy\"><a href=\"#JADX反编译源码更easy\" class=\"headerlink\" title=\"JADX反编译源码更easy\"></a>JADX反编译源码更easy</h3><blockquote>\n<p>一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高</p>\n</blockquote>\n<p>Command line and GUI tools for produce Java source code from Android Dex and Apk files</p>\n<p><img src=\"https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67\" alt=\"\"></p>\n<p>Downloads</p>\n<ul>\n<li><a href=\"https://drone.io/github.com/skylot/jadx/files\" target=\"_blank\" rel=\"external\">unstable</a></li>\n<li>from <a href=\"https://github.com/skylot/jadx/releases\" target=\"_blank\" rel=\"external\">github</a></li>\n<li>from <a href=\"http://sourceforge.net/projects/jadx/files/\" target=\"_blank\" rel=\"external\">sourceforge</a></li>\n</ul>\n<p>参考地址：<a href=\"#\"> https://github.com/skylot/jadx </a></p>\n","excerpt":"","more":"<h3 id=\"JADX反编译源码更easy\"><a href=\"#JADX反编译源码更easy\" class=\"headerlink\" title=\"JADX反编译源码更easy\"></a>JADX反编译源码更easy</h3><blockquote>\n<p>一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高</p>\n</blockquote>\n<p>Command line and GUI tools for produce Java source code from Android Dex and Apk files</p>\n<p><img src=\"https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67\" alt=\"\"></p>\n<p>Downloads</p>\n<ul>\n<li><a href=\"https://drone.io/github.com/skylot/jadx/files\">unstable</a></li>\n<li>from <a href=\"https://github.com/skylot/jadx/releases\">github</a></li>\n<li>from <a href=\"http://sourceforge.net/projects/jadx/files/\">sourceforge</a></li>\n</ul>\n<p>参考地址：<a href=\"#\"> https://github.com/skylot/jadx </a></p>\n"},{"title":"AndroidStudio","date":"2015-09-19T09:02:01.000Z","_content":"\nAndroid Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：\n\n- 1.修改系统hosts文件，添加如下2行\n\n\t\t203.208.46.146   dl-ssl.google.com\n\t\t203.208.46.146   dl.google.com\n\t\t\n- 2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行\n\n\t\t-Djava.net.preferIPv4Stack=true  \n\t\t-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n\t\t-Didea.patches.url=http://dl.google.com/android/studio/patches/\n\t\t\n\t**重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n**\n\n- 3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。\n- 4.android studio首次安装运行时卡在更新处理方法\n\t\n\t01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。\n\t\n\t02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加\n\t\t\n\t\tdisable.android.first.run=true \n\n\n本方法适用于在某些网络下无法直接更新的问题\n\n\n---\n\n","source":"_posts/AndroidStudio.md","raw":"title: AndroidStudio\ndate: 2015-09-19 17:02:01\ntags: AndroidStudio\n---\n\nAndroid Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：\n\n- 1.修改系统hosts文件，添加如下2行\n\n\t\t203.208.46.146   dl-ssl.google.com\n\t\t203.208.46.146   dl.google.com\n\t\t\n- 2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行\n\n\t\t-Djava.net.preferIPv4Stack=true  \n\t\t-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n\t\t-Didea.patches.url=http://dl.google.com/android/studio/patches/\n\t\t\n\t**重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n**\n\n- 3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。\n- 4.android studio首次安装运行时卡在更新处理方法\n\t\n\t01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。\n\t\n\t02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加\n\t\t\n\t\tdisable.android.first.run=true \n\n\n本方法适用于在某些网络下无法直接更新的问题\n\n\n---\n\n","slug":"AndroidStudio","published":1,"updated":"2015-11-03T02:21:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1y40007rgexyv2mqfuw","content":"<p>Android Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：</p>\n<ul>\n<li><p>1.修改系统hosts文件，添加如下2行</p>\n<pre><code>203.208.46.146   dl-ssl.google.com\n203.208.46.146   dl.google.com\n</code></pre></li>\n<li><p>2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行</p>\n<pre><code>-Djava.net.preferIPv4Stack=true  \n-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n-Didea.patches.url=http://dl.google.com/android/studio/patches/\n</code></pre><p>  <strong>重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n</strong></p>\n</li>\n<li><p>3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。</p>\n</li>\n<li><p>4.android studio首次安装运行时卡在更新处理方法</p>\n<p>  01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。</p>\n<p>  02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加</p>\n<pre><code>disable.android.first.run=true \n</code></pre></li>\n</ul>\n<p>本方法适用于在某些网络下无法直接更新的问题</p>\n<hr>\n","excerpt":"","more":"<p>Android Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：</p>\n<ul>\n<li><p>1.修改系统hosts文件，添加如下2行</p>\n<pre><code>203.208.46.146   dl-ssl.google.com\n203.208.46.146   dl.google.com\n</code></pre></li>\n<li><p>2.修改Android Studio\\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行</p>\n<pre><code>-Djava.net.preferIPv4Stack=true  \n-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  \n-Didea.patches.url=http://dl.google.com/android/studio/patches/\n</code></pre><p>  <strong>重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。\n</strong></p>\n</li>\n<li><p>3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。</p>\n</li>\n<li><p>4.android studio首次安装运行时卡在更新处理方法</p>\n<p>  01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。</p>\n<p>  02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加</p>\n<pre><code>disable.android.first.run=true \n</code></pre></li>\n</ul>\n<p>本方法适用于在某些网络下无法直接更新的问题</p>\n<hr>\n"},{"title":"Android在图形界面UI方面的工具","date":"2015-10-09T07:03:19.000Z","keywords":null,"_content":"#### [来源][1]\n\n\n\n之前折腾过一些Android的UI，比如：\n\n### 9patch方面的：\n\n[【记录】继续为Android的EditText制作9 patch图片][2]\n\n其中用到了，无意间发现的，用于专门制作9 patch的在线工具：\n\n[Android Holo Colors][3]\n\n然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：\n\n[Android Asset Studio][4]\n\n其中包含与UI有关的，很多方面的工具：\n\n### 图标有关的\n\n- [Launcher icons][5] ：制作启动界面的图片的？\n- [Action bar and tab icons][6] ：工具栏的图片\n- [Notification icons ][7]：通知栏图片\n- [Navigation drawer indicator][8] ：导航栏图片\n- [Generic icons][9] ：通用的图片\n- [Tab icons (pre-Android 3.0)][10] ：旧的Tab的图片\n- [Menu icons (pre-Android 3.0) ][11]：旧的菜单的图片\n\n### 其他的生成器\n\n[Device frame generator][12] (or see the [official version for Nexus devices][13] ) ：设备帧？\n[Simple nine-patch generator][14] ：简单的9 patch图片生成器\n社区提供的工具\n\n[Android Action Bar Style Generator][15] by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片\n[Android Holo Colors Generator][16] by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。\n总之：\n\n这些工具，都还是很好用的。\n\n当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。\n\n\n---\n[1]: http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\n[2]: http://www.crifan.com/android_make_9_patch_for_edittext/\n[3]: http://android-holo-colors.com/\n[4]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\n[5]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\n[6]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\n[7]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\n[8]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\n[9]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\n[10]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\n[11]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\n[12]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\n[13]: http://developer.android.com/distribute/promote/device-art.html\n[14]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\n[15]: http://jgilfelt.github.com/android-actionbarstylegenerator/\n[16]: http://android-holo-colors.com/\n\n","source":"_posts/Android在图形界面UI方面的工具.md","raw":"title: Android在图形界面UI方面的工具\ndate: 2015-10-09 15:03:19\ncategories:\nkeywords:\ntags: android\n---\n#### [来源][1]\n\n\n\n之前折腾过一些Android的UI，比如：\n\n### 9patch方面的：\n\n[【记录】继续为Android的EditText制作9 patch图片][2]\n\n其中用到了，无意间发现的，用于专门制作9 patch的在线工具：\n\n[Android Holo Colors][3]\n\n然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：\n\n[Android Asset Studio][4]\n\n其中包含与UI有关的，很多方面的工具：\n\n### 图标有关的\n\n- [Launcher icons][5] ：制作启动界面的图片的？\n- [Action bar and tab icons][6] ：工具栏的图片\n- [Notification icons ][7]：通知栏图片\n- [Navigation drawer indicator][8] ：导航栏图片\n- [Generic icons][9] ：通用的图片\n- [Tab icons (pre-Android 3.0)][10] ：旧的Tab的图片\n- [Menu icons (pre-Android 3.0) ][11]：旧的菜单的图片\n\n### 其他的生成器\n\n[Device frame generator][12] (or see the [official version for Nexus devices][13] ) ：设备帧？\n[Simple nine-patch generator][14] ：简单的9 patch图片生成器\n社区提供的工具\n\n[Android Action Bar Style Generator][15] by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片\n[Android Holo Colors Generator][16] by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。\n总之：\n\n这些工具，都还是很好用的。\n\n当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。\n\n\n---\n[1]: http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\n[2]: http://www.crifan.com/android_make_9_patch_for_edittext/\n[3]: http://android-holo-colors.com/\n[4]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\n[5]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\n[6]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\n[7]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\n[8]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\n[9]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\n[10]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\n[11]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\n[12]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\n[13]: http://developer.android.com/distribute/promote/device-art.html\n[14]: http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\n[15]: http://jgilfelt.github.com/android-actionbarstylegenerator/\n[16]: http://android-holo-colors.com/\n\n","slug":"Android在图形界面UI方面的工具","published":1,"updated":"2015-10-09T07:14:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1y80009rgexkhas901n","content":"<h4 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a><a href=\"http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\" target=\"_blank\" rel=\"external\">来源</a></h4><p>之前折腾过一些Android的UI，比如：</p>\n<h3 id=\"9patch方面的：\"><a href=\"#9patch方面的：\" class=\"headerlink\" title=\"9patch方面的：\"></a>9patch方面的：</h3><p><a href=\"http://www.crifan.com/android_make_9_patch_for_edittext/\" target=\"_blank\" rel=\"external\">【记录】继续为Android的EditText制作9 patch图片</a></p>\n<p>其中用到了，无意间发现的，用于专门制作9 patch的在线工具：</p>\n<p><a href=\"http://android-holo-colors.com/\" target=\"_blank\" rel=\"external\">Android Holo Colors</a></p>\n<p>然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：</p>\n<p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\" target=\"_blank\" rel=\"external\">Android Asset Studio</a></p>\n<p>其中包含与UI有关的，很多方面的工具：</p>\n<h3 id=\"图标有关的\"><a href=\"#图标有关的\" class=\"headerlink\" title=\"图标有关的\"></a>图标有关的</h3><ul>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\" target=\"_blank\" rel=\"external\">Launcher icons</a> ：制作启动界面的图片的？</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\" target=\"_blank\" rel=\"external\">Action bar and tab icons</a> ：工具栏的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\" target=\"_blank\" rel=\"external\">Notification icons </a>：通知栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\" target=\"_blank\" rel=\"external\">Navigation drawer indicator</a> ：导航栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\" target=\"_blank\" rel=\"external\">Generic icons</a> ：通用的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\" target=\"_blank\" rel=\"external\">Tab icons (pre-Android 3.0)</a> ：旧的Tab的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\" target=\"_blank\" rel=\"external\">Menu icons (pre-Android 3.0) </a>：旧的菜单的图片</li>\n</ul>\n<h3 id=\"其他的生成器\"><a href=\"#其他的生成器\" class=\"headerlink\" title=\"其他的生成器\"></a>其他的生成器</h3><p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\" target=\"_blank\" rel=\"external\">Device frame generator</a> (or see the <a href=\"http://developer.android.com/distribute/promote/device-art.html\" target=\"_blank\" rel=\"external\">official version for Nexus devices</a> ) ：设备帧？<br><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\" target=\"_blank\" rel=\"external\">Simple nine-patch generator</a> ：简单的9 patch图片生成器<br>社区提供的工具</p>\n<p><a href=\"http://jgilfelt.github.com/android-actionbarstylegenerator/\" target=\"_blank\" rel=\"external\">Android Action Bar Style Generator</a> by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片<br><a href=\"http://android-holo-colors.com/\" target=\"_blank\" rel=\"external\">Android Holo Colors Generator</a> by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。<br>总之：</p>\n<p>这些工具，都还是很好用的。</p>\n<p>当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。</p>\n<hr>\n","excerpt":"","more":"<h4 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a><a href=\"http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool\">来源</a></h4><p>之前折腾过一些Android的UI，比如：</p>\n<h3 id=\"9patch方面的：\"><a href=\"#9patch方面的：\" class=\"headerlink\" title=\"9patch方面的：\"></a>9patch方面的：</h3><p><a href=\"http://www.crifan.com/android_make_9_patch_for_edittext/\">【记录】继续为Android的EditText制作9 patch图片</a></p>\n<p>其中用到了，无意间发现的，用于专门制作9 patch的在线工具：</p>\n<p><a href=\"http://android-holo-colors.com/\">Android Holo Colors</a></p>\n<p>然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：</p>\n<p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html\">Android Asset Studio</a></p>\n<p>其中包含与UI有关的，很多方面的工具：</p>\n<h3 id=\"图标有关的\"><a href=\"#图标有关的\" class=\"headerlink\" title=\"图标有关的\"></a>图标有关的</h3><ul>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html\">Launcher icons</a> ：制作启动界面的图片的？</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html\">Action bar and tab icons</a> ：工具栏的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html\">Notification icons </a>：通知栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html\">Navigation drawer indicator</a> ：导航栏图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html\">Generic icons</a> ：通用的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html\">Tab icons (pre-Android 3.0)</a> ：旧的Tab的图片</li>\n<li><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html\">Menu icons (pre-Android 3.0) </a>：旧的菜单的图片</li>\n</ul>\n<h3 id=\"其他的生成器\"><a href=\"#其他的生成器\" class=\"headerlink\" title=\"其他的生成器\"></a>其他的生成器</h3><p><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html\">Device frame generator</a> (or see the <a href=\"http://developer.android.com/distribute/promote/device-art.html\">official version for Nexus devices</a> ) ：设备帧？<br><a href=\"http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html\">Simple nine-patch generator</a> ：简单的9 patch图片生成器<br>社区提供的工具</p>\n<p><a href=\"http://jgilfelt.github.com/android-actionbarstylegenerator/\">Android Action Bar Style Generator</a> by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片<br><a href=\"http://android-holo-colors.com/\">Android Holo Colors Generator</a> by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。<br>总之：</p>\n<p>这些工具，都还是很好用的。</p>\n<p>当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。</p>\n<hr>\n"},{"title":"Android开发者提升技能水平的大招","date":"2016-02-19T09:40:14.000Z","keywords":null,"_content":"<br>\n国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。\n\n> 本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。\n\n### 参加活动，沙龙，技术聚会：\n\n参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。\n\n### 参加培训：\n\n公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。\n\n### 参加讨论会：\n\n参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。\n\n### 回答问题：\n\n个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。\n\n### 边吃边学：\n\n如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。\n\n### 加入一个开源项目：\n\n开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。\n\n### 读书，读代码，读博客：\n\n可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。\n\n### 发表博客：\n\n编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。\n\n### 通过做Kata来实践：\n\nKata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。\n\n### 写书：\n\n在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。\n\n这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。\n\n### 看视频教程，听播客，看在线研讨会：\n\n从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。\n\n在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：\n\n![](http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg)\n\n\n**很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？**\n\n<br>\n\n来自：[ http://mobile.51cto.com/anews-417838.htm ](#)\n\n参考：[ https://www.zhihu.com/question/20217218 ](#)","source":"_posts/Android开发者提升技能水平的大招.md","raw":"title: Android开发者提升技能水平的大招\ndate: 2016-02-19 17:40:14\ncategories:\nkeywords:\ntags: 技能提升\n---\n<br>\n国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。\n\n> 本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。\n\n### 参加活动，沙龙，技术聚会：\n\n参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。\n\n### 参加培训：\n\n公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。\n\n### 参加讨论会：\n\n参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。\n\n### 回答问题：\n\n个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。\n\n### 边吃边学：\n\n如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。\n\n### 加入一个开源项目：\n\n开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。\n\n### 读书，读代码，读博客：\n\n可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。\n\n### 发表博客：\n\n编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。\n\n### 通过做Kata来实践：\n\nKata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。\n\n### 写书：\n\n在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。\n\n这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。\n\n### 看视频教程，听播客，看在线研讨会：\n\n从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。\n\n在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：\n\n![](http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg)\n\n\n**很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？**\n\n<br>\n\n来自：[ http://mobile.51cto.com/anews-417838.htm ](#)\n\n参考：[ https://www.zhihu.com/question/20217218 ](#)","slug":"Android开发者提升技能水平的大招","published":1,"updated":"2016-02-22T02:40:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yc000brgexvptu38n8","content":"<p><br><br>国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。</p>\n<blockquote>\n<p>本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。</p>\n</blockquote>\n<h3 id=\"参加活动，沙龙，技术聚会：\"><a href=\"#参加活动，沙龙，技术聚会：\" class=\"headerlink\" title=\"参加活动，沙龙，技术聚会：\"></a>参加活动，沙龙，技术聚会：</h3><p>参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。</p>\n<h3 id=\"参加培训：\"><a href=\"#参加培训：\" class=\"headerlink\" title=\"参加培训：\"></a>参加培训：</h3><p>公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。</p>\n<h3 id=\"参加讨论会：\"><a href=\"#参加讨论会：\" class=\"headerlink\" title=\"参加讨论会：\"></a>参加讨论会：</h3><p>参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。</p>\n<h3 id=\"回答问题：\"><a href=\"#回答问题：\" class=\"headerlink\" title=\"回答问题：\"></a>回答问题：</h3><p>个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。</p>\n<h3 id=\"边吃边学：\"><a href=\"#边吃边学：\" class=\"headerlink\" title=\"边吃边学：\"></a>边吃边学：</h3><p>如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。</p>\n<h3 id=\"加入一个开源项目：\"><a href=\"#加入一个开源项目：\" class=\"headerlink\" title=\"加入一个开源项目：\"></a>加入一个开源项目：</h3><p>开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。</p>\n<h3 id=\"读书，读代码，读博客：\"><a href=\"#读书，读代码，读博客：\" class=\"headerlink\" title=\"读书，读代码，读博客：\"></a>读书，读代码，读博客：</h3><p>可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。</p>\n<h3 id=\"发表博客：\"><a href=\"#发表博客：\" class=\"headerlink\" title=\"发表博客：\"></a>发表博客：</h3><p>编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。</p>\n<h3 id=\"通过做Kata来实践：\"><a href=\"#通过做Kata来实践：\" class=\"headerlink\" title=\"通过做Kata来实践：\"></a>通过做Kata来实践：</h3><p>Kata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。</p>\n<h3 id=\"写书：\"><a href=\"#写书：\" class=\"headerlink\" title=\"写书：\"></a>写书：</h3><p>在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。</p>\n<p>这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。</p>\n<h3 id=\"看视频教程，听播客，看在线研讨会：\"><a href=\"#看视频教程，听播客，看在线研讨会：\" class=\"headerlink\" title=\"看视频教程，听播客，看在线研讨会：\"></a>看视频教程，听播客，看在线研讨会：</h3><p>从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。</p>\n<p>在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：</p>\n<p><img src=\"http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg\" alt=\"\"></p>\n<p><strong>很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？</strong></p>\n<p><br></p>\n<p>来自：<a href=\"#\"> http://mobile.51cto.com/anews-417838.htm </a></p>\n<p>参考：<a href=\"#\"> https://www.zhihu.com/question/20217218 </a></p>\n","excerpt":"","more":"<p><br><br>国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。</p>\n<blockquote>\n<p>本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。</p>\n</blockquote>\n<h3 id=\"参加活动，沙龙，技术聚会：\"><a href=\"#参加活动，沙龙，技术聚会：\" class=\"headerlink\" title=\"参加活动，沙龙，技术聚会：\"></a>参加活动，沙龙，技术聚会：</h3><p>参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。</p>\n<h3 id=\"参加培训：\"><a href=\"#参加培训：\" class=\"headerlink\" title=\"参加培训：\"></a>参加培训：</h3><p>公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。</p>\n<h3 id=\"参加讨论会：\"><a href=\"#参加讨论会：\" class=\"headerlink\" title=\"参加讨论会：\"></a>参加讨论会：</h3><p>参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。</p>\n<h3 id=\"回答问题：\"><a href=\"#回答问题：\" class=\"headerlink\" title=\"回答问题：\"></a>回答问题：</h3><p>个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。</p>\n<h3 id=\"边吃边学：\"><a href=\"#边吃边学：\" class=\"headerlink\" title=\"边吃边学：\"></a>边吃边学：</h3><p>如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。</p>\n<h3 id=\"加入一个开源项目：\"><a href=\"#加入一个开源项目：\" class=\"headerlink\" title=\"加入一个开源项目：\"></a>加入一个开源项目：</h3><p>开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。</p>\n<h3 id=\"读书，读代码，读博客：\"><a href=\"#读书，读代码，读博客：\" class=\"headerlink\" title=\"读书，读代码，读博客：\"></a>读书，读代码，读博客：</h3><p>可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。</p>\n<h3 id=\"发表博客：\"><a href=\"#发表博客：\" class=\"headerlink\" title=\"发表博客：\"></a>发表博客：</h3><p>编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。</p>\n<h3 id=\"通过做Kata来实践：\"><a href=\"#通过做Kata来实践：\" class=\"headerlink\" title=\"通过做Kata来实践：\"></a>通过做Kata来实践：</h3><p>Kata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。</p>\n<h3 id=\"写书：\"><a href=\"#写书：\" class=\"headerlink\" title=\"写书：\"></a>写书：</h3><p>在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。</p>\n<p>这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。</p>\n<h3 id=\"看视频教程，听播客，看在线研讨会：\"><a href=\"#看视频教程，听播客，看在线研讨会：\" class=\"headerlink\" title=\"看视频教程，听播客，看在线研讨会：\"></a>看视频教程，听播客，看在线研讨会：</h3><p>从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。</p>\n<p>在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：</p>\n<p><img src=\"http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg\" alt=\"\"></p>\n<p><strong>很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？</strong></p>\n<p><br></p>\n<p>来自：<a href=\"#\"> http://mobile.51cto.com/anews-417838.htm </a></p>\n<p>参考：<a href=\"#\"> https://www.zhihu.com/question/20217218 </a></p>\n"},{"title":"Bug小记(**贵金属)","date":"2015-11-20T10:24:09.000Z","keywords":null,"_content":"# Bug 小记（\\*\\*贵金属）\n\n**作者：球儿**\n\n\n最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：\n####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击\n\n\n使用 GCD 写的倒计时，源代码：\n \n    _isCountDown = YES;\n    __block int timeout=kCountdownTime; //倒计时时间\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\n    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\n    dispatch_source_set_event_handler(_timer, ^{\n        if(timeout<=0){ //倒计时结束，关闭\n            dispatch_source_cancel(_timer);\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n                \n                [self.getSmsCodeBtn setEnabled:YES];\n                _isCountDown = NO;\n            });\n        }else{\n            NSString *strTime = [NSString stringWithFormat:@\"%ds后重发\",timeout];\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n            });\n            timeout--;\n            \n        }\n    });\n    dispatch_resume(_timer);\n\n\n\n如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 [http://blog.csdn.net/zhangyanshen/article/details/46910515][1]\n\n\n\n<font color=green>**解决方案：**</font>\n\n`[sendAuthCodeBtn setTitle:@\"发送验证码\" forState:UIControlStateDisabled];` \n\n\n关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。\n\n</br>\n#### Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\n</br>\nUIButton 设置 title时会闪烁。\n\n<font color=brown>**原因：**</font>UIButton 的 buttonType 是 System 类型时会出现该种问题\n\n<font color=green>**解决方案：**</font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。\n\n</br>\n#### Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\n</br>\nplist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。\n\n<font color=brown>**原因：**</font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。\n\n<font color=green>**解决方案：**</font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）\n\n\n[1]:\thttp://blog.csdn.net/zhangyanshen/article/details/46910515 \"http://blog.csdn.net/zhangyanshen/article/details/46910515\"","source":"_posts/Bug小记-贵金属.md","raw":"title: 'Bug小记(**贵金属)'\ndate: 2015-11-20 18:24:09\ncategories:\nkeywords:\ntags: ios\n---\n# Bug 小记（\\*\\*贵金属）\n\n**作者：球儿**\n\n\n最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：\n####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击\n\n\n使用 GCD 写的倒计时，源代码：\n \n    _isCountDown = YES;\n    __block int timeout=kCountdownTime; //倒计时时间\n    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n    dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\n    dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\n    dispatch_source_set_event_handler(_timer, ^{\n        if(timeout<=0){ //倒计时结束，关闭\n            dispatch_source_cancel(_timer);\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:@\"重新获取\" forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n                \n                [self.getSmsCodeBtn setEnabled:YES];\n                _isCountDown = NO;\n            });\n        }else{\n            NSString *strTime = [NSString stringWithFormat:@\"%ds后重发\",timeout];\n            dispatch_async(dispatch_get_main_queue(), ^{\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n                [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n                [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n            });\n            timeout--;\n            \n        }\n    });\n    dispatch_resume(_timer);\n\n\n\n如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 [http://blog.csdn.net/zhangyanshen/article/details/46910515][1]\n\n\n\n<font color=green>**解决方案：**</font>\n\n`[sendAuthCodeBtn setTitle:@\"发送验证码\" forState:UIControlStateDisabled];` \n\n\n关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。\n\n</br>\n#### Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\n</br>\nUIButton 设置 title时会闪烁。\n\n<font color=brown>**原因：**</font>UIButton 的 buttonType 是 System 类型时会出现该种问题\n\n<font color=green>**解决方案：**</font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。\n\n</br>\n#### Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\n</br>\nplist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。\n\n<font color=brown>**原因：**</font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。\n\n<font color=green>**解决方案：**</font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）\n\n\n[1]:\thttp://blog.csdn.net/zhangyanshen/article/details/46910515 \"http://blog.csdn.net/zhangyanshen/article/details/46910515\"","slug":"Bug小记-贵金属","published":1,"updated":"2015-11-20T10:32:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yh000drgexbfnl0tws","content":"<h1 id=\"Bug-小记（-贵金属）\"><a href=\"#Bug-小记（-贵金属）\" class=\"headerlink\" title=\"Bug 小记（**贵金属）\"></a>Bug 小记（**贵金属）</h1><p><strong>作者：球儿</strong></p>\n<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：</p>\n<p>####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击</p>\n<p>使用 GCD 写的倒计时，源代码：</p>\n<pre><code>_isCountDown = YES;\n__block int timeout=kCountdownTime; //倒计时时间\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\ndispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\ndispatch_source_set_event_handler(_timer, ^{\n    if(timeout&lt;=0){ //倒计时结束，关闭\n        dispatch_source_cancel(_timer);\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n\n            [self.getSmsCodeBtn setEnabled:YES];\n            _isCountDown = NO;\n        });\n    }else{\n        NSString *strTime = [NSString stringWithFormat:@&quot;%ds后重发&quot;,timeout];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n        });\n        timeout--;\n\n    }\n});\ndispatch_resume(_timer);\n</code></pre><p>如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 <a href=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\" title=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zhangyanshen/article/details/46910515</a></p>\n<font color=\"green\"><strong>解决方案：</strong></font>\n\n<p><code>[sendAuthCodeBtn setTitle:@&quot;发送验证码&quot; forState:UIControlStateDisabled];</code> </p>\n<p>关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。</p>\n<p><br></p>\n<h4 id=\"Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\"><a href=\"#Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\" class=\"headerlink\" title=\"Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\"></a>Bug1：倒计时 UIButton 上的文字变更会有闪烁效果</h4><p><br><br>UIButton 设置 title时会闪烁。</p>\n<p><font color=\"brown\"><strong>原因：</strong></font>UIButton 的 buttonType 是 System 类型时会出现该种问题</p>\n<p><font color=\"green\"><strong>解决方案：</strong></font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。</p>\n<p><br></p>\n<h4 id=\"Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"><a href=\"#Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\" class=\"headerlink\" title=\"Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"></a>Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变</h4><p><br><br>plist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。</p>\n<p><font color=\"brown\"><strong>原因：</strong></font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。</p>\n<p><font color=\"green\"><strong>解决方案：</strong></font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）</p>\n","excerpt":"","more":"<h1 id=\"Bug-小记（-贵金属）\"><a href=\"#Bug-小记（-贵金属）\" class=\"headerlink\" title=\"Bug 小记（**贵金属）\"></a>Bug 小记（**贵金属）</h1><p><strong>作者：球儿</strong></p>\n<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：</p>\n<p>####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击</p>\n<p>使用 GCD 写的倒计时，源代码：</p>\n<pre><code>_isCountDown = YES;\n__block int timeout=kCountdownTime; //倒计时时间\ndispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\ndispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);\ndispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行\ndispatch_source_set_event_handler(_timer, ^{\n    if(timeout&lt;=0){ //倒计时结束，关闭\n        dispatch_source_cancel(_timer);\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];\n\n            [self.getSmsCodeBtn setEnabled:YES];\n            _isCountDown = NO;\n        });\n    }else{\n        NSString *strTime = [NSString stringWithFormat:@&quot;%ds后重发&quot;,timeout];\n        dispatch_async(dispatch_get_main_queue(), ^{\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];\n            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];\n\n            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];\n        });\n        timeout--;\n\n    }\n});\ndispatch_resume(_timer);\n</code></pre><p>如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 <a href=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\" title=\"http://blog.csdn.net/zhangyanshen/article/details/46910515\">http://blog.csdn.net/zhangyanshen/article/details/46910515</a></p>\n<font color=green><strong>解决方案：</strong></font>\n\n<p><code>[sendAuthCodeBtn setTitle:@&quot;发送验证码&quot; forState:UIControlStateDisabled];</code> </p>\n<p>关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。</p>\n<p></br></p>\n<h4 id=\"Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\"><a href=\"#Bug1：倒计时-UIButton-上的文字变更会有闪烁效果\" class=\"headerlink\" title=\"Bug1：倒计时 UIButton 上的文字变更会有闪烁效果\"></a>Bug1：倒计时 UIButton 上的文字变更会有闪烁效果</h4><p></br><br>UIButton 设置 title时会闪烁。</p>\n<p><font color=brown><strong>原因：</strong></font>UIButton 的 buttonType 是 System 类型时会出现该种问题</p>\n<p><font color=green><strong>解决方案：</strong></font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。</p>\n<p></br></p>\n<h4 id=\"Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"><a href=\"#Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\" class=\"headerlink\" title=\"Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变\"></a>Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变</h4><p></br><br>plist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。</p>\n<p><font color=brown><strong>原因：</strong></font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。</p>\n<p><font color=green><strong>解决方案：</strong></font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）</p>\n"},{"title":"Android录音使用 byte 类型获取分贝或声音振幅","date":"2015-10-08T10:10:20.000Z","keywords":"获取分贝值","_content":"\n以下是获取声音振幅的代码：\n\n\n\ttry {\n            while (isRecording) {\n                read = audioRecord.read(data, 0, recBufSize);\n\t//                L.i(context, \"开始获取音频TTT：\" + data.length);\n                if (AudioRecord.ERROR_INVALID_OPERATION != read && retry <= 3) {\n\t//                    L.i(context, \"发出的音频TTT：\" + data.length);\n                    //录音成功，重置录音失败的次数\n                    retry = 0;\n                    int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                    long v = 0;\n                    long tv = 0;\n                    // 将 data 内容取出，进行平方和运算\n                    for (int i = 0; i < data.length; i+=2) {\n                        tv = data[i+1] * 128 + data[i];\n                        tv *= tv;\n                        v += tv;\n                    }\n                    // 平方和除以数据总长度，得到音量大小。\n                    double mean = v / (double) read;\n                    double volume = 10 * Math.log10(mean * 2);\n                    KL.d(AudioThread.class, \"分贝值:\" + volume);\n\n                    EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                    KL.d(AudioThread.class, \"分贝值: {}，v = {}， read  = {}， mean = {}  \", volume, v,\n                            read, mean);\n\n\t//                    L.i(context, \"上传录音状态TTT：\" + up);\n\t//                    if (isTest) {\n\t//                        try {\n\t//                            os.write(data);\n\t//                        } catch (Exception e) {\n\t//                            e.printStackTrace();\n\t//                        }\n\t//                    }\n                } else {\n                    L.i(AudioThread.class, \"TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}\", read, retry);\n                    if (retry <= 3) {\n                        retry++;\n                    } else {\n                        isRecording = false;\n                        EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                        break;\n                    }\n\n                }\n\t//                L.i(context, \"上次音频TTT：\" + data.length);\n\n                Thread.sleep(10);\n\n                if (isRecording())\n                    pauseThread();\n            }\n\n\t//            if (isTest) {\n\t//                try {\n\t//                    os.close();\n\t//                } catch (IOException e) {\n\t//                    e.printStackTrace();\n\t//                }\n\t//            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            L.i(AudioThread.class, \"上传出现异常\");\n\n        }\n        \n        \n效果是：\n\n```\n当前接受到的分贝值: %s，v =15\n当前接受到的分贝值: %s，v =41\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =49\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =64\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =57\n当前接受到的分贝值: %s，v =60\n当前接受到的分贝值: %s，v =58\n当前接受到的分贝值: %s，v =55\n当前接受到的分贝值: %s，v =55\n```\n声音在0-100以内，基本声音维持在 40-60之间","source":"_posts/Android录音使用-byte-类型获取分贝或声音振幅.md","raw":"title: Android录音使用 byte 类型获取分贝或声音振幅\ndate: 2015-10-08 18:10:20\ncategories:\nkeywords: 获取分贝值\ntags: android录音\n---\n\n以下是获取声音振幅的代码：\n\n\n\ttry {\n            while (isRecording) {\n                read = audioRecord.read(data, 0, recBufSize);\n\t//                L.i(context, \"开始获取音频TTT：\" + data.length);\n                if (AudioRecord.ERROR_INVALID_OPERATION != read && retry <= 3) {\n\t//                    L.i(context, \"发出的音频TTT：\" + data.length);\n                    //录音成功，重置录音失败的次数\n                    retry = 0;\n                    int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                    long v = 0;\n                    long tv = 0;\n                    // 将 data 内容取出，进行平方和运算\n                    for (int i = 0; i < data.length; i+=2) {\n                        tv = data[i+1] * 128 + data[i];\n                        tv *= tv;\n                        v += tv;\n                    }\n                    // 平方和除以数据总长度，得到音量大小。\n                    double mean = v / (double) read;\n                    double volume = 10 * Math.log10(mean * 2);\n                    KL.d(AudioThread.class, \"分贝值:\" + volume);\n\n                    EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                    KL.d(AudioThread.class, \"分贝值: {}，v = {}， read  = {}， mean = {}  \", volume, v,\n                            read, mean);\n\n\t//                    L.i(context, \"上传录音状态TTT：\" + up);\n\t//                    if (isTest) {\n\t//                        try {\n\t//                            os.write(data);\n\t//                        } catch (Exception e) {\n\t//                            e.printStackTrace();\n\t//                        }\n\t//                    }\n                } else {\n                    L.i(AudioThread.class, \"TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}\", read, retry);\n                    if (retry <= 3) {\n                        retry++;\n                    } else {\n                        isRecording = false;\n                        EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                        break;\n                    }\n\n                }\n\t//                L.i(context, \"上次音频TTT：\" + data.length);\n\n                Thread.sleep(10);\n\n                if (isRecording())\n                    pauseThread();\n            }\n\n\t//            if (isTest) {\n\t//                try {\n\t//                    os.close();\n\t//                } catch (IOException e) {\n\t//                    e.printStackTrace();\n\t//                }\n\t//            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            L.i(AudioThread.class, \"上传出现异常\");\n\n        }\n        \n        \n效果是：\n\n```\n当前接受到的分贝值: %s，v =15\n当前接受到的分贝值: %s，v =41\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =42\n当前接受到的分贝值: %s，v =43\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =49\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =50\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =47\n当前接受到的分贝值: %s，v =48\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =46\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =44\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =45\n当前接受到的分贝值: %s，v =64\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =65\n当前接受到的分贝值: %s，v =57\n当前接受到的分贝值: %s，v =60\n当前接受到的分贝值: %s，v =58\n当前接受到的分贝值: %s，v =55\n当前接受到的分贝值: %s，v =55\n```\n声音在0-100以内，基本声音维持在 40-60之间","slug":"Android录音使用-byte-类型获取分贝或声音振幅","published":1,"updated":"2015-10-08T10:19:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yk000grgexq5s52oxn","content":"<p>以下是获取声音振幅的代码：</p>\n<pre><code>try {\n        while (isRecording) {\n            read = audioRecord.read(data, 0, recBufSize);\n//                L.i(context, &quot;开始获取音频TTT：&quot; + data.length);\n            if (AudioRecord.ERROR_INVALID_OPERATION != read &amp;&amp; retry &lt;= 3) {\n//                    L.i(context, &quot;发出的音频TTT：&quot; + data.length);\n                //录音成功，重置录音失败的次数\n                retry = 0;\n                int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                long v = 0;\n                long tv = 0;\n                // 将 data 内容取出，进行平方和运算\n                for (int i = 0; i &lt; data.length; i+=2) {\n                    tv = data[i+1] * 128 + data[i];\n                    tv *= tv;\n                    v += tv;\n                }\n                // 平方和除以数据总长度，得到音量大小。\n                double mean = v / (double) read;\n                double volume = 10 * Math.log10(mean * 2);\n                KL.d(AudioThread.class, &quot;分贝值:&quot; + volume);\n\n                EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                KL.d(AudioThread.class, &quot;分贝值: {}，v = {}， read  = {}， mean = {}  &quot;, volume, v,\n                        read, mean);\n\n//                    L.i(context, &quot;上传录音状态TTT：&quot; + up);\n//                    if (isTest) {\n//                        try {\n//                            os.write(data);\n//                        } catch (Exception e) {\n//                            e.printStackTrace();\n//                        }\n//                    }\n            } else {\n                L.i(AudioThread.class, &quot;TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}&quot;, read, retry);\n                if (retry &lt;= 3) {\n                    retry++;\n                } else {\n                    isRecording = false;\n                    EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                    break;\n                }\n\n            }\n//                L.i(context, &quot;上次音频TTT：&quot; + data.length);\n\n            Thread.sleep(10);\n\n            if (isRecording())\n                pauseThread();\n        }\n\n//            if (isTest) {\n//                try {\n//                    os.close();\n//                } catch (IOException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        L.i(AudioThread.class, &quot;上传出现异常&quot;);\n\n    }\n</code></pre><p>效果是：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">15</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">41</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">49</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">64</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">57</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">60</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">58</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br></pre></td></tr></table></figure>\n<p>声音在0-100以内，基本声音维持在 40-60之间</p>\n","excerpt":"","more":"<p>以下是获取声音振幅的代码：</p>\n<pre><code>try {\n        while (isRecording) {\n            read = audioRecord.read(data, 0, recBufSize);\n//                L.i(context, &quot;开始获取音频TTT：&quot; + data.length);\n            if (AudioRecord.ERROR_INVALID_OPERATION != read &amp;&amp; retry &lt;= 3) {\n//                    L.i(context, &quot;发出的音频TTT：&quot; + data.length);\n                //录音成功，重置录音失败的次数\n                retry = 0;\n                int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度\n\n                long v = 0;\n                long tv = 0;\n                // 将 data 内容取出，进行平方和运算\n                for (int i = 0; i &lt; data.length; i+=2) {\n                    tv = data[i+1] * 128 + data[i];\n                    tv *= tv;\n                    v += tv;\n                }\n                // 平方和除以数据总长度，得到音量大小。\n                double mean = v / (double) read;\n                double volume = 10 * Math.log10(mean * 2);\n                KL.d(AudioThread.class, &quot;分贝值:&quot; + volume);\n\n                EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);\n\n                KL.d(AudioThread.class, &quot;分贝值: {}，v = {}， read  = {}， mean = {}  &quot;, volume, v,\n                        read, mean);\n\n//                    L.i(context, &quot;上传录音状态TTT：&quot; + up);\n//                    if (isTest) {\n//                        try {\n//                            os.write(data);\n//                        } catch (Exception e) {\n//                            e.printStackTrace();\n//                        }\n//                    }\n            } else {\n                L.i(AudioThread.class, &quot;TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}&quot;, read, retry);\n                if (retry &lt;= 3) {\n                    retry++;\n                } else {\n                    isRecording = false;\n                    EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);\n                    break;\n                }\n\n            }\n//                L.i(context, &quot;上次音频TTT：&quot; + data.length);\n\n            Thread.sleep(10);\n\n            if (isRecording())\n                pauseThread();\n        }\n\n//            if (isTest) {\n//                try {\n//                    os.close();\n//                } catch (IOException e) {\n//                    e.printStackTrace();\n//                }\n//            }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        L.i(AudioThread.class, &quot;上传出现异常&quot;);\n\n    }\n</code></pre><p>效果是：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">15</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">41</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">42</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">43</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">49</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">50</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">47</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">48</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">46</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">44</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">45</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">64</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">65</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">57</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">60</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">58</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br><span class=\"line\">当前接受到的分贝值: <span class=\"built_in\">%s</span>，v =<span class=\"number\">55</span></span><br></pre></td></tr></table></figure>\n<p>声音在0-100以内，基本声音维持在 40-60之间</p>\n"},{"title":"Fragment not attached to Activity 异常","date":"2015-11-27T02:48:17.000Z","keywords":null,"_content":"\n\n### 关于Fragment（XXFragment） not attached to Activity 异常\n\n\n出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：[http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity ](http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0) 回答的主要是在调用\n\n\tgetResources().getString(R.string.app_name); \n\n之前增加一个判断isAdded(),两外说这个异常解决办法的有\n[http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity](http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity)\n\n这个是针对另外一种情况下的解决方式。\n\n### 在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\n\n\n\tBundle b = new Bundle(); \n\tb.putParcelable(\"bitmap\", bitmap2); \n\timageRecognitionFragment.setArguments(b); \n\n设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:\n\n\tjava.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n\n### 分析原因：\n\n你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。\n\n这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了\n","source":"_posts/Fragment-not-attached-to-Activity-异常.md","raw":"title: Fragment not attached to Activity 异常\ndate: 2015-11-27 10:48:17\ncategories:\nkeywords:\ntags: android\n---\n\n\n### 关于Fragment（XXFragment） not attached to Activity 异常\n\n\n出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：[http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity ](http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0) 回答的主要是在调用\n\n\tgetResources().getString(R.string.app_name); \n\n之前增加一个判断isAdded(),两外说这个异常解决办法的有\n[http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity](http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity)\n\n这个是针对另外一种情况下的解决方式。\n\n### 在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\n\n\n\tBundle b = new Bundle(); \n\tb.putParcelable(\"bitmap\", bitmap2); \n\timageRecognitionFragment.setArguments(b); \n\n设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:\n\n\tjava.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n\n### 分析原因：\n\n你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。\n\n这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了\n","slug":"Fragment-not-attached-to-Activity-异常","published":1,"updated":"2015-11-27T02:52:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1ym000hrgexjk358zay","content":"<h3 id=\"关于Fragment（XXFragment）-not-attached-to-Activity-异常\"><a href=\"#关于Fragment（XXFragment）-not-attached-to-Activity-异常\" class=\"headerlink\" title=\"关于Fragment（XXFragment） not attached to Activity 异常\"></a>关于Fragment（XXFragment） not attached to Activity 异常</h3><p>出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：<a href=\"http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity </a> 回答的主要是在调用</p>\n<pre><code>getResources().getString(R.string.app_name); \n</code></pre><p>之前增加一个判断isAdded(),两外说这个异常解决办法的有<br><a href=\"http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity</a></p>\n<p>这个是针对另外一种情况下的解决方式。</p>\n<h3 id=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"><a href=\"#在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\" class=\"headerlink\" title=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"></a>在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常</h3><pre><code>Bundle b = new Bundle(); \nb.putParcelable(&quot;bitmap&quot;, bitmap2); \nimageRecognitionFragment.setArguments(b); \n</code></pre><p>设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:</p>\n<pre><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n</code></pre><h3 id=\"分析原因：\"><a href=\"#分析原因：\" class=\"headerlink\" title=\"分析原因：\"></a>分析原因：</h3><p>你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。</p>\n<p>这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了</p>\n","excerpt":"","more":"<h3 id=\"关于Fragment（XXFragment）-not-attached-to-Activity-异常\"><a href=\"#关于Fragment（XXFragment）-not-attached-to-Activity-异常\" class=\"headerlink\" title=\"关于Fragment（XXFragment） not attached to Activity 异常\"></a>关于Fragment（XXFragment） not attached to Activity 异常</h3><p>出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：<a href=\"http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0\">http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity </a> 回答的主要是在调用</p>\n<pre><code>getResources().getString(R.string.app_name); \n</code></pre><p>之前增加一个判断isAdded(),两外说这个异常解决办法的有<br><a href=\"http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity\">http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity</a></p>\n<p>这个是针对另外一种情况下的解决方式。</p>\n<h3 id=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"><a href=\"#在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\" class=\"headerlink\" title=\"在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常\"></a>在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常</h3><pre><code>Bundle b = new Bundle(); \nb.putParcelable(&quot;bitmap&quot;, bitmap2); \nimageRecognitionFragment.setArguments(b); \n</code></pre><p>设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:</p>\n<pre><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState\n</code></pre><h3 id=\"分析原因：\"><a href=\"#分析原因：\" class=\"headerlink\" title=\"分析原因：\"></a>分析原因：</h3><p>你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。</p>\n<p>这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了</p>\n"},{"title":"RecyclerView的基类写法","date":"2015-11-17T03:01:47.000Z","keywords":null,"_content":"\n# RecyclerView的基类写法\n\n### KLBaseRecyclerAdapter\\<T\\> \n\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.LayoutInflater;\n\timport android.view.View;\n\timport android.view.ViewGroup;\n\n\timport java.util.ArrayList;\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/16.\n\t */\n\tpublic abstract class KLBaseRecyclerAdapter<T> extends RecyclerView.Adapter {\n\n\t    protected Context mContext;\n\t    protected LayoutInflater mInflater;\n\t    protected List<T> datas = new ArrayList<T>();\n\n\t    private View.OnClickListener onClickListener ;\n\n\t    public KLBaseRecyclerAdapter(Context context) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas = new ArrayList<T>();\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public KLBaseRecyclerAdapter(Context context, List<T> datas) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas.addAll(datas);\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public void setOnClickListener(View.OnClickListener onClickListener) {\n\t        this.onClickListener = onClickListener;\n\t    }\n\n\t    /**\n\t     * 加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void setData(List<T> datas) {\n\t        if (null != datas) {\n\t//            if (this.datas.size() > 0) {\n\t//                this.datas.clear();\n\t//            }\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    public List<T> getData() {\n\t        return this.datas;\n\t    }\n\n\t    public T getOneData(int potion) {\n\t        return datas.get(potion);\n\t    }\n\n\t    /**\n\t     * 上拉加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void addData(List<T> datas) {\n\t        if (null != datas) {\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    /**\n\t     * 清除数据源\n\t     */\n\t    public void clearData() {\n\t        if (datas != null) {\n\t            datas.clear();\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    @Override\n\t    public long getItemId(int position) {\n\t        return position;\n\t    }\n\n\t    @Override\n\t    public int getItemCount() {\n\t        return datas != null ? datas.size() : 0;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t        View view = mInflater.inflate(setConvertView(), parent, false);\n\t        return setViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n\t        onBindViewHolder((KLViewHolder)holder, position);\n\t    }\n\n\t    public abstract int setConvertView();\n\t    \n\t    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n\t    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n\t    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n\t        public KLViewHolder(View convertView) {\n\t            super(convertView);\n\n\t            initView(convertView);\n\n\t            if (onClickListener != null)\n\t                convertView.setOnClickListener(onClickListener);\n\t        }\n\n\t        abstract void initView(View convertView);\n\t    }\n\t}\n\n\n### 实现：\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.View;\n\timport android.widget.TextView;\n\n\timport com.zhuyongit.recyclerviewdemo.R;\n\timport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/17.\n\t */\n\tpublic class TestAdapter extends KLBaseRecyclerAdapter<NewsBean> {\n\n\t    public TestAdapter(Context context) {\n\t        super(context);\n\t    }\n\n\t    public TestAdapter(Context context, List<NewsBean> datas) {\n\t        super(context, datas);\n\t    }\n\n\t    @Override\n\t    public int setConvertView() {\n\t        return R.layout.grid_recycler_item_layout;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder setViewHolder(View view) {\n\t        return new ViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(KLViewHolder holder, int position) {\n\t        ViewHolder _viewHolder = (ViewHolder) holder;\n\t        NewsBean  _newsBean = getData().get(position);\n\t        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n\t        _viewHolder.tvContent.setText(_newsBean.getContent());\n\t    }\n\n\t    class ViewHolder extends KLViewHolder{\n\n\t        private TextView tvTitle ;\n\t        private TextView tvContent ;\n\n\t        public ViewHolder(View convertView) {\n\t            super(convertView);\n\t        }\n\n\t        @Override\n\t        void initView(View convertView) {\n\t            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n\t            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n\t        }\n\t    }\n\t}\n\n\t\n","source":"_posts/RecyclerView的基类写法.md","raw":"title: RecyclerView的基类写法\ndate: 2015-11-17 11:01:47\ncategories:\nkeywords:\ntags: android\n---\n\n# RecyclerView的基类写法\n\n### KLBaseRecyclerAdapter\\<T\\> \n\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.LayoutInflater;\n\timport android.view.View;\n\timport android.view.ViewGroup;\n\n\timport java.util.ArrayList;\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/16.\n\t */\n\tpublic abstract class KLBaseRecyclerAdapter<T> extends RecyclerView.Adapter {\n\n\t    protected Context mContext;\n\t    protected LayoutInflater mInflater;\n\t    protected List<T> datas = new ArrayList<T>();\n\n\t    private View.OnClickListener onClickListener ;\n\n\t    public KLBaseRecyclerAdapter(Context context) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas = new ArrayList<T>();\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public KLBaseRecyclerAdapter(Context context, List<T> datas) {\n\t        super();\n\t        this.mContext = context;\n\t        this.datas.addAll(datas);\n\t        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t    }\n\n\t    public void setOnClickListener(View.OnClickListener onClickListener) {\n\t        this.onClickListener = onClickListener;\n\t    }\n\n\t    /**\n\t     * 加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void setData(List<T> datas) {\n\t        if (null != datas) {\n\t//            if (this.datas.size() > 0) {\n\t//                this.datas.clear();\n\t//            }\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    public List<T> getData() {\n\t        return this.datas;\n\t    }\n\n\t    public T getOneData(int potion) {\n\t        return datas.get(potion);\n\t    }\n\n\t    /**\n\t     * 上拉加载数据\n\t     *\n\t     * @param datas\n\t     */\n\t    public void addData(List<T> datas) {\n\t        if (null != datas) {\n\t            this.datas.addAll(datas);\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    /**\n\t     * 清除数据源\n\t     */\n\t    public void clearData() {\n\t        if (datas != null) {\n\t            datas.clear();\n\t            notifyDataSetChanged();\n\t        }\n\t    }\n\n\t    @Override\n\t    public long getItemId(int position) {\n\t        return position;\n\t    }\n\n\t    @Override\n\t    public int getItemCount() {\n\t        return datas != null ? datas.size() : 0;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n\t        View view = mInflater.inflate(setConvertView(), parent, false);\n\t        return setViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n\t        onBindViewHolder((KLViewHolder)holder, position);\n\t    }\n\n\t    public abstract int setConvertView();\n\t    \n\t    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n\t    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n\t    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n\t        public KLViewHolder(View convertView) {\n\t            super(convertView);\n\n\t            initView(convertView);\n\n\t            if (onClickListener != null)\n\t                convertView.setOnClickListener(onClickListener);\n\t        }\n\n\t        abstract void initView(View convertView);\n\t    }\n\t}\n\n\n### 实现：\n\tpackage com.xxx.recyclerviewdemo.adapter;\n\n\timport android.content.Context;\n\timport android.support.v7.widget.RecyclerView;\n\timport android.view.View;\n\timport android.widget.TextView;\n\n\timport com.zhuyongit.recyclerviewdemo.R;\n\timport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\n\timport java.util.List;\n\n\t/**\n\t * Created by WangQing on 15/11/17.\n\t */\n\tpublic class TestAdapter extends KLBaseRecyclerAdapter<NewsBean> {\n\n\t    public TestAdapter(Context context) {\n\t        super(context);\n\t    }\n\n\t    public TestAdapter(Context context, List<NewsBean> datas) {\n\t        super(context, datas);\n\t    }\n\n\t    @Override\n\t    public int setConvertView() {\n\t        return R.layout.grid_recycler_item_layout;\n\t    }\n\n\t    @Override\n\t    public RecyclerView.ViewHolder setViewHolder(View view) {\n\t        return new ViewHolder(view);\n\t    }\n\n\t    @Override\n\t    public void onBindViewHolder(KLViewHolder holder, int position) {\n\t        ViewHolder _viewHolder = (ViewHolder) holder;\n\t        NewsBean  _newsBean = getData().get(position);\n\t        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n\t        _viewHolder.tvContent.setText(_newsBean.getContent());\n\t    }\n\n\t    class ViewHolder extends KLViewHolder{\n\n\t        private TextView tvTitle ;\n\t        private TextView tvContent ;\n\n\t        public ViewHolder(View convertView) {\n\t            super(convertView);\n\t        }\n\n\t        @Override\n\t        void initView(View convertView) {\n\t            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n\t            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n\t        }\n\t    }\n\t}\n\n\t\n","slug":"RecyclerView的基类写法","published":1,"updated":"2015-11-17T03:03:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yp000jrgex2hoosygo","content":"<h1 id=\"RecyclerView的基类写法\"><a href=\"#RecyclerView的基类写法\" class=\"headerlink\" title=\"RecyclerView的基类写法\"></a>RecyclerView的基类写法</h1><h3 id=\"KLBaseRecyclerAdapter\"><a href=\"#KLBaseRecyclerAdapter\" class=\"headerlink\" title=\"KLBaseRecyclerAdapter\\\"></a>KLBaseRecyclerAdapter\\<t\\></t\\></h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/16.\n */\npublic abstract class KLBaseRecyclerAdapter&lt;T&gt; extends RecyclerView.Adapter {\n\n    protected Context mContext;\n    protected LayoutInflater mInflater;\n    protected List&lt;T&gt; datas = new ArrayList&lt;T&gt;();\n\n    private View.OnClickListener onClickListener ;\n\n    public KLBaseRecyclerAdapter(Context context) {\n        super();\n        this.mContext = context;\n        this.datas = new ArrayList&lt;T&gt;();\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public KLBaseRecyclerAdapter(Context context, List&lt;T&gt; datas) {\n        super();\n        this.mContext = context;\n        this.datas.addAll(datas);\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public void setOnClickListener(View.OnClickListener onClickListener) {\n        this.onClickListener = onClickListener;\n    }\n\n    /**\n     * 加载数据\n     *\n     * @param datas\n     */\n    public void setData(List&lt;T&gt; datas) {\n        if (null != datas) {\n//            if (this.datas.size() &gt; 0) {\n//                this.datas.clear();\n//            }\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    public List&lt;T&gt; getData() {\n        return this.datas;\n    }\n\n    public T getOneData(int potion) {\n        return datas.get(potion);\n    }\n\n    /**\n     * 上拉加载数据\n     *\n     * @param datas\n     */\n    public void addData(List&lt;T&gt; datas) {\n        if (null != datas) {\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    /**\n     * 清除数据源\n     */\n    public void clearData() {\n        if (datas != null) {\n            datas.clear();\n            notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public int getItemCount() {\n        return datas != null ? datas.size() : 0;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = mInflater.inflate(setConvertView(), parent, false);\n        return setViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        onBindViewHolder((KLViewHolder)holder, position);\n    }\n\n    public abstract int setConvertView();\n\n    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n        public KLViewHolder(View convertView) {\n            super(convertView);\n\n            initView(convertView);\n\n            if (onClickListener != null)\n                convertView.setOnClickListener(onClickListener);\n        }\n\n        abstract void initView(View convertView);\n    }\n}\n</code></pre><h3 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.widget.TextView;\n\nimport com.zhuyongit.recyclerviewdemo.R;\nimport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/17.\n */\npublic class TestAdapter extends KLBaseRecyclerAdapter&lt;NewsBean&gt; {\n\n    public TestAdapter(Context context) {\n        super(context);\n    }\n\n    public TestAdapter(Context context, List&lt;NewsBean&gt; datas) {\n        super(context, datas);\n    }\n\n    @Override\n    public int setConvertView() {\n        return R.layout.grid_recycler_item_layout;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder setViewHolder(View view) {\n        return new ViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(KLViewHolder holder, int position) {\n        ViewHolder _viewHolder = (ViewHolder) holder;\n        NewsBean  _newsBean = getData().get(position);\n        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n        _viewHolder.tvContent.setText(_newsBean.getContent());\n    }\n\n    class ViewHolder extends KLViewHolder{\n\n        private TextView tvTitle ;\n        private TextView tvContent ;\n\n        public ViewHolder(View convertView) {\n            super(convertView);\n        }\n\n        @Override\n        void initView(View convertView) {\n            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n        }\n    }\n}\n</code></pre>","excerpt":"","more":"<h1 id=\"RecyclerView的基类写法\"><a href=\"#RecyclerView的基类写法\" class=\"headerlink\" title=\"RecyclerView的基类写法\"></a>RecyclerView的基类写法</h1><h3 id=\"KLBaseRecyclerAdapter\"><a href=\"#KLBaseRecyclerAdapter\" class=\"headerlink\" title=\"KLBaseRecyclerAdapter\\\"></a>KLBaseRecyclerAdapter\\<T\\></h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/16.\n */\npublic abstract class KLBaseRecyclerAdapter&lt;T&gt; extends RecyclerView.Adapter {\n\n    protected Context mContext;\n    protected LayoutInflater mInflater;\n    protected List&lt;T&gt; datas = new ArrayList&lt;T&gt;();\n\n    private View.OnClickListener onClickListener ;\n\n    public KLBaseRecyclerAdapter(Context context) {\n        super();\n        this.mContext = context;\n        this.datas = new ArrayList&lt;T&gt;();\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public KLBaseRecyclerAdapter(Context context, List&lt;T&gt; datas) {\n        super();\n        this.mContext = context;\n        this.datas.addAll(datas);\n        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    }\n\n    public void setOnClickListener(View.OnClickListener onClickListener) {\n        this.onClickListener = onClickListener;\n    }\n\n    /**\n     * 加载数据\n     *\n     * @param datas\n     */\n    public void setData(List&lt;T&gt; datas) {\n        if (null != datas) {\n//            if (this.datas.size() &gt; 0) {\n//                this.datas.clear();\n//            }\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    public List&lt;T&gt; getData() {\n        return this.datas;\n    }\n\n    public T getOneData(int potion) {\n        return datas.get(potion);\n    }\n\n    /**\n     * 上拉加载数据\n     *\n     * @param datas\n     */\n    public void addData(List&lt;T&gt; datas) {\n        if (null != datas) {\n            this.datas.addAll(datas);\n            notifyDataSetChanged();\n        }\n    }\n\n    /**\n     * 清除数据源\n     */\n    public void clearData() {\n        if (datas != null) {\n            datas.clear();\n            notifyDataSetChanged();\n        }\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return position;\n    }\n\n    @Override\n    public int getItemCount() {\n        return datas != null ? datas.size() : 0;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View view = mInflater.inflate(setConvertView(), parent, false);\n        return setViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {\n        onBindViewHolder((KLViewHolder)holder, position);\n    }\n\n    public abstract int setConvertView();\n\n    public abstract RecyclerView.ViewHolder setViewHolder(View view);\n\n    public abstract void onBindViewHolder(KLViewHolder holder, int position);\n\n    abstract class KLViewHolder extends RecyclerView.ViewHolder {\n\n        public KLViewHolder(View convertView) {\n            super(convertView);\n\n            initView(convertView);\n\n            if (onClickListener != null)\n                convertView.setOnClickListener(onClickListener);\n        }\n\n        abstract void initView(View convertView);\n    }\n}\n</code></pre><h3 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h3><pre><code>package com.xxx.recyclerviewdemo.adapter;\n\nimport android.content.Context;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\nimport android.widget.TextView;\n\nimport com.zhuyongit.recyclerviewdemo.R;\nimport com.zhuyongit.recyclerviewdemo.bean.NewsBean;\n\nimport java.util.List;\n\n/**\n * Created by WangQing on 15/11/17.\n */\npublic class TestAdapter extends KLBaseRecyclerAdapter&lt;NewsBean&gt; {\n\n    public TestAdapter(Context context) {\n        super(context);\n    }\n\n    public TestAdapter(Context context, List&lt;NewsBean&gt; datas) {\n        super(context, datas);\n    }\n\n    @Override\n    public int setConvertView() {\n        return R.layout.grid_recycler_item_layout;\n    }\n\n    @Override\n    public RecyclerView.ViewHolder setViewHolder(View view) {\n        return new ViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(KLViewHolder holder, int position) {\n        ViewHolder _viewHolder = (ViewHolder) holder;\n        NewsBean  _newsBean = getData().get(position);\n        _viewHolder.tvTitle.setText(_newsBean.getTitle());\n        _viewHolder.tvContent.setText(_newsBean.getContent());\n    }\n\n    class ViewHolder extends KLViewHolder{\n\n        private TextView tvTitle ;\n        private TextView tvContent ;\n\n        public ViewHolder(View convertView) {\n            super(convertView);\n        }\n\n        @Override\n        void initView(View convertView) {\n            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);\n            tvContent = (TextView) convertView.findViewById(R.id.tvContent);\n        }\n    }\n}\n</code></pre>"},{"title":"monkey 测试命令，保存到SD，遇到崩溃继续","date":"2015-09-19T11:16:05.000Z","keywords":"android,monkey,adb","_content":"\n\n### 开始测试：\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v 600000>/mnt/sdcard/monkey1.txt & \n```\n\n### 保存monkey 和 logcat 的日志\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v -v 15000000>>/mnt/sdcard/monkey_kaola.txt & logcat  -v time >>/mnt/sdcard/logcat.txt\n```\n\n### 终止：\n\n```\nadb shell\nps|grep monkey\nkill id\n```\n\n###### adb logcat -s com.xx.xx","source":"_posts/android-monkey.md","raw":"title: monkey 测试命令，保存到SD，遇到崩溃继续\ndate: 2015-09-19 19:16:05\ncategories: android\nkeywords: android,monkey,adb\ntags: android\n---\n\n\n### 开始测试：\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v 600000>/mnt/sdcard/monkey1.txt & \n```\n\n### 保存monkey 和 logcat 的日志\n```\nmonkey -p com.itings.myradio -c android.intent.category.LAUNCHER -s 500 --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle 50 -v -v -v 15000000>>/mnt/sdcard/monkey_kaola.txt & logcat  -v time >>/mnt/sdcard/logcat.txt\n```\n\n### 终止：\n\n```\nadb shell\nps|grep monkey\nkill id\n```\n\n###### adb logcat -s com.xx.xx","slug":"android-monkey","published":1,"updated":"2015-09-19T11:19:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yt000orgexihwq4b4p","content":"<h3 id=\"开始测试：\"><a href=\"#开始测试：\" class=\"headerlink\" title=\"开始测试：\"></a>开始测试：</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v <span class=\"number\">600000</span>&gt;/mnt/sdcard/monkey1<span class=\"selector-class\">.txt</span> &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存monkey-和-logcat-的日志\"><a href=\"#保存monkey-和-logcat-的日志\" class=\"headerlink\" title=\"保存monkey 和 logcat 的日志\"></a>保存monkey 和 logcat 的日志</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v -v <span class=\"number\">15000000</span>&gt;&gt;/mnt/sdcard/monkey_kaola<span class=\"selector-class\">.txt</span> &amp; logcat  -v <span class=\"selector-tag\">time</span> &gt;&gt;/mnt/sdcard/logcat.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"终止：\"><a href=\"#终止：\" class=\"headerlink\" title=\"终止：\"></a>终止：</h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb <span class=\"keyword\">shell</span></span><br><span class=\"line\"><span class=\"keyword\">ps</span>|<span class=\"keyword\">grep</span> monkey</span><br><span class=\"line\">kill id</span><br></pre></td></tr></table></figure>\n<h6 id=\"adb-logcat-s-com-xx-xx\"><a href=\"#adb-logcat-s-com-xx-xx\" class=\"headerlink\" title=\"adb logcat -s com.xx.xx\"></a>adb logcat -s com.xx.xx</h6>","excerpt":"","more":"<h3 id=\"开始测试：\"><a href=\"#开始测试：\" class=\"headerlink\" title=\"开始测试：\"></a>开始测试：</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v <span class=\"number\">600000</span>&gt;/mnt/sdcard/monkey1<span class=\"selector-class\">.txt</span> &amp;</span><br></pre></td></tr></table></figure>\n<h3 id=\"保存monkey-和-logcat-的日志\"><a href=\"#保存monkey-和-logcat-的日志\" class=\"headerlink\" title=\"保存monkey 和 logcat 的日志\"></a>保存monkey 和 logcat 的日志</h3><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">monkey -<span class=\"selector-tag\">p</span> com<span class=\"selector-class\">.itings</span><span class=\"selector-class\">.myradio</span> -c android<span class=\"selector-class\">.intent</span><span class=\"selector-class\">.category</span><span class=\"selector-class\">.LAUNCHER</span> -s <span class=\"number\">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class=\"number\">50</span> -v -v -v <span class=\"number\">15000000</span>&gt;&gt;/mnt/sdcard/monkey_kaola<span class=\"selector-class\">.txt</span> &amp; logcat  -v <span class=\"selector-tag\">time</span> &gt;&gt;/mnt/sdcard/logcat.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"终止：\"><a href=\"#终止：\" class=\"headerlink\" title=\"终止：\"></a>终止：</h3><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb <span class=\"keyword\">shell</span></span><br><span class=\"line\"><span class=\"keyword\">ps</span>|<span class=\"keyword\">grep</span> monkey</span><br><span class=\"line\">kill id</span><br></pre></td></tr></table></figure>\n<h6 id=\"adb-logcat-s-com-xx-xx\"><a href=\"#adb-logcat-s-com-xx-xx\" class=\"headerlink\" title=\"adb logcat -s com.xx.xx\"></a>adb logcat -s com.xx.xx</h6>"},{"title":"代码面试最常用的10大算法","date":"2016-03-12T00:32:44.000Z","keywords":"算法","_content":"### 代码面试最常用的10大算法\n\n> 面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。\n\n在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。\n本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。\n\n### 1. String/Array/Matrix\n\n    toCharArray() //get char array of a String\n    Arrays.sort()  //sort an array\n    Arrays.toString(char[] a) //convert to string\n    charAt(int x) //get a char at the specific index\n    length() //string length\n    length //array size \n    substring(int beginIndex) \n    substring(int beginIndex, int endIndex)\n    Integer.valueOf()//string to integer\n    String.valueOf()/integer to string\n\nString/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。\n下面列出一些需要高级算法才能解决的经典问题：\n- [Evaluate Reverse Polish Notation](http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/)\n- [Longest Palindromic Substring](http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/)\n- [单词分割](http://www.programcreek.com/2012/12/leetcode-solution-word-break/)\n- [字梯](http://www.programcreek.com/2012/12/leetcode-word-ladder/)\n- [Median of Two Sorted Arrays](http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/)\n- [正则表达式匹配￼Java](http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/)\n- [合并间隔](http://merge%20intervals/)\n- [插入间隔](http://www.programcreek.com/2012/12/leetcode-insert-interval/)\n- [Two Sum](http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/)\n- 3Sum\n- 4Sum\n- 3Sum Closest\n- String to Integer\n- 合并排序数组\n- Valid Parentheses\n- 实现strStr()\n- Set Matrix Zeroes\n- 搜索插入位置\n- Longest Consecutive Sequence\n- Valid Palindrome\n- 螺旋矩阵\n- 搜索一个二维矩阵\n- 旋转图像\n- 三角形\n- Distinct Subsequences Total\n- Maximum Subarray\n- 删除重复的排序数组\n- 删除重复的排序数组2\n- 查找没有重复的最长子串\n- 包含两个独特字符的最长子串\n- Palindrome Partitioning\n\n### 2. 链表\n在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   \n\n    class Node {\n        int val;\n        Node next;\n     \n        Node(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n\n比较流行的两个链表例子就是栈和队列。\n#### 栈（Stack） \n\n    class Stack{\n        Node top; \n     \n        public Node peek(){\n            if(top != null){\n                return top;\n            }\n     \n            return null;\n        }\n     \n        public Node pop(){\n            if(top == null){\n                return null;\n            }else{\n                Node temp = new Node(top.val);\n                top = top.next;\n                return temp;    \n            }\n        }\n     \n        public void push(Node n){\n            if(n != null){\n                n.next = top;\n                top = n;\n            }\n        }\n    }\n\n#### 队列（Queue）\n\n    class Queue{\n        Node first, last;\n    &nbsp;\n        public void enqueue(Node n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n    &nbsp;\n        public Node dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                Node temp = new Node(first.val);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。\n在实际中，需要用到链表的算法有：\n\n- 插入两个数字\n- 重新排序列表\n- 链表周期\n- Copy List with Random Pointer\n- 合并两个有序列表\n- 合并多个排序列表\n- 从排序列表中删除重复的\n- 分区列表\n- LRU缓存\n\n### 3. 树&堆\n这里的树通常是指二叉树。\n\n    class TreeNode{\n        int value;\n        TreeNode left;\n        TreeNode right;\n    } \n\n下面是一些与二叉树有关的概念：\n\n\n- 二叉树搜索：对于所有节点，顺序是：left children \\<= current node \\<= right children；\n- 平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；\n- 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；\n- 完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；\n- 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n\n堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。\n\n下面列出一些基于二叉树和堆的算法：\n\n- 二叉树前序遍历\n- 二叉树中序遍历\n- 二叉树后序遍历\n- 字梯\n- 验证二叉查找树\n- 把二叉树变平放到链表里\n- 二叉树路径和\n- 从前序和后序构建二叉树\n- 把有序数组转换为二叉查找树\n- 把有序列表转为二叉查找树\n- 最小深度二叉树\n- 二叉树最大路径和\n- 平衡二叉树\n\n### 4. Graph \n与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。\n\n![](http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg)\n\n#### 第一步，定义一个GraphNode\n    class GraphNode{ \n        int val;\n        GraphNode next;\n        GraphNode[] neighbors;\n        boolean visited;\n     \n        GraphNode(int x) {\n            val = x;\n        }\n     \n        GraphNode(int x, GraphNode[] n){\n            val = x;\n            neighbors = n;\n        }\n     \n        public String toString(){\n            return \"value: \"+ this.val; \n        }\n    }\n\n#### 第二步，定义一个队列\n\n    class Queue{\n        GraphNode first, last;\n     \n        public void enqueue(GraphNode n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n     \n        public GraphNode dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                GraphNode temp = new GraphNode(first.val, first.neighbors);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n#### 第三步，使用队列进行宽度优先搜索\n    public class GraphTest {\n     \n        public static void main(String[] args) {\n            GraphNode n1 = new GraphNode(1); \n            GraphNode n2 = new GraphNode(2); \n            GraphNode n3 = new GraphNode(3); \n            GraphNode n4 = new GraphNode(4); \n            GraphNode n5 = new GraphNode(5); \n     \n            n1.neighbors = new GraphNode[]{n2,n3,n5};\n            n2.neighbors = new GraphNode[]{n1,n4};\n            n3.neighbors = new GraphNode[]{n1,n4,n5};\n            n4.neighbors = new GraphNode[]{n2,n3,n5};\n            n5.neighbors = new GraphNode[]{n1,n3,n4};\n     \n            breathFirstSearch(n1, 5);\n        }\n     \n        public static void breathFirstSearch(GraphNode root, int x){\n            if(root.val == x)\n                System.out.println(\"find in root\");\n     \n            Queue queue = new Queue();\n            root.visited = true;\n            queue.enqueue(root);\n     \n            while(queue.first != null){\n                GraphNode c = (GraphNode) queue.dequeue();\n                for(GraphNode n: c.neighbors){\n     \n                    if(!n.visited){\n                        System.out.print(n + \" \");\n                        n.visited = true;\n                        if(n.val == x)\n                            System.out.println(\"Find \"+n);\n                        queue.enqueue(n);\n                    }\n                }\n            }\n        }\n    }\n\n#### 输出结果：\n    value: 2 value: 3 value: 5 Find value: 5 \n    value: 4\n\n实际中，基于Graph需要经常用到的算法：\n\n- 克隆Graph\n\n### 5. 排序\n不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。\n\n![](http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg)\n\nBinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   \n\n下面是这些算法的具体实例，另外，你还可以阅读： [Java开发者在实际操作中是如何排序的](http://www.programcreek.com/2014/03/how-developers-sort-in-java/)。\n\n- 归并排序\n- 快速排序\n- 插入排序\n\n### 6. 递归和迭代\n下面通过一个例子来说明什么是递归。\n#### 问题：\n\n> 这里有n个台阶，每次能爬1或2节，请问有多少种爬法？\n\n#### 步骤1：查找n和n-1之间的关系\n为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   \n\n#### 步骤2：确保开始条件是正确的\nf(0) = 0;   \nf(1) = 1; \n\n    public static int f(int n){\n        if(n <= 2) return n;\n        int x = f(n-1) + f(n-2);\n        return x;\n    }\n\n递归方法的时间复杂度指数为n，这里会有很多冗余计算。\n    f(5)\n    f(4) + f(3)\n    f(3) + f(2) + f(2) + f(1)\n    f(2) + f(1) + f(2) + f(2) + f(1)\n\n该递归可以很简单地转换为迭代。 \n    public static int f(int n) {\n     \n        if (n <= 2){\n            return n;\n        }\n     \n        int first = 1, second = 2;\n        int third = 0;\n     \n        for (int i = 3; i <= n; i++) {\n            third = first + second;\n            first = second;\n            second = third;\n        }\n     \n        return third;\n    }\n\n在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 [这里](http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/)看看。\n### 7. 动态规划\n动态规划主要用来解决如下技术问题：\n- 通过较小的子例来解决一个实例；\n- 对于一个较小的实例，可能需要许多个解决方案；\n- 把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；\n- 附加空间用来节省时间。\n上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：\n    public static int[] A = new int[100];\n     \n    public static int f3(int n) {\n        if (n <= 2)\n            A[n]= n;\n     \n        if(A[n] > 0)\n            return A[n];\n        else\n            A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\n        return A[n];\n    }\n\n一些基于动态规划的算法：\n\n- 编辑距离\n- 最长回文子串\n- 单词分割\n- 最大的子数组\n\n### 8. 位操作\n位操作符：\n![](http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg)\n\n从一个给定的数n中找位i（i从0开始，然后向右开始）\n\n    public static boolean getBit(int num, int i){\n        int result = num & (1<<i);\n     \n        if(result == 0){\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n例如，获取10的第二位：\n    i=1, n=10\n    1<<1= 10\n    1010&10=10\n    10 is not 0, so return true;\n\n典型的位算法：\n\n\n- Find Single Number\n- Maximum Binary Gap\n\n### 9. 概率\n\n通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： \n> 有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）\n\n    public static double caculateProbability(int n){\n        double x = 1; \n     \n        for(int i=0; i<n; i++){\n            x *=  (365.0-i)/365.0;\n        }\n     \n        double pro = Math.round((1-x) * 100);\n        return pro/100;\n    }I\n\n结果：\n> calculateProbability(50) = 0.97\n### 10. 组合和排列\n\n组合和排列的主要差别在于顺序是否重要。\n例1：\n> 1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？\n例2：\n> 有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？\n\n基于它们的一些常见算法\n- 排列\n- 排列2\n- 排列顺序\n\n来自：[http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview](http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview)\n","source":"_posts/代码面试最常用的10大算法.md","raw":"title: 代码面试最常用的10大算法\ndate: 2016-03-12 08:32:44\ncategories:\nkeywords: 算法\ntags: 算法\n---\n### 代码面试最常用的10大算法\n\n> 面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。\n\n在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。\n本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。\n\n### 1. String/Array/Matrix\n\n    toCharArray() //get char array of a String\n    Arrays.sort()  //sort an array\n    Arrays.toString(char[] a) //convert to string\n    charAt(int x) //get a char at the specific index\n    length() //string length\n    length //array size \n    substring(int beginIndex) \n    substring(int beginIndex, int endIndex)\n    Integer.valueOf()//string to integer\n    String.valueOf()/integer to string\n\nString/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。\n下面列出一些需要高级算法才能解决的经典问题：\n- [Evaluate Reverse Polish Notation](http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/)\n- [Longest Palindromic Substring](http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/)\n- [单词分割](http://www.programcreek.com/2012/12/leetcode-solution-word-break/)\n- [字梯](http://www.programcreek.com/2012/12/leetcode-word-ladder/)\n- [Median of Two Sorted Arrays](http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/)\n- [正则表达式匹配￼Java](http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/)\n- [合并间隔](http://merge%20intervals/)\n- [插入间隔](http://www.programcreek.com/2012/12/leetcode-insert-interval/)\n- [Two Sum](http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/)\n- 3Sum\n- 4Sum\n- 3Sum Closest\n- String to Integer\n- 合并排序数组\n- Valid Parentheses\n- 实现strStr()\n- Set Matrix Zeroes\n- 搜索插入位置\n- Longest Consecutive Sequence\n- Valid Palindrome\n- 螺旋矩阵\n- 搜索一个二维矩阵\n- 旋转图像\n- 三角形\n- Distinct Subsequences Total\n- Maximum Subarray\n- 删除重复的排序数组\n- 删除重复的排序数组2\n- 查找没有重复的最长子串\n- 包含两个独特字符的最长子串\n- Palindrome Partitioning\n\n### 2. 链表\n在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   \n\n    class Node {\n        int val;\n        Node next;\n     \n        Node(int x) {\n            val = x;\n            next = null;\n        }\n    }\n\n\n比较流行的两个链表例子就是栈和队列。\n#### 栈（Stack） \n\n    class Stack{\n        Node top; \n     \n        public Node peek(){\n            if(top != null){\n                return top;\n            }\n     \n            return null;\n        }\n     \n        public Node pop(){\n            if(top == null){\n                return null;\n            }else{\n                Node temp = new Node(top.val);\n                top = top.next;\n                return temp;    \n            }\n        }\n     \n        public void push(Node n){\n            if(n != null){\n                n.next = top;\n                top = n;\n            }\n        }\n    }\n\n#### 队列（Queue）\n\n    class Queue{\n        Node first, last;\n    &nbsp;\n        public void enqueue(Node n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n    &nbsp;\n        public Node dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                Node temp = new Node(first.val);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。\n在实际中，需要用到链表的算法有：\n\n- 插入两个数字\n- 重新排序列表\n- 链表周期\n- Copy List with Random Pointer\n- 合并两个有序列表\n- 合并多个排序列表\n- 从排序列表中删除重复的\n- 分区列表\n- LRU缓存\n\n### 3. 树&堆\n这里的树通常是指二叉树。\n\n    class TreeNode{\n        int value;\n        TreeNode left;\n        TreeNode right;\n    } \n\n下面是一些与二叉树有关的概念：\n\n\n- 二叉树搜索：对于所有节点，顺序是：left children \\<= current node \\<= right children；\n- 平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；\n- 满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；\n- 完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；\n- 完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。\n\n堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。\n\n下面列出一些基于二叉树和堆的算法：\n\n- 二叉树前序遍历\n- 二叉树中序遍历\n- 二叉树后序遍历\n- 字梯\n- 验证二叉查找树\n- 把二叉树变平放到链表里\n- 二叉树路径和\n- 从前序和后序构建二叉树\n- 把有序数组转换为二叉查找树\n- 把有序列表转为二叉查找树\n- 最小深度二叉树\n- 二叉树最大路径和\n- 平衡二叉树\n\n### 4. Graph \n与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。\n\n![](http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg)\n\n#### 第一步，定义一个GraphNode\n    class GraphNode{ \n        int val;\n        GraphNode next;\n        GraphNode[] neighbors;\n        boolean visited;\n     \n        GraphNode(int x) {\n            val = x;\n        }\n     \n        GraphNode(int x, GraphNode[] n){\n            val = x;\n            neighbors = n;\n        }\n     \n        public String toString(){\n            return \"value: \"+ this.val; \n        }\n    }\n\n#### 第二步，定义一个队列\n\n    class Queue{\n        GraphNode first, last;\n     \n        public void enqueue(GraphNode n){\n            if(first == null){\n                first = n;\n                last = first;\n            }else{\n                last.next = n;\n                last = n;\n            }\n        }\n     \n        public GraphNode dequeue(){\n            if(first == null){\n                return null;\n            }else{\n                GraphNode temp = new GraphNode(first.val, first.neighbors);\n                first = first.next;\n                return temp;\n            }   \n        }\n    }\n\n#### 第三步，使用队列进行宽度优先搜索\n    public class GraphTest {\n     \n        public static void main(String[] args) {\n            GraphNode n1 = new GraphNode(1); \n            GraphNode n2 = new GraphNode(2); \n            GraphNode n3 = new GraphNode(3); \n            GraphNode n4 = new GraphNode(4); \n            GraphNode n5 = new GraphNode(5); \n     \n            n1.neighbors = new GraphNode[]{n2,n3,n5};\n            n2.neighbors = new GraphNode[]{n1,n4};\n            n3.neighbors = new GraphNode[]{n1,n4,n5};\n            n4.neighbors = new GraphNode[]{n2,n3,n5};\n            n5.neighbors = new GraphNode[]{n1,n3,n4};\n     \n            breathFirstSearch(n1, 5);\n        }\n     \n        public static void breathFirstSearch(GraphNode root, int x){\n            if(root.val == x)\n                System.out.println(\"find in root\");\n     \n            Queue queue = new Queue();\n            root.visited = true;\n            queue.enqueue(root);\n     \n            while(queue.first != null){\n                GraphNode c = (GraphNode) queue.dequeue();\n                for(GraphNode n: c.neighbors){\n     \n                    if(!n.visited){\n                        System.out.print(n + \" \");\n                        n.visited = true;\n                        if(n.val == x)\n                            System.out.println(\"Find \"+n);\n                        queue.enqueue(n);\n                    }\n                }\n            }\n        }\n    }\n\n#### 输出结果：\n    value: 2 value: 3 value: 5 Find value: 5 \n    value: 4\n\n实际中，基于Graph需要经常用到的算法：\n\n- 克隆Graph\n\n### 5. 排序\n不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。\n\n![](http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg)\n\nBinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   \n\n下面是这些算法的具体实例，另外，你还可以阅读： [Java开发者在实际操作中是如何排序的](http://www.programcreek.com/2014/03/how-developers-sort-in-java/)。\n\n- 归并排序\n- 快速排序\n- 插入排序\n\n### 6. 递归和迭代\n下面通过一个例子来说明什么是递归。\n#### 问题：\n\n> 这里有n个台阶，每次能爬1或2节，请问有多少种爬法？\n\n#### 步骤1：查找n和n-1之间的关系\n为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   \n\n#### 步骤2：确保开始条件是正确的\nf(0) = 0;   \nf(1) = 1; \n\n    public static int f(int n){\n        if(n <= 2) return n;\n        int x = f(n-1) + f(n-2);\n        return x;\n    }\n\n递归方法的时间复杂度指数为n，这里会有很多冗余计算。\n    f(5)\n    f(4) + f(3)\n    f(3) + f(2) + f(2) + f(1)\n    f(2) + f(1) + f(2) + f(2) + f(1)\n\n该递归可以很简单地转换为迭代。 \n    public static int f(int n) {\n     \n        if (n <= 2){\n            return n;\n        }\n     \n        int first = 1, second = 2;\n        int third = 0;\n     \n        for (int i = 3; i <= n; i++) {\n            third = first + second;\n            first = second;\n            second = third;\n        }\n     \n        return third;\n    }\n\n在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 [这里](http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/)看看。\n### 7. 动态规划\n动态规划主要用来解决如下技术问题：\n- 通过较小的子例来解决一个实例；\n- 对于一个较小的实例，可能需要许多个解决方案；\n- 把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；\n- 附加空间用来节省时间。\n上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：\n    public static int[] A = new int[100];\n     \n    public static int f3(int n) {\n        if (n <= 2)\n            A[n]= n;\n     \n        if(A[n] > 0)\n            return A[n];\n        else\n            A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\n        return A[n];\n    }\n\n一些基于动态规划的算法：\n\n- 编辑距离\n- 最长回文子串\n- 单词分割\n- 最大的子数组\n\n### 8. 位操作\n位操作符：\n![](http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg)\n\n从一个给定的数n中找位i（i从0开始，然后向右开始）\n\n    public static boolean getBit(int num, int i){\n        int result = num & (1<<i);\n     \n        if(result == 0){\n            return false;\n        }else{\n            return true;\n        }\n    }\n\n例如，获取10的第二位：\n    i=1, n=10\n    1<<1= 10\n    1010&10=10\n    10 is not 0, so return true;\n\n典型的位算法：\n\n\n- Find Single Number\n- Maximum Binary Gap\n\n### 9. 概率\n\n通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： \n> 有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）\n\n    public static double caculateProbability(int n){\n        double x = 1; \n     \n        for(int i=0; i<n; i++){\n            x *=  (365.0-i)/365.0;\n        }\n     \n        double pro = Math.round((1-x) * 100);\n        return pro/100;\n    }I\n\n结果：\n> calculateProbability(50) = 0.97\n### 10. 组合和排列\n\n组合和排列的主要差别在于顺序是否重要。\n例1：\n> 1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？\n例2：\n> 有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？\n\n基于它们的一些常见算法\n- 排列\n- 排列2\n- 排列顺序\n\n来自：[http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview](http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview)\n","slug":"代码面试最常用的10大算法","published":1,"updated":"2016-03-12T00:47:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yw000qrgex3qa873hp","content":"<h3 id=\"代码面试最常用的10大算法\"><a href=\"#代码面试最常用的10大算法\" class=\"headerlink\" title=\"代码面试最常用的10大算法\"></a>代码面试最常用的10大算法</h3><blockquote>\n<p>面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。</p>\n</blockquote>\n<p>在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。<br>本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。</p>\n<h3 id=\"1-String-Array-Matrix\"><a href=\"#1-String-Array-Matrix\" class=\"headerlink\" title=\"1. String/Array/Matrix\"></a>1. String/Array/Matrix</h3><pre><code>toCharArray() //get char array of a String\nArrays.sort()  //sort an array\nArrays.toString(char[] a) //convert to string\ncharAt(int x) //get a char at the specific index\nlength() //string length\nlength //array size \nsubstring(int beginIndex) \nsubstring(int beginIndex, int endIndex)\nInteger.valueOf()//string to integer\nString.valueOf()/integer to string\n</code></pre><p>String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。<br>下面列出一些需要高级算法才能解决的经典问题：</p>\n<ul>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/\" target=\"_blank\" rel=\"external\">Evaluate Reverse Polish Notation</a></li>\n<li><a href=\"http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/\" target=\"_blank\" rel=\"external\">Longest Palindromic Substring</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-word-break/\" target=\"_blank\" rel=\"external\">单词分割</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-word-ladder/\" target=\"_blank\" rel=\"external\">字梯</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/\" target=\"_blank\" rel=\"external\">Median of Two Sorted Arrays</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/\" target=\"_blank\" rel=\"external\">正则表达式匹配￼Java</a></li>\n<li><a href=\"http://merge%20intervals/\" target=\"_blank\" rel=\"external\">合并间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-insert-interval/\" target=\"_blank\" rel=\"external\">插入间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/\" target=\"_blank\" rel=\"external\">Two Sum</a></li>\n<li>3Sum</li>\n<li>4Sum</li>\n<li>3Sum Closest</li>\n<li>String to Integer</li>\n<li>合并排序数组</li>\n<li>Valid Parentheses</li>\n<li>实现strStr()</li>\n<li>Set Matrix Zeroes</li>\n<li>搜索插入位置</li>\n<li>Longest Consecutive Sequence</li>\n<li>Valid Palindrome</li>\n<li>螺旋矩阵</li>\n<li>搜索一个二维矩阵</li>\n<li>旋转图像</li>\n<li>三角形</li>\n<li>Distinct Subsequences Total</li>\n<li>Maximum Subarray</li>\n<li>删除重复的排序数组</li>\n<li>删除重复的排序数组2</li>\n<li>查找没有重复的最长子串</li>\n<li>包含两个独特字符的最长子串</li>\n<li>Palindrome Partitioning</li>\n</ul>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2. 链表\"></a>2. 链表</h3><p>在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   </p>\n<pre><code>class Node {\n    int val;\n    Node next;\n\n    Node(int x) {\n        val = x;\n        next = null;\n    }\n}\n</code></pre><p>比较流行的两个链表例子就是栈和队列。</p>\n<h4 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h4><pre><code>class Stack{\n    Node top; \n\n    public Node peek(){\n        if(top != null){\n            return top;\n        }\n\n        return null;\n    }\n\n    public Node pop(){\n        if(top == null){\n            return null;\n        }else{\n            Node temp = new Node(top.val);\n            top = top.next;\n            return temp;    \n        }\n    }\n\n    public void push(Node n){\n        if(n != null){\n            n.next = top;\n            top = n;\n        }\n    }\n}\n</code></pre><h4 id=\"队列（Queue）\"><a href=\"#队列（Queue）\" class=\"headerlink\" title=\"队列（Queue）\"></a>队列（Queue）</h4><pre><code>class Queue{\n    Node first, last;\n&amp;nbsp;\n    public void enqueue(Node n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n&amp;nbsp;\n    public Node dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            Node temp = new Node(first.val);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><p>值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。<br>在实际中，需要用到链表的算法有：</p>\n<ul>\n<li>插入两个数字</li>\n<li>重新排序列表</li>\n<li>链表周期</li>\n<li>Copy List with Random Pointer</li>\n<li>合并两个有序列表</li>\n<li>合并多个排序列表</li>\n<li>从排序列表中删除重复的</li>\n<li>分区列表</li>\n<li>LRU缓存</li>\n</ul>\n<h3 id=\"3-树-amp-堆\"><a href=\"#3-树-amp-堆\" class=\"headerlink\" title=\"3. 树&amp;堆\"></a>3. 树&amp;堆</h3><p>这里的树通常是指二叉树。</p>\n<pre><code>class TreeNode{\n    int value;\n    TreeNode left;\n    TreeNode right;\n} \n</code></pre><p>下面是一些与二叉树有关的概念：</p>\n<ul>\n<li>二叉树搜索：对于所有节点，顺序是：left children \\&lt;= current node \\&lt;= right children；</li>\n<li>平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；</li>\n<li>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；</li>\n<li>完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；</li>\n<li>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</li>\n</ul>\n<p>堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>\n<p>下面列出一些基于二叉树和堆的算法：</p>\n<ul>\n<li>二叉树前序遍历</li>\n<li>二叉树中序遍历</li>\n<li>二叉树后序遍历</li>\n<li>字梯</li>\n<li>验证二叉查找树</li>\n<li>把二叉树变平放到链表里</li>\n<li>二叉树路径和</li>\n<li>从前序和后序构建二叉树</li>\n<li>把有序数组转换为二叉查找树</li>\n<li>把有序列表转为二叉查找树</li>\n<li>最小深度二叉树</li>\n<li>二叉树最大路径和</li>\n<li>平衡二叉树</li>\n</ul>\n<h3 id=\"4-Graph\"><a href=\"#4-Graph\" class=\"headerlink\" title=\"4. Graph\"></a>4. Graph</h3><p>与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg\" alt=\"\"></p>\n<h4 id=\"第一步，定义一个GraphNode\"><a href=\"#第一步，定义一个GraphNode\" class=\"headerlink\" title=\"第一步，定义一个GraphNode\"></a>第一步，定义一个GraphNode</h4><pre><code>class GraphNode{ \n    int val;\n    GraphNode next;\n    GraphNode[] neighbors;\n    boolean visited;\n\n    GraphNode(int x) {\n        val = x;\n    }\n\n    GraphNode(int x, GraphNode[] n){\n        val = x;\n        neighbors = n;\n    }\n\n    public String toString(){\n        return &quot;value: &quot;+ this.val; \n    }\n}\n</code></pre><h4 id=\"第二步，定义一个队列\"><a href=\"#第二步，定义一个队列\" class=\"headerlink\" title=\"第二步，定义一个队列\"></a>第二步，定义一个队列</h4><pre><code>class Queue{\n    GraphNode first, last;\n\n    public void enqueue(GraphNode n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n\n    public GraphNode dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            GraphNode temp = new GraphNode(first.val, first.neighbors);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><h4 id=\"第三步，使用队列进行宽度优先搜索\"><a href=\"#第三步，使用队列进行宽度优先搜索\" class=\"headerlink\" title=\"第三步，使用队列进行宽度优先搜索\"></a>第三步，使用队列进行宽度优先搜索</h4><pre><code>public class GraphTest {\n\n    public static void main(String[] args) {\n        GraphNode n1 = new GraphNode(1); \n        GraphNode n2 = new GraphNode(2); \n        GraphNode n3 = new GraphNode(3); \n        GraphNode n4 = new GraphNode(4); \n        GraphNode n5 = new GraphNode(5); \n\n        n1.neighbors = new GraphNode[]{n2,n3,n5};\n        n2.neighbors = new GraphNode[]{n1,n4};\n        n3.neighbors = new GraphNode[]{n1,n4,n5};\n        n4.neighbors = new GraphNode[]{n2,n3,n5};\n        n5.neighbors = new GraphNode[]{n1,n3,n4};\n\n        breathFirstSearch(n1, 5);\n    }\n\n    public static void breathFirstSearch(GraphNode root, int x){\n        if(root.val == x)\n            System.out.println(&quot;find in root&quot;);\n\n        Queue queue = new Queue();\n        root.visited = true;\n        queue.enqueue(root);\n\n        while(queue.first != null){\n            GraphNode c = (GraphNode) queue.dequeue();\n            for(GraphNode n: c.neighbors){\n\n                if(!n.visited){\n                    System.out.print(n + &quot; &quot;);\n                    n.visited = true;\n                    if(n.val == x)\n                        System.out.println(&quot;Find &quot;+n);\n                    queue.enqueue(n);\n                }\n            }\n        }\n    }\n}\n</code></pre><h4 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h4><pre><code>value: 2 value: 3 value: 5 Find value: 5 \nvalue: 4\n</code></pre><p>实际中，基于Graph需要经常用到的算法：</p>\n<ul>\n<li>克隆Graph</li>\n</ul>\n<h3 id=\"5-排序\"><a href=\"#5-排序\" class=\"headerlink\" title=\"5. 排序\"></a>5. 排序</h3><p>不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg\" alt=\"\"></p>\n<p>BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   </p>\n<p>下面是这些算法的具体实例，另外，你还可以阅读： <a href=\"http://www.programcreek.com/2014/03/how-developers-sort-in-java/\" target=\"_blank\" rel=\"external\">Java开发者在实际操作中是如何排序的</a>。</p>\n<ul>\n<li>归并排序</li>\n<li>快速排序</li>\n<li>插入排序</li>\n</ul>\n<h3 id=\"6-递归和迭代\"><a href=\"#6-递归和迭代\" class=\"headerlink\" title=\"6. 递归和迭代\"></a>6. 递归和迭代</h3><p>下面通过一个例子来说明什么是递归。</p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><blockquote>\n<p>这里有n个台阶，每次能爬1或2节，请问有多少种爬法？</p>\n</blockquote>\n<h4 id=\"步骤1：查找n和n-1之间的关系\"><a href=\"#步骤1：查找n和n-1之间的关系\" class=\"headerlink\" title=\"步骤1：查找n和n-1之间的关系\"></a>步骤1：查找n和n-1之间的关系</h4><p>为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   </p>\n<h4 id=\"步骤2：确保开始条件是正确的\"><a href=\"#步骤2：确保开始条件是正确的\" class=\"headerlink\" title=\"步骤2：确保开始条件是正确的\"></a>步骤2：确保开始条件是正确的</h4><p>f(0) = 0;<br>f(1) = 1; </p>\n<pre><code>public static int f(int n){\n    if(n &lt;= 2) return n;\n    int x = f(n-1) + f(n-2);\n    return x;\n}\n</code></pre><p>递归方法的时间复杂度指数为n，这里会有很多冗余计算。<br>    f(5)<br>    f(4) + f(3)<br>    f(3) + f(2) + f(2) + f(1)<br>    f(2) + f(1) + f(2) + f(2) + f(1)</p>\n<p>该递归可以很简单地转换为迭代。<br>    public static int f(int n) {</p>\n<pre><code>    if (n &lt;= 2){\n        return n;\n    }\n\n    int first = 1, second = 2;\n    int third = 0;\n\n    for (int i = 3; i &lt;= n; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n\n    return third;\n}\n</code></pre><p>在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 <a href=\"http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/\" target=\"_blank\" rel=\"external\">这里</a>看看。</p>\n<h3 id=\"7-动态规划\"><a href=\"#7-动态规划\" class=\"headerlink\" title=\"7. 动态规划\"></a>7. 动态规划</h3><p>动态规划主要用来解决如下技术问题：</p>\n<ul>\n<li>通过较小的子例来解决一个实例；</li>\n<li>对于一个较小的实例，可能需要许多个解决方案；</li>\n<li>把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；</li>\n<li><p>附加空间用来节省时间。<br>上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：<br>  public static int[] A = new int[100];</p>\n<p>  public static int f3(int n) {</p>\n<pre><code>if (n &lt;= 2)\n    A[n]= n;\n\nif(A[n] &gt; 0)\n    return A[n];\nelse\n    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\nreturn A[n];\n</code></pre><p>  }</p>\n</li>\n</ul>\n<p>一些基于动态规划的算法：</p>\n<ul>\n<li>编辑距离</li>\n<li>最长回文子串</li>\n<li>单词分割</li>\n<li>最大的子数组</li>\n</ul>\n<h3 id=\"8-位操作\"><a href=\"#8-位操作\" class=\"headerlink\" title=\"8. 位操作\"></a>8. 位操作</h3><p>位操作符：<br><img src=\"http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg\" alt=\"\"></p>\n<p>从一个给定的数n中找位i（i从0开始，然后向右开始）</p>\n<pre><code>public static boolean getBit(int num, int i){\n    int result = num &amp; (1&lt;&lt;i);\n\n    if(result == 0){\n        return false;\n    }else{\n        return true;\n    }\n}\n</code></pre><p>例如，获取10的第二位：<br>    i=1, n=10<br>    1&lt;&lt;1= 10<br>    1010&amp;10=10<br>    10 is not 0, so return true;</p>\n<p>典型的位算法：</p>\n<ul>\n<li>Find Single Number</li>\n<li>Maximum Binary Gap</li>\n</ul>\n<h3 id=\"9-概率\"><a href=\"#9-概率\" class=\"headerlink\" title=\"9. 概率\"></a>9. 概率</h3><p>通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： </p>\n<blockquote>\n<p>有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）</p>\n</blockquote>\n<pre><code>public static double caculateProbability(int n){\n    double x = 1; \n\n    for(int i=0; i&lt;n; i++){\n        x *=  (365.0-i)/365.0;\n    }\n\n    double pro = Math.round((1-x) * 100);\n    return pro/100;\n}I\n</code></pre><p>结果：</p>\n<blockquote>\n<p>calculateProbability(50) = 0.97</p>\n<h3 id=\"10-组合和排列\"><a href=\"#10-组合和排列\" class=\"headerlink\" title=\"10. 组合和排列\"></a>10. 组合和排列</h3></blockquote>\n<p>组合和排列的主要差别在于顺序是否重要。<br>例1：</p>\n<blockquote>\n<p>1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？<br>例2：<br>有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？</p>\n</blockquote>\n<p>基于它们的一些常见算法</p>\n<ul>\n<li>排列</li>\n<li>排列2</li>\n<li>排列顺序</li>\n</ul>\n<p>来自：<a href=\"http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview\" target=\"_blank\" rel=\"external\">http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview</a></p>\n","excerpt":"","more":"<h3 id=\"代码面试最常用的10大算法\"><a href=\"#代码面试最常用的10大算法\" class=\"headerlink\" title=\"代码面试最常用的10大算法\"></a>代码面试最常用的10大算法</h3><blockquote>\n<p>面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。</p>\n</blockquote>\n<p>在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。<br>本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。</p>\n<h3 id=\"1-String-Array-Matrix\"><a href=\"#1-String-Array-Matrix\" class=\"headerlink\" title=\"1. String/Array/Matrix\"></a>1. String/Array/Matrix</h3><pre><code>toCharArray() //get char array of a String\nArrays.sort()  //sort an array\nArrays.toString(char[] a) //convert to string\ncharAt(int x) //get a char at the specific index\nlength() //string length\nlength //array size \nsubstring(int beginIndex) \nsubstring(int beginIndex, int endIndex)\nInteger.valueOf()//string to integer\nString.valueOf()/integer to string\n</code></pre><p>String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。<br>下面列出一些需要高级算法才能解决的经典问题：</p>\n<ul>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/\">Evaluate Reverse Polish Notation</a></li>\n<li><a href=\"http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/\">Longest Palindromic Substring</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-word-break/\">单词分割</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-word-ladder/\">字梯</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/\">Median of Two Sorted Arrays</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/\">正则表达式匹配￼Java</a></li>\n<li><a href=\"http://merge%20intervals/\">合并间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-insert-interval/\">插入间隔</a></li>\n<li><a href=\"http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/\">Two Sum</a></li>\n<li>3Sum</li>\n<li>4Sum</li>\n<li>3Sum Closest</li>\n<li>String to Integer</li>\n<li>合并排序数组</li>\n<li>Valid Parentheses</li>\n<li>实现strStr()</li>\n<li>Set Matrix Zeroes</li>\n<li>搜索插入位置</li>\n<li>Longest Consecutive Sequence</li>\n<li>Valid Palindrome</li>\n<li>螺旋矩阵</li>\n<li>搜索一个二维矩阵</li>\n<li>旋转图像</li>\n<li>三角形</li>\n<li>Distinct Subsequences Total</li>\n<li>Maximum Subarray</li>\n<li>删除重复的排序数组</li>\n<li>删除重复的排序数组2</li>\n<li>查找没有重复的最长子串</li>\n<li>包含两个独特字符的最长子串</li>\n<li>Palindrome Partitioning</li>\n</ul>\n<h3 id=\"2-链表\"><a href=\"#2-链表\" class=\"headerlink\" title=\"2. 链表\"></a>2. 链表</h3><p>在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   </p>\n<pre><code>class Node {\n    int val;\n    Node next;\n\n    Node(int x) {\n        val = x;\n        next = null;\n    }\n}\n</code></pre><p>比较流行的两个链表例子就是栈和队列。</p>\n<h4 id=\"栈（Stack）\"><a href=\"#栈（Stack）\" class=\"headerlink\" title=\"栈（Stack）\"></a>栈（Stack）</h4><pre><code>class Stack{\n    Node top; \n\n    public Node peek(){\n        if(top != null){\n            return top;\n        }\n\n        return null;\n    }\n\n    public Node pop(){\n        if(top == null){\n            return null;\n        }else{\n            Node temp = new Node(top.val);\n            top = top.next;\n            return temp;    \n        }\n    }\n\n    public void push(Node n){\n        if(n != null){\n            n.next = top;\n            top = n;\n        }\n    }\n}\n</code></pre><h4 id=\"队列（Queue）\"><a href=\"#队列（Queue）\" class=\"headerlink\" title=\"队列（Queue）\"></a>队列（Queue）</h4><pre><code>class Queue{\n    Node first, last;\n&amp;nbsp;\n    public void enqueue(Node n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n&amp;nbsp;\n    public Node dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            Node temp = new Node(first.val);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><p>值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。<br>在实际中，需要用到链表的算法有：</p>\n<ul>\n<li>插入两个数字</li>\n<li>重新排序列表</li>\n<li>链表周期</li>\n<li>Copy List with Random Pointer</li>\n<li>合并两个有序列表</li>\n<li>合并多个排序列表</li>\n<li>从排序列表中删除重复的</li>\n<li>分区列表</li>\n<li>LRU缓存</li>\n</ul>\n<h3 id=\"3-树-amp-堆\"><a href=\"#3-树-amp-堆\" class=\"headerlink\" title=\"3. 树&amp;堆\"></a>3. 树&amp;堆</h3><p>这里的树通常是指二叉树。</p>\n<pre><code>class TreeNode{\n    int value;\n    TreeNode left;\n    TreeNode right;\n} \n</code></pre><p>下面是一些与二叉树有关的概念：</p>\n<ul>\n<li>二叉树搜索：对于所有节点，顺序是：left children \\&lt;= current node \\&lt;= right children；</li>\n<li>平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；</li>\n<li>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；</li>\n<li>完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；</li>\n<li>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</li>\n</ul>\n<p>堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>\n<p>下面列出一些基于二叉树和堆的算法：</p>\n<ul>\n<li>二叉树前序遍历</li>\n<li>二叉树中序遍历</li>\n<li>二叉树后序遍历</li>\n<li>字梯</li>\n<li>验证二叉查找树</li>\n<li>把二叉树变平放到链表里</li>\n<li>二叉树路径和</li>\n<li>从前序和后序构建二叉树</li>\n<li>把有序数组转换为二叉查找树</li>\n<li>把有序列表转为二叉查找树</li>\n<li>最小深度二叉树</li>\n<li>二叉树最大路径和</li>\n<li>平衡二叉树</li>\n</ul>\n<h3 id=\"4-Graph\"><a href=\"#4-Graph\" class=\"headerlink\" title=\"4. Graph\"></a>4. Graph</h3><p>与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg\" alt=\"\"></p>\n<h4 id=\"第一步，定义一个GraphNode\"><a href=\"#第一步，定义一个GraphNode\" class=\"headerlink\" title=\"第一步，定义一个GraphNode\"></a>第一步，定义一个GraphNode</h4><pre><code>class GraphNode{ \n    int val;\n    GraphNode next;\n    GraphNode[] neighbors;\n    boolean visited;\n\n    GraphNode(int x) {\n        val = x;\n    }\n\n    GraphNode(int x, GraphNode[] n){\n        val = x;\n        neighbors = n;\n    }\n\n    public String toString(){\n        return &quot;value: &quot;+ this.val; \n    }\n}\n</code></pre><h4 id=\"第二步，定义一个队列\"><a href=\"#第二步，定义一个队列\" class=\"headerlink\" title=\"第二步，定义一个队列\"></a>第二步，定义一个队列</h4><pre><code>class Queue{\n    GraphNode first, last;\n\n    public void enqueue(GraphNode n){\n        if(first == null){\n            first = n;\n            last = first;\n        }else{\n            last.next = n;\n            last = n;\n        }\n    }\n\n    public GraphNode dequeue(){\n        if(first == null){\n            return null;\n        }else{\n            GraphNode temp = new GraphNode(first.val, first.neighbors);\n            first = first.next;\n            return temp;\n        }   \n    }\n}\n</code></pre><h4 id=\"第三步，使用队列进行宽度优先搜索\"><a href=\"#第三步，使用队列进行宽度优先搜索\" class=\"headerlink\" title=\"第三步，使用队列进行宽度优先搜索\"></a>第三步，使用队列进行宽度优先搜索</h4><pre><code>public class GraphTest {\n\n    public static void main(String[] args) {\n        GraphNode n1 = new GraphNode(1); \n        GraphNode n2 = new GraphNode(2); \n        GraphNode n3 = new GraphNode(3); \n        GraphNode n4 = new GraphNode(4); \n        GraphNode n5 = new GraphNode(5); \n\n        n1.neighbors = new GraphNode[]{n2,n3,n5};\n        n2.neighbors = new GraphNode[]{n1,n4};\n        n3.neighbors = new GraphNode[]{n1,n4,n5};\n        n4.neighbors = new GraphNode[]{n2,n3,n5};\n        n5.neighbors = new GraphNode[]{n1,n3,n4};\n\n        breathFirstSearch(n1, 5);\n    }\n\n    public static void breathFirstSearch(GraphNode root, int x){\n        if(root.val == x)\n            System.out.println(&quot;find in root&quot;);\n\n        Queue queue = new Queue();\n        root.visited = true;\n        queue.enqueue(root);\n\n        while(queue.first != null){\n            GraphNode c = (GraphNode) queue.dequeue();\n            for(GraphNode n: c.neighbors){\n\n                if(!n.visited){\n                    System.out.print(n + &quot; &quot;);\n                    n.visited = true;\n                    if(n.val == x)\n                        System.out.println(&quot;Find &quot;+n);\n                    queue.enqueue(n);\n                }\n            }\n        }\n    }\n}\n</code></pre><h4 id=\"输出结果：\"><a href=\"#输出结果：\" class=\"headerlink\" title=\"输出结果：\"></a>输出结果：</h4><pre><code>value: 2 value: 3 value: 5 Find value: 5 \nvalue: 4\n</code></pre><p>实际中，基于Graph需要经常用到的算法：</p>\n<ul>\n<li>克隆Graph</li>\n</ul>\n<h3 id=\"5-排序\"><a href=\"#5-排序\" class=\"headerlink\" title=\"5. 排序\"></a>5. 排序</h3><p>不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。</p>\n<p><img src=\"http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg\" alt=\"\"></p>\n<p>BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   </p>\n<p>下面是这些算法的具体实例，另外，你还可以阅读： <a href=\"http://www.programcreek.com/2014/03/how-developers-sort-in-java/\">Java开发者在实际操作中是如何排序的</a>。</p>\n<ul>\n<li>归并排序</li>\n<li>快速排序</li>\n<li>插入排序</li>\n</ul>\n<h3 id=\"6-递归和迭代\"><a href=\"#6-递归和迭代\" class=\"headerlink\" title=\"6. 递归和迭代\"></a>6. 递归和迭代</h3><p>下面通过一个例子来说明什么是递归。</p>\n<h4 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h4><blockquote>\n<p>这里有n个台阶，每次能爬1或2节，请问有多少种爬法？</p>\n</blockquote>\n<h4 id=\"步骤1：查找n和n-1之间的关系\"><a href=\"#步骤1：查找n和n-1之间的关系\" class=\"headerlink\" title=\"步骤1：查找n和n-1之间的关系\"></a>步骤1：查找n和n-1之间的关系</h4><p>为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   </p>\n<h4 id=\"步骤2：确保开始条件是正确的\"><a href=\"#步骤2：确保开始条件是正确的\" class=\"headerlink\" title=\"步骤2：确保开始条件是正确的\"></a>步骤2：确保开始条件是正确的</h4><p>f(0) = 0;<br>f(1) = 1; </p>\n<pre><code>public static int f(int n){\n    if(n &lt;= 2) return n;\n    int x = f(n-1) + f(n-2);\n    return x;\n}\n</code></pre><p>递归方法的时间复杂度指数为n，这里会有很多冗余计算。<br>    f(5)<br>    f(4) + f(3)<br>    f(3) + f(2) + f(2) + f(1)<br>    f(2) + f(1) + f(2) + f(2) + f(1)</p>\n<p>该递归可以很简单地转换为迭代。<br>    public static int f(int n) {</p>\n<pre><code>    if (n &lt;= 2){\n        return n;\n    }\n\n    int first = 1, second = 2;\n    int third = 0;\n\n    for (int i = 3; i &lt;= n; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n\n    return third;\n}\n</code></pre><p>在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 <a href=\"http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/\">这里</a>看看。</p>\n<h3 id=\"7-动态规划\"><a href=\"#7-动态规划\" class=\"headerlink\" title=\"7. 动态规划\"></a>7. 动态规划</h3><p>动态规划主要用来解决如下技术问题：</p>\n<ul>\n<li>通过较小的子例来解决一个实例；</li>\n<li>对于一个较小的实例，可能需要许多个解决方案；</li>\n<li>把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；</li>\n<li><p>附加空间用来节省时间。<br>上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：<br>  public static int[] A = new int[100];</p>\n<p>  public static int f3(int n) {</p>\n<pre><code>if (n &lt;= 2)\n    A[n]= n;\n\nif(A[n] &gt; 0)\n    return A[n];\nelse\n    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!\nreturn A[n];\n</code></pre><p>  }</p>\n</li>\n</ul>\n<p>一些基于动态规划的算法：</p>\n<ul>\n<li>编辑距离</li>\n<li>最长回文子串</li>\n<li>单词分割</li>\n<li>最大的子数组</li>\n</ul>\n<h3 id=\"8-位操作\"><a href=\"#8-位操作\" class=\"headerlink\" title=\"8. 位操作\"></a>8. 位操作</h3><p>位操作符：<br><img src=\"http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg\" alt=\"\"></p>\n<p>从一个给定的数n中找位i（i从0开始，然后向右开始）</p>\n<pre><code>public static boolean getBit(int num, int i){\n    int result = num &amp; (1&lt;&lt;i);\n\n    if(result == 0){\n        return false;\n    }else{\n        return true;\n    }\n}\n</code></pre><p>例如，获取10的第二位：<br>    i=1, n=10<br>    1&lt;&lt;1= 10<br>    1010&amp;10=10<br>    10 is not 0, so return true;</p>\n<p>典型的位算法：</p>\n<ul>\n<li>Find Single Number</li>\n<li>Maximum Binary Gap</li>\n</ul>\n<h3 id=\"9-概率\"><a href=\"#9-概率\" class=\"headerlink\" title=\"9. 概率\"></a>9. 概率</h3><p>通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： </p>\n<blockquote>\n<p>有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）</p>\n</blockquote>\n<pre><code>public static double caculateProbability(int n){\n    double x = 1; \n\n    for(int i=0; i&lt;n; i++){\n        x *=  (365.0-i)/365.0;\n    }\n\n    double pro = Math.round((1-x) * 100);\n    return pro/100;\n}I\n</code></pre><p>结果：</p>\n<blockquote>\n<p>calculateProbability(50) = 0.97</p>\n<h3 id=\"10-组合和排列\"><a href=\"#10-组合和排列\" class=\"headerlink\" title=\"10. 组合和排列\"></a>10. 组合和排列</h3></blockquote>\n<p>组合和排列的主要差别在于顺序是否重要。<br>例1：</p>\n<blockquote>\n<p>1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？<br>例2：<br>有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？</p>\n</blockquote>\n<p>基于它们的一些常见算法</p>\n<ul>\n<li>排列</li>\n<li>排列2</li>\n<li>排列顺序</li>\n</ul>\n<p>来自：<a href=\"http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview\">http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview</a></p>\n"},{"title":"使用groovy读取excel里面内容","date":"2015-11-20T08:27:54.000Z","keywords":null,"_content":"# 使用groovy读取excel里面内容\n\n### 需要依赖\n[apache.org/poi](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n### 项目目录结构：\n![](http://m1.yea.im/43k.jpg)\n\n项目 assets 下面放了一个people.xlsx文件\n\n![](http://m1.yea.im/43i.jpg)\n\n### **PS**：\n- 本文依赖 [Groovy读取excel文件](http://blog.csdn.net/andyxuq/article/details/7916098) 尝试读取后，发现不能运行\n- 下载 Apache的POI组建 遇到问题\n\n### 项目的源码：\n\n\timport org.apache.poi.ss.usermodel.Row\n\timport org.apache.poi.xssf.usermodel.XSSFCell\n\timport org.apache.poi.xssf.usermodel.XSSFRow\n\timport org.apache.poi.xssf.usermodel.XSSFSheet\n\timport org.apache.poi.xssf.usermodel.XSSFWorkbook\n\t/**\n\t * Created by WangQing on 15/11/20.\n\t */\n\tclass TestGroovy {\n\t\n\t\n\t\n\t    void updateResourceDate(){\n\t        def filePath = \"./assets/people.xlsx\"\n\t\n\t\n\t        File file = new File(filePath)\n\t\n\t        FileInputStream is = new FileInputStream(file);\n\t\n\t        XSSFWorkbook workbook = new XSSFWorkbook(is);\n\t        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\t\n\t        //循环sheet\n\t        (0..<workbook.sheetIterator().collect {return it}.@size).each {s->\n\t            XSSFSheet sheet = workbook.getSheetAt(s);\n\t            int rows = sheet.physicalNumberOfRows;\n\t\n\t            //忽略第一行,标题行\n\t            (1..<rows).each{r->\n\t                XSSFRow row = sheet.getRow(r);\n\t                def cells = row.physicalNumberOfCells;\n\t\n\t                (0..<cells).each{c->\n\t                    XSSFCell cell = row.getCell(c);\n\t\n\t                    def name = \"\";\n\t\n\t                    switch (c) {\n\t                        case 0:\n\t                            name = \"A:\"\n\t                            break;\n\t                        case 1:\n\t                            name = \"B:\"\n\t                            break\n\t                        case 2:\n\t                            name = \"C:\"\n\t                            break\n\t                        case 3:\n\t                            name = \"D:\"\n\t                            break\n\t                    }\n\t                    print name + \"  \"+cell+ \", \";\n\t\n\t\n\t                }\n\t                println \"\";\n\t            }\n\t        }\n\t    }\n\t\n\t    static main(args) {\n\t        TestGroovy a = new TestGroovy();\n\t        a.updateResourceDate();\n\t    }\n\t}\n\t\n\n项目运行结果：\n![](http://m1.yea.im/43n.jpg)\n\n### Apache的POI组建 遇到问题\n首先进入网址：[http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：\n![](http://m1.yea.im/43l.jpg)\n\n其中该项目中使用了\n![](http://m1.yea.im/43j.jpg)\nxmlbeans-2.6.0.jar\n\n这个文件在上面的 lib 下面。\n\n因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 \n\n*HSSFRow*  ，发现报错：\n\tRequest processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents\n\n\tPOIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(\"xxx.xlsx\"));\n\tHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n\n原因是：\nHSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls \nXSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx\n\n所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。","source":"_posts/使用groovy读取excel里面内容.md","raw":"title: 使用groovy读取excel里面内容\ndate: 2015-11-20 16:27:54\ncategories:\nkeywords:\ntags: groovy\n---\n# 使用groovy读取excel里面内容\n\n### 需要依赖\n[apache.org/poi](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n### 项目目录结构：\n![](http://m1.yea.im/43k.jpg)\n\n项目 assets 下面放了一个people.xlsx文件\n\n![](http://m1.yea.im/43i.jpg)\n\n### **PS**：\n- 本文依赖 [Groovy读取excel文件](http://blog.csdn.net/andyxuq/article/details/7916098) 尝试读取后，发现不能运行\n- 下载 Apache的POI组建 遇到问题\n\n### 项目的源码：\n\n\timport org.apache.poi.ss.usermodel.Row\n\timport org.apache.poi.xssf.usermodel.XSSFCell\n\timport org.apache.poi.xssf.usermodel.XSSFRow\n\timport org.apache.poi.xssf.usermodel.XSSFSheet\n\timport org.apache.poi.xssf.usermodel.XSSFWorkbook\n\t/**\n\t * Created by WangQing on 15/11/20.\n\t */\n\tclass TestGroovy {\n\t\n\t\n\t\n\t    void updateResourceDate(){\n\t        def filePath = \"./assets/people.xlsx\"\n\t\n\t\n\t        File file = new File(filePath)\n\t\n\t        FileInputStream is = new FileInputStream(file);\n\t\n\t        XSSFWorkbook workbook = new XSSFWorkbook(is);\n\t        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\t\n\t        //循环sheet\n\t        (0..<workbook.sheetIterator().collect {return it}.@size).each {s->\n\t            XSSFSheet sheet = workbook.getSheetAt(s);\n\t            int rows = sheet.physicalNumberOfRows;\n\t\n\t            //忽略第一行,标题行\n\t            (1..<rows).each{r->\n\t                XSSFRow row = sheet.getRow(r);\n\t                def cells = row.physicalNumberOfCells;\n\t\n\t                (0..<cells).each{c->\n\t                    XSSFCell cell = row.getCell(c);\n\t\n\t                    def name = \"\";\n\t\n\t                    switch (c) {\n\t                        case 0:\n\t                            name = \"A:\"\n\t                            break;\n\t                        case 1:\n\t                            name = \"B:\"\n\t                            break\n\t                        case 2:\n\t                            name = \"C:\"\n\t                            break\n\t                        case 3:\n\t                            name = \"D:\"\n\t                            break\n\t                    }\n\t                    print name + \"  \"+cell+ \", \";\n\t\n\t\n\t                }\n\t                println \"\";\n\t            }\n\t        }\n\t    }\n\t\n\t    static main(args) {\n\t        TestGroovy a = new TestGroovy();\n\t        a.updateResourceDate();\n\t    }\n\t}\n\t\n\n项目运行结果：\n![](http://m1.yea.im/43n.jpg)\n\n### Apache的POI组建 遇到问题\n首先进入网址：[http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip](http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip)\n\n下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：\n![](http://m1.yea.im/43l.jpg)\n\n其中该项目中使用了\n![](http://m1.yea.im/43j.jpg)\nxmlbeans-2.6.0.jar\n\n这个文件在上面的 lib 下面。\n\n因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 \n\n*HSSFRow*  ，发现报错：\n\tRequest processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents\n\n\tPOIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(\"xxx.xlsx\"));\n\tHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n\n原因是：\nHSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls \nXSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx\n\n所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。","slug":"使用groovy读取excel里面内容","published":1,"updated":"2015-11-20T08:28:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1yy000urgexasat0dh8","content":"<h1 id=\"使用groovy读取excel里面内容\"><a href=\"#使用groovy读取excel里面内容\" class=\"headerlink\" title=\"使用groovy读取excel里面内容\"></a>使用groovy读取excel里面内容</h1><h3 id=\"需要依赖\"><a href=\"#需要依赖\" class=\"headerlink\" title=\"需要依赖\"></a>需要依赖</h3><p><a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\" target=\"_blank\" rel=\"external\">apache.org/poi</a></p>\n<h3 id=\"项目目录结构：\"><a href=\"#项目目录结构：\" class=\"headerlink\" title=\"项目目录结构：\"></a>项目目录结构：</h3><p><img src=\"http://m1.yea.im/43k.jpg\" alt=\"\"></p>\n<p>项目 assets 下面放了一个people.xlsx文件</p>\n<p><img src=\"http://m1.yea.im/43i.jpg\" alt=\"\"></p>\n<h3 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a><strong>PS</strong>：</h3><ul>\n<li>本文依赖 <a href=\"http://blog.csdn.net/andyxuq/article/details/7916098\" target=\"_blank\" rel=\"external\">Groovy读取excel文件</a> 尝试读取后，发现不能运行</li>\n<li>下载 Apache的POI组建 遇到问题</li>\n</ul>\n<h3 id=\"项目的源码：\"><a href=\"#项目的源码：\" class=\"headerlink\" title=\"项目的源码：\"></a>项目的源码：</h3><pre><code>import org.apache.poi.ss.usermodel.Row\nimport org.apache.poi.xssf.usermodel.XSSFCell\nimport org.apache.poi.xssf.usermodel.XSSFRow\nimport org.apache.poi.xssf.usermodel.XSSFSheet\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook\n/**\n * Created by WangQing on 15/11/20.\n */\nclass TestGroovy {\n\n\n\n    void updateResourceDate(){\n        def filePath = &quot;./assets/people.xlsx&quot;\n\n\n        File file = new File(filePath)\n\n        FileInputStream is = new FileInputStream(file);\n\n        XSSFWorkbook workbook = new XSSFWorkbook(is);\n        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\n        //循环sheet\n        (0..&lt;workbook.sheetIterator().collect {return it}.@size).each {s-&gt;\n            XSSFSheet sheet = workbook.getSheetAt(s);\n            int rows = sheet.physicalNumberOfRows;\n\n            //忽略第一行,标题行\n            (1..&lt;rows).each{r-&gt;\n                XSSFRow row = sheet.getRow(r);\n                def cells = row.physicalNumberOfCells;\n\n                (0..&lt;cells).each{c-&gt;\n                    XSSFCell cell = row.getCell(c);\n\n                    def name = &quot;&quot;;\n\n                    switch (c) {\n                        case 0:\n                            name = &quot;A:&quot;\n                            break;\n                        case 1:\n                            name = &quot;B:&quot;\n                            break\n                        case 2:\n                            name = &quot;C:&quot;\n                            break\n                        case 3:\n                            name = &quot;D:&quot;\n                            break\n                    }\n                    print name + &quot;  &quot;+cell+ &quot;, &quot;;\n\n\n                }\n                println &quot;&quot;;\n            }\n        }\n    }\n\n    static main(args) {\n        TestGroovy a = new TestGroovy();\n        a.updateResourceDate();\n    }\n}\n</code></pre><p>项目运行结果：<br><img src=\"http://m1.yea.im/43n.jpg\" alt=\"\"></p>\n<h3 id=\"Apache的POI组建-遇到问题\"><a href=\"#Apache的POI组建-遇到问题\" class=\"headerlink\" title=\"Apache的POI组建 遇到问题\"></a>Apache的POI组建 遇到问题</h3><p>首先进入网址：<a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\" target=\"_blank\" rel=\"external\">http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip</a></p>\n<p>下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：<br><img src=\"http://m1.yea.im/43l.jpg\" alt=\"\"></p>\n<p>其中该项目中使用了<br><img src=\"http://m1.yea.im/43j.jpg\" alt=\"\"><br>xmlbeans-2.6.0.jar</p>\n<p>这个文件在上面的 lib 下面。</p>\n<p>因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 </p>\n<p><em>HSSFRow</em>  ，发现报错：<br>    Request processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents</p>\n<pre><code>POIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(&quot;xxx.xlsx&quot;));\nHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n</code></pre><p>原因是：<br>HSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls<br>XSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx</p>\n<p>所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。</p>\n","excerpt":"","more":"<h1 id=\"使用groovy读取excel里面内容\"><a href=\"#使用groovy读取excel里面内容\" class=\"headerlink\" title=\"使用groovy读取excel里面内容\"></a>使用groovy读取excel里面内容</h1><h3 id=\"需要依赖\"><a href=\"#需要依赖\" class=\"headerlink\" title=\"需要依赖\"></a>需要依赖</h3><p><a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\">apache.org/poi</a></p>\n<h3 id=\"项目目录结构：\"><a href=\"#项目目录结构：\" class=\"headerlink\" title=\"项目目录结构：\"></a>项目目录结构：</h3><p><img src=\"http://m1.yea.im/43k.jpg\" alt=\"\"></p>\n<p>项目 assets 下面放了一个people.xlsx文件</p>\n<p><img src=\"http://m1.yea.im/43i.jpg\" alt=\"\"></p>\n<h3 id=\"PS：\"><a href=\"#PS：\" class=\"headerlink\" title=\"PS：\"></a><strong>PS</strong>：</h3><ul>\n<li>本文依赖 <a href=\"http://blog.csdn.net/andyxuq/article/details/7916098\">Groovy读取excel文件</a> 尝试读取后，发现不能运行</li>\n<li>下载 Apache的POI组建 遇到问题</li>\n</ul>\n<h3 id=\"项目的源码：\"><a href=\"#项目的源码：\" class=\"headerlink\" title=\"项目的源码：\"></a>项目的源码：</h3><pre><code>import org.apache.poi.ss.usermodel.Row\nimport org.apache.poi.xssf.usermodel.XSSFCell\nimport org.apache.poi.xssf.usermodel.XSSFRow\nimport org.apache.poi.xssf.usermodel.XSSFSheet\nimport org.apache.poi.xssf.usermodel.XSSFWorkbook\n/**\n * Created by WangQing on 15/11/20.\n */\nclass TestGroovy {\n\n\n\n    void updateResourceDate(){\n        def filePath = &quot;./assets/people.xlsx&quot;\n\n\n        File file = new File(filePath)\n\n        FileInputStream is = new FileInputStream(file);\n\n        XSSFWorkbook workbook = new XSSFWorkbook(is);\n        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);\n\n        //循环sheet\n        (0..&lt;workbook.sheetIterator().collect {return it}.@size).each {s-&gt;\n            XSSFSheet sheet = workbook.getSheetAt(s);\n            int rows = sheet.physicalNumberOfRows;\n\n            //忽略第一行,标题行\n            (1..&lt;rows).each{r-&gt;\n                XSSFRow row = sheet.getRow(r);\n                def cells = row.physicalNumberOfCells;\n\n                (0..&lt;cells).each{c-&gt;\n                    XSSFCell cell = row.getCell(c);\n\n                    def name = &quot;&quot;;\n\n                    switch (c) {\n                        case 0:\n                            name = &quot;A:&quot;\n                            break;\n                        case 1:\n                            name = &quot;B:&quot;\n                            break\n                        case 2:\n                            name = &quot;C:&quot;\n                            break\n                        case 3:\n                            name = &quot;D:&quot;\n                            break\n                    }\n                    print name + &quot;  &quot;+cell+ &quot;, &quot;;\n\n\n                }\n                println &quot;&quot;;\n            }\n        }\n    }\n\n    static main(args) {\n        TestGroovy a = new TestGroovy();\n        a.updateResourceDate();\n    }\n}\n</code></pre><p>项目运行结果：<br><img src=\"http://m1.yea.im/43n.jpg\" alt=\"\"></p>\n<h3 id=\"Apache的POI组建-遇到问题\"><a href=\"#Apache的POI组建-遇到问题\" class=\"headerlink\" title=\"Apache的POI组建 遇到问题\"></a>Apache的POI组建 遇到问题</h3><p>首先进入网址：<a href=\"http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip\">http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip</a></p>\n<p>下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：<br><img src=\"http://m1.yea.im/43l.jpg\" alt=\"\"></p>\n<p>其中该项目中使用了<br><img src=\"http://m1.yea.im/43j.jpg\" alt=\"\"><br>xmlbeans-2.6.0.jar</p>\n<p>这个文件在上面的 lib 下面。</p>\n<p>因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 </p>\n<p><em>HSSFRow</em>  ，发现报错：<br>    Request processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents</p>\n<pre><code>POIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(&quot;xxx.xlsx&quot;));\nHSSFWorkbook wb = new HSSFWorkbook(excelFile);\n</code></pre><p>原因是：<br>HSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls<br>XSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx</p>\n<p>所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。</p>\n"},{"title":"圆角图片处理","date":"2015-10-10T07:17:43.000Z","keywords":null,"_content":"\n\n\t//图片圆角处理\n    public Bitmap getRoundedBitmap(Bitmap mBitmap) {\n        //创建新的位图\n        Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        //把创建的位图作为画板\n        Canvas mCanvas = new Canvas(bgBitmap);\n\n        Paint mPaint = new Paint();\n        Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n        RectF mRectF = new RectF(mRect);\n        //设置圆角半径为20\n        float roundPx = 10;\n        mPaint.setAntiAlias(true);\n        //先绘制圆角矩形\n        mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n        //设置图像的叠加模式\n        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        //绘制图像\n        mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n        return bgBitmap;\n    }","source":"_posts/圆角图片处理.md","raw":"title: 圆角图片处理\ndate: 2015-10-10 15:17:43\ncategories:\nkeywords:\ntags:\n---\n\n\n\t//图片圆角处理\n    public Bitmap getRoundedBitmap(Bitmap mBitmap) {\n        //创建新的位图\n        Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n        //把创建的位图作为画板\n        Canvas mCanvas = new Canvas(bgBitmap);\n\n        Paint mPaint = new Paint();\n        Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n        RectF mRectF = new RectF(mRect);\n        //设置圆角半径为20\n        float roundPx = 10;\n        mPaint.setAntiAlias(true);\n        //先绘制圆角矩形\n        mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n        //设置图像的叠加模式\n        mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n        //绘制图像\n        mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n        return bgBitmap;\n    }","slug":"圆角图片处理","published":1,"updated":"2015-10-10T07:18:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1z4000wrgexru6iexo1","content":"<pre><code>//图片圆角处理\npublic Bitmap getRoundedBitmap(Bitmap mBitmap) {\n    //创建新的位图\n    Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n    //把创建的位图作为画板\n    Canvas mCanvas = new Canvas(bgBitmap);\n\n    Paint mPaint = new Paint();\n    Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n    RectF mRectF = new RectF(mRect);\n    //设置圆角半径为20\n    float roundPx = 10;\n    mPaint.setAntiAlias(true);\n    //先绘制圆角矩形\n    mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n    //设置图像的叠加模式\n    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n    //绘制图像\n    mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n    return bgBitmap;\n}\n</code></pre>","excerpt":"","more":"<pre><code>//图片圆角处理\npublic Bitmap getRoundedBitmap(Bitmap mBitmap) {\n    //创建新的位图\n    Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);\n    //把创建的位图作为画板\n    Canvas mCanvas = new Canvas(bgBitmap);\n\n    Paint mPaint = new Paint();\n    Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());\n    RectF mRectF = new RectF(mRect);\n    //设置圆角半径为20\n    float roundPx = 10;\n    mPaint.setAntiAlias(true);\n    //先绘制圆角矩形\n    mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);\n\n    //设置图像的叠加模式\n    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));\n    //绘制图像\n    mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);\n\n    return bgBitmap;\n}\n</code></pre>"},{"title":"推荐processon 让流程图也可以共享","date":"2016-02-25T02:32:02.000Z","keywords":null,"_content":"\n推荐一个流程图共享的网站：\n[https://www.processon.com/popular](https://www.processon.com/popular)\n\n一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用\n\n![https://www.processon.com/view/56ca927ce4b0362f22d848b5](http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg)\n[原样图](https://www.processon.com/view/56ca927ce4b0362f22d848b5 \"原样图\")\n\n然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。\n### 例如：\n- [IOS开发](https://www.processon.com/view/557051bee4b0d6a77d619124)\n- [前端技能树](https://www.processon.com/view/55783184e4b0d6a77d9f9560)\n- [Android Service总结1](https://www.processon.com/view/555097e7e4b09739f4652bf3)\n- [Android Service总结2](https://www.processon.com/view/5550a05ee4b09739f46585b0)\n- [Android测试工具](https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08)\n- [Android中主要类的关系图 Activity Class](https://www.processon.com/view/55f69023e4b0a8c6fae84984)\n- [APP开发人员技能树](https://www.processon.com/view/55110a6ee4b00af64b0c3cba)\n- [EventBus源码分析简要图](https://www.processon.com/view/568bc9eae4b002e52c0fb427)\n- [Android小说阅读器部分计划及流程](https://www.processon.com/view/561ccd9de4b07efc017ca19b)\n- [View绘制流程](https://www.processon.com/view/562847b4e4b04931dccccbfe)\n- [Android Drawable分类汇总](https://www.processon.com/view/550cf083e4b0b74dae7c2c7d)","source":"_posts/推荐processon-让流程图也可以共享.md","raw":"title: 推荐processon 让流程图也可以共享\ndate: 2016-02-25 10:32:02\ncategories:\nkeywords:\ntags:\n---\n\n推荐一个流程图共享的网站：\n[https://www.processon.com/popular](https://www.processon.com/popular)\n\n一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用\n\n![https://www.processon.com/view/56ca927ce4b0362f22d848b5](http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg)\n[原样图](https://www.processon.com/view/56ca927ce4b0362f22d848b5 \"原样图\")\n\n然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。\n### 例如：\n- [IOS开发](https://www.processon.com/view/557051bee4b0d6a77d619124)\n- [前端技能树](https://www.processon.com/view/55783184e4b0d6a77d9f9560)\n- [Android Service总结1](https://www.processon.com/view/555097e7e4b09739f4652bf3)\n- [Android Service总结2](https://www.processon.com/view/5550a05ee4b09739f46585b0)\n- [Android测试工具](https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08)\n- [Android中主要类的关系图 Activity Class](https://www.processon.com/view/55f69023e4b0a8c6fae84984)\n- [APP开发人员技能树](https://www.processon.com/view/55110a6ee4b00af64b0c3cba)\n- [EventBus源码分析简要图](https://www.processon.com/view/568bc9eae4b002e52c0fb427)\n- [Android小说阅读器部分计划及流程](https://www.processon.com/view/561ccd9de4b07efc017ca19b)\n- [View绘制流程](https://www.processon.com/view/562847b4e4b04931dccccbfe)\n- [Android Drawable分类汇总](https://www.processon.com/view/550cf083e4b0b74dae7c2c7d)","slug":"推荐processon-让流程图也可以共享","published":1,"updated":"2016-02-25T02:49:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1z5000yrgexcuq3mcpp","content":"<p>推荐一个流程图共享的网站：<br><a href=\"https://www.processon.com/popular\" target=\"_blank\" rel=\"external\">https://www.processon.com/popular</a></p>\n<p>一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg\" alt=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\"><br><a href=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\" title=\"原样图\" target=\"_blank\" rel=\"external\">原样图</a></p>\n<p>然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。</p>\n<h3 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h3><ul>\n<li><a href=\"https://www.processon.com/view/557051bee4b0d6a77d619124\" target=\"_blank\" rel=\"external\">IOS开发</a></li>\n<li><a href=\"https://www.processon.com/view/55783184e4b0d6a77d9f9560\" target=\"_blank\" rel=\"external\">前端技能树</a></li>\n<li><a href=\"https://www.processon.com/view/555097e7e4b09739f4652bf3\" target=\"_blank\" rel=\"external\">Android Service总结1</a></li>\n<li><a href=\"https://www.processon.com/view/5550a05ee4b09739f46585b0\" target=\"_blank\" rel=\"external\">Android Service总结2</a></li>\n<li><a href=\"https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08\" target=\"_blank\" rel=\"external\">Android测试工具</a></li>\n<li><a href=\"https://www.processon.com/view/55f69023e4b0a8c6fae84984\" target=\"_blank\" rel=\"external\">Android中主要类的关系图 Activity Class</a></li>\n<li><a href=\"https://www.processon.com/view/55110a6ee4b00af64b0c3cba\" target=\"_blank\" rel=\"external\">APP开发人员技能树</a></li>\n<li><a href=\"https://www.processon.com/view/568bc9eae4b002e52c0fb427\" target=\"_blank\" rel=\"external\">EventBus源码分析简要图</a></li>\n<li><a href=\"https://www.processon.com/view/561ccd9de4b07efc017ca19b\" target=\"_blank\" rel=\"external\">Android小说阅读器部分计划及流程</a></li>\n<li><a href=\"https://www.processon.com/view/562847b4e4b04931dccccbfe\" target=\"_blank\" rel=\"external\">View绘制流程</a></li>\n<li><a href=\"https://www.processon.com/view/550cf083e4b0b74dae7c2c7d\" target=\"_blank\" rel=\"external\">Android Drawable分类汇总</a></li>\n</ul>\n","excerpt":"","more":"<p>推荐一个流程图共享的网站：<br><a href=\"https://www.processon.com/popular\">https://www.processon.com/popular</a></p>\n<p>一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg\" alt=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\"><br><a href=\"https://www.processon.com/view/56ca927ce4b0362f22d848b5\" title=\"原样图\">原样图</a></p>\n<p>然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。</p>\n<h3 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h3><ul>\n<li><a href=\"https://www.processon.com/view/557051bee4b0d6a77d619124\">IOS开发</a></li>\n<li><a href=\"https://www.processon.com/view/55783184e4b0d6a77d9f9560\">前端技能树</a></li>\n<li><a href=\"https://www.processon.com/view/555097e7e4b09739f4652bf3\">Android Service总结1</a></li>\n<li><a href=\"https://www.processon.com/view/5550a05ee4b09739f46585b0\">Android Service总结2</a></li>\n<li><a href=\"https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08\">Android测试工具</a></li>\n<li><a href=\"https://www.processon.com/view/55f69023e4b0a8c6fae84984\">Android中主要类的关系图 Activity Class</a></li>\n<li><a href=\"https://www.processon.com/view/55110a6ee4b00af64b0c3cba\">APP开发人员技能树</a></li>\n<li><a href=\"https://www.processon.com/view/568bc9eae4b002e52c0fb427\">EventBus源码分析简要图</a></li>\n<li><a href=\"https://www.processon.com/view/561ccd9de4b07efc017ca19b\">Android小说阅读器部分计划及流程</a></li>\n<li><a href=\"https://www.processon.com/view/562847b4e4b04931dccccbfe\">View绘制流程</a></li>\n<li><a href=\"https://www.processon.com/view/550cf083e4b0b74dae7c2c7d\">Android Drawable分类汇总</a></li>\n</ul>\n"},{"title":"凯哥高质量文章系列","date":"2015-11-20T04:17:18.000Z","keywords":null,"_content":"\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n\n# 凯哥系列：\n## 1. [Activity启动过程全解析](http://www.devtf.cn/?p=1101)\n## 2. [framework-Activity界面显示全解析](http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287)\n\n\n注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念\n\n\n### 看文章的记录：\n1.App启动\n2.App入口\n3.Launcher?\n4.AMS??\n5.Binder是神马？怎么进行IPC通信？\n6.Activity生命周期是被谁 什么时候调用的？\n\n### 目的：\n1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度\n2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系\n\n3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合\n\n4.Activity相关的framework问题\n\n### 主要对象功能介绍：\n1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；\n2.ActivityThread:App的真正入口。打开App-\\>main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；\n3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。\n4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。\n5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。\n6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。\n7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。\n8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。\n\n### 主要流程介绍\n\n- zygote 是神马？\n程序 Crash 的时候，打印红色的log通常带有这个\nAndroid基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！\n\nAndroid 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程\n\n我们都知道，每一个App其实都是：\n- 一个单独的dalvik 虚拟机\n\t- 单独的进程\n\n当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！\n\n### SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\n\n首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！\n\n这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。\n\n为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？\n\n那么这些服务是怎么开启起来的呢?\n\n在zygote 开启的时候，会调用 ZygoteInit.main初始化\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n关键代码：\n\tif (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t}\n\t~~~\n\t//开始fork我们的SystemServer进程\n\tif (startSystemServer) {\n\t       startSystemServer(abiList, socketName);\n\t}\n\n\n我们看下startSystemServer()做了些什么:\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n\n我们看下startSystemServer()做了些什么\n\t\n\t    /**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n\t     * Prepare the arguments and fork for the system server process.\n\t     */\n\t    private static boolean startSystemServer(String abiList, String socketName)\n\t            throws MethodAndArgsCaller, RuntimeException {\n\t\n\t         ...ignore some code...\n\t\n\t        //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n\t        /* Hardcoded command line to start the system server */\n\t        String args[] = {\n\t            \"--setuid=1000\",\n\t            \"--setgid=1000\",\n\t            \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007\",\n\t            \"--capabilities=\" + capabilities + \",\" + capabilities,\n\t            \"--runtime-init\",\n\t            \"--nice-name=system_server\",\n\t            \"com.android.server.SystemServer\",\n\t        };\n\t\n\t        int pid;\n\t        try {\n\t            parsedArgs = new ZygoteConnection.Arguments(args);\n\t            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n\t            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\t\n\t        //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n\t            /* Request to fork the system server process */\n\t            pid = Zygote.forkSystemServer(\n\t                    parsedArgs.uid, parsedArgs.gid,\n\t                    parsedArgs.gids,\n\t                    parsedArgs.debugFlags,\n\t                    null,\n\t                    parsedArgs.permittedCapabilities,\n\t                    parsedArgs.effectiveCapabilities);\n\t        } catch (IllegalArgumentException ex) {\n\t            throw new RuntimeException(ex);\n\t        }\n\t\n\t        /* For child process */\n\t        if (pid == 0) {\n\t            if (hasSecondZygote(abiList)) {\n\t                waitForSecondaryZygote(socketName);\n\t            }\n\t\n\t            handleSystemServerProcess(parsedArgs);\n\t        }\n\t\n\t        return true;\n\t    }\n\n### ActivityManagerService是什么？什么时候创建？作用?\n\nActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。\n\nAMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService \n\n\tpublic final class SystemServer {\n\t\n\t    //zygote的主入口\n\t    public static void main(String[] args) {\n\t        new SystemServer().run();\n\t    }\n\t\n\t    public SystemServer() {\n\t        // Check for factory test mode.\n\t        mFactoryTestMode = FactoryTest.getMode();\n\t    }\n\t\n\t    private void run() {\n\t\n\t        ...ignore some code...\n\t\n\t        //加载本地系统服务库，并进行初始化 \n\t        System.loadLibrary(\"android_servers\");\n\t        nativeInit();\n\t\n\t        // 创建系统上下文\n\t        createSystemContext();\n\t\n\t        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class<T>)，这个方法通过反射来启动对应的服务\n\t        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\t\n\t        //开启服务\n\t        try {\n\t            startBootstrapServices();\n\t            startCoreServices();\n\t            startOtherServices();\n\t        } catch (Throwable ex) {\n\t            Slog.e(\"System\", \"******************************************\");\n\t            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n\t            throw ex;\n\t        }\n\t\n\t        ...ignore some code...\n\t\n\t    }\n\t\n\t    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n\t    private void createSystemContext() {\n\t        ActivityThread activityThread = ActivityThread.systemMain();\n\t        mSystemContext = activityThread.getSystemContext();\n\t        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n\t    }\n\t\n\t    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n\t    private void startBootstrapServices() {\n\t\n\t        ...ignore some code...\n\t\n\t        //初始化ActivityManagerService\n\t        mActivityManagerService = mSystemServiceManager.startService(\n\t                ActivityManagerService.Lifecycle.class).getService();\n\t        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\t\n\t        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n\t        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\t\n\t        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n\t        mActivityManagerService.initPowerManagement();\n\t\n\t        // 初始化DisplayManagerService\n\t        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\t\n\t    //初始化PackageManagerService\n\t    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n\t       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\t\n\t    ...ignore some code...\n\t\n\t    }\n\t\n\t}\n\n经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。\n\n你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。\n\n其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开\n\n\tIntent intent = new Intent(Intent.ACTION_MAIN);  \n\tintent.addCategory(Intent.CATEGORY_LAUNCHER);              \n\tComponentName cn = new ComponentName(packageName, className);              \n\tintent.setComponent(cn);  \n\tstartActivity(intent); \n\n但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。\n\n知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？\n\nApp与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。\n\n那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。\n\n在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。\n\n这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。\n\n### Launche是什么？ 什么时候启动？\n\n当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？\n\nLauncher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。\n\n\npackages/apps/Launcher2/src/com/android/launcher2/Launcher.java\n\tpublic final class Launcher extends Activity\n\t        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,\n\t                   View.OnTouchListener {\n\t                   }\n\nLauncher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。\n\n![](DraggedImage.png)\n\n程序列表里面：\n![](DraggedImage-1.png)\n\n可以看到的是，调用的是：\n\tmLauncher.startActivitySafely(v, appInfo.intent, appInfo);\n\n和上面的一样，这叫什么？ 这叫殊途同归！\n\n所以现在我们明白了一件事：不管从哪里点击图标，调用的都是 \n\tLauncher.startActivitySafely()\n\n下面来看看 Launcher.startActivitySafely()到底做了什么事情\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n调用了startAcitivity(v,intent,tag)\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：\n\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n### Instrumentation是什么？和ActivityThread 是什么关系？\n每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()\n\n\tboolean startActivity(View v, Intent intent, Object tag) {\n\t\n\t        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t        try {\n\t            boolean useLaunchAnimation = (v != null) &&\n\t                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\t\n\t            if (useLaunchAnimation) {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent, opts.toBundle());\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(),\n\t                            opts.toBundle());\n\t                }\n\t            } else {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent);\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(), null);\n\t                }\n\t            }\n\t            return true;\n\t        } catch (SecurityException e) {\n\t        ...\n\t        }\n\t        return false;\n\t    }\n\n\n有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？\n\n是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！\n\n那你可能要问老板是who?\n老板当然是 大名鼎鼎的 ActivityThread了\n\nActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。\n\nASM说：『ActivityThread， 你给我暂停一个Activity！』\n\nActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』\n\n于是，Instrumentation 就去把事儿搞定了。\n所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。\n\n### 如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\n前面提到 调用 startActivity()的时候，时间调用了 \n\tmInstrumentation.execStartActivity()\n\n里面又调用了：\n\tActivityManagerNative.getDefault()\n\t                .startActivity\n\n这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。\n\nBinder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。\n\n为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：\n\nAMS， 和 AMP 都实现利率同一个接口： IActivityManager。\n\tclass ActivityManagerProxy implements IActivityManager{}\n\t\n\tpublic final class ActivityManagerService extends ActivityManagerNative{}\n\t\n\tpublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n\n虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。\n\n\n但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。\n\n但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如\n\tpublic int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n\t            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n\t        Parcel data = Parcel.obtain();\n\t        Parcel reply = Parcel.obtain();\n\t\n\t        ...ignore some code...\n\t\n\t        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n\t        reply.readException();\n\t        int result = reply.readInt();\n\t        reply.recycle();\n\t        data.recycle();\n\t        return result;\n\t    }\n\n上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。\n\n即：\n客户度：ActivityManagerProxy ====\\> Binder驱动 ====》ActivityManagerService：服务器\n\n而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。\n\n但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ \n\n还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。\n\n客户端：ApplicationThread \\<=== Binder驱动 \\<=== ApplicationThreadProxy：服务器\n\n他们也实现了相同的接口 IApplicationThread:\n\tprivate class ApplicationThread extends ApplicationThreadNative {}\n\t\n\t  public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\t\n\t  class ApplicationThreadProxy implements IApplicationThread {}\n\n\n### AMS 接收到 客户端的请求后，如果开启一个Activity？\n\nOK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？\n\n注：前方高能，方法调用链接很强！\n\n调用startActivity（）\n\t@Override\n\t    public final int startActivity(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) {\n\t        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n\t            resultWho, requestCode, startFlags, profilerInfo, options,\n\t            UserHandle.getCallingUserId());\n\t    }\n\n调用startActivityAsUser（）\n\t@Override\n\t    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n\t\n\t            ...ignore some code...\n\t\n\t        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n\t                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n\t                profilerInfo, null, null, options, userId, null, null);\n\t    }\n\n这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作\n\t final int startActivityMayWait(IApplicationThread caller, int callingUid,\n\t            String callingPackage, Intent intent, String resolvedType,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n\t            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,\n\t            Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t              int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n\t                    voiceSession, voiceInteractor, resultTo, resultWho,\n\t                    requestCode, callingPid, callingUid, callingPackage,\n\t                    realCallingPid, realCallingUid, startFlags, options,\n\t                    componentSpecified, null, container, inTask);\n\t\n\t            ...ignore some code...\n\t\n\t            }\n\n继续调用 startActivityLocked()\n\n\tfinal int startActivityLocked(IApplicationThread caller,\n\t            Intent intent, String resolvedType, ActivityInfo aInfo,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode,\n\t            int callingPid, int callingUid, String callingPackage,\n\t            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n\t            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n\t            TaskRecord inTask) {\n\t\n\t              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n\t              startFlags, true, options, inTask);\n\t        if (err < 0) {\n\t            notifyActivityDrawnForKeyguard();\n\t        }\n\t        return err;\n\t    }\n\n调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。\n\n终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)\n\nActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，\n\n\tfinal int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n\t            boolean doResume, Bundle options, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\t\n\t            ...ignore some code...\n\t\n\t             return ActivityManager.START_SUCCESS;\n\t            }\n\n调用 ActivityStack.startActivityLocked()\n\n\tfinal void startActivityLocked(ActivityRecord r, boolean newTask,\n\t            boolean doResume, boolean keepCurTransition, Bundle options) {\n\t\n\t        //ActivityRecord中存储的TaskRecord信息\n\t        TaskRecord rTask = r.task;\n\t\n\t         ...ignore some code...\n\t\n\t        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n\t     TaskRecord task = null;\n\t        if (!newTask) {\n\t            boolean startIt = true;\n\t            for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n\t                task = mTaskHistory.get(taskNdx);\n\t                if (task.getTopActivity() == null) {\n\t                    // task中的所有Activity都结束了\n\t                    continue;\n\t                }\n\t                if (task == r.task) {\n\t                    // 找到了\n\t                    if (!startIt) {\n\t                        task.addActivityToTop(r);\n\t                        r.putInHistory();\n\t                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n\t                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n\t                                (r.info.flags & ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n\t                                r.userId, r.info.configChanges, task.voiceSession != null,\n\t                                r.mLaunchTaskBehind);\n\t                        if (VALIDATE_TOKENS) {\n\t                            validateAppTokensLocked();\n\t                        }\n\t                        ActivityOptions.abort(options);\n\t                        return;\n\t                    }\n\t                    break;\n\t                } else if (task.numFullscreen > 0) {\n\t                    startIt = false;\n\t                }\n\t            }\n\t        }\n\t\n\t      ...ignore some code...\n\t\n\t        // Place a new activity at top of stack, so it is next to interact\n\t        // with the user.\n\t        task = r.task;\n\t        task.addActivityToTop(r);\n\t        task.setFrontOfTask();\n\t\n\t        ...ignore some code...\n\t\n\t         if (doResume) {\n\t            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n\t        }\n\t    }\n\n折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor \n\n淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。\n\n一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：\n\tboolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,\n\t            Bundle targetOptions) {\n\t        if (targetStack == null) {\n\t            targetStack = getFocusedStack();\n\t        }\n\t        // Do targetStack first.\n\t        boolean result = false;\n\t        if (isFrontStack(targetStack)) {\n\t            result = targetStack.resumeTopActivityLocked(target, targetOptions);\n\t        }\n\t\n\t          ...ignore some code...\n\t\n\t        return result;\n\t    }\n\n又回到 ActivityStack了。。。\n\nActivityStack.resumeTopActivityLocked()\n\tfinal boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {\n\t        if (inResumeTopActivity) {\n\t            // Don't even start recursing.\n\t            return false;\n\t        }\n\t\n\t        boolean result = false;\n\t        try {\n\t            // Protect against recursion.\n\t            inResumeTopActivity = true;\n\t            result = resumeTopActivityInnerLocked(prev, options);\n\t        } finally {\n\t            inResumeTopActivity = false;\n\t        }\n\t        return result;\n\t    }\n\n坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？\n\n\tfinal boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\t\n\t          ...ignore some code...\n\t      //找出还没结束的首个ActivityRecord\n\t     ActivityRecord next = topRunningActivityLocked(null);\n\t\n\t    //如果一个没结束的Activity都没有，就开启Launcher程序\n\t    if (next == null) {\n\t            ActivityOptions.abort(options);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: No more activities go home\");\n\t            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n\t            // Only resume home if on home display\n\t            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n\t                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n\t            return isOnHomeDisplay() &&\n\t                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n\t        }\n\t\n\t        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n\t          if (mResumedActivity != null) {\n\t            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: Pausing \" + mResumedActivity);\n\t        }\n\t\n\t  }\n\n\n在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。\n\tActivityManagerNative.getDefault().activityPaused(token).\n\n上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。\n\n最后 来一张高清五码的大图，方便记忆\n\n![](Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png)\n\n### 一个App的程序入口是什么？\n是ActivityThread.main()\n\n### 整个App的主线程的消息循环是在哪里创建的?\n是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。\n\n\tpublic static void main(String[] args) {\n\t\n\t          ...ignore some code...    \n\t\n\t      Looper.prepareMainLooper();\n\t\n\t        ActivityThread thread = new ActivityThread();\n\t        thread.attach(false);\n\t\n\t        if (sMainThreadHandler == null) {\n\t            sMainThreadHandler = thread.getHandler();\n\t        }\n\t\n\t        AsyncTask.init();\n\t\n\t        if (false) {\n\t            Looper.myLooper().setMessageLogging(new\n\t                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n\t        }\n\t\n\t        Looper.loop();\n\t\n\t          ...ignore some code...    \n\t\n\t }\n\nLooper.prepareMainLooper();\n准备完成后：\n\nLooper.loop()\n\n\n### Application 是在什么时候创建的？onCreate()什么时候调用的？\n也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。\n\n不相信，一起看看去!\n\n先看下ActivityThead.attach()\n\tprivate void attach(boolean system) {\n\t        sCurrentActivityThread = this;\n\t        mSystemThread = system;\n\t        //普通App进这里\n\t        if (!system) {\n\t\n\t            ...ignore some code...    \n\t\n\t            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n\t            final IActivityManager mgr = ActivityManagerNative.getDefault();\n\t            try {\n\t                mgr.attachApplication(mAppThread);\n\t            } catch (RemoteException ex) {\n\t                // Ignore\n\t            }\n\t           } else {\n\t             //这个分支在SystemServer加载的时候会进入，通过调用\n\t             // private void createSystemContext() {\n\t             //    ActivityThread activityThread = ActivityThread.systemMain()；\n\t             //} \n\t\n\t             // public static ActivityThread systemMain() {\n\t        //        if (!ActivityManager.isHighEndGfx()) {\n\t        //            HardwareRenderer.disable(true);\n\t        //        } else {\n\t        //            HardwareRenderer.enableForegroundTrimming();\n\t        //        }\n\t        //        ActivityThread thread = new ActivityThread();\n\t        //        thread.attach(true);\n\t        //        return thread;\n\t        //    }       \n\t           }\n\t    }\n\n这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法\n\n\t@Override\n\t    public final void attachApplication(IApplicationThread thread) {\n\t        synchronized (this) {\n\t            int callingPid = Binder.getCallingPid();\n\t            final long origId = Binder.clearCallingIdentity();\n\t            attachApplicationLocked(thread, callingPid);\n\t            Binder.restoreCallingIdentity(origId);\n\t        }\n\t    }\n\n然后：\n\n\tprivate final boolean attachApplicationLocked(IApplicationThread thread,\n\t            int pid) {\n\t\n\t\n\t             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n\t                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n\t                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n\t                    isRestrictedBackupMode || !normalMode, app.persistent,\n\t                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n\t                    mCoreSettingsObserver.getCoreSettingsLocked());\n\t\n\t\n\t            }\n\nthread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法\n\tpublic final void bindApplication(String processName, ApplicationInfo appInfo,\n\t                List<ProviderInfo> providers, ComponentName instrumentationName,\n\t                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\n\t                IInstrumentationWatcher instrumentationWatcher,\n\t                IUiAutomationConnection instrumentationUiConnection, int debugMode,\n\t                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,\n\t                Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,\n\t                Bundle coreSettings) {\n\t\n\t                 ...ignore some code...    \n\t\n\t             AppBindData data = new AppBindData();\n\t            data.processName = processName;\n\t            data.appInfo = appInfo;\n\t            data.providers = providers;\n\t            data.instrumentationName = instrumentationName;\n\t            data.instrumentationArgs = instrumentationArgs;\n\t            data.instrumentationWatcher = instrumentationWatcher;\n\t            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n\t            data.debugMode = debugMode;\n\t            data.enableOpenGlTrace = enableOpenGlTrace;\n\t            data.restrictedBackupMode = isRestrictedBackupMode;\n\t            data.persistent = persistent;\n\t            data.config = config;\n\t            data.compatInfo = compatInfo;\n\t            data.initProfilerInfo = profilerInfo;\n\t            sendMessage(H.BIND_APPLICATION, data);\n\t\n\t           }\n\t\n\t}\n\n\n其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理\n\tprivate class H extends Handler {\n\t\n\t      ...ignore some code... \n\t\n\t     public static final int BIND_APPLICATION        = 110;\n\t\n\t    ...ignore some code... \n\t\n\t     public void handleMessage(Message msg) {\n\t          switch (msg.what) {\n\t        ...ignore some code... \n\t         case BIND_APPLICATION:\n\t                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n\t                    AppBindData data = (AppBindData)msg.obj;\n\t                    handleBindApplication(data);\n\t                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\t                    break;\n\t        ...ignore some code... \n\t        }\n\t }\n\n最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。\n\n\tprivate void handleBindApplication(AppBindData data) {\n\t\n\t try {\n\t\n\t           ...ignore some code... \n\t\n\t            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n\t            mInitialApplication = app;\n\t\n\t           ...ignore some code... \n\t\n\t            try {\n\t                mInstrumentation.onCreate(data.instrumentationArgs);\n\t            }\n\t            catch (Exception e) {\n\t            }\n\t            try {\n\t                mInstrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {            }\n\t        } finally {\n\t            StrictMode.setThreadPolicy(savedPolicy);\n\t        }\n\t }\n\t\n\ndata.info 是一个LoadeApk 对象\n\nLoadeApk.data.info.makeApplication()\n\n\tpublic Application makeApplication(boolean forceDefaultAppClass,\n\t            Instrumentation instrumentation) {\n\t        if (mApplication != null) {\n\t            return mApplication;\n\t        }\n\t\n\t        Application app = null;\n\t\n\t        String appClass = mApplicationInfo.className;\n\t        if (forceDefaultAppClass || (appClass == null)) {\n\t            appClass = \"android.app.Application\";\n\t        }\n\t\n\t        try {\n\t            java.lang.ClassLoader cl = getClassLoader();\n\t            if (!mPackageName.equals(\"android\")) {\n\t                initializeJavaContextClassLoader();\n\t            }\n\t            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n\t            app = mActivityThread.mInstrumentation.newApplication(\n\t                    cl, appClass, appContext);\n\t            appContext.setOuterContext(app);\n\t        } catch (Exception e) {        }\n\t        mActivityThread.mAllApplications.add(app);\n\t        mApplication = app;\n\t\n\t    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n\t        if (instrumentation != null) {\n\t            try {\n\t                instrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {\n\t\n\t            }\n\t        }\n\t        ...ignore some code... \n\t\n\t       }\n\t\n\t        return app;\n\t    }\n\n最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！\n\n\tstatic public Application newApplication(Class<?> clazz, Context context)\n\t            throws InstantiationException, IllegalAccessException, \n\t            ClassNotFoundException {\n\t        Application app = (Application)clazz.newInstance();\n\t        app.attach(context);\n\t        return app;\n\t    }\n\n而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。\n\n参考文章\n\n下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。\n\nBinder:\n- [Android Bander设计与实现 - 设计篇](http://blog.csdn.net/universus/article/details/6211589)\n\nzygote\n•\t[Android系统进程Zygote启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6768304)\n•\t[Android 之 zygote 与进程创建](http://blog.csdn.net/xieqibao/article/details/6581975)\n•\t[Zygote浅谈](http://www.th7.cn/Program/Android/201404/187670.shtml)\nActivityThread、Instrumentation、AMS\n•\t[Android Activity.startActivity流程简介](http://blog.csdn.net/myarrow/article/details/14224273)\n•\t[Android应用程序进程启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6747696#comments)\n•\t[框架层理解Activity生命周期(APP启动过程)](http://laokaddk.blog.51cto.com/368606/1206840)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\n•\t[ActivityManagerService分析一：AMS的启动](http://www.xuebuyuan.com/2172927.html)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\nLauncher\n•\t[Android 4.0 Launcher源码分析系列(一)](http://mobile.51cto.com/hot-312129.htm)\n•\t[Android Launcher分析和修改9——Launcher启动APP流程](http://www.cnblogs.com/mythou/p/3187881.html)\n\n结束语：\n到了这里，我们回来看下开头的几个问题：\n- ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期\n- ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作\n- ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。\n- ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的\n- Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作\n- ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射\n- TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。\n\n如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/凯哥高质量文章系列.md","raw":"title: 凯哥高质量文章系列\ndate: 2015-11-20 12:17:18\ncategories:\nkeywords:\ntags: Android\n---\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n\n\n# 凯哥系列：\n## 1. [Activity启动过程全解析](http://www.devtf.cn/?p=1101)\n## 2. [framework-Activity界面显示全解析](http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287)\n\n\n注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念\n\n\n### 看文章的记录：\n1.App启动\n2.App入口\n3.Launcher?\n4.AMS??\n5.Binder是神马？怎么进行IPC通信？\n6.Activity生命周期是被谁 什么时候调用的？\n\n### 目的：\n1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度\n2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系\n\n3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合\n\n4.Activity相关的framework问题\n\n### 主要对象功能介绍：\n1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；\n2.ActivityThread:App的真正入口。打开App-\\>main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；\n3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。\n4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。\n5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。\n6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。\n7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。\n8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。\n\n### 主要流程介绍\n\n- zygote 是神马？\n程序 Crash 的时候，打印红色的log通常带有这个\nAndroid基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！\n\nAndroid 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程\n\n我们都知道，每一个App其实都是：\n- 一个单独的dalvik 虚拟机\n\t- 单独的进程\n\n当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！\n\n### SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\n\n首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！\n\n这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。\n\n为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？\n\n那么这些服务是怎么开启起来的呢?\n\n在zygote 开启的时候，会调用 ZygoteInit.main初始化\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n关键代码：\n\tif (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t}\n\t~~~\n\t//开始fork我们的SystemServer进程\n\tif (startSystemServer) {\n\t       startSystemServer(abiList, socketName);\n\t}\n\n\n我们看下startSystemServer()做了些什么:\n\n\tpublic static void main(String argv[]) {\n\t\n\t     ...ignore some code...\n\t\n\t    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n\t     boolean startSystemServer = false;\n\t     for (int i = 1; i < argv.length; i++) {\n\t                if (\"start-system-server\".equals(argv[i])) {\n\t                    startSystemServer = true;\n\t                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n\t                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n\t                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n\t                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n\t                } else {\n\t                    throw new RuntimeException(\"Unknown command line argument: \" + argv[i]);\n\t                }\n\t            }\n\t\n\t            ...ignore some code...\n\t\n\t         //开始fork我们的SystemServer进程\n\t     if (startSystemServer) {\n\t                startSystemServer(abiList, socketName);\n\t         }\n\t\n\t     ...ignore some code...\n\t\n\t}\n\n\n我们看下startSystemServer()做了些什么\n\t\n\t    /**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n\t     * Prepare the arguments and fork for the system server process.\n\t     */\n\t    private static boolean startSystemServer(String abiList, String socketName)\n\t            throws MethodAndArgsCaller, RuntimeException {\n\t\n\t         ...ignore some code...\n\t\n\t        //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n\t        /* Hardcoded command line to start the system server */\n\t        String args[] = {\n\t            \"--setuid=1000\",\n\t            \"--setgid=1000\",\n\t            \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007\",\n\t            \"--capabilities=\" + capabilities + \",\" + capabilities,\n\t            \"--runtime-init\",\n\t            \"--nice-name=system_server\",\n\t            \"com.android.server.SystemServer\",\n\t        };\n\t\n\t        int pid;\n\t        try {\n\t            parsedArgs = new ZygoteConnection.Arguments(args);\n\t            ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n\t            ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\t\n\t        //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n\t            /* Request to fork the system server process */\n\t            pid = Zygote.forkSystemServer(\n\t                    parsedArgs.uid, parsedArgs.gid,\n\t                    parsedArgs.gids,\n\t                    parsedArgs.debugFlags,\n\t                    null,\n\t                    parsedArgs.permittedCapabilities,\n\t                    parsedArgs.effectiveCapabilities);\n\t        } catch (IllegalArgumentException ex) {\n\t            throw new RuntimeException(ex);\n\t        }\n\t\n\t        /* For child process */\n\t        if (pid == 0) {\n\t            if (hasSecondZygote(abiList)) {\n\t                waitForSecondaryZygote(socketName);\n\t            }\n\t\n\t            handleSystemServerProcess(parsedArgs);\n\t        }\n\t\n\t        return true;\n\t    }\n\n### ActivityManagerService是什么？什么时候创建？作用?\n\nActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。\n\nAMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService \n\n\tpublic final class SystemServer {\n\t\n\t    //zygote的主入口\n\t    public static void main(String[] args) {\n\t        new SystemServer().run();\n\t    }\n\t\n\t    public SystemServer() {\n\t        // Check for factory test mode.\n\t        mFactoryTestMode = FactoryTest.getMode();\n\t    }\n\t\n\t    private void run() {\n\t\n\t        ...ignore some code...\n\t\n\t        //加载本地系统服务库，并进行初始化 \n\t        System.loadLibrary(\"android_servers\");\n\t        nativeInit();\n\t\n\t        // 创建系统上下文\n\t        createSystemContext();\n\t\n\t        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class<T>)，这个方法通过反射来启动对应的服务\n\t        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\t\n\t        //开启服务\n\t        try {\n\t            startBootstrapServices();\n\t            startCoreServices();\n\t            startOtherServices();\n\t        } catch (Throwable ex) {\n\t            Slog.e(\"System\", \"******************************************\");\n\t            Slog.e(\"System\", \"************ Failure starting system services\", ex);\n\t            throw ex;\n\t        }\n\t\n\t        ...ignore some code...\n\t\n\t    }\n\t\n\t    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n\t    private void createSystemContext() {\n\t        ActivityThread activityThread = ActivityThread.systemMain();\n\t        mSystemContext = activityThread.getSystemContext();\n\t        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n\t    }\n\t\n\t    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n\t    private void startBootstrapServices() {\n\t\n\t        ...ignore some code...\n\t\n\t        //初始化ActivityManagerService\n\t        mActivityManagerService = mSystemServiceManager.startService(\n\t                ActivityManagerService.Lifecycle.class).getService();\n\t        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\t\n\t        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n\t        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\t\n\t        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n\t        mActivityManagerService.initPowerManagement();\n\t\n\t        // 初始化DisplayManagerService\n\t        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\t\n\t    //初始化PackageManagerService\n\t    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n\t       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\t\n\t    ...ignore some code...\n\t\n\t    }\n\t\n\t}\n\n经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。\n\n你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。\n\n其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开\n\n\tIntent intent = new Intent(Intent.ACTION_MAIN);  \n\tintent.addCategory(Intent.CATEGORY_LAUNCHER);              \n\tComponentName cn = new ComponentName(packageName, className);              \n\tintent.setComponent(cn);  \n\tstartActivity(intent); \n\n但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。\n\n知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？\n\nApp与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。\n\n那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。\n\n在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。\n\n这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。\n\n### Launche是什么？ 什么时候启动？\n\n当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？\n\nLauncher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。\n\n\npackages/apps/Launcher2/src/com/android/launcher2/Launcher.java\n\tpublic final class Launcher extends Activity\n\t        implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,\n\t                   View.OnTouchListener {\n\t                   }\n\nLauncher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。\n\n![](DraggedImage.png)\n\n程序列表里面：\n![](DraggedImage-1.png)\n\n可以看到的是，调用的是：\n\tmLauncher.startActivitySafely(v, appInfo.intent, appInfo);\n\n和上面的一样，这叫什么？ 这叫殊途同归！\n\n所以现在我们明白了一件事：不管从哪里点击图标，调用的都是 \n\tLauncher.startActivitySafely()\n\n下面来看看 Launcher.startActivitySafely()到底做了什么事情\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n调用了startAcitivity(v,intent,tag)\n\tboolean startActivitySafely(View v, Intent intent, Object tag) {\n\t        boolean success = false;\n\t        try {\n\t            success = startActivity(v, intent, tag);\n\t        } catch (ActivityNotFoundException e) {\n\t            Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();\n\t            Log.e(TAG, \"Unable to launch. tag=\" + tag + \" intent=\" + intent, e);\n\t        }\n\t        return success;\n\t    }\n\n这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：\n\tintent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\n### Instrumentation是什么？和ActivityThread 是什么关系？\n每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()\n\n\tboolean startActivity(View v, Intent intent, Object tag) {\n\t\n\t        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n\t        try {\n\t            boolean useLaunchAnimation = (v != null) &&\n\t                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\t\n\t            if (useLaunchAnimation) {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent, opts.toBundle());\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(),\n\t                            opts.toBundle());\n\t                }\n\t            } else {\n\t                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n\t                    startActivity(intent);\n\t                } else {\n\t                    launcherApps.startMainActivity(intent.getComponent(), user,\n\t                            intent.getSourceBounds(), null);\n\t                }\n\t            }\n\t            return true;\n\t        } catch (SecurityException e) {\n\t        ...\n\t        }\n\t        return false;\n\t    }\n\n\n有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？\n\n是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！\n\n那你可能要问老板是who?\n老板当然是 大名鼎鼎的 ActivityThread了\n\nActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。\n\nASM说：『ActivityThread， 你给我暂停一个Activity！』\n\nActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』\n\n于是，Instrumentation 就去把事儿搞定了。\n所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。\n\n### 如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\n前面提到 调用 startActivity()的时候，时间调用了 \n\tmInstrumentation.execStartActivity()\n\n里面又调用了：\n\tActivityManagerNative.getDefault()\n\t                .startActivity\n\n这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。\n\nBinder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。\n\n为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：\n\nAMS， 和 AMP 都实现利率同一个接口： IActivityManager。\n\tclass ActivityManagerProxy implements IActivityManager{}\n\t\n\tpublic final class ActivityManagerService extends ActivityManagerNative{}\n\t\n\tpublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n\n虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。\n\n\n但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。\n\n但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如\n\tpublic int startActivity(IApplicationThread caller, String callingPackage, Intent intent,\n\t            String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {\n\t        Parcel data = Parcel.obtain();\n\t        Parcel reply = Parcel.obtain();\n\t\n\t        ...ignore some code...\n\t\n\t        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n\t        reply.readException();\n\t        int result = reply.readInt();\n\t        reply.recycle();\n\t        data.recycle();\n\t        return result;\n\t    }\n\n上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。\n\n即：\n客户度：ActivityManagerProxy ====\\> Binder驱动 ====》ActivityManagerService：服务器\n\n而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。\n\n但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ \n\n还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。\n\n客户端：ApplicationThread \\<=== Binder驱动 \\<=== ApplicationThreadProxy：服务器\n\n他们也实现了相同的接口 IApplicationThread:\n\tprivate class ApplicationThread extends ApplicationThreadNative {}\n\t\n\t  public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\t\n\t  class ApplicationThreadProxy implements IApplicationThread {}\n\n\n### AMS 接收到 客户端的请求后，如果开启一个Activity？\n\nOK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？\n\n注：前方高能，方法调用链接很强！\n\n调用startActivity（）\n\t@Override\n\t    public final int startActivity(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options) {\n\t        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,\n\t            resultWho, requestCode, startFlags, profilerInfo, options,\n\t            UserHandle.getCallingUserId());\n\t    }\n\n调用startActivityAsUser（）\n\t@Override\n\t    public final int startActivityAsUser(IApplicationThread caller, String callingPackage,\n\t            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,\n\t            int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {\n\t\n\t            ...ignore some code...\n\t\n\t        return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n\t                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n\t                profilerInfo, null, null, options, userId, null, null);\n\t    }\n\n这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作\n\t final int startActivityMayWait(IApplicationThread caller, int callingUid,\n\t            String callingPackage, Intent intent, String resolvedType,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode, int startFlags,\n\t            ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,\n\t            Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t              int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n\t                    voiceSession, voiceInteractor, resultTo, resultWho,\n\t                    requestCode, callingPid, callingUid, callingPackage,\n\t                    realCallingPid, realCallingUid, startFlags, options,\n\t                    componentSpecified, null, container, inTask);\n\t\n\t            ...ignore some code...\n\t\n\t            }\n\n继续调用 startActivityLocked()\n\n\tfinal int startActivityLocked(IApplicationThread caller,\n\t            Intent intent, String resolvedType, ActivityInfo aInfo,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n\t            IBinder resultTo, String resultWho, int requestCode,\n\t            int callingPid, int callingUid, String callingPackage,\n\t            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n\t            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n\t            TaskRecord inTask) {\n\t\n\t              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n\t              startFlags, true, options, inTask);\n\t        if (err < 0) {\n\t            notifyActivityDrawnForKeyguard();\n\t        }\n\t        return err;\n\t    }\n\n调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。\n\n终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)\n\nActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，\n\n\tfinal int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n\t            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n\t            boolean doResume, Bundle options, TaskRecord inTask) {\n\t\n\t            ...ignore some code...\n\t\n\t            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\t\n\t            ...ignore some code...\n\t\n\t             return ActivityManager.START_SUCCESS;\n\t            }\n\n调用 ActivityStack.startActivityLocked()\n\n\tfinal void startActivityLocked(ActivityRecord r, boolean newTask,\n\t            boolean doResume, boolean keepCurTransition, Bundle options) {\n\t\n\t        //ActivityRecord中存储的TaskRecord信息\n\t        TaskRecord rTask = r.task;\n\t\n\t         ...ignore some code...\n\t\n\t        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n\t     TaskRecord task = null;\n\t        if (!newTask) {\n\t            boolean startIt = true;\n\t            for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {\n\t                task = mTaskHistory.get(taskNdx);\n\t                if (task.getTopActivity() == null) {\n\t                    // task中的所有Activity都结束了\n\t                    continue;\n\t                }\n\t                if (task == r.task) {\n\t                    // 找到了\n\t                    if (!startIt) {\n\t                        task.addActivityToTop(r);\n\t                        r.putInHistory();\n\t                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n\t                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n\t                                (r.info.flags & ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n\t                                r.userId, r.info.configChanges, task.voiceSession != null,\n\t                                r.mLaunchTaskBehind);\n\t                        if (VALIDATE_TOKENS) {\n\t                            validateAppTokensLocked();\n\t                        }\n\t                        ActivityOptions.abort(options);\n\t                        return;\n\t                    }\n\t                    break;\n\t                } else if (task.numFullscreen > 0) {\n\t                    startIt = false;\n\t                }\n\t            }\n\t        }\n\t\n\t      ...ignore some code...\n\t\n\t        // Place a new activity at top of stack, so it is next to interact\n\t        // with the user.\n\t        task = r.task;\n\t        task.addActivityToTop(r);\n\t        task.setFrontOfTask();\n\t\n\t        ...ignore some code...\n\t\n\t         if (doResume) {\n\t            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n\t        }\n\t    }\n\n折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor \n\n淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。\n\n一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：\n\tboolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,\n\t            Bundle targetOptions) {\n\t        if (targetStack == null) {\n\t            targetStack = getFocusedStack();\n\t        }\n\t        // Do targetStack first.\n\t        boolean result = false;\n\t        if (isFrontStack(targetStack)) {\n\t            result = targetStack.resumeTopActivityLocked(target, targetOptions);\n\t        }\n\t\n\t          ...ignore some code...\n\t\n\t        return result;\n\t    }\n\n又回到 ActivityStack了。。。\n\nActivityStack.resumeTopActivityLocked()\n\tfinal boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {\n\t        if (inResumeTopActivity) {\n\t            // Don't even start recursing.\n\t            return false;\n\t        }\n\t\n\t        boolean result = false;\n\t        try {\n\t            // Protect against recursion.\n\t            inResumeTopActivity = true;\n\t            result = resumeTopActivityInnerLocked(prev, options);\n\t        } finally {\n\t            inResumeTopActivity = false;\n\t        }\n\t        return result;\n\t    }\n\n坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？\n\n\tfinal boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\t\n\t          ...ignore some code...\n\t      //找出还没结束的首个ActivityRecord\n\t     ActivityRecord next = topRunningActivityLocked(null);\n\t\n\t    //如果一个没结束的Activity都没有，就开启Launcher程序\n\t    if (next == null) {\n\t            ActivityOptions.abort(options);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: No more activities go home\");\n\t            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n\t            // Only resume home if on home display\n\t            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n\t                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n\t            return isOnHomeDisplay() &&\n\t                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n\t        }\n\t\n\t        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n\t          if (mResumedActivity != null) {\n\t            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n\t            if (DEBUG_STATES) Slog.d(TAG, \"resumeTopActivityLocked: Pausing \" + mResumedActivity);\n\t        }\n\t\n\t  }\n\n\n在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。\n\tActivityManagerNative.getDefault().activityPaused(token).\n\n上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。\n\n最后 来一张高清五码的大图，方便记忆\n\n![](Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png)\n\n### 一个App的程序入口是什么？\n是ActivityThread.main()\n\n### 整个App的主线程的消息循环是在哪里创建的?\n是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。\n\n\tpublic static void main(String[] args) {\n\t\n\t          ...ignore some code...    \n\t\n\t      Looper.prepareMainLooper();\n\t\n\t        ActivityThread thread = new ActivityThread();\n\t        thread.attach(false);\n\t\n\t        if (sMainThreadHandler == null) {\n\t            sMainThreadHandler = thread.getHandler();\n\t        }\n\t\n\t        AsyncTask.init();\n\t\n\t        if (false) {\n\t            Looper.myLooper().setMessageLogging(new\n\t                    LogPrinter(Log.DEBUG, \"ActivityThread\"));\n\t        }\n\t\n\t        Looper.loop();\n\t\n\t          ...ignore some code...    \n\t\n\t }\n\nLooper.prepareMainLooper();\n准备完成后：\n\nLooper.loop()\n\n\n### Application 是在什么时候创建的？onCreate()什么时候调用的？\n也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。\n\n不相信，一起看看去!\n\n先看下ActivityThead.attach()\n\tprivate void attach(boolean system) {\n\t        sCurrentActivityThread = this;\n\t        mSystemThread = system;\n\t        //普通App进这里\n\t        if (!system) {\n\t\n\t            ...ignore some code...    \n\t\n\t            RuntimeInit.setApplicationObject(mAppThread.asBinder());\n\t            final IActivityManager mgr = ActivityManagerNative.getDefault();\n\t            try {\n\t                mgr.attachApplication(mAppThread);\n\t            } catch (RemoteException ex) {\n\t                // Ignore\n\t            }\n\t           } else {\n\t             //这个分支在SystemServer加载的时候会进入，通过调用\n\t             // private void createSystemContext() {\n\t             //    ActivityThread activityThread = ActivityThread.systemMain()；\n\t             //} \n\t\n\t             // public static ActivityThread systemMain() {\n\t        //        if (!ActivityManager.isHighEndGfx()) {\n\t        //            HardwareRenderer.disable(true);\n\t        //        } else {\n\t        //            HardwareRenderer.enableForegroundTrimming();\n\t        //        }\n\t        //        ActivityThread thread = new ActivityThread();\n\t        //        thread.attach(true);\n\t        //        return thread;\n\t        //    }       \n\t           }\n\t    }\n\n这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法\n\n\t@Override\n\t    public final void attachApplication(IApplicationThread thread) {\n\t        synchronized (this) {\n\t            int callingPid = Binder.getCallingPid();\n\t            final long origId = Binder.clearCallingIdentity();\n\t            attachApplicationLocked(thread, callingPid);\n\t            Binder.restoreCallingIdentity(origId);\n\t        }\n\t    }\n\n然后：\n\n\tprivate final boolean attachApplicationLocked(IApplicationThread thread,\n\t            int pid) {\n\t\n\t\n\t             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n\t                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n\t                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n\t                    isRestrictedBackupMode || !normalMode, app.persistent,\n\t                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n\t                    mCoreSettingsObserver.getCoreSettingsLocked());\n\t\n\t\n\t            }\n\nthread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法\n\tpublic final void bindApplication(String processName, ApplicationInfo appInfo,\n\t                List<ProviderInfo> providers, ComponentName instrumentationName,\n\t                ProfilerInfo profilerInfo, Bundle instrumentationArgs,\n\t                IInstrumentationWatcher instrumentationWatcher,\n\t                IUiAutomationConnection instrumentationUiConnection, int debugMode,\n\t                boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,\n\t                Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,\n\t                Bundle coreSettings) {\n\t\n\t                 ...ignore some code...    \n\t\n\t             AppBindData data = new AppBindData();\n\t            data.processName = processName;\n\t            data.appInfo = appInfo;\n\t            data.providers = providers;\n\t            data.instrumentationName = instrumentationName;\n\t            data.instrumentationArgs = instrumentationArgs;\n\t            data.instrumentationWatcher = instrumentationWatcher;\n\t            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n\t            data.debugMode = debugMode;\n\t            data.enableOpenGlTrace = enableOpenGlTrace;\n\t            data.restrictedBackupMode = isRestrictedBackupMode;\n\t            data.persistent = persistent;\n\t            data.config = config;\n\t            data.compatInfo = compatInfo;\n\t            data.initProfilerInfo = profilerInfo;\n\t            sendMessage(H.BIND_APPLICATION, data);\n\t\n\t           }\n\t\n\t}\n\n\n其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理\n\tprivate class H extends Handler {\n\t\n\t      ...ignore some code... \n\t\n\t     public static final int BIND_APPLICATION        = 110;\n\t\n\t    ...ignore some code... \n\t\n\t     public void handleMessage(Message msg) {\n\t          switch (msg.what) {\n\t        ...ignore some code... \n\t         case BIND_APPLICATION:\n\t                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\");\n\t                    AppBindData data = (AppBindData)msg.obj;\n\t                    handleBindApplication(data);\n\t                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n\t                    break;\n\t        ...ignore some code... \n\t        }\n\t }\n\n最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。\n\n\tprivate void handleBindApplication(AppBindData data) {\n\t\n\t try {\n\t\n\t           ...ignore some code... \n\t\n\t            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n\t            mInitialApplication = app;\n\t\n\t           ...ignore some code... \n\t\n\t            try {\n\t                mInstrumentation.onCreate(data.instrumentationArgs);\n\t            }\n\t            catch (Exception e) {\n\t            }\n\t            try {\n\t                mInstrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {            }\n\t        } finally {\n\t            StrictMode.setThreadPolicy(savedPolicy);\n\t        }\n\t }\n\t\n\ndata.info 是一个LoadeApk 对象\n\nLoadeApk.data.info.makeApplication()\n\n\tpublic Application makeApplication(boolean forceDefaultAppClass,\n\t            Instrumentation instrumentation) {\n\t        if (mApplication != null) {\n\t            return mApplication;\n\t        }\n\t\n\t        Application app = null;\n\t\n\t        String appClass = mApplicationInfo.className;\n\t        if (forceDefaultAppClass || (appClass == null)) {\n\t            appClass = \"android.app.Application\";\n\t        }\n\t\n\t        try {\n\t            java.lang.ClassLoader cl = getClassLoader();\n\t            if (!mPackageName.equals(\"android\")) {\n\t                initializeJavaContextClassLoader();\n\t            }\n\t            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n\t            app = mActivityThread.mInstrumentation.newApplication(\n\t                    cl, appClass, appContext);\n\t            appContext.setOuterContext(app);\n\t        } catch (Exception e) {        }\n\t        mActivityThread.mAllApplications.add(app);\n\t        mApplication = app;\n\t\n\t    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n\t        if (instrumentation != null) {\n\t            try {\n\t                instrumentation.callApplicationOnCreate(app);\n\t            } catch (Exception e) {\n\t\n\t            }\n\t        }\n\t        ...ignore some code... \n\t\n\t       }\n\t\n\t        return app;\n\t    }\n\n最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！\n\n\tstatic public Application newApplication(Class<?> clazz, Context context)\n\t            throws InstantiationException, IllegalAccessException, \n\t            ClassNotFoundException {\n\t        Application app = (Application)clazz.newInstance();\n\t        app.attach(context);\n\t        return app;\n\t    }\n\n而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。\n\n参考文章\n\n下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。\n\nBinder:\n- [Android Bander设计与实现 - 设计篇](http://blog.csdn.net/universus/article/details/6211589)\n\nzygote\n•\t[Android系统进程Zygote启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6768304)\n•\t[Android 之 zygote 与进程创建](http://blog.csdn.net/xieqibao/article/details/6581975)\n•\t[Zygote浅谈](http://www.th7.cn/Program/Android/201404/187670.shtml)\nActivityThread、Instrumentation、AMS\n•\t[Android Activity.startActivity流程简介](http://blog.csdn.net/myarrow/article/details/14224273)\n•\t[Android应用程序进程启动过程的源代码分析](http://blog.csdn.net/luoshengyang/article/details/6747696#comments)\n•\t[框架层理解Activity生命周期(APP启动过程)](http://laokaddk.blog.51cto.com/368606/1206840)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\n•\t[ActivityManagerService分析一：AMS的启动](http://www.xuebuyuan.com/2172927.html)\n•\t[Android应用程序窗口设计框架介绍](http://blog.csdn.net/yangwen123/article/details/35987609)\nLauncher\n•\t[Android 4.0 Launcher源码分析系列(一)](http://mobile.51cto.com/hot-312129.htm)\n•\t[Android Launcher分析和修改9——Launcher启动APP流程](http://www.cnblogs.com/mythou/p/3187881.html)\n\n结束语：\n到了这里，我们回来看下开头的几个问题：\n- ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期\n- ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作\n- ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。\n- ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的\n- Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作\n- ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射\n- TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。\n\n如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"凯哥高质量文章系列","published":1,"updated":"2015-11-20T08:30:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1z60011rgexgg4xybkv","content":"<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<h1 id=\"凯哥系列：\"><a href=\"#凯哥系列：\" class=\"headerlink\" title=\"凯哥系列：\"></a>凯哥系列：</h1><h2 id=\"1-Activity启动过程全解析\"><a href=\"#1-Activity启动过程全解析\" class=\"headerlink\" title=\"1. Activity启动过程全解析\"></a>1. <a href=\"http://www.devtf.cn/?p=1101\" target=\"_blank\" rel=\"external\">Activity启动过程全解析</a></h2><h2 id=\"2-framework-Activity界面显示全解析\"><a href=\"#2-framework-Activity界面显示全解析\" class=\"headerlink\" title=\"2. framework-Activity界面显示全解析\"></a>2. <a href=\"http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287\" target=\"_blank\" rel=\"external\">framework-Activity界面显示全解析</a></h2><p>注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念</p>\n<h3 id=\"看文章的记录：\"><a href=\"#看文章的记录：\" class=\"headerlink\" title=\"看文章的记录：\"></a>看文章的记录：</h3><p>1.App启动<br>2.App入口<br>3.Launcher?<br>4.AMS??<br>5.Binder是神马？怎么进行IPC通信？<br>6.Activity生命周期是被谁 什么时候调用的？</p>\n<h3 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h3><p>1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度<br>2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系</p>\n<p>3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合</p>\n<p>4.Activity相关的framework问题</p>\n<h3 id=\"主要对象功能介绍：\"><a href=\"#主要对象功能介绍：\" class=\"headerlink\" title=\"主要对象功能介绍：\"></a>主要对象功能介绍：</h3><p>1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；<br>2.ActivityThread:App的真正入口。打开App->main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；<br>3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。<br>4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。<br>5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。<br>6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。<br>7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。<br>8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。</p>\n<h3 id=\"主要流程介绍\"><a href=\"#主要流程介绍\" class=\"headerlink\" title=\"主要流程介绍\"></a>主要流程介绍</h3><ul>\n<li>zygote 是神马？<br>程序 Crash 的时候，打印红色的log通常带有这个<br>Android基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！</li>\n</ul>\n<p>Android 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程</p>\n<p>我们都知道，每一个App其实都是：</p>\n<ul>\n<li>一个单独的dalvik 虚拟机<ul>\n<li>单独的进程</li>\n</ul>\n</li>\n</ul>\n<p>当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！</p>\n<h3 id=\"SystemServer是什么？-作用？它与zygote有什么样的一重关系？\"><a href=\"#SystemServer是什么？-作用？它与zygote有什么样的一重关系？\" class=\"headerlink\" title=\"SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\"></a>SystemServer是什么？ 作用？它与zygote有什么样的一重关系？</h3><p>首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！</p>\n<p>这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。</p>\n<p>为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？</p>\n<p>那么这些服务是怎么开启起来的呢?</p>\n<p>在zygote 开启的时候，会调用 ZygoteInit.main初始化</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>关键代码：<br>    if (“start-system-server”.equals(argv[i])) {<br>                        startSystemServer = true;<br>    }<br>    ~~~<br>    //开始fork我们的SystemServer进程<br>    if (startSystemServer) {<br>           startSystemServer(abiList, socketName);<br>    }</p>\n<p>我们看下startSystemServer()做了些什么:</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>我们看下startSystemServer()做了些什么</p>\n<pre><code>/**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n * Prepare the arguments and fork for the system server process.\n */\nprivate static boolean startSystemServer(String abiList, String socketName)\n        throws MethodAndArgsCaller, RuntimeException {\n\n     ...ignore some code...\n\n    //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n    /* Hardcoded command line to start the system server */\n    String args[] = {\n        &quot;--setuid=1000&quot;,\n        &quot;--setgid=1000&quot;,\n        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,\n        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,\n        &quot;--runtime-init&quot;,\n        &quot;--nice-name=system_server&quot;,\n        &quot;com.android.server.SystemServer&quot;,\n    };\n\n    int pid;\n    try {\n        parsedArgs = new ZygoteConnection.Arguments(args);\n        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n    //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n        /* Request to fork the system server process */\n        pid = Zygote.forkSystemServer(\n                parsedArgs.uid, parsedArgs.gid,\n                parsedArgs.gids,\n                parsedArgs.debugFlags,\n                null,\n                parsedArgs.permittedCapabilities,\n                parsedArgs.effectiveCapabilities);\n    } catch (IllegalArgumentException ex) {\n        throw new RuntimeException(ex);\n    }\n\n    /* For child process */\n    if (pid == 0) {\n        if (hasSecondZygote(abiList)) {\n            waitForSecondaryZygote(socketName);\n        }\n\n        handleSystemServerProcess(parsedArgs);\n    }\n\n    return true;\n}\n</code></pre><h3 id=\"ActivityManagerService是什么？什么时候创建？作用\"><a href=\"#ActivityManagerService是什么？什么时候创建？作用\" class=\"headerlink\" title=\"ActivityManagerService是什么？什么时候创建？作用?\"></a>ActivityManagerService是什么？什么时候创建？作用?</h3><p>ActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。</p>\n<p>AMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService </p>\n<pre><code>public final class SystemServer {\n\n    //zygote的主入口\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n\n    public SystemServer() {\n        // Check for factory test mode.\n        mFactoryTestMode = FactoryTest.getMode();\n    }\n\n    private void run() {\n\n        ...ignore some code...\n\n        //加载本地系统服务库，并进行初始化 \n        System.loadLibrary(&quot;android_servers&quot;);\n        nativeInit();\n\n        // 创建系统上下文\n        createSystemContext();\n\n        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\n        //开启服务\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);\n            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);\n            throw ex;\n        }\n\n        ...ignore some code...\n\n    }\n\n    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n    private void createSystemContext() {\n        ActivityThread activityThread = ActivityThread.systemMain();\n        mSystemContext = activityThread.getSystemContext();\n        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n    }\n\n    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n    private void startBootstrapServices() {\n\n        ...ignore some code...\n\n        //初始化ActivityManagerService\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\n        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n        mActivityManagerService.initPowerManagement();\n\n        // 初始化DisplayManagerService\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n    //初始化PackageManagerService\n    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\n    ...ignore some code...\n\n    }\n\n}\n</code></pre><p>经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。</p>\n<p>你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。</p>\n<p>其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开</p>\n<pre><code>Intent intent = new Intent(Intent.ACTION_MAIN);  \nintent.addCategory(Intent.CATEGORY_LAUNCHER);              \nComponentName cn = new ComponentName(packageName, className);              \nintent.setComponent(cn);  \nstartActivity(intent); \n</code></pre><p>但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。</p>\n<p>知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？</p>\n<p>App与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。</p>\n<p>那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。</p>\n<p>在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。</p>\n<p>这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。</p>\n<h3 id=\"Launche是什么？-什么时候启动？\"><a href=\"#Launche是什么？-什么时候启动？\" class=\"headerlink\" title=\"Launche是什么？ 什么时候启动？\"></a>Launche是什么？ 什么时候启动？</h3><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？</p>\n<p>Launcher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。</p>\n<p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java<br>    public final class Launcher extends Activity<br>            implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,<br>                       View.OnTouchListener {<br>                       }</p>\n<p>Launcher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。</p>\n<p><img src=\"DraggedImage.png\" alt=\"\"></p>\n<p>程序列表里面：<br><img src=\"DraggedImage-1.png\" alt=\"\"></p>\n<p>可以看到的是，调用的是：<br>    mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</p>\n<p>和上面的一样，这叫什么？ 这叫殊途同归！</p>\n<p>所以现在我们明白了一件事：不管从哪里点击图标，调用的都是<br>    Launcher.startActivitySafely()</p>\n<p>下面来看看 Launcher.startActivitySafely()到底做了什么事情<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>调用了startAcitivity(v,intent,tag)<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：<br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>\n<h3 id=\"Instrumentation是什么？和ActivityThread-是什么关系？\"><a href=\"#Instrumentation是什么？和ActivityThread-是什么关系？\" class=\"headerlink\" title=\"Instrumentation是什么？和ActivityThread 是什么关系？\"></a>Instrumentation是什么？和ActivityThread 是什么关系？</h3><p>每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()</p>\n<pre><code>boolean startActivity(View v, Intent intent, Object tag) {\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        try {\n            boolean useLaunchAnimation = (v != null) &amp;&amp;\n                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\n            if (useLaunchAnimation) {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent, opts.toBundle());\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(),\n                            opts.toBundle());\n                }\n            } else {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent);\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(), null);\n                }\n            }\n            return true;\n        } catch (SecurityException e) {\n        ...\n        }\n        return false;\n    }\n</code></pre><p>有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？</p>\n<p>是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！</p>\n<p>那你可能要问老板是who?<br>老板当然是 大名鼎鼎的 ActivityThread了</p>\n<p>ActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。</p>\n<p>ASM说：『ActivityThread， 你给我暂停一个Activity！』</p>\n<p>ActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』</p>\n<p>于是，Instrumentation 就去把事儿搞定了。<br>所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。</p>\n<h3 id=\"如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\"><a href=\"#如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\" class=\"headerlink\" title=\"如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\"></a>如何理解 AMS 和 ActivityThread 之间的 Binder 通信？</h3><p>前面提到 调用 startActivity()的时候，时间调用了<br>    mInstrumentation.execStartActivity()</p>\n<p>里面又调用了：<br>    ActivityManagerNative.getDefault()<br>                    .startActivity</p>\n<p>这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。</p>\n<p>Binder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。</p>\n<p>为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：</p>\n<p>AMS， 和 AMP 都实现利率同一个接口： IActivityManager。<br>    class ActivityManagerProxy implements IActivityManager{}</p>\n<pre><code>public final class ActivityManagerService extends ActivityManagerNative{}\n\npublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n</code></pre><p>虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。</p>\n<p>但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。</p>\n<p>但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如<br>    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,<br>                String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {<br>            Parcel data = Parcel.obtain();<br>            Parcel reply = Parcel.obtain();</p>\n<pre><code>    ...ignore some code...\n\n    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n    reply.readException();\n    int result = reply.readInt();\n    reply.recycle();\n    data.recycle();\n    return result;\n}\n</code></pre><p>上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。</p>\n<p>即：<br>客户度：ActivityManagerProxy ====> Binder驱动 ====》ActivityManagerService：服务器</p>\n<p>而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。</p>\n<p>但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ </p>\n<p>还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。</p>\n<p>客户端：ApplicationThread \\&lt;=== Binder驱动 \\&lt;=== ApplicationThreadProxy：服务器</p>\n<p>他们也实现了相同的接口 IApplicationThread:<br>    private class ApplicationThread extends ApplicationThreadNative {}</p>\n<pre><code>public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\nclass ApplicationThreadProxy implements IApplicationThread {}\n</code></pre><h3 id=\"AMS-接收到-客户端的请求后，如果开启一个Activity？\"><a href=\"#AMS-接收到-客户端的请求后，如果开启一个Activity？\" class=\"headerlink\" title=\"AMS 接收到 客户端的请求后，如果开启一个Activity？\"></a>AMS 接收到 客户端的请求后，如果开启一个Activity？</h3><p>OK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？</p>\n<p>注：前方高能，方法调用链接很强！</p>\n<p>调用startActivity（）<br>    @Override<br>        public final int startActivity(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) {<br>            return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>                resultWho, requestCode, startFlags, profilerInfo, options,<br>                UserHandle.getCallingUserId());<br>        }</p>\n<p>调用startActivityAsUser（）<br>    @Override<br>        public final int startActivityAsUser(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {</p>\n<pre><code>        ...ignore some code...\n\n    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, options, userId, null, null);\n}\n</code></pre><p>这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作<br>     final int startActivityMayWait(IApplicationThread caller, int callingUid,<br>                String callingPackage, Intent intent, String resolvedType,<br>                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>                IBinder resultTo, String resultWho, int requestCode, int startFlags,<br>                ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,<br>                Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {</p>\n<pre><code>...ignore some code...\n\n  int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n        voiceSession, voiceInteractor, resultTo, resultWho,\n        requestCode, callingPid, callingUid, callingPackage,\n        realCallingPid, realCallingUid, startFlags, options,\n        componentSpecified, null, container, inTask);\n\n...ignore some code...\n\n}\n</code></pre><p>继续调用 startActivityLocked()</p>\n<pre><code>final int startActivityLocked(IApplicationThread caller,\n            Intent intent, String resolvedType, ActivityInfo aInfo,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n            IBinder resultTo, String resultWho, int requestCode,\n            int callingPid, int callingUid, String callingPackage,\n            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n            TaskRecord inTask) {\n\n              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n              startFlags, true, options, inTask);\n        if (err &lt; 0) {\n            notifyActivityDrawnForKeyguard();\n        }\n        return err;\n    }\n</code></pre><p>调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。</p>\n<p>终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)</p>\n<p>ActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，</p>\n<pre><code>final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n            boolean doResume, Bundle options, TaskRecord inTask) {\n\n            ...ignore some code...\n\n            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\n            ...ignore some code...\n\n             return ActivityManager.START_SUCCESS;\n            }\n</code></pre><p>调用 ActivityStack.startActivityLocked()</p>\n<pre><code>final void startActivityLocked(ActivityRecord r, boolean newTask,\n            boolean doResume, boolean keepCurTransition, Bundle options) {\n\n        //ActivityRecord中存储的TaskRecord信息\n        TaskRecord rTask = r.task;\n\n         ...ignore some code...\n\n        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n     TaskRecord task = null;\n        if (!newTask) {\n            boolean startIt = true;\n            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) {\n                task = mTaskHistory.get(taskNdx);\n                if (task.getTopActivity() == null) {\n                    // task中的所有Activity都结束了\n                    continue;\n                }\n                if (task == r.task) {\n                    // 找到了\n                    if (!startIt) {\n                        task.addActivityToTop(r);\n                        r.putInHistory();\n                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n                                r.userId, r.info.configChanges, task.voiceSession != null,\n                                r.mLaunchTaskBehind);\n                        if (VALIDATE_TOKENS) {\n                            validateAppTokensLocked();\n                        }\n                        ActivityOptions.abort(options);\n                        return;\n                    }\n                    break;\n                } else if (task.numFullscreen &gt; 0) {\n                    startIt = false;\n                }\n            }\n        }\n\n      ...ignore some code...\n\n        // Place a new activity at top of stack, so it is next to interact\n        // with the user.\n        task = r.task;\n        task.addActivityToTop(r);\n        task.setFrontOfTask();\n\n        ...ignore some code...\n\n         if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n    }\n</code></pre><p>折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor </p>\n<p>淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。</p>\n<p>一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：<br>    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,<br>                Bundle targetOptions) {<br>            if (targetStack == null) {<br>                targetStack = getFocusedStack();<br>            }<br>            // Do targetStack first.<br>            boolean result = false;<br>            if (isFrontStack(targetStack)) {<br>                result = targetStack.resumeTopActivityLocked(target, targetOptions);<br>            }</p>\n<pre><code>      ...ignore some code...\n\n    return result;\n}\n</code></pre><p>又回到 ActivityStack了。。。</p>\n<p>ActivityStack.resumeTopActivityLocked()<br>    final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {<br>            if (inResumeTopActivity) {<br>                // Don’t even start recursing.<br>                return false;<br>            }</p>\n<pre><code>    boolean result = false;\n    try {\n        // Protect against recursion.\n        inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        inResumeTopActivity = false;\n    }\n    return result;\n}\n</code></pre><p>坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？</p>\n<pre><code>final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\n          ...ignore some code...\n      //找出还没结束的首个ActivityRecord\n     ActivityRecord next = topRunningActivityLocked(null);\n\n    //如果一个没结束的Activity都没有，就开启Launcher程序\n    if (next == null) {\n            ActivityOptions.abort(options);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);\n            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n            // Only resume home if on home display\n            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n            return isOnHomeDisplay() &amp;&amp;\n                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n        }\n\n        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n          if (mResumedActivity != null) {\n            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);\n        }\n\n  }\n</code></pre><p>在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。<br>    ActivityManagerNative.getDefault().activityPaused(token).</p>\n<p>上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。</p>\n<p>最后 来一张高清五码的大图，方便记忆</p>\n<p><img src=\"Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png\" alt=\"\"></p>\n<h3 id=\"一个App的程序入口是什么？\"><a href=\"#一个App的程序入口是什么？\" class=\"headerlink\" title=\"一个App的程序入口是什么？\"></a>一个App的程序入口是什么？</h3><p>是ActivityThread.main()</p>\n<h3 id=\"整个App的主线程的消息循环是在哪里创建的\"><a href=\"#整个App的主线程的消息循环是在哪里创建的\" class=\"headerlink\" title=\"整个App的主线程的消息循环是在哪里创建的?\"></a>整个App的主线程的消息循环是在哪里创建的?</h3><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。</p>\n<pre><code>public static void main(String[] args) {\n\n          ...ignore some code...    \n\n      Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n        }\n\n        Looper.loop();\n\n          ...ignore some code...    \n\n }\n</code></pre><p>Looper.prepareMainLooper();<br>准备完成后：</p>\n<p>Looper.loop()</p>\n<h3 id=\"Application-是在什么时候创建的？onCreate-什么时候调用的？\"><a href=\"#Application-是在什么时候创建的？onCreate-什么时候调用的？\" class=\"headerlink\" title=\"Application 是在什么时候创建的？onCreate()什么时候调用的？\"></a>Application 是在什么时候创建的？onCreate()什么时候调用的？</h3><p>也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。</p>\n<p>不相信，一起看看去!</p>\n<p>先看下ActivityThead.attach()<br>    private void attach(boolean system) {<br>            sCurrentActivityThread = this;<br>            mSystemThread = system;<br>            //普通App进这里<br>            if (!system) {</p>\n<pre><code>        ...ignore some code...    \n\n        RuntimeInit.setApplicationObject(mAppThread.asBinder());\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            // Ignore\n        }\n       } else {\n         //这个分支在SystemServer加载的时候会进入，通过调用\n         // private void createSystemContext() {\n         //    ActivityThread activityThread = ActivityThread.systemMain()；\n         //} \n\n         // public static ActivityThread systemMain() {\n    //        if (!ActivityManager.isHighEndGfx()) {\n    //            HardwareRenderer.disable(true);\n    //        } else {\n    //            HardwareRenderer.enableForegroundTrimming();\n    //        }\n    //        ActivityThread thread = new ActivityThread();\n    //        thread.attach(true);\n    //        return thread;\n    //    }       \n       }\n}\n</code></pre><p>这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法</p>\n<pre><code>@Override\n    public final void attachApplication(IApplicationThread thread) {\n        synchronized (this) {\n            int callingPid = Binder.getCallingPid();\n            final long origId = Binder.clearCallingIdentity();\n            attachApplicationLocked(thread, callingPid);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n</code></pre><p>然后：</p>\n<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,\n            int pid) {\n\n\n             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                    isRestrictedBackupMode || !normalMode, app.persistent,\n                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n                    mCoreSettingsObserver.getCoreSettingsLocked());\n\n\n            }\n</code></pre><p>thread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法<br>    public final void bindApplication(String processName, ApplicationInfo appInfo,<br>                    List<providerinfo> providers, ComponentName instrumentationName,<br>                    ProfilerInfo profilerInfo, Bundle instrumentationArgs,<br>                    IInstrumentationWatcher instrumentationWatcher,<br>                    IUiAutomationConnection instrumentationUiConnection, int debugMode,<br>                    boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,<br>                    Configuration config, CompatibilityInfo compatInfo, Map<string, ibinder=\"\"> services,<br>                    Bundle coreSettings) {</string,></providerinfo></p>\n<pre><code>                 ...ignore some code...    \n\n             AppBindData data = new AppBindData();\n            data.processName = processName;\n            data.appInfo = appInfo;\n            data.providers = providers;\n            data.instrumentationName = instrumentationName;\n            data.instrumentationArgs = instrumentationArgs;\n            data.instrumentationWatcher = instrumentationWatcher;\n            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n            data.debugMode = debugMode;\n            data.enableOpenGlTrace = enableOpenGlTrace;\n            data.restrictedBackupMode = isRestrictedBackupMode;\n            data.persistent = persistent;\n            data.config = config;\n            data.compatInfo = compatInfo;\n            data.initProfilerInfo = profilerInfo;\n            sendMessage(H.BIND_APPLICATION, data);\n\n           }\n\n}\n</code></pre><p>其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理<br>    private class H extends Handler {</p>\n<pre><code>     ...ignore some code... \n\n    public static final int BIND_APPLICATION        = 110;\n\n   ...ignore some code... \n\n    public void handleMessage(Message msg) {\n         switch (msg.what) {\n       ...ignore some code... \n        case BIND_APPLICATION:\n                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);\n                   AppBindData data = (AppBindData)msg.obj;\n                   handleBindApplication(data);\n                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                   break;\n       ...ignore some code... \n       }\n}\n</code></pre><p>最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。</p>\n<pre><code>private void handleBindApplication(AppBindData data) {\n\n try {\n\n           ...ignore some code... \n\n            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n            mInitialApplication = app;\n\n           ...ignore some code... \n\n            try {\n                mInstrumentation.onCreate(data.instrumentationArgs);\n            }\n            catch (Exception e) {\n            }\n            try {\n                mInstrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {            }\n        } finally {\n            StrictMode.setThreadPolicy(savedPolicy);\n        }\n }\n</code></pre><p>data.info 是一个LoadeApk 对象</p>\n<p>LoadeApk.data.info.makeApplication()</p>\n<pre><code>public Application makeApplication(boolean forceDefaultAppClass,\n            Instrumentation instrumentation) {\n        if (mApplication != null) {\n            return mApplication;\n        }\n\n        Application app = null;\n\n        String appClass = mApplicationInfo.className;\n        if (forceDefaultAppClass || (appClass == null)) {\n            appClass = &quot;android.app.Application&quot;;\n        }\n\n        try {\n            java.lang.ClassLoader cl = getClassLoader();\n            if (!mPackageName.equals(&quot;android&quot;)) {\n                initializeJavaContextClassLoader();\n            }\n            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n            app = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n            appContext.setOuterContext(app);\n        } catch (Exception e) {        }\n        mActivityThread.mAllApplications.add(app);\n        mApplication = app;\n\n    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n        if (instrumentation != null) {\n            try {\n                instrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {\n\n            }\n        }\n        ...ignore some code... \n\n       }\n\n        return app;\n    }\n</code></pre><p>最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！</p>\n<pre><code>static public Application newApplication(Class&lt;?&gt; clazz, Context context)\n            throws InstantiationException, IllegalAccessException, \n            ClassNotFoundException {\n        Application app = (Application)clazz.newInstance();\n        app.attach(context);\n        return app;\n    }\n</code></pre><p>而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。</p>\n<p>参考文章</p>\n<p>下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。</p>\n<p>Binder:</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/universus/article/details/6211589\" target=\"_blank\" rel=\"external\">Android Bander设计与实现 - 设计篇</a></li>\n</ul>\n<p>zygote<br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6768304\" target=\"_blank\" rel=\"external\">Android系统进程Zygote启动过程的源代码分析</a><br>•    <a href=\"http://blog.csdn.net/xieqibao/article/details/6581975\" target=\"_blank\" rel=\"external\">Android 之 zygote 与进程创建</a><br>•    <a href=\"http://www.th7.cn/Program/Android/201404/187670.shtml\" target=\"_blank\" rel=\"external\">Zygote浅谈</a><br>ActivityThread、Instrumentation、AMS<br>•    <a href=\"http://blog.csdn.net/myarrow/article/details/14224273\" target=\"_blank\" rel=\"external\">Android Activity.startActivity流程简介</a><br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6747696#comments\" target=\"_blank\" rel=\"external\">Android应用程序进程启动过程的源代码分析</a><br>•    <a href=\"http://laokaddk.blog.51cto.com/368606/1206840\" target=\"_blank\" rel=\"external\">框架层理解Activity生命周期(APP启动过程)</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\" target=\"_blank\" rel=\"external\">Android应用程序窗口设计框架介绍</a><br>•    <a href=\"http://www.xuebuyuan.com/2172927.html\" target=\"_blank\" rel=\"external\">ActivityManagerService分析一：AMS的启动</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\" target=\"_blank\" rel=\"external\">Android应用程序窗口设计框架介绍</a><br>Launcher<br>•    <a href=\"http://mobile.51cto.com/hot-312129.htm\" target=\"_blank\" rel=\"external\">Android 4.0 Launcher源码分析系列(一)</a><br>•    <a href=\"http://www.cnblogs.com/mythou/p/3187881.html\" target=\"_blank\" rel=\"external\">Android Launcher分析和修改9——Launcher启动APP流程</a></p>\n<p>结束语：<br>到了这里，我们回来看下开头的几个问题：</p>\n<ul>\n<li>ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>\n<li>ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作</li>\n<li>ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。</li>\n<li>ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的</li>\n<li>Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作</li>\n<li>ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射</li>\n<li>TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。</li>\n</ul>\n<p>如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 </p>\n","excerpt":"","more":"<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n<h1 id=\"凯哥系列：\"><a href=\"#凯哥系列：\" class=\"headerlink\" title=\"凯哥系列：\"></a>凯哥系列：</h1><h2 id=\"1-Activity启动过程全解析\"><a href=\"#1-Activity启动过程全解析\" class=\"headerlink\" title=\"1. Activity启动过程全解析\"></a>1. <a href=\"http://www.devtf.cn/?p=1101\">Activity启动过程全解析</a></h2><h2 id=\"2-framework-Activity界面显示全解析\"><a href=\"#2-framework-Activity界面显示全解析\" class=\"headerlink\" title=\"2. framework-Activity界面显示全解析\"></a>2. <a href=\"http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287\">framework-Activity界面显示全解析</a></h2><p>注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念</p>\n<h3 id=\"看文章的记录：\"><a href=\"#看文章的记录：\" class=\"headerlink\" title=\"看文章的记录：\"></a>看文章的记录：</h3><p>1.App启动<br>2.App入口<br>3.Launcher?<br>4.AMS??<br>5.Binder是神马？怎么进行IPC通信？<br>6.Activity生命周期是被谁 什么时候调用的？</p>\n<h3 id=\"目的：\"><a href=\"#目的：\" class=\"headerlink\" title=\"目的：\"></a>目的：</h3><p>1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度<br>2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系</p>\n<p>3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合</p>\n<p>4.Activity相关的framework问题</p>\n<h3 id=\"主要对象功能介绍：\"><a href=\"#主要对象功能介绍：\" class=\"headerlink\" title=\"主要对象功能介绍：\"></a>主要对象功能介绍：</h3><p>1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；<br>2.ActivityThread:App的真正入口。打开App->main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；<br>3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。<br>4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。<br>5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。<br>6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。<br>7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。<br>8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。</p>\n<h3 id=\"主要流程介绍\"><a href=\"#主要流程介绍\" class=\"headerlink\" title=\"主要流程介绍\"></a>主要流程介绍</h3><ul>\n<li>zygote 是神马？<br>程序 Crash 的时候，打印红色的log通常带有这个<br>Android基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！</li>\n</ul>\n<p>Android 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程</p>\n<p>我们都知道，每一个App其实都是：</p>\n<ul>\n<li>一个单独的dalvik 虚拟机<ul>\n<li>单独的进程</li>\n</ul>\n</li>\n</ul>\n<p>当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！</p>\n<h3 id=\"SystemServer是什么？-作用？它与zygote有什么样的一重关系？\"><a href=\"#SystemServer是什么？-作用？它与zygote有什么样的一重关系？\" class=\"headerlink\" title=\"SystemServer是什么？ 作用？它与zygote有什么样的一重关系？\"></a>SystemServer是什么？ 作用？它与zygote有什么样的一重关系？</h3><p>首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！</p>\n<p>这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。</p>\n<p>为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？</p>\n<p>那么这些服务是怎么开启起来的呢?</p>\n<p>在zygote 开启的时候，会调用 ZygoteInit.main初始化</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>关键代码：<br>    if (“start-system-server”.equals(argv[i])) {<br>                        startSystemServer = true;<br>    }<br>    ~~~<br>    //开始fork我们的SystemServer进程<br>    if (startSystemServer) {<br>           startSystemServer(abiList, socketName);<br>    }</p>\n<p>我们看下startSystemServer()做了些什么:</p>\n<pre><code>public static void main(String argv[]) {\n\n     ...ignore some code...\n\n    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true\n     boolean startSystemServer = false;\n     for (int i = 1; i &lt; argv.length; i++) {\n                if (&quot;start-system-server&quot;.equals(argv[i])) {\n                    startSystemServer = true;\n                } else if (argv[i].startsWith(ABI_LIST_ARG)) {\n                    abiList = argv[i].substring(ABI_LIST_ARG.length());\n                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {\n                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());\n                } else {\n                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);\n                }\n            }\n\n            ...ignore some code...\n\n         //开始fork我们的SystemServer进程\n     if (startSystemServer) {\n                startSystemServer(abiList, socketName);\n         }\n\n     ...ignore some code...\n\n}\n</code></pre><p>我们看下startSystemServer()做了些什么</p>\n<pre><code>/**留着这个注释，就是为了说明SystemServer确实是被fork出来的\n * Prepare the arguments and fork for the system server process.\n */\nprivate static boolean startSystemServer(String abiList, String socketName)\n        throws MethodAndArgsCaller, RuntimeException {\n\n     ...ignore some code...\n\n    //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的\n    /* Hardcoded command line to start the system server */\n    String args[] = {\n        &quot;--setuid=1000&quot;,\n        &quot;--setgid=1000&quot;,\n        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,\n        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,\n        &quot;--runtime-init&quot;,\n        &quot;--nice-name=system_server&quot;,\n        &quot;com.android.server.SystemServer&quot;,\n    };\n\n    int pid;\n    try {\n        parsedArgs = new ZygoteConnection.Arguments(args);\n        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);\n        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);\n\n    //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||\n        /* Request to fork the system server process */\n        pid = Zygote.forkSystemServer(\n                parsedArgs.uid, parsedArgs.gid,\n                parsedArgs.gids,\n                parsedArgs.debugFlags,\n                null,\n                parsedArgs.permittedCapabilities,\n                parsedArgs.effectiveCapabilities);\n    } catch (IllegalArgumentException ex) {\n        throw new RuntimeException(ex);\n    }\n\n    /* For child process */\n    if (pid == 0) {\n        if (hasSecondZygote(abiList)) {\n            waitForSecondaryZygote(socketName);\n        }\n\n        handleSystemServerProcess(parsedArgs);\n    }\n\n    return true;\n}\n</code></pre><h3 id=\"ActivityManagerService是什么？什么时候创建？作用\"><a href=\"#ActivityManagerService是什么？什么时候创建？作用\" class=\"headerlink\" title=\"ActivityManagerService是什么？什么时候创建？作用?\"></a>ActivityManagerService是什么？什么时候创建？作用?</h3><p>ActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。</p>\n<p>AMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService </p>\n<pre><code>public final class SystemServer {\n\n    //zygote的主入口\n    public static void main(String[] args) {\n        new SystemServer().run();\n    }\n\n    public SystemServer() {\n        // Check for factory test mode.\n        mFactoryTestMode = FactoryTest.getMode();\n    }\n\n    private void run() {\n\n        ...ignore some code...\n\n        //加载本地系统服务库，并进行初始化 \n        System.loadLibrary(&quot;android_servers&quot;);\n        nativeInit();\n\n        // 创建系统上下文\n        createSystemContext();\n\n        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务\n        mSystemServiceManager = new SystemServiceManager(mSystemContext);\n\n        //开启服务\n        try {\n            startBootstrapServices();\n            startCoreServices();\n            startOtherServices();\n        } catch (Throwable ex) {\n            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);\n            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);\n            throw ex;\n        }\n\n        ...ignore some code...\n\n    }\n\n    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。\n    private void createSystemContext() {\n        ActivityThread activityThread = ActivityThread.systemMain();\n        mSystemContext = activityThread.getSystemContext();\n        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);\n    }\n\n    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。\n    private void startBootstrapServices() {\n\n        ...ignore some code...\n\n        //初始化ActivityManagerService\n        mActivityManagerService = mSystemServiceManager.startService(\n                ActivityManagerService.Lifecycle.class).getService();\n        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);\n\n        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化\n        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);\n\n        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能\n        mActivityManagerService.initPowerManagement();\n\n        // 初始化DisplayManagerService\n        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);\n\n    //初始化PackageManagerService\n    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,\n       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);\n\n    ...ignore some code...\n\n    }\n\n}\n</code></pre><p>经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。</p>\n<p>你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。</p>\n<p>其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开</p>\n<pre><code>Intent intent = new Intent(Intent.ACTION_MAIN);  \nintent.addCategory(Intent.CATEGORY_LAUNCHER);              \nComponentName cn = new ComponentName(packageName, className);              \nintent.setComponent(cn);  \nstartActivity(intent); \n</code></pre><p>但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。</p>\n<p>知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？</p>\n<p>App与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。</p>\n<p>那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。</p>\n<p>在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。</p>\n<p>这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。</p>\n<h3 id=\"Launche是什么？-什么时候启动？\"><a href=\"#Launche是什么？-什么时候启动？\" class=\"headerlink\" title=\"Launche是什么？ 什么时候启动？\"></a>Launche是什么？ 什么时候启动？</h3><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？</p>\n<p>Launcher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。</p>\n<p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java<br>    public final class Launcher extends Activity<br>            implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,<br>                       View.OnTouchListener {<br>                       }</p>\n<p>Launcher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。</p>\n<p><img src=\"DraggedImage.png\" alt=\"\"></p>\n<p>程序列表里面：<br><img src=\"DraggedImage-1.png\" alt=\"\"></p>\n<p>可以看到的是，调用的是：<br>    mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</p>\n<p>和上面的一样，这叫什么？ 这叫殊途同归！</p>\n<p>所以现在我们明白了一件事：不管从哪里点击图标，调用的都是<br>    Launcher.startActivitySafely()</p>\n<p>下面来看看 Launcher.startActivitySafely()到底做了什么事情<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>调用了startAcitivity(v,intent,tag)<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>\n<p>这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：<br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>\n<h3 id=\"Instrumentation是什么？和ActivityThread-是什么关系？\"><a href=\"#Instrumentation是什么？和ActivityThread-是什么关系？\" class=\"headerlink\" title=\"Instrumentation是什么？和ActivityThread 是什么关系？\"></a>Instrumentation是什么？和ActivityThread 是什么关系？</h3><p>每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()</p>\n<pre><code>boolean startActivity(View v, Intent intent, Object tag) {\n\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        try {\n            boolean useLaunchAnimation = (v != null) &amp;&amp;\n                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);\n\n            if (useLaunchAnimation) {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent, opts.toBundle());\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(),\n                            opts.toBundle());\n                }\n            } else {\n                if (user == null || user.equals(android.os.Process.myUserHandle())) {\n                    startActivity(intent);\n                } else {\n                    launcherApps.startMainActivity(intent.getComponent(), user,\n                            intent.getSourceBounds(), null);\n                }\n            }\n            return true;\n        } catch (SecurityException e) {\n        ...\n        }\n        return false;\n    }\n</code></pre><p>有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？</p>\n<p>是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！</p>\n<p>那你可能要问老板是who?<br>老板当然是 大名鼎鼎的 ActivityThread了</p>\n<p>ActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。</p>\n<p>ASM说：『ActivityThread， 你给我暂停一个Activity！』</p>\n<p>ActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』</p>\n<p>于是，Instrumentation 就去把事儿搞定了。<br>所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。</p>\n<h3 id=\"如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\"><a href=\"#如何理解-AMS-和-ActivityThread-之间的-Binder-通信？\" class=\"headerlink\" title=\"如何理解 AMS 和 ActivityThread 之间的 Binder 通信？\"></a>如何理解 AMS 和 ActivityThread 之间的 Binder 通信？</h3><p>前面提到 调用 startActivity()的时候，时间调用了<br>    mInstrumentation.execStartActivity()</p>\n<p>里面又调用了：<br>    ActivityManagerNative.getDefault()<br>                    .startActivity</p>\n<p>这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。</p>\n<p>Binder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。</p>\n<p>为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：</p>\n<p>AMS， 和 AMP 都实现利率同一个接口： IActivityManager。<br>    class ActivityManagerProxy implements IActivityManager{}</p>\n<pre><code>public final class ActivityManagerService extends ActivityManagerNative{}\n\npublic abstract class ActivityManagerNative extends Binder implements IActivityManager{}\n</code></pre><p>虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。</p>\n<p>但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。</p>\n<p>但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如<br>    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,<br>                String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {<br>            Parcel data = Parcel.obtain();<br>            Parcel reply = Parcel.obtain();</p>\n<pre><code>    ...ignore some code...\n\n    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);\n    reply.readException();\n    int result = reply.readInt();\n    reply.recycle();\n    data.recycle();\n    return result;\n}\n</code></pre><p>上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。</p>\n<p>即：<br>客户度：ActivityManagerProxy ====> Binder驱动 ====》ActivityManagerService：服务器</p>\n<p>而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。</p>\n<p>但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ </p>\n<p>还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。</p>\n<p>客户端：ApplicationThread \\&lt;=== Binder驱动 \\&lt;=== ApplicationThreadProxy：服务器</p>\n<p>他们也实现了相同的接口 IApplicationThread:<br>    private class ApplicationThread extends ApplicationThreadNative {}</p>\n<pre><code>public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}\n\nclass ApplicationThreadProxy implements IApplicationThread {}\n</code></pre><h3 id=\"AMS-接收到-客户端的请求后，如果开启一个Activity？\"><a href=\"#AMS-接收到-客户端的请求后，如果开启一个Activity？\" class=\"headerlink\" title=\"AMS 接收到 客户端的请求后，如果开启一个Activity？\"></a>AMS 接收到 客户端的请求后，如果开启一个Activity？</h3><p>OK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？</p>\n<p>注：前方高能，方法调用链接很强！</p>\n<p>调用startActivity（）<br>    @Override<br>        public final int startActivity(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) {<br>            return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>                resultWho, requestCode, startFlags, profilerInfo, options,<br>                UserHandle.getCallingUserId());<br>        }</p>\n<p>调用startActivityAsUser（）<br>    @Override<br>        public final int startActivityAsUser(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {</p>\n<pre><code>        ...ignore some code...\n\n    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,\n            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,\n            profilerInfo, null, null, options, userId, null, null);\n}\n</code></pre><p>这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作<br>     final int startActivityMayWait(IApplicationThread caller, int callingUid,<br>                String callingPackage, Intent intent, String resolvedType,<br>                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>                IBinder resultTo, String resultWho, int requestCode, int startFlags,<br>                ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,<br>                Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {</p>\n<pre><code>...ignore some code...\n\n  int res = startActivityLocked(caller, intent, resolvedType, aInfo,\n        voiceSession, voiceInteractor, resultTo, resultWho,\n        requestCode, callingPid, callingUid, callingPackage,\n        realCallingPid, realCallingUid, startFlags, options,\n        componentSpecified, null, container, inTask);\n\n...ignore some code...\n\n}\n</code></pre><p>继续调用 startActivityLocked()</p>\n<pre><code>final int startActivityLocked(IApplicationThread caller,\n            Intent intent, String resolvedType, ActivityInfo aInfo,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,\n            IBinder resultTo, String resultWho, int requestCode,\n            int callingPid, int callingUid, String callingPackage,\n            int realCallingPid, int realCallingUid, int startFlags, Bundle options,\n            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,\n            TaskRecord inTask) {\n\n              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,\n              startFlags, true, options, inTask);\n        if (err &lt; 0) {\n            notifyActivityDrawnForKeyguard();\n        }\n        return err;\n    }\n</code></pre><p>调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。</p>\n<p>终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)</p>\n<p>ActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，</p>\n<pre><code>final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,\n            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,\n            boolean doResume, Bundle options, TaskRecord inTask) {\n\n            ...ignore some code...\n\n            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);\n\n            ...ignore some code...\n\n             return ActivityManager.START_SUCCESS;\n            }\n</code></pre><p>调用 ActivityStack.startActivityLocked()</p>\n<pre><code>final void startActivityLocked(ActivityRecord r, boolean newTask,\n            boolean doResume, boolean keepCurTransition, Bundle options) {\n\n        //ActivityRecord中存储的TaskRecord信息\n        TaskRecord rTask = r.task;\n\n         ...ignore some code...\n\n        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象\n     TaskRecord task = null;\n        if (!newTask) {\n            boolean startIt = true;\n            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) {\n                task = mTaskHistory.get(taskNdx);\n                if (task.getTopActivity() == null) {\n                    // task中的所有Activity都结束了\n                    continue;\n                }\n                if (task == r.task) {\n                    // 找到了\n                    if (!startIt) {\n                        task.addActivityToTop(r);\n                        r.putInHistory();\n                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,\n                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,\n                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,\n                                r.userId, r.info.configChanges, task.voiceSession != null,\n                                r.mLaunchTaskBehind);\n                        if (VALIDATE_TOKENS) {\n                            validateAppTokensLocked();\n                        }\n                        ActivityOptions.abort(options);\n                        return;\n                    }\n                    break;\n                } else if (task.numFullscreen &gt; 0) {\n                    startIt = false;\n                }\n            }\n        }\n\n      ...ignore some code...\n\n        // Place a new activity at top of stack, so it is next to interact\n        // with the user.\n        task = r.task;\n        task.addActivityToTop(r);\n        task.setFrontOfTask();\n\n        ...ignore some code...\n\n         if (doResume) {\n            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);\n        }\n    }\n</code></pre><p>折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor </p>\n<p>淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。</p>\n<p>一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：<br>    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,<br>                Bundle targetOptions) {<br>            if (targetStack == null) {<br>                targetStack = getFocusedStack();<br>            }<br>            // Do targetStack first.<br>            boolean result = false;<br>            if (isFrontStack(targetStack)) {<br>                result = targetStack.resumeTopActivityLocked(target, targetOptions);<br>            }</p>\n<pre><code>      ...ignore some code...\n\n    return result;\n}\n</code></pre><p>又回到 ActivityStack了。。。</p>\n<p>ActivityStack.resumeTopActivityLocked()<br>    final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {<br>            if (inResumeTopActivity) {<br>                // Don’t even start recursing.<br>                return false;<br>            }</p>\n<pre><code>    boolean result = false;\n    try {\n        // Protect against recursion.\n        inResumeTopActivity = true;\n        result = resumeTopActivityInnerLocked(prev, options);\n    } finally {\n        inResumeTopActivity = false;\n    }\n    return result;\n}\n</code></pre><p>坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？</p>\n<pre><code>final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {\n\n          ...ignore some code...\n      //找出还没结束的首个ActivityRecord\n     ActivityRecord next = topRunningActivityLocked(null);\n\n    //如果一个没结束的Activity都没有，就开启Launcher程序\n    if (next == null) {\n            ActivityOptions.abort(options);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);\n            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();\n            // Only resume home if on home display\n            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?\n                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();\n            return isOnHomeDisplay() &amp;&amp;\n                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);\n        }\n\n        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态\n          if (mResumedActivity != null) {\n            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);\n            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);\n        }\n\n  }\n</code></pre><p>在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。<br>    ActivityManagerNative.getDefault().activityPaused(token).</p>\n<p>上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。</p>\n<p>最后 来一张高清五码的大图，方便记忆</p>\n<p><img src=\"Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png\" alt=\"\"></p>\n<h3 id=\"一个App的程序入口是什么？\"><a href=\"#一个App的程序入口是什么？\" class=\"headerlink\" title=\"一个App的程序入口是什么？\"></a>一个App的程序入口是什么？</h3><p>是ActivityThread.main()</p>\n<h3 id=\"整个App的主线程的消息循环是在哪里创建的\"><a href=\"#整个App的主线程的消息循环是在哪里创建的\" class=\"headerlink\" title=\"整个App的主线程的消息循环是在哪里创建的?\"></a>整个App的主线程的消息循环是在哪里创建的?</h3><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。</p>\n<pre><code>public static void main(String[] args) {\n\n          ...ignore some code...    \n\n      Looper.prepareMainLooper();\n\n        ActivityThread thread = new ActivityThread();\n        thread.attach(false);\n\n        if (sMainThreadHandler == null) {\n            sMainThreadHandler = thread.getHandler();\n        }\n\n        AsyncTask.init();\n\n        if (false) {\n            Looper.myLooper().setMessageLogging(new\n                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));\n        }\n\n        Looper.loop();\n\n          ...ignore some code...    \n\n }\n</code></pre><p>Looper.prepareMainLooper();<br>准备完成后：</p>\n<p>Looper.loop()</p>\n<h3 id=\"Application-是在什么时候创建的？onCreate-什么时候调用的？\"><a href=\"#Application-是在什么时候创建的？onCreate-什么时候调用的？\" class=\"headerlink\" title=\"Application 是在什么时候创建的？onCreate()什么时候调用的？\"></a>Application 是在什么时候创建的？onCreate()什么时候调用的？</h3><p>也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。</p>\n<p>不相信，一起看看去!</p>\n<p>先看下ActivityThead.attach()<br>    private void attach(boolean system) {<br>            sCurrentActivityThread = this;<br>            mSystemThread = system;<br>            //普通App进这里<br>            if (!system) {</p>\n<pre><code>        ...ignore some code...    \n\n        RuntimeInit.setApplicationObject(mAppThread.asBinder());\n        final IActivityManager mgr = ActivityManagerNative.getDefault();\n        try {\n            mgr.attachApplication(mAppThread);\n        } catch (RemoteException ex) {\n            // Ignore\n        }\n       } else {\n         //这个分支在SystemServer加载的时候会进入，通过调用\n         // private void createSystemContext() {\n         //    ActivityThread activityThread = ActivityThread.systemMain()；\n         //} \n\n         // public static ActivityThread systemMain() {\n    //        if (!ActivityManager.isHighEndGfx()) {\n    //            HardwareRenderer.disable(true);\n    //        } else {\n    //            HardwareRenderer.enableForegroundTrimming();\n    //        }\n    //        ActivityThread thread = new ActivityThread();\n    //        thread.attach(true);\n    //        return thread;\n    //    }       \n       }\n}\n</code></pre><p>这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法</p>\n<pre><code>@Override\n    public final void attachApplication(IApplicationThread thread) {\n        synchronized (this) {\n            int callingPid = Binder.getCallingPid();\n            final long origId = Binder.clearCallingIdentity();\n            attachApplicationLocked(thread, callingPid);\n            Binder.restoreCallingIdentity(origId);\n        }\n    }\n</code></pre><p>然后：</p>\n<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,\n            int pid) {\n\n\n             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,\n                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,\n                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,\n                    isRestrictedBackupMode || !normalMode, app.persistent,\n                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),\n                    mCoreSettingsObserver.getCoreSettingsLocked());\n\n\n            }\n</code></pre><p>thread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法<br>    public final void bindApplication(String processName, ApplicationInfo appInfo,<br>                    List<ProviderInfo> providers, ComponentName instrumentationName,<br>                    ProfilerInfo profilerInfo, Bundle instrumentationArgs,<br>                    IInstrumentationWatcher instrumentationWatcher,<br>                    IUiAutomationConnection instrumentationUiConnection, int debugMode,<br>                    boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,<br>                    Configuration config, CompatibilityInfo compatInfo, Map<String, IBinder> services,<br>                    Bundle coreSettings) {</p>\n<pre><code>                 ...ignore some code...    \n\n             AppBindData data = new AppBindData();\n            data.processName = processName;\n            data.appInfo = appInfo;\n            data.providers = providers;\n            data.instrumentationName = instrumentationName;\n            data.instrumentationArgs = instrumentationArgs;\n            data.instrumentationWatcher = instrumentationWatcher;\n            data.instrumentationUiAutomationConnection = instrumentationUiConnection;\n            data.debugMode = debugMode;\n            data.enableOpenGlTrace = enableOpenGlTrace;\n            data.restrictedBackupMode = isRestrictedBackupMode;\n            data.persistent = persistent;\n            data.config = config;\n            data.compatInfo = compatInfo;\n            data.initProfilerInfo = profilerInfo;\n            sendMessage(H.BIND_APPLICATION, data);\n\n           }\n\n}\n</code></pre><p>其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理<br>    private class H extends Handler {</p>\n<pre><code>     ...ignore some code... \n\n    public static final int BIND_APPLICATION        = 110;\n\n   ...ignore some code... \n\n    public void handleMessage(Message msg) {\n         switch (msg.what) {\n       ...ignore some code... \n        case BIND_APPLICATION:\n                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);\n                   AppBindData data = (AppBindData)msg.obj;\n                   handleBindApplication(data);\n                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);\n                   break;\n       ...ignore some code... \n       }\n}\n</code></pre><p>最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。</p>\n<pre><code>private void handleBindApplication(AppBindData data) {\n\n try {\n\n           ...ignore some code... \n\n            Application app = data.info.makeApplication(data.restrictedBackupMode, null);\n            mInitialApplication = app;\n\n           ...ignore some code... \n\n            try {\n                mInstrumentation.onCreate(data.instrumentationArgs);\n            }\n            catch (Exception e) {\n            }\n            try {\n                mInstrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {            }\n        } finally {\n            StrictMode.setThreadPolicy(savedPolicy);\n        }\n }\n</code></pre><p>data.info 是一个LoadeApk 对象</p>\n<p>LoadeApk.data.info.makeApplication()</p>\n<pre><code>public Application makeApplication(boolean forceDefaultAppClass,\n            Instrumentation instrumentation) {\n        if (mApplication != null) {\n            return mApplication;\n        }\n\n        Application app = null;\n\n        String appClass = mApplicationInfo.className;\n        if (forceDefaultAppClass || (appClass == null)) {\n            appClass = &quot;android.app.Application&quot;;\n        }\n\n        try {\n            java.lang.ClassLoader cl = getClassLoader();\n            if (!mPackageName.equals(&quot;android&quot;)) {\n                initializeJavaContextClassLoader();\n            }\n            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);\n            app = mActivityThread.mInstrumentation.newApplication(\n                    cl, appClass, appContext);\n            appContext.setOuterContext(app);\n        } catch (Exception e) {        }\n        mActivityThread.mAllApplications.add(app);\n        mApplication = app;\n\n    //传进来的是null，所以这里不会执行，onCreate在上一层执行\n        if (instrumentation != null) {\n            try {\n                instrumentation.callApplicationOnCreate(app);\n            } catch (Exception e) {\n\n            }\n        }\n        ...ignore some code... \n\n       }\n\n        return app;\n    }\n</code></pre><p>最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！</p>\n<pre><code>static public Application newApplication(Class&lt;?&gt; clazz, Context context)\n            throws InstantiationException, IllegalAccessException, \n            ClassNotFoundException {\n        Application app = (Application)clazz.newInstance();\n        app.attach(context);\n        return app;\n    }\n</code></pre><p>而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。</p>\n<p>参考文章</p>\n<p>下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。</p>\n<p>Binder:</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/universus/article/details/6211589\">Android Bander设计与实现 - 设计篇</a></li>\n</ul>\n<p>zygote<br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6768304\">Android系统进程Zygote启动过程的源代码分析</a><br>•    <a href=\"http://blog.csdn.net/xieqibao/article/details/6581975\">Android 之 zygote 与进程创建</a><br>•    <a href=\"http://www.th7.cn/Program/Android/201404/187670.shtml\">Zygote浅谈</a><br>ActivityThread、Instrumentation、AMS<br>•    <a href=\"http://blog.csdn.net/myarrow/article/details/14224273\">Android Activity.startActivity流程简介</a><br>•    <a href=\"http://blog.csdn.net/luoshengyang/article/details/6747696#comments\">Android应用程序进程启动过程的源代码分析</a><br>•    <a href=\"http://laokaddk.blog.51cto.com/368606/1206840\">框架层理解Activity生命周期(APP启动过程)</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\">Android应用程序窗口设计框架介绍</a><br>•    <a href=\"http://www.xuebuyuan.com/2172927.html\">ActivityManagerService分析一：AMS的启动</a><br>•    <a href=\"http://blog.csdn.net/yangwen123/article/details/35987609\">Android应用程序窗口设计框架介绍</a><br>Launcher<br>•    <a href=\"http://mobile.51cto.com/hot-312129.htm\">Android 4.0 Launcher源码分析系列(一)</a><br>•    <a href=\"http://www.cnblogs.com/mythou/p/3187881.html\">Android Launcher分析和修改9——Launcher启动APP流程</a></p>\n<p>结束语：<br>到了这里，我们回来看下开头的几个问题：</p>\n<ul>\n<li>ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>\n<li>ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作</li>\n<li>ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。</li>\n<li>ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的</li>\n<li>Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作</li>\n<li>ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射</li>\n<li>TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。</li>\n</ul>\n<p>如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 </p>\n"},{"title":"日志指南","date":"2015-09-11T02:12:24.000Z","_content":"\n\n参考：[最佳日志实践][2]\n\n<br>\n### 前言\n<br>\n\n\t\t几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\t\t\n        日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n        \n        日志作用：\n        - 好的日志记录系统出现问题时能快速定位\n        - 可以通过对日志的观察和分析\n        - 提前发现系统可能的风险\n        - 避免线上事故的发生\n\n<br>\n## 一、日志级别\n<br>\n###### 通常使用的日志库（如**log4j**, **logback** 等）\n\n\n\n**日志基本分为以下几类（从低到高）：**\n\n**VERBOSE** – *The VERBOSE Level designates finer-grained informational events than the DEBUG*\n\n**DEBUG** – *The DEBUG Level designates fine-grained informational events that are most useful to debug an application.*\n\n**INFO** – *The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.*\n\n**WARN** – *The WARN level designates potentially harmful situations.*\n\n**ERROR** – *The ERROR level designates error events that might still allow the application to continue running.*\n\n**FATAL** – *The FATAL level designates very severe error events that will presumably lead the application to abort.*\n\n\n- 一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；\n- 即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;\n- 对于日志级别的分类，有以下参考：\n\n```\nFATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；\n\nERROR — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；\n\nWARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；\n\nINFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；\n\nDEBUG or TRACE — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过DEBUG（或TRACE）日志来定位问题；\n\n```\n\n**Rule 1**：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等\n\n<br>\n## 二、对记录的日志要进行更新维护\n<br>\n\n由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：\n\n- 定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；\n- 整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；\n\n**Rule 2**：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题\n\n<br>\n## 三、关于日志分类\n<br>\n\n日志从功能来说，可分为诊断日志、统计日志、审计日志。\n\n诊断日志， 典型的有：\n\n- 请求入口和出口\n- 外部服务调用和返回\n- 资源消耗操作: 打开文件等\n- 容错行为： 譬如云硬盘的副本修复操作\n- 程序异常： 譬如数据库无法连接\n- 后台操作：清理程序\n- 启动、关闭、配置加载\n- 抛出异常时，不记录日志\n\n统计日志：\n\n- 用户访问统计\n- 计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）\n\n审计日志：\n\n- 管理操作\n\n\t将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。\n\n**Rule 3**：要明确不同日志的用途，对日志内容进行分类\n\n<br>\n## 四、日志中不要记录无用信息\n<br>\n\n例如一些测试的log: log.i(\"tag\", \"数据加载成功\")，可以打印一些比较有实用价值的Log， 例如：\nlog.i(\"tag\", \"数据加载成功，数据是：{}\"， “XXXX”)\n\n**Rule 4**: 绝不要打印没有用的日志，防止无用日志淹没重要信息\n\n<br>\n## 五、5. 日志记录信息要完整\n<br>\n\n问题描述：\n\n```\nNOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：\n\n- InitMultiUpload（生成一个UploadID）\n- UploadPart\n- UploadPart\n-  ……\n- UploadPart\n- CompleteMultiUpload（AbortMultiUpload）\n\n之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。\n\n然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。\n\n类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。\n\n因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：\n\n- 在系统启动或初始化时记录重要的系统初始化参数\n- 记录系统运行过程中的所有的错误\n- 记录系统运行过程中的所有的警告\n- 在持久化数据修改时记录修改前和修改后的值\n- 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）\n- 重要的状态变化（如NOS中对系统白名单的修改等）\n- 系统中一些长期执行的任务的执行进度\n```\n\n**不推荐记录日志的内容有：**\n\n- 函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志\n- 文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志\n- “良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理\n\n**Rule 5**：日志信息要准确全面，能做到仅凭日志就可以定位问题\n\n*解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。*\n\n<br>\n## 六、测试的日志\n<br>\n\n测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。\n\n测试日志应该包含以下内容：\n\n- 测试执行的环境\n- 测试执行前的初始状态\n- 测试的详细步骤\n- 测试和系统的交互信息\n- 测试期望的返回结果\n- 测试实际的返回结果\n\n**Rule 6**：要以同样严格的要求对待测试程序的日志\n\n<br>\n## 七、从问题中完善日志\n<br>\n\n在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：\n\n- 如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化\n- 需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）\n\n通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。\n\n**Rule 7**：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习\n\n<br>\n## 八、对日志进行监控报警，比客户先发现系统问题\n<br>\n\ncrash关键字报警：\n\n程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志\n\n类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。\n\n**Rule 8**：对日志进行监控报警，比客户先发现系统问题\n\n<br>\n## 九、关于日志格式\n<br>\n\n日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：\n\n```\n第一种：\nlogger.error(“Gearman timeout exception for request ” + getRequestID() + ” value: ” + value, e);\n\n第二种：\nlogger.error(“RequestID: ” + getRequestID() + “, Error Message: Gearman timeout exception: ” + e);\n\n第三种：\nlogger.error(getErrorMessage(getRequestID(), getErrorMessage(), e));\n```\n\n\n第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：\n\n- 系统中日志格式不统一，不利于自动化处理\n- 有些日志可能只有开发人员自己才能看懂\n- 代码规范性不好\n\n而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。\n\n**Rule 9**：日志格式要统一规范\n\n<br>\n## 十、错误日志输出到不同文件\n<br>\n\n在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。\n\n这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。\n\n**Rule 10**：将错误日志输出到一个单独的文件中进行分析\n\n<br>\n## 十一、关于日志文件大小\n<br>\n\n日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。\n\n为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：\n\n- 将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；\n- 每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志\n\n**Rule 11**：要把日志的大小，如何切分，如何删除等作为规范建立起来\n\n\n\n\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n\n\n\n\n\n---\n\n[1]:http://img.blog.csdn.net/20140502002840109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhneGh1YWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\n\n[2]:http://www.bitstech.net/2014/01/07/log-best-practice/\n\n\n\n\n\n","source":"_posts/日志指南.md","raw":"title: 日志指南\ndate: 2015-09-11 10:12:24\n\ntags: Android日志规范\n---\n\n\n参考：[最佳日志实践][2]\n\n<br>\n### 前言\n<br>\n\n\t\t几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\t\t\n        日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n        \n        日志作用：\n        - 好的日志记录系统出现问题时能快速定位\n        - 可以通过对日志的观察和分析\n        - 提前发现系统可能的风险\n        - 避免线上事故的发生\n\n<br>\n## 一、日志级别\n<br>\n###### 通常使用的日志库（如**log4j**, **logback** 等）\n\n\n\n**日志基本分为以下几类（从低到高）：**\n\n**VERBOSE** – *The VERBOSE Level designates finer-grained informational events than the DEBUG*\n\n**DEBUG** – *The DEBUG Level designates fine-grained informational events that are most useful to debug an application.*\n\n**INFO** – *The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.*\n\n**WARN** – *The WARN level designates potentially harmful situations.*\n\n**ERROR** – *The ERROR level designates error events that might still allow the application to continue running.*\n\n**FATAL** – *The FATAL level designates very severe error events that will presumably lead the application to abort.*\n\n\n- 一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；\n- 即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;\n- 对于日志级别的分类，有以下参考：\n\n```\nFATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；\n\nERROR — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当ERROR错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上ERROR错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而ERROR相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印ERROR日志。特别需要注意的是，ERROR和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为ERROR日志的；\n\nWARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；\n\nINFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,ERROR,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于TRACE日志的10%；\n\nDEBUG or TRACE — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过DEBUG（或TRACE）级别的日志对问题进行诊断。需要注意的是，DEBUG日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过DEBUG（或TRACE）日志来定位问题；\n\n```\n\n**Rule 1**：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等\n\n<br>\n## 二、对记录的日志要进行更新维护\n<br>\n\n由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：\n\n- 定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；\n- 整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；\n\n**Rule 2**：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题\n\n<br>\n## 三、关于日志分类\n<br>\n\n日志从功能来说，可分为诊断日志、统计日志、审计日志。\n\n诊断日志， 典型的有：\n\n- 请求入口和出口\n- 外部服务调用和返回\n- 资源消耗操作: 打开文件等\n- 容错行为： 譬如云硬盘的副本修复操作\n- 程序异常： 譬如数据库无法连接\n- 后台操作：清理程序\n- 启动、关闭、配置加载\n- 抛出异常时，不记录日志\n\n统计日志：\n\n- 用户访问统计\n- 计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）\n\n审计日志：\n\n- 管理操作\n\n\t将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。\n\n**Rule 3**：要明确不同日志的用途，对日志内容进行分类\n\n<br>\n## 四、日志中不要记录无用信息\n<br>\n\n例如一些测试的log: log.i(\"tag\", \"数据加载成功\")，可以打印一些比较有实用价值的Log， 例如：\nlog.i(\"tag\", \"数据加载成功，数据是：{}\"， “XXXX”)\n\n**Rule 4**: 绝不要打印没有用的日志，防止无用日志淹没重要信息\n\n<br>\n## 五、5. 日志记录信息要完整\n<br>\n\n问题描述：\n\n```\nNOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：\n\n- InitMultiUpload（生成一个UploadID）\n- UploadPart\n- UploadPart\n-  ……\n- UploadPart\n- CompleteMultiUpload（AbortMultiUpload）\n\n之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。\n\n然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。\n\n类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。\n\n因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：\n\n- 在系统启动或初始化时记录重要的系统初始化参数\n- 记录系统运行过程中的所有的错误\n- 记录系统运行过程中的所有的警告\n- 在持久化数据修改时记录修改前和修改后的值\n- 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）\n- 重要的状态变化（如NOS中对系统白名单的修改等）\n- 系统中一些长期执行的任务的执行进度\n```\n\n**不推荐记录日志的内容有：**\n\n- 函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志\n- 文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志\n- “良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理\n\n**Rule 5**：日志信息要准确全面，能做到仅凭日志就可以定位问题\n\n*解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。*\n\n<br>\n## 六、测试的日志\n<br>\n\n测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。\n\n测试日志应该包含以下内容：\n\n- 测试执行的环境\n- 测试执行前的初始状态\n- 测试的详细步骤\n- 测试和系统的交互信息\n- 测试期望的返回结果\n- 测试实际的返回结果\n\n**Rule 6**：要以同样严格的要求对待测试程序的日志\n\n<br>\n## 七、从问题中完善日志\n<br>\n\n在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：\n\n- 如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化\n- 需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）\n\n通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。\n\n**Rule 7**：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习\n\n<br>\n## 八、对日志进行监控报警，比客户先发现系统问题\n<br>\n\ncrash关键字报警：\n\n程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志\n\n类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。\n\n**Rule 8**：对日志进行监控报警，比客户先发现系统问题\n\n<br>\n## 九、关于日志格式\n<br>\n\n日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：\n\n```\n第一种：\nlogger.error(“Gearman timeout exception for request ” + getRequestID() + ” value: ” + value, e);\n\n第二种：\nlogger.error(“RequestID: ” + getRequestID() + “, Error Message: Gearman timeout exception: ” + e);\n\n第三种：\nlogger.error(getErrorMessage(getRequestID(), getErrorMessage(), e));\n```\n\n\n第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：\n\n- 系统中日志格式不统一，不利于自动化处理\n- 有些日志可能只有开发人员自己才能看懂\n- 代码规范性不好\n\n而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。\n\n**Rule 9**：日志格式要统一规范\n\n<br>\n## 十、错误日志输出到不同文件\n<br>\n\n在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。\n\n这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。\n\n**Rule 10**：将错误日志输出到一个单独的文件中进行分析\n\n<br>\n## 十一、关于日志文件大小\n<br>\n\n日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。\n\n为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：\n\n- 将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；\n- 每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志\n\n**Rule 11**：要把日志的大小，如何切分，如何删除等作为规范建立起来\n\n\n\n\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n\n\n\n\n\n---\n\n[1]:http://img.blog.csdn.net/20140502002840109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhneGh1YWE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\n\n[2]:http://www.bitstech.net/2014/01/07/log-best-practice/\n\n\n\n\n\n","slug":"日志指南","published":1,"updated":"2015-09-11T02:38:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1z80013rgexqiaj6dxn","content":"<p>参考：<a href=\"http://www.bitstech.net/2014/01/07/log-best-practice/\" target=\"_blank\" rel=\"external\">最佳日志实践</a></p>\n<p><br></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><br></p>\n<pre><code>几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\n日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n\n日志作用：\n- 好的日志记录系统出现问题时能快速定位\n- 可以通过对日志的观察和分析\n- 提前发现系统可能的风险\n- 避免线上事故的发生\n</code></pre><p><br></p>\n<h2 id=\"一、日志级别\"><a href=\"#一、日志级别\" class=\"headerlink\" title=\"一、日志级别\"></a>一、日志级别</h2><p><br></p>\n<h6 id=\"通常使用的日志库（如log4j-logback-等）\"><a href=\"#通常使用的日志库（如log4j-logback-等）\" class=\"headerlink\" title=\"通常使用的日志库（如log4j, logback 等）\"></a>通常使用的日志库（如<strong>log4j</strong>, <strong>logback</strong> 等）</h6><p><strong>日志基本分为以下几类（从低到高）：</strong></p>\n<p><strong>VERBOSE</strong> – <em>The VERBOSE Level designates finer-grained informational events than the DEBUG</em></p>\n<p><strong>DEBUG</strong> – <em>The DEBUG Level designates fine-grained informational events that are most useful to debug an application.</em></p>\n<p><strong>INFO</strong> – <em>The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.</em></p>\n<p><strong>WARN</strong> – <em>The WARN level designates potentially harmful situations.</em></p>\n<p><strong>ERROR</strong> – <em>The ERROR level designates error events that might still allow the application to continue running.</em></p>\n<p><strong>FATAL</strong> – <em>The FATAL level designates very severe error events that will presumably lead the application to abort.</em></p>\n<ul>\n<li>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；</li>\n<li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;</li>\n<li>对于日志级别的分类，有以下参考：</li>\n</ul>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ERROR</span> — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当<span class=\"built_in\">ERROR</span>错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上<span class=\"built_in\">ERROR</span>错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而<span class=\"built_in\">ERROR</span>相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印<span class=\"built_in\">ERROR</span>日志。特别需要注意的是，<span class=\"built_in\">ERROR</span>和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为<span class=\"built_in\">ERROR</span>日志的；</span><br><span class=\"line\"></span><br><span class=\"line\">WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；</span><br><span class=\"line\"></span><br><span class=\"line\">INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,<span class=\"built_in\">ERROR</span>,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于<span class=\"keyword\">TRACE</span>日志的<span class=\"number\">10</span>%；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DEBUG</span> <span class=\"keyword\">or</span> <span class=\"keyword\">TRACE</span> — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）级别的日志对问题进行诊断。需要注意的是，<span class=\"keyword\">DEBUG</span>日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）日志来定位问题；</span><br></pre></td></tr></table></figure>\n<p><strong>Rule 1</strong>：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p>\n<p><br></p>\n<h2 id=\"二、对记录的日志要进行更新维护\"><a href=\"#二、对记录的日志要进行更新维护\" class=\"headerlink\" title=\"二、对记录的日志要进行更新维护\"></a>二、对记录的日志要进行更新维护</h2><p><br></p>\n<p>由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：</p>\n<ul>\n<li>定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；</li>\n<li>整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；</li>\n</ul>\n<p><strong>Rule 2</strong>：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p>\n<p><br></p>\n<h2 id=\"三、关于日志分类\"><a href=\"#三、关于日志分类\" class=\"headerlink\" title=\"三、关于日志分类\"></a>三、关于日志分类</h2><p><br></p>\n<p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p>\n<p>诊断日志， 典型的有：</p>\n<ul>\n<li>请求入口和出口</li>\n<li>外部服务调用和返回</li>\n<li>资源消耗操作: 打开文件等</li>\n<li>容错行为： 譬如云硬盘的副本修复操作</li>\n<li>程序异常： 譬如数据库无法连接</li>\n<li>后台操作：清理程序</li>\n<li>启动、关闭、配置加载</li>\n<li>抛出异常时，不记录日志</li>\n</ul>\n<p>统计日志：</p>\n<ul>\n<li>用户访问统计</li>\n<li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li>\n</ul>\n<p>审计日志：</p>\n<ul>\n<li><p>管理操作</p>\n<p>  将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p>\n</li>\n</ul>\n<p><strong>Rule 3</strong>：要明确不同日志的用途，对日志内容进行分类</p>\n<p><br></p>\n<h2 id=\"四、日志中不要记录无用信息\"><a href=\"#四、日志中不要记录无用信息\" class=\"headerlink\" title=\"四、日志中不要记录无用信息\"></a>四、日志中不要记录无用信息</h2><p><br></p>\n<p>例如一些测试的log: log.i(“tag”, “数据加载成功”)，可以打印一些比较有实用价值的Log， 例如：<br>log.i(“tag”, “数据加载成功，数据是：{}”， “XXXX”)</p>\n<p><strong>Rule 4</strong>: 绝不要打印没有用的日志，防止无用日志淹没重要信息</p>\n<p><br></p>\n<h2 id=\"五、5-日志记录信息要完整\"><a href=\"#五、5-日志记录信息要完整\" class=\"headerlink\" title=\"五、5. 日志记录信息要完整\"></a>五、5. 日志记录信息要完整</h2><p><br></p>\n<p>问题描述：</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> InitMultiUpload（生成一个UploadID）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\">  ……</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> CompleteMultiUpload（AbortMultiUpload）</span><br><span class=\"line\"></span></span><br><span class=\"line\">之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。</span><br><span class=\"line\"></span><br><span class=\"line\">然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。</span><br><span class=\"line\"></span><br><span class=\"line\">类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。</span><br><span class=\"line\"></span><br><span class=\"line\">因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> 在系统启动或初始化时记录重要的系统初始化参数</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的错误</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的警告</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 在持久化数据修改时记录修改前和修改后的值</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 重要的状态变化（如NOS中对系统白名单的修改等）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 系统中一些长期执行的任务的执行进度</span></span><br></pre></td></tr></table></figure>\n<p><strong>不推荐记录日志的内容有：</strong></p>\n<ul>\n<li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li>\n<li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li>\n<li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li>\n</ul>\n<p><strong>Rule 5</strong>：日志信息要准确全面，能做到仅凭日志就可以定位问题</p>\n<p><em>解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。</em></p>\n<p><br></p>\n<h2 id=\"六、测试的日志\"><a href=\"#六、测试的日志\" class=\"headerlink\" title=\"六、测试的日志\"></a>六、测试的日志</h2><p><br></p>\n<p>测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。</p>\n<p>测试日志应该包含以下内容：</p>\n<ul>\n<li>测试执行的环境</li>\n<li>测试执行前的初始状态</li>\n<li>测试的详细步骤</li>\n<li>测试和系统的交互信息</li>\n<li>测试期望的返回结果</li>\n<li>测试实际的返回结果</li>\n</ul>\n<p><strong>Rule 6</strong>：要以同样严格的要求对待测试程序的日志</p>\n<p><br></p>\n<h2 id=\"七、从问题中完善日志\"><a href=\"#七、从问题中完善日志\" class=\"headerlink\" title=\"七、从问题中完善日志\"></a>七、从问题中完善日志</h2><p><br></p>\n<p>在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：</p>\n<ul>\n<li>如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化</li>\n<li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li>\n</ul>\n<p>通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。</p>\n<p><strong>Rule 7</strong>：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p>\n<p><br></p>\n<h2 id=\"八、对日志进行监控报警，比客户先发现系统问题\"><a href=\"#八、对日志进行监控报警，比客户先发现系统问题\" class=\"headerlink\" title=\"八、对日志进行监控报警，比客户先发现系统问题\"></a>八、对日志进行监控报警，比客户先发现系统问题</h2><p><br></p>\n<p>crash关键字报警：</p>\n<p>程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志</p>\n<p>类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。</p>\n<p><strong>Rule 8</strong>：对日志进行监控报警，比客户先发现系统问题</p>\n<p><br></p>\n<h2 id=\"九、关于日志格式\"><a href=\"#九、关于日志格式\" class=\"headerlink\" title=\"九、关于日志格式\"></a>九、关于日志格式</h2><p><br></p>\n<p>日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“Gearman timeout exception for request ” + getRequestID() + ” <span class=\"attribute\">value</span>: ” + value, e);</span><br><span class=\"line\"></span><br><span class=\"line\">第二种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“<span class=\"attribute\">RequestID</span>: ” + getRequestID() + “, Error <span class=\"attribute\">Message</span>: Gearman timeout <span class=\"attribute\">exception</span>: ” + e);</span><br><span class=\"line\"></span><br><span class=\"line\">第三种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(getErrorMessage(getRequestID(), getErrorMessage(), e));</span><br></pre></td></tr></table></figure>\n<p>第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：</p>\n<ul>\n<li>系统中日志格式不统一，不利于自动化处理</li>\n<li>有些日志可能只有开发人员自己才能看懂</li>\n<li>代码规范性不好</li>\n</ul>\n<p>而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。</p>\n<p><strong>Rule 9</strong>：日志格式要统一规范</p>\n<p><br></p>\n<h2 id=\"十、错误日志输出到不同文件\"><a href=\"#十、错误日志输出到不同文件\" class=\"headerlink\" title=\"十、错误日志输出到不同文件\"></a>十、错误日志输出到不同文件</h2><p><br></p>\n<p>在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。</p>\n<p>这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。</p>\n<p><strong>Rule 10</strong>：将错误日志输出到一个单独的文件中进行分析</p>\n<p><br></p>\n<h2 id=\"十一、关于日志文件大小\"><a href=\"#十一、关于日志文件大小\" class=\"headerlink\" title=\"十一、关于日志文件大小\"></a>十一、关于日志文件大小</h2><p><br></p>\n<p>日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。</p>\n<p>为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：</p>\n<ul>\n<li>将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；</li>\n<li>每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志</li>\n</ul>\n<p><strong>Rule 11</strong>：要把日志的大小，如何切分，如何删除等作为规范建立起来</p>\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n<hr>\n","excerpt":"","more":"<p>参考：<a href=\"http://www.bitstech.net/2014/01/07/log-best-practice/\">最佳日志实践</a></p>\n<p><br></p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p><br></p>\n<pre><code>几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。\n\n日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。\n\n日志作用：\n- 好的日志记录系统出现问题时能快速定位\n- 可以通过对日志的观察和分析\n- 提前发现系统可能的风险\n- 避免线上事故的发生\n</code></pre><p><br></p>\n<h2 id=\"一、日志级别\"><a href=\"#一、日志级别\" class=\"headerlink\" title=\"一、日志级别\"></a>一、日志级别</h2><p><br></p>\n<h6 id=\"通常使用的日志库（如log4j-logback-等）\"><a href=\"#通常使用的日志库（如log4j-logback-等）\" class=\"headerlink\" title=\"通常使用的日志库（如log4j, logback 等）\"></a>通常使用的日志库（如<strong>log4j</strong>, <strong>logback</strong> 等）</h6><p><strong>日志基本分为以下几类（从低到高）：</strong></p>\n<p><strong>VERBOSE</strong> – <em>The VERBOSE Level designates finer-grained informational events than the DEBUG</em></p>\n<p><strong>DEBUG</strong> – <em>The DEBUG Level designates fine-grained informational events that are most useful to debug an application.</em></p>\n<p><strong>INFO</strong> – <em>The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.</em></p>\n<p><strong>WARN</strong> – <em>The WARN level designates potentially harmful situations.</em></p>\n<p><strong>ERROR</strong> – <em>The ERROR level designates error events that might still allow the application to continue running.</em></p>\n<p><strong>FATAL</strong> – <em>The FATAL level designates very severe error events that will presumably lead the application to abort.</em></p>\n<ul>\n<li>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；</li>\n<li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;</li>\n<li>对于日志级别的分类，有以下参考：</li>\n</ul>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">ERROR</span> — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当<span class=\"built_in\">ERROR</span>错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上<span class=\"built_in\">ERROR</span>错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而<span class=\"built_in\">ERROR</span>相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印<span class=\"built_in\">ERROR</span>日志。特别需要注意的是，<span class=\"built_in\">ERROR</span>和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为<span class=\"built_in\">ERROR</span>日志的；</span><br><span class=\"line\"></span><br><span class=\"line\">WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；</span><br><span class=\"line\"></span><br><span class=\"line\">INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,<span class=\"built_in\">ERROR</span>,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于<span class=\"keyword\">TRACE</span>日志的<span class=\"number\">10</span>%；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DEBUG</span> <span class=\"keyword\">or</span> <span class=\"keyword\">TRACE</span> — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）级别的日志对问题进行诊断。需要注意的是，<span class=\"keyword\">DEBUG</span>日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过<span class=\"keyword\">DEBUG</span>（或<span class=\"keyword\">TRACE</span>）日志来定位问题；</span><br></pre></td></tr></table></figure>\n<p><strong>Rule 1</strong>：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p>\n<p><br></p>\n<h2 id=\"二、对记录的日志要进行更新维护\"><a href=\"#二、对记录的日志要进行更新维护\" class=\"headerlink\" title=\"二、对记录的日志要进行更新维护\"></a>二、对记录的日志要进行更新维护</h2><p><br></p>\n<p>由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：</p>\n<ul>\n<li>定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；</li>\n<li>整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；</li>\n</ul>\n<p><strong>Rule 2</strong>：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p>\n<p><br></p>\n<h2 id=\"三、关于日志分类\"><a href=\"#三、关于日志分类\" class=\"headerlink\" title=\"三、关于日志分类\"></a>三、关于日志分类</h2><p><br></p>\n<p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p>\n<p>诊断日志， 典型的有：</p>\n<ul>\n<li>请求入口和出口</li>\n<li>外部服务调用和返回</li>\n<li>资源消耗操作: 打开文件等</li>\n<li>容错行为： 譬如云硬盘的副本修复操作</li>\n<li>程序异常： 譬如数据库无法连接</li>\n<li>后台操作：清理程序</li>\n<li>启动、关闭、配置加载</li>\n<li>抛出异常时，不记录日志</li>\n</ul>\n<p>统计日志：</p>\n<ul>\n<li>用户访问统计</li>\n<li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li>\n</ul>\n<p>审计日志：</p>\n<ul>\n<li><p>管理操作</p>\n<p>  将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p>\n</li>\n</ul>\n<p><strong>Rule 3</strong>：要明确不同日志的用途，对日志内容进行分类</p>\n<p><br></p>\n<h2 id=\"四、日志中不要记录无用信息\"><a href=\"#四、日志中不要记录无用信息\" class=\"headerlink\" title=\"四、日志中不要记录无用信息\"></a>四、日志中不要记录无用信息</h2><p><br></p>\n<p>例如一些测试的log: log.i(“tag”, “数据加载成功”)，可以打印一些比较有实用价值的Log， 例如：<br>log.i(“tag”, “数据加载成功，数据是：{}”， “XXXX”)</p>\n<p><strong>Rule 4</strong>: 绝不要打印没有用的日志，防止无用日志淹没重要信息</p>\n<p><br></p>\n<h2 id=\"五、5-日志记录信息要完整\"><a href=\"#五、5-日志记录信息要完整\" class=\"headerlink\" title=\"五、5. 日志记录信息要完整\"></a>五、5. 日志记录信息要完整</h2><p><br></p>\n<p>问题描述：</p>\n<figure class=\"highlight haml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> InitMultiUpload（生成一个UploadID）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\">  ……</span><br><span class=\"line\"></span>-<span class=\"ruby\"> UploadPart</span><br><span class=\"line\"></span>-<span class=\"ruby\"> CompleteMultiUpload（AbortMultiUpload）</span><br><span class=\"line\"></span></span><br><span class=\"line\">之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。</span><br><span class=\"line\"></span><br><span class=\"line\">然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。</span><br><span class=\"line\"></span><br><span class=\"line\">类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。</span><br><span class=\"line\"></span><br><span class=\"line\">因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"ruby\"> 在系统启动或初始化时记录重要的系统初始化参数</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的错误</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统运行过程中的所有的警告</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 在持久化数据修改时记录修改前和修改后的值</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 重要的状态变化（如NOS中对系统白名单的修改等）</span><br><span class=\"line\"></span>-<span class=\"ruby\"> 系统中一些长期执行的任务的执行进度</span></span><br></pre></td></tr></table></figure>\n<p><strong>不推荐记录日志的内容有：</strong></p>\n<ul>\n<li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li>\n<li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li>\n<li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li>\n</ul>\n<p><strong>Rule 5</strong>：日志信息要准确全面，能做到仅凭日志就可以定位问题</p>\n<p><em>解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。</em></p>\n<p><br></p>\n<h2 id=\"六、测试的日志\"><a href=\"#六、测试的日志\" class=\"headerlink\" title=\"六、测试的日志\"></a>六、测试的日志</h2><p><br></p>\n<p>测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。</p>\n<p>测试日志应该包含以下内容：</p>\n<ul>\n<li>测试执行的环境</li>\n<li>测试执行前的初始状态</li>\n<li>测试的详细步骤</li>\n<li>测试和系统的交互信息</li>\n<li>测试期望的返回结果</li>\n<li>测试实际的返回结果</li>\n</ul>\n<p><strong>Rule 6</strong>：要以同样严格的要求对待测试程序的日志</p>\n<p><br></p>\n<h2 id=\"七、从问题中完善日志\"><a href=\"#七、从问题中完善日志\" class=\"headerlink\" title=\"七、从问题中完善日志\"></a>七、从问题中完善日志</h2><p><br></p>\n<p>在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：</p>\n<ul>\n<li>如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化</li>\n<li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li>\n</ul>\n<p>通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。</p>\n<p><strong>Rule 7</strong>：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p>\n<p><br></p>\n<h2 id=\"八、对日志进行监控报警，比客户先发现系统问题\"><a href=\"#八、对日志进行监控报警，比客户先发现系统问题\" class=\"headerlink\" title=\"八、对日志进行监控报警，比客户先发现系统问题\"></a>八、对日志进行监控报警，比客户先发现系统问题</h2><p><br></p>\n<p>crash关键字报警：</p>\n<p>程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志</p>\n<p>类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。</p>\n<p><strong>Rule 8</strong>：对日志进行监控报警，比客户先发现系统问题</p>\n<p><br></p>\n<h2 id=\"九、关于日志格式\"><a href=\"#九、关于日志格式\" class=\"headerlink\" title=\"九、关于日志格式\"></a>九、关于日志格式</h2><p><br></p>\n<p>日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“Gearman timeout exception for request ” + getRequestID() + ” <span class=\"attribute\">value</span>: ” + value, e);</span><br><span class=\"line\"></span><br><span class=\"line\">第二种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(“<span class=\"attribute\">RequestID</span>: ” + getRequestID() + “, Error <span class=\"attribute\">Message</span>: Gearman timeout <span class=\"attribute\">exception</span>: ” + e);</span><br><span class=\"line\"></span><br><span class=\"line\">第三种：</span><br><span class=\"line\">logger<span class=\"selector-class\">.error</span>(getErrorMessage(getRequestID(), getErrorMessage(), e));</span><br></pre></td></tr></table></figure>\n<p>第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：</p>\n<ul>\n<li>系统中日志格式不统一，不利于自动化处理</li>\n<li>有些日志可能只有开发人员自己才能看懂</li>\n<li>代码规范性不好</li>\n</ul>\n<p>而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。</p>\n<p><strong>Rule 9</strong>：日志格式要统一规范</p>\n<p><br></p>\n<h2 id=\"十、错误日志输出到不同文件\"><a href=\"#十、错误日志输出到不同文件\" class=\"headerlink\" title=\"十、错误日志输出到不同文件\"></a>十、错误日志输出到不同文件</h2><p><br></p>\n<p>在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。</p>\n<p>这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。</p>\n<p><strong>Rule 10</strong>：将错误日志输出到一个单独的文件中进行分析</p>\n<p><br></p>\n<h2 id=\"十一、关于日志文件大小\"><a href=\"#十一、关于日志文件大小\" class=\"headerlink\" title=\"十一、关于日志文件大小\"></a>十一、关于日志文件大小</h2><p><br></p>\n<p>日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。</p>\n<p>为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：</p>\n<ul>\n<li>将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；</li>\n<li>每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志</li>\n</ul>\n<p><strong>Rule 11</strong>：要把日志的大小，如何切分，如何删除等作为规范建立起来</p>\n<!--###参考示例\n\n![示例图][1]\n\n\n1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现\n2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。\n3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。\n4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。\n5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->\n<hr>\n"},{"title":"是什么使你无法完成工作？——番茄告诉你","date":"2015-09-13T04:28:36.000Z","_content":"# 是什么让你无法完成胜任的工作呢？\n\n- 面对复杂，望而却步\n- 无聊琐事，越拖越久\n- 小事忙活一天，大事一样没办\n- 最后期限，步步紧逼\n- 从休息回到工作，心智调整不过来\n- 一错再错，不长记性\n- 没想到一件事越做越复杂\n- 头脑被各种想法占据\n- 时间都用来学习适应复杂的工作了\n- 只顾埋头工作，忘了抬头看路\n- 把预估当做承诺\n- 流程管理，纸上谈兵\n- 牵着不走，打着倒退\n- 完美主义，碍手碍脚\n- 前怕虎，后怕狼，害怕失败和评论\n\n如有以上烦恼，请看下图：\n\n### 番茄工作法\n\t\t番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n\t\t使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n\n如有以上烦恼，没事多看看 下图：\n\n\n![番茄工作法][1]\n\n\n必要的时候请使用 戴明循环（PDCA）工作法。\n\n---\n[1]: http://i3.tietuku.com/ab907523c2054c41.png","source":"_posts/是什么使你无法完成工作？——番茄告诉你.md","raw":"title: 是什么使你无法完成工作？——番茄告诉你\ndate: 2015-09-13 12:28:36\ntags: 番茄工作法\n---\n# 是什么让你无法完成胜任的工作呢？\n\n- 面对复杂，望而却步\n- 无聊琐事，越拖越久\n- 小事忙活一天，大事一样没办\n- 最后期限，步步紧逼\n- 从休息回到工作，心智调整不过来\n- 一错再错，不长记性\n- 没想到一件事越做越复杂\n- 头脑被各种想法占据\n- 时间都用来学习适应复杂的工作了\n- 只顾埋头工作，忘了抬头看路\n- 把预估当做承诺\n- 流程管理，纸上谈兵\n- 牵着不走，打着倒退\n- 完美主义，碍手碍脚\n- 前怕虎，后怕狼，害怕失败和评论\n\n如有以上烦恼，请看下图：\n\n### 番茄工作法\n\t\t番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n\t\t使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n\n如有以上烦恼，没事多看看 下图：\n\n\n![番茄工作法][1]\n\n\n必要的时候请使用 戴明循环（PDCA）工作法。\n\n---\n[1]: http://i3.tietuku.com/ab907523c2054c41.png","slug":"是什么使你无法完成工作？——番茄告诉你","published":1,"updated":"2015-09-13T04:52:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1z90015rgex6ffrxmmm","content":"<h1 id=\"是什么让你无法完成胜任的工作呢？\"><a href=\"#是什么让你无法完成胜任的工作呢？\" class=\"headerlink\" title=\"是什么让你无法完成胜任的工作呢？\"></a>是什么让你无法完成胜任的工作呢？</h1><ul>\n<li>面对复杂，望而却步</li>\n<li>无聊琐事，越拖越久</li>\n<li>小事忙活一天，大事一样没办</li>\n<li>最后期限，步步紧逼</li>\n<li>从休息回到工作，心智调整不过来</li>\n<li>一错再错，不长记性</li>\n<li>没想到一件事越做越复杂</li>\n<li>头脑被各种想法占据</li>\n<li>时间都用来学习适应复杂的工作了</li>\n<li>只顾埋头工作，忘了抬头看路</li>\n<li>把预估当做承诺</li>\n<li>流程管理，纸上谈兵</li>\n<li>牵着不走，打着倒退</li>\n<li>完美主义，碍手碍脚</li>\n<li>前怕虎，后怕狼，害怕失败和评论</li>\n</ul>\n<p>如有以上烦恼，请看下图：</p>\n<h3 id=\"番茄工作法\"><a href=\"#番茄工作法\" class=\"headerlink\" title=\"番茄工作法\"></a>番茄工作法</h3><pre><code>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n</code></pre><p>如有以上烦恼，没事多看看 下图：</p>\n<p><img src=\"http://i3.tietuku.com/ab907523c2054c41.png\" alt=\"番茄工作法\"></p>\n<p>必要的时候请使用 戴明循环（PDCA）工作法。</p>\n<hr>\n","excerpt":"","more":"<h1 id=\"是什么让你无法完成胜任的工作呢？\"><a href=\"#是什么让你无法完成胜任的工作呢？\" class=\"headerlink\" title=\"是什么让你无法完成胜任的工作呢？\"></a>是什么让你无法完成胜任的工作呢？</h1><ul>\n<li>面对复杂，望而却步</li>\n<li>无聊琐事，越拖越久</li>\n<li>小事忙活一天，大事一样没办</li>\n<li>最后期限，步步紧逼</li>\n<li>从休息回到工作，心智调整不过来</li>\n<li>一错再错，不长记性</li>\n<li>没想到一件事越做越复杂</li>\n<li>头脑被各种想法占据</li>\n<li>时间都用来学习适应复杂的工作了</li>\n<li>只顾埋头工作，忘了抬头看路</li>\n<li>把预估当做承诺</li>\n<li>流程管理，纸上谈兵</li>\n<li>牵着不走，打着倒退</li>\n<li>完美主义，碍手碍脚</li>\n<li>前怕虎，后怕狼，害怕失败和评论</li>\n</ul>\n<p>如有以上烦恼，请看下图：</p>\n<h3 id=\"番茄工作法\"><a href=\"#番茄工作法\" class=\"headerlink\" title=\"番茄工作法\"></a>番茄工作法</h3><pre><code>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。\n使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿\n</code></pre><p>如有以上烦恼，没事多看看 下图：</p>\n<p><img src=\"http://i3.tietuku.com/ab907523c2054c41.png\" alt=\"番茄工作法\"></p>\n<p>必要的时候请使用 戴明循环（PDCA）工作法。</p>\n<hr>\n"},{"title":"比较好的Android网站","date":"2015-09-26T06:53:07.000Z","keywords":"干货","_content":"\n\n\n这是分享一些比较靠谱的干货，可以参考下面的链接：<br>\n\n\n\n- [12大Android开发资源，你有几种会用？][1]\n\n- [快速提高Android开发效率的Web工具][2]\n\n- [Android酷炫实用的开源框架（UI框架）][3]\n\n- [Android开发六个建议（经验之谈）][4]\n\n- [Android Studio常用插件] [5]\n\n- [Android App 性能优化实践] [6]\n\n- [Android Support 库百分比布局] [7]\n\n- [Android 项目部署之Nexus私服搭建和应用][8]\n\n- [移动应用 Bug 快速反馈利器][9] \n\n\n\n后续将整理一些比较又实用价值的文章分享给大家\n\n---\n[1]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=1&sn=4102a3f1d369ba79abeb85e77e4c380d&scene=1&srcid=0926h7Wvn1gzNIiKmoZAutR7&key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[2]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=2&sn=e6bf1c5afb0e09147484a61c68583b3e&scene=1&srcid=0926n9p8bsx5NQNAg274lTGy&key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207916695&idx=4&sn=69a69ba7986eeb9fda0054354db828a4&scene=1&srcid=0926JcG6UjZuN7LEu7giAoR9&key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[4]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207581833&idx=3&sn=97bfca775b657f19f990a80fa401392e&scene=1&srcid=09265F2U0UdTJJXCpg11k4ll&key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[5]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208540095&idx=1&sn=8a4c7e4d5d9a64839992462f27b4bb95&scene=1&srcid=09266oDuhW22HgxDuGmM0WYC&key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[6]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208525243&idx=1&sn=8afc00211b37af68f1995a3e8ad45111&scene=1&srcid=0926NrC0khf5Fa9fJEwRfRPY&key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n\n[7]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208510253&idx=2&sn=28598cc02ad39b73ca615e886c8eb24c&scene=1&srcid=0926DwVYFw4g4Od2AAnu6iHa&key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[8]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208554056&idx=1&sn=b98bfef690e316fa5dc0fccef8dae198&scene=1&srcid=0926PFrnACpa0rgVOJL2BLlc&key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[9]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n","source":"_posts/比较好的Android网站.md","raw":"title: 比较好的Android网站\ndate: 2015-09-26 14:53:07\ncategories:\nkeywords: 干货\ntags: 干货\n---\n\n\n\n这是分享一些比较靠谱的干货，可以参考下面的链接：<br>\n\n\n\n- [12大Android开发资源，你有几种会用？][1]\n\n- [快速提高Android开发效率的Web工具][2]\n\n- [Android酷炫实用的开源框架（UI框架）][3]\n\n- [Android开发六个建议（经验之谈）][4]\n\n- [Android Studio常用插件] [5]\n\n- [Android App 性能优化实践] [6]\n\n- [Android Support 库百分比布局] [7]\n\n- [Android 项目部署之Nexus私服搭建和应用][8]\n\n- [移动应用 Bug 快速反馈利器][9] \n\n\n\n后续将整理一些比较又实用价值的文章分享给大家\n\n---\n[1]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=1&sn=4102a3f1d369ba79abeb85e77e4c380d&scene=1&srcid=0926h7Wvn1gzNIiKmoZAutR7&key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[2]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=208024947&idx=2&sn=e6bf1c5afb0e09147484a61c68583b3e&scene=1&srcid=0926n9p8bsx5NQNAg274lTGy&key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[3]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207916695&idx=4&sn=69a69ba7986eeb9fda0054354db828a4&scene=1&srcid=0926JcG6UjZuN7LEu7giAoR9&key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[4]: http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&mid=207581833&idx=3&sn=97bfca775b657f19f990a80fa401392e&scene=1&srcid=09265F2U0UdTJJXCpg11k4ll&key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[5]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208540095&idx=1&sn=8a4c7e4d5d9a64839992462f27b4bb95&scene=1&srcid=09266oDuhW22HgxDuGmM0WYC&key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[6]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208525243&idx=1&sn=8afc00211b37af68f1995a3e8ad45111&scene=1&srcid=0926NrC0khf5Fa9fJEwRfRPY&key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n\n[7]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208510253&idx=2&sn=28598cc02ad39b73ca615e886c8eb24c&scene=1&srcid=0926DwVYFw4g4Od2AAnu6iHa&key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[8]: http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&mid=208554056&idx=1&sn=b98bfef690e316fa5dc0fccef8dae198&scene=1&srcid=0926PFrnACpa0rgVOJL2BLlc&key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n[9]: http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&mid=207368806&idx=1&sn=ab1203e49d15b5a81a30d3c199fdc80d&scene=1&srcid=0926RMXXJe3DfggnLTgzVz8M&key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&ascene=0&uin=MTA5NTgyNjA0MA%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&version=11020012&pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\n\n","slug":"比较好的Android网站","published":1,"updated":"2015-09-26T06:55:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1za0017rgex6x4lw3hv","content":"<p>这是分享一些比较靠谱的干货，可以参考下面的链接：<br></p>\n<ul>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=1&amp;sn=4102a3f1d369ba79abeb85e77e4c380d&amp;scene=1&amp;srcid=0926h7Wvn1gzNIiKmoZAutR7&amp;key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">12大Android开发资源，你有几种会用？</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=2&amp;sn=e6bf1c5afb0e09147484a61c68583b3e&amp;scene=1&amp;srcid=0926n9p8bsx5NQNAg274lTGy&amp;key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">快速提高Android开发效率的Web工具</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207916695&amp;idx=4&amp;sn=69a69ba7986eeb9fda0054354db828a4&amp;scene=1&amp;srcid=0926JcG6UjZuN7LEu7giAoR9&amp;key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android酷炫实用的开源框架（UI框架）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207581833&amp;idx=3&amp;sn=97bfca775b657f19f990a80fa401392e&amp;scene=1&amp;srcid=09265F2U0UdTJJXCpg11k4ll&amp;key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android开发六个建议（经验之谈）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208540095&amp;idx=1&amp;sn=8a4c7e4d5d9a64839992462f27b4bb95&amp;scene=1&amp;srcid=09266oDuhW22HgxDuGmM0WYC&amp;key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android Studio常用插件</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208525243&amp;idx=1&amp;sn=8afc00211b37af68f1995a3e8ad45111&amp;scene=1&amp;srcid=0926NrC0khf5Fa9fJEwRfRPY&amp;key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android App 性能优化实践</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208510253&amp;idx=2&amp;sn=28598cc02ad39b73ca615e886c8eb24c&amp;scene=1&amp;srcid=0926DwVYFw4g4Od2AAnu6iHa&amp;key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android Support 库百分比布局</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208554056&amp;idx=1&amp;sn=b98bfef690e316fa5dc0fccef8dae198&amp;scene=1&amp;srcid=0926PFrnACpa0rgVOJL2BLlc&amp;key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">Android 项目部署之Nexus私服搭建和应用</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\" target=\"_blank\" rel=\"external\">移动应用 Bug 快速反馈利器</a> </p>\n</li>\n</ul>\n<p>后续将整理一些比较又实用价值的文章分享给大家</p>\n<hr>\n","excerpt":"","more":"<p>这是分享一些比较靠谱的干货，可以参考下面的链接：<br></p>\n<ul>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=1&amp;sn=4102a3f1d369ba79abeb85e77e4c380d&amp;scene=1&amp;srcid=0926h7Wvn1gzNIiKmoZAutR7&amp;key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">12大Android开发资源，你有几种会用？</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=2&amp;sn=e6bf1c5afb0e09147484a61c68583b3e&amp;scene=1&amp;srcid=0926n9p8bsx5NQNAg274lTGy&amp;key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">快速提高Android开发效率的Web工具</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207916695&amp;idx=4&amp;sn=69a69ba7986eeb9fda0054354db828a4&amp;scene=1&amp;srcid=0926JcG6UjZuN7LEu7giAoR9&amp;key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android酷炫实用的开源框架（UI框架）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207581833&amp;idx=3&amp;sn=97bfca775b657f19f990a80fa401392e&amp;scene=1&amp;srcid=09265F2U0UdTJJXCpg11k4ll&amp;key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android开发六个建议（经验之谈）</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208540095&amp;idx=1&amp;sn=8a4c7e4d5d9a64839992462f27b4bb95&amp;scene=1&amp;srcid=09266oDuhW22HgxDuGmM0WYC&amp;key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android Studio常用插件</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208525243&amp;idx=1&amp;sn=8afc00211b37af68f1995a3e8ad45111&amp;scene=1&amp;srcid=0926NrC0khf5Fa9fJEwRfRPY&amp;key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android App 性能优化实践</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208510253&amp;idx=2&amp;sn=28598cc02ad39b73ca615e886c8eb24c&amp;scene=1&amp;srcid=0926DwVYFw4g4Od2AAnu6iHa&amp;key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android Support 库百分比布局</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208554056&amp;idx=1&amp;sn=b98bfef690e316fa5dc0fccef8dae198&amp;scene=1&amp;srcid=0926PFrnACpa0rgVOJL2BLlc&amp;key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">Android 项目部署之Nexus私服搭建和应用</a></p>\n</li>\n<li><p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir\">移动应用 Bug 快速反馈利器</a> </p>\n</li>\n</ul>\n<p>后续将整理一些比较又实用价值的文章分享给大家</p>\n<hr>\n"},{"title":"程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析","date":"2015-11-12T04:01:59.000Z","keywords":"android崩溃异常","_content":"\n### 程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\n<br>\n\n遇到该问题，程序会直接崩溃\n\n1.具体问题：\n\n\tjava.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\n\tat android.widget.ListView.layoutChildren(ListView.java:1562)\n\tat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\n\tat android.os.Handler.handleCallback(Handler.java:739)\n\tat android.os.Handler.dispatchMessage(Handler.java:95)\n\tat android.os.Looper.loop(Looper.java:135)\n\tat android.app.ActivityThread.main(ActivityThread.java:5254)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat java.lang.reflect.Method.invoke(Method.java:372)\n\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\n\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n\n2.出现的过程：\n\n程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。\n\n具体源码是：\n\twhile (mDataList != null && mDataList.size() > MAX_MESSAGE_NUM) {\n\t                        mDataList.remove(0);\n\t                    }\n\t                    MessageBean data = (MessageBean) msg.obj;\n\t                    if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {\n\t                        messageBeanList.add(data);\n\t                    }\n\t\n\t                    //调整 在线人数很多，发消息很频繁的bug.\n\t                    isOnlinePeopleLock = true;\n\t                    if (isOnlinePeopleLock) {\n\t                        mHandler.postDelayed(new Runnable() {\n\t                            @Override\n\t                            public void run() {\n\t                                mDataList.addAll(messageBeanList);\n\t                                messageBeanList.clear();\n\t                                isOnlinePeopleLock = false;\n\t                                listViewSelectEnd(mListView, isTouchListView);\n\t                            }\n\t                        }, ONE_SECOND);\n\t                    }\n\n当人数很多的时候会偶然出现：\n\tjava.lang.IllegalStateException\n\n3.分析问题:\n\n**Exception解读：**\n**        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。**\n\n<br>\n从Android源码上看看：\n\n\t// Handle the empty set by removing all views that are visible\n\t// and calling it a day\n\tif (mItemCount == 0) {\n\t    resetList();\n\t    invokeOnItemScrollListener();\n\t    return;\n\t} else if (mItemCount != mAdapter.getCount()) {\n\t    throw new IllegalStateException(\"The content of the adapter has changed but \"\n\t            + \"ListView did not receive a notification. Make sure the content of \"\n\t            + \"your adapter is not modified from a background thread, but only \"\n\t            + \"from the UI thread. [in ListView(\" + getId() + \", \" + getClass()\n\t            + \") with Adapter(\" + mAdapter.getClass() + \")]\");\n\t}\n\n#### **当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。**\n\n<br>\n可以分析出来的是：\n\n当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。\n\n4.解决办法：\n\n**把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。**\n\n5.注意事项：\n\n为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：\n\n- 确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView\n- 数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步\n- 仔细检查确认getCount()方法返回值是否正确\n\n参考：\n[http://www.cnblogs.com/monodin/p/3874147.html](http://www.cnblogs.com/monodin/p/3874147.html)","source":"_posts/程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析.md","raw":"title: 程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\ndate: 2015-11-12 12:01:59\ncategories:\nkeywords: android崩溃异常\ntags: android\n---\n\n### 程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\n<br>\n\n遇到该问题，程序会直接崩溃\n\n1.具体问题：\n\n\tjava.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\n\tat android.widget.ListView.layoutChildren(ListView.java:1562)\n\tat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\n\tat android.os.Handler.handleCallback(Handler.java:739)\n\tat android.os.Handler.dispatchMessage(Handler.java:95)\n\tat android.os.Looper.loop(Looper.java:135)\n\tat android.app.ActivityThread.main(ActivityThread.java:5254)\n\tat java.lang.reflect.Method.invoke(Native Method)\n\tat java.lang.reflect.Method.invoke(Method.java:372)\n\tat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\n\tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n\n2.出现的过程：\n\n程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。\n\n具体源码是：\n\twhile (mDataList != null && mDataList.size() > MAX_MESSAGE_NUM) {\n\t                        mDataList.remove(0);\n\t                    }\n\t                    MessageBean data = (MessageBean) msg.obj;\n\t                    if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {\n\t                        messageBeanList.add(data);\n\t                    }\n\t\n\t                    //调整 在线人数很多，发消息很频繁的bug.\n\t                    isOnlinePeopleLock = true;\n\t                    if (isOnlinePeopleLock) {\n\t                        mHandler.postDelayed(new Runnable() {\n\t                            @Override\n\t                            public void run() {\n\t                                mDataList.addAll(messageBeanList);\n\t                                messageBeanList.clear();\n\t                                isOnlinePeopleLock = false;\n\t                                listViewSelectEnd(mListView, isTouchListView);\n\t                            }\n\t                        }, ONE_SECOND);\n\t                    }\n\n当人数很多的时候会偶然出现：\n\tjava.lang.IllegalStateException\n\n3.分析问题:\n\n**Exception解读：**\n**        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。**\n\n<br>\n从Android源码上看看：\n\n\t// Handle the empty set by removing all views that are visible\n\t// and calling it a day\n\tif (mItemCount == 0) {\n\t    resetList();\n\t    invokeOnItemScrollListener();\n\t    return;\n\t} else if (mItemCount != mAdapter.getCount()) {\n\t    throw new IllegalStateException(\"The content of the adapter has changed but \"\n\t            + \"ListView did not receive a notification. Make sure the content of \"\n\t            + \"your adapter is not modified from a background thread, but only \"\n\t            + \"from the UI thread. [in ListView(\" + getId() + \", \" + getClass()\n\t            + \") with Adapter(\" + mAdapter.getClass() + \")]\");\n\t}\n\n#### **当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。**\n\n<br>\n可以分析出来的是：\n\n当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。\n\n4.解决办法：\n\n**把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。**\n\n5.注意事项：\n\n为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：\n\n- 确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView\n- 数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步\n- 仔细检查确认getCount()方法返回值是否正确\n\n参考：\n[http://www.cnblogs.com/monodin/p/3874147.html](http://www.cnblogs.com/monodin/p/3874147.html)","slug":"程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析","published":1,"updated":"2015-11-12T04:04:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cin6yr1zb0019rgexbuwf2ywa","content":"<h3 id=\"程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\"><a href=\"#程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\" class=\"headerlink\" title=\"程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\"></a>程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析</h3><p><br></p>\n<p>遇到该问题，程序会直接崩溃</p>\n<p>1.具体问题：</p>\n<pre><code>java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\nat android.widget.ListView.layoutChildren(ListView.java:1562)\nat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\nat android.os.Handler.handleCallback(Handler.java:739)\nat android.os.Handler.dispatchMessage(Handler.java:95)\nat android.os.Looper.loop(Looper.java:135)\nat android.app.ActivityThread.main(ActivityThread.java:5254)\nat java.lang.reflect.Method.invoke(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:372)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n</code></pre><p>2.出现的过程：</p>\n<p>程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。</p>\n<p>具体源码是：<br>    while (mDataList != null &amp;&amp; mDataList.size() &gt; MAX_MESSAGE_NUM) {<br>                            mDataList.remove(0);<br>                        }<br>                        MessageBean data = (MessageBean) msg.obj;<br>                        if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {<br>                            messageBeanList.add(data);<br>                        }</p>\n<pre><code>//调整 在线人数很多，发消息很频繁的bug.\nisOnlinePeopleLock = true;\nif (isOnlinePeopleLock) {\n    mHandler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            mDataList.addAll(messageBeanList);\n            messageBeanList.clear();\n            isOnlinePeopleLock = false;\n            listViewSelectEnd(mListView, isTouchListView);\n        }\n    }, ONE_SECOND);\n}\n</code></pre><p>当人数很多的时候会偶然出现：<br>    java.lang.IllegalStateException</p>\n<p>3.分析问题:</p>\n<p><strong>Exception解读：</strong><br><strong>        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。</strong></p>\n<p><br><br>从Android源码上看看：</p>\n<pre><code>// Handle the empty set by removing all views that are visible\n// and calling it a day\nif (mItemCount == 0) {\n    resetList();\n    invokeOnItemScrollListener();\n    return;\n} else if (mItemCount != mAdapter.getCount()) {\n    throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;\n            + &quot;ListView did not receive a notification. Make sure the content of &quot;\n            + &quot;your adapter is not modified from a background thread, but only &quot;\n            + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()\n            + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);\n}\n</code></pre><h4 id=\"当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\"><a href=\"#当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\" class=\"headerlink\" title=\"当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。\"></a><strong>当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。</strong></h4><p><br><br>可以分析出来的是：</p>\n<p>当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。</p>\n<p>4.解决办法：</p>\n<p><strong>把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。</strong></p>\n<p>5.注意事项：</p>\n<p>为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：</p>\n<ul>\n<li>确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView</li>\n<li>数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步</li>\n<li>仔细检查确认getCount()方法返回值是否正确</li>\n</ul>\n<p>参考：<br><a href=\"http://www.cnblogs.com/monodin/p/3874147.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/monodin/p/3874147.html</a></p>\n","excerpt":"","more":"<h3 id=\"程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\"><a href=\"#程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析\" class=\"headerlink\" title=\"程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析\"></a>程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析</h3><p><br></p>\n<p>遇到该问题，程序会直接崩溃</p>\n<p>1.具体问题：</p>\n<pre><code>java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]\nat android.widget.ListView.layoutChildren(ListView.java:1562)\nat android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)\nat android.os.Handler.handleCallback(Handler.java:739)\nat android.os.Handler.dispatchMessage(Handler.java:95)\nat android.os.Looper.loop(Looper.java:135)\nat android.app.ActivityThread.main(ActivityThread.java:5254)\nat java.lang.reflect.Method.invoke(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:372)\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)\n</code></pre><p>2.出现的过程：</p>\n<p>程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。</p>\n<p>具体源码是：<br>    while (mDataList != null &amp;&amp; mDataList.size() &gt; MAX_MESSAGE_NUM) {<br>                            mDataList.remove(0);<br>                        }<br>                        MessageBean data = (MessageBean) msg.obj;<br>                        if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {<br>                            messageBeanList.add(data);<br>                        }</p>\n<pre><code>//调整 在线人数很多，发消息很频繁的bug.\nisOnlinePeopleLock = true;\nif (isOnlinePeopleLock) {\n    mHandler.postDelayed(new Runnable() {\n        @Override\n        public void run() {\n            mDataList.addAll(messageBeanList);\n            messageBeanList.clear();\n            isOnlinePeopleLock = false;\n            listViewSelectEnd(mListView, isTouchListView);\n        }\n    }, ONE_SECOND);\n}\n</code></pre><p>当人数很多的时候会偶然出现：<br>    java.lang.IllegalStateException</p>\n<p>3.分析问题:</p>\n<p><strong>Exception解读：</strong><br><strong>        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。</strong></p>\n<p><br><br>从Android源码上看看：</p>\n<pre><code>// Handle the empty set by removing all views that are visible\n// and calling it a day\nif (mItemCount == 0) {\n    resetList();\n    invokeOnItemScrollListener();\n    return;\n} else if (mItemCount != mAdapter.getCount()) {\n    throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;\n            + &quot;ListView did not receive a notification. Make sure the content of &quot;\n            + &quot;your adapter is not modified from a background thread, but only &quot;\n            + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()\n            + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);\n}\n</code></pre><h4 id=\"当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\"><a href=\"#当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。\" class=\"headerlink\" title=\"当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。\"></a><strong>当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。</strong></h4><p><br><br>可以分析出来的是：</p>\n<p>当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。</p>\n<p>4.解决办法：</p>\n<p><strong>把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。</strong></p>\n<p>5.注意事项：</p>\n<p>为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：</p>\n<ul>\n<li>确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView</li>\n<li>数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步</li>\n<li>仔细检查确认getCount()方法返回值是否正确</li>\n</ul>\n<p>参考：<br><a href=\"http://www.cnblogs.com/monodin/p/3874147.html\">http://www.cnblogs.com/monodin/p/3874147.html</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cin6yr1yt000orgexihwq4b4p","category_id":"cin6yr1yx000srgexbtifw7yk","_id":"cin6yr1z80012rgexdd73nq7h"}],"PostTag":[{"post_id":"cin6yr1xo0002rgexqx5iwk57","tag_id":"cin6yr1xx0005rgex8lq323yz","_id":"cin6yr1yb000argex7fxqm52u"},{"post_id":"cin6yr1y80009rgexkhas901n","tag_id":"cin6yr1xx0005rgex8lq323yz","_id":"cin6yr1yg000crgexvjrxrd2f"},{"post_id":"cin6yr1xu0004rgexwt6wp622","tag_id":"cin6yr1y70008rgexf8jpd9w5","_id":"cin6yr1yk000frgextu19tptx"},{"post_id":"cin6yr1y40007rgexyv2mqfuw","tag_id":"cin6yr1yk000ergex29ay0ahr","_id":"cin6yr1yq000krgexr9d2un2w"},{"post_id":"cin6yr1ym000hrgexjk358zay","tag_id":"cin6yr1xx0005rgex8lq323yz","_id":"cin6yr1ys000mrgexu6lanj5h"},{"post_id":"cin6yr1yp000jrgex2hoosygo","tag_id":"cin6yr1xx0005rgex8lq323yz","_id":"cin6yr1yu000prgex5fpkkwdl"},{"post_id":"cin6yr1yc000brgexvptu38n8","tag_id":"cin6yr1yn000irgexqtwhk2wj","_id":"cin6yr1yx000rrgex9270tetb"},{"post_id":"cin6yr1yt000orgexihwq4b4p","tag_id":"cin6yr1xx0005rgex8lq323yz","_id":"cin6yr1z2000vrgexfpktbi33"},{"post_id":"cin6yr1yh000drgexbfnl0tws","tag_id":"cin6yr1ys000nrgexnce4iaay","_id":"cin6yr1z5000xrgex2d33nvaj"},{"post_id":"cin6yr1yk000grgexq5s52oxn","tag_id":"cin6yr1yy000trgexaj1re6le","_id":"cin6yr1z60010rgexwgg8kesh"},{"post_id":"cin6yr1yw000qrgex3qa873hp","tag_id":"cin6yr1z6000zrgex47tm8hzu","_id":"cin6yr1za0016rgex3jhwxgt4"},{"post_id":"cin6yr1yy000urgexasat0dh8","tag_id":"cin6yr1z90014rgexz4smwyvu","_id":"cin6yr1zc001argex3bsoeejr"},{"post_id":"cin6yr1zb0019rgexbuwf2ywa","tag_id":"cin6yr1xx0005rgex8lq323yz","_id":"cin6yr1zc001brgexua6wpb74"},{"post_id":"cin6yr1z60011rgexgg4xybkv","tag_id":"cin6yr1zb0018rgexcqp9k5y9","_id":"cin6yr1zd001drgexhhh2bo5h"},{"post_id":"cin6yr1z80013rgexqiaj6dxn","tag_id":"cin6yr1zc001crgexqzrge42t","_id":"cin6yr1ze001frgex6z2brvw5"},{"post_id":"cin6yr1z90015rgex6ffrxmmm","tag_id":"cin6yr1zd001ergex8wppn7p6","_id":"cin6yr1zf001hrgexudokej9b"},{"post_id":"cin6yr1za0017rgex6x4lw3hv","tag_id":"cin6yr1ze001grgex1g4rf2rc","_id":"cin6yr1zf001irgexstn0pydn"}],"Tag":[{"name":"android","_id":"cin6yr1xx0005rgex8lq323yz"},{"name":"android gradle工作原理","_id":"cin6yr1y70008rgexf8jpd9w5"},{"name":"AndroidStudio","_id":"cin6yr1yk000ergex29ay0ahr"},{"name":"技能提升","_id":"cin6yr1yn000irgexqtwhk2wj"},{"name":"ios","_id":"cin6yr1ys000nrgexnce4iaay"},{"name":"android录音","_id":"cin6yr1yy000trgexaj1re6le"},{"name":"算法","_id":"cin6yr1z6000zrgex47tm8hzu"},{"name":"groovy","_id":"cin6yr1z90014rgexz4smwyvu"},{"name":"Android","_id":"cin6yr1zb0018rgexcqp9k5y9"},{"name":"Android日志规范","_id":"cin6yr1zc001crgexqzrge42t"},{"name":"番茄工作法","_id":"cin6yr1zd001ergex8wppn7p6"},{"name":"干货","_id":"cin6yr1ze001grgex1g4rf2rc"}]}}