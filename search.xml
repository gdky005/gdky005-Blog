<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[从 volley 切换到 OkHttp 遇到的坑]]></title>
      <url>http://gdky005.com/2016/06/20/%E4%BB%8E-volley-%E5%88%87%E6%8D%A2%E5%88%B0-OkHttp-%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>这几天打算把项目的 volley 切换到 okhttp,遇到了一些小问题，现在予以整理。</p>
<p>之前考虑直接将 volley 切换到 okhttp, 底层肯定使用 okhttp, 请求队列也使用 okhttp。但是考虑到代价可能比较大，所以我是基于网上给的解决方案： 上层队列依然使用 volley,但是对于底层发送请求的地方，可以直接切换到 okhttp.</p>
<h3 id="代理异常？"><a href="#代理异常？" class="headerlink" title="代理异常？"></a>代理异常？</h3><p>切换成功后，遇到的第一个问题就是：代理功能没法使用，我们客户端 是有联通流量包的功能的，因此必须要加 代理功能。</p>
<p>根据 okhttp 里面  issue 的回答，弄好多次都不行，折腾了一两天左右。 最后也懒得管了，先放放，优先解决其他问题。 </p>
<p>之后过了几天，再回来弄这块的时候，就突然好了，兴奋坏了。赶紧查查和之前的有没有什么差异？</p>
<p>经过对比后发现：原来是 之前写 volley 的时候是这样的：</p>
<pre><code>HttpURLConnection connection;
    if (&quot;https&quot;.equals(url.getProtocol())) {
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                InetSocketAddress
                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGETCPPORT));
        connection = (HttpURLConnection) url
                .openConnection(proxy);
        connection.addRequestProperty(&quot;Proxy-Authorization&quot;,
                &quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;);
    } else {
        Proxy proxy = new Proxy(Proxy.Type.HTTP,
                InetSocketAddress
                        .createUnresolved(FLOWPACKAGEHOST, FLOWPACKAGEPORT));
        connection = (HttpURLConnection) url
                .openConnection(proxy);
        connection.addRequestProperty(&quot;Authorization&quot;,
                &quot;Basic MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;);
    }
    connection.addRequestProperty(&quot;Proxy-Connection&quot;, &quot;Keep-Alive&quot;);
</code></pre><p>主要区分了 https 和 http, 然后里面传入的 key 和 端口号都不一样。</p>
<p>但是在 okhttp 里面貌似是不需要区分的。只需要这样写：</p>
<pre><code>/**
     * 设置联通流量 代理功能
     * @param builder
     */
    private void setUnicomProxy(OkHttpClient.Builder builder) {
        //添加联通代理功能
        if (TrafficUtil.getUnicomProxyAvailable()) {
            Authenticator proxyAuthenticator = new Authenticator() {
                @Override
                public okhttp3.Request authenticate(Route route, Response response) throws IOException {
                    return response.request().newBuilder().header(&quot;Proxy-Authorization&quot;, &quot;Basic &quot; +
                            &quot;MzAwMDAwNDU4NDo0Mjk5NjREMEI1Q0QyODc6&quot;).header(&quot;Proxy-Connection&quot;,
                            &quot;Keep-Alive&quot;).build();
                }
            };

            builder.proxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(FLOWPACKAGEHOST,
                    FLOWPACKAGETCPPORT)));
            builder.proxyAuthenticator(proxyAuthenticator);
        }
    }
</code></pre><p>就可以了。<br><code>FLOWPACKAGEHOST -&gt; test.proxy.1111.com (这是域名)</code><br><code>FLOWPACKAGETCPPORT -&gt; 8143</code><br>这还是真是一个偶然的机会，歪打正着，否则估计得排除好久。</p>
<p><code>备注： 上面 key 我随意修改了几个字符，看看就行，想要直接使用肯定不行的， 哈哈</code></p>
<h3 id="SSL-STL证书-出错？"><a href="#SSL-STL证书-出错？" class="headerlink" title="SSL/STL证书 出错？"></a>SSL/STL证书 出错？</h3><p>这是第二个遇到的问题，证书一直没法用，一使用 https 的接口就失败。最后解决办法是：<br>     @NonNull<br>        private SSLContext getSslContext(InputStream… certificates) {<br>            SSLContext sslContext = null;</p>
<pre><code>        try {
            CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;);
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null);
            int index = 0;
            for (InputStream certificate : certificates) {
                String certificateAlias = Integer.toString(index++);
                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate
                        (certificate));
                try {
                    if (certificate != null)
                        certificate.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

            sslContext = SSLContext.getInstance(&quot;TLS&quot;);

            TrustManagerFactory trustManagerFactory =
                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

            trustManagerFactory.init(keyStore);
            sslContext.init(null, trustManagerFactory.getTrustManagers(),
                    new SecureRandom());

        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (KeyManagementException e) {
            e.printStackTrace();
        } catch (Exception e){
            e.printStackTrace();
        }   finally {
        }

        return sslContext;
    }

/**
     * 启用 OkHttps 域名校验功能
     * @param builder
     */
    private void setOkhttpSSLContext(OkHttpClient.Builder builder) {
        SSLContext sslContext = getSslContext(KaolaApplication.mContext.getResources().openRawResource(R
                .raw.kl_magic));

        if (sslContext != null) {
            builder.hostnameVerifier(new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    HostnameVerifier hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
                    return hostnameVerifier.verify(&quot;xxx.com&quot;, session); //启用xxx 域名校验 (这里是一个非常重要的地方，缺少了这一步肯定不行)
                }
            });
            builder.sslSocketFactory(sslContext.getSocketFactory());
        }
    }
</code></pre><p>这句是非常重要的：<br><code>hostnameVerifier.verify(&quot;xxx.com&quot;, session);</code>主要是进行 https 的域名校验，用证书匹配你的域名，如果匹配成功，那么就可以直接使用，否则 https 握手失败，无法正确发送请求。</p>
<p>之前尝试过使用 使用<br>    builder.hostnameVerifier(new AllowAllHostnameVerifier());</p>
<p>这样可以忽略证书，默认都允许，也能正常使用，但是 存在安全隐患。</p>
<h3 id="post-参数不能为空？"><a href="#post-参数不能为空？" class="headerlink" title="post 参数不能为空？"></a>post 参数不能为空？</h3><p>这个问题遇到的比较奇葩，原因是，我们的 https  的接口使用了 post 请求，但是 post 里面没有参数，通用参数都放在 url 后面追加了，这就造成 这个 request 没有 body( body 就是对 post 请求的参数 处理下).</p>
<p>但是 okhttp 对于参数为空的请求，直接返回 null, 所以对于这种不规范的 接口定义就报错了。在 <a href="https://github.com/square/okhttp/issues/751" target="_blank" rel="external">okhttp issue</a> 里面也有关于这个的讨论，说明这个不符合 http 的标准，所以不能发出请求。解决办法是添加一个空的 参数就可以，但是绝不能 “”:””, 里面必须有值，因此我这边和服务器约定了一下，用 temp 代替，服务器也肯定不会用这个字段取数据。</p>
<p>具体参考这个：</p>
<pre><code>public void addRequest(int method, final Map&lt;String, String&gt; params, final String baseUrl,
                           final TypeReference&lt;? extends BaseResponse&gt; type, final JsonResultCallback callback) {
            ......
          if (params.size() == 0 &amp;&amp; method == Request.Method.POST)
            params.put(&quot;temp&quot;, &quot;temp&quot;); //解决 method POST must have a request body.;
            ......
}
</code></pre><p>这三个问题解决后，基本就可以放心使用了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分享Java Collection 的一张图]]></title>
      <url>http://gdky005.com/2016/06/20/Java-Collection-Cheat-Sheet/</url>
      <content type="html"><![CDATA[<p>在这张图中展示了 Collection 相关一些常用类，例如最常见的 Map（Interface）, Collection(Interface), List(Interface) 等等</p>
<p>我们可以看出他们之间的关系以及差别。</p>
<p>例如：HashMap, HastTable,  Vector 和 LinkedList等</p>
<p><img src="http://7xlcno.com1.z0.glb.clouddn.com/java_array_big_img.png" alt="Java Collection Cheat Sheet"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Okio 简单处理I/O操作]]></title>
      <url>http://gdky005.com/2016/06/20/Okio-%E7%AE%80%E5%8D%95%E5%A4%84%E7%90%86I-O%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>Android 善用Okio简化处理I/O操作<br>Okio库是一个由square公司开发的，它补充了java.io和java.nio的不足，以便能够更加方便，快速的访问、存储和处理你的数据。而OkHttp的底层也使用该库作为支持。而在开发中，使用该库可以大大给你带来方便。</p>
<pre><code>compile &apos;com.squareup.okio:okio:1.6.0&apos;
</code></pre><p>Ohio 有两个关键接口， Sink 和 Source, 这两个接口都继承了 Colseable 接口；而 Sink 可以简单的看成 OutputStream, Source 可以简单的看做 InputStream. 而这两个接口凑是支持读写超时设置的。<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/okio_01.png" alt=""></p>
<p>它们各自有一个支持缓冲区的子类接口，BufferedSink 和 BufferedSource,而 BufferedSink有一个实现类 RealBufferedSink， BufferedSource有一个实现类 RealBufferedSource；此外 Sink 和 Source 有一个支持 gzip 的实现类 GzipSink和GzipSource；一个具有委托功能的抽象类ForwardingSink 和 ForwardingSource; 还有一个实现类便是 InflaterSource 和 DeflaterSink, 这两个类主要用于压缩，为 GzipSink 和 GzipSource 服务；<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/okio_02.png" alt=""></p>
<p>BufferedSink中定义了一系列写入缓存区的方法，比如write方法写byte数组，writeUtf8写字符串，还有一些列的writeByte，writeString，writeShort，writeInt，writeLong，writeDecimalLong等等方法；BufferedSource定义的方法和BufferedSink极为相似，只不过一个是写一个是读，基本上都是一一对应的，如readUtf8，readByte，readString，readShort，readInt等等等等。这两个接口中的方法有兴趣的点源码进去看就可以了。</p>
<p>而这两个支持缓冲区的接口的实现类 RealBufferedSink 和 RealBufferedSource 都是通过包装一个 Sink + Buffer 或者 Source + Buffer 进行实现的。<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/okio_03.png" alt=""></p>
<p>用 RealBufferedSink 来说，实际调用的 write 的一系列方法，都是直接对成员变量 buffer 进行的操作，当写入 buffer 成功后，最后调用一个方法将 buffer 中的内容写入到 sink 中，举例：</p>
<pre><code>public BufferedSink writeLong(long v) throws IOException {
    if (this.closed) {
        throw new IllegalStateException(&quot;closed&quot;);
    } else {
        this.buffer.writeLong(v);
        return this.emitCompleteSegments();
    }
}
</code></pre><p>可以看到，首先会判断closed成员变量是否是标记着关闭，如果已经关闭了则扔出一个异常，否则将内容写入到buffer，写入完成后调用了一个emitCompleteSegments的方法，该方法中做了什么呢,没错，就是将buffer中的内容写入到sink成员变量中去，然后将自身返回。</p>
<pre><code>public BufferedSink emitCompleteSegments() throws IOException {
        if(this.closed) {
            throw new IllegalStateException(&quot;closed&quot;);
        } else {
            long byteCount = this.buffer.completeSegmentByteCount();
            if(byteCount &gt; 0L) {
                this.sink.write(this.buffer, byteCount);
            }
            return this;
        }
    }
</code></pre><p>这两个实现类的内部的所有方法都是类似的，这里不一一展开。<br>而这一切的背后都有一个叫做 Buffer 的类在支持着缓冲区， Buffer 是 BufferedSink 和 BufferedSource 的实现类，因此它即可以用来读数据，也可以用来写数据，其内部使用了一个 Segment 和 SegmentPool, 维持着一个链表，其循环利用的机制 和 Android 中的 Message 的利用机制是一模一样的。</p>
<pre><code>final class SegmentPool {
    static final long MAX_SIZE = 65536L;
    static Segment next;
    static long byteCount;

    private SegmentPool() {
    }

    static Segment take() {
        Class var0 = SegmentPool.class;

        synchronized(SegmentPool.class) {
            if(next != null) {
                Segment result = next;
                next = result.next;
                result.next = null;
                byteCount -= 2048L;
                return result;
            }
        }
        return new Segment();
    }

    static void recycle(Segment segment) {
        if(segment.next == null &amp;&amp; segment.prev == null) {
            if(!segment.shared) {
                Class var1 = SegmentPool.class;

                synchronized(SegmentPool.class) {
                    if(byteCount + 2048L &lt;= 65536L) {
                        byteCount += 2048L;
                        segment.next = next;
                        segment.pos = segment.limit = 0;
                        next = segment;
                    }
                }
            }
        } else {
            throw new IllegalArgumentException();
        }
    }
}
</code></pre><p>内部一个成员变量 next 指向 链表下一个元素，take 首先判断池中是否存在可用的，存在则返回，不存在则 new 一个，而 recycle 则是将不再使用的 Segment 重新扔到池中去，从而达到一个 Segment 池的作用。</p>
<p>而Okio暴露给外部使用的类便是Okio这个类，其内部有大量的静态方法,包括通过一个Source获得BufferedSource，通过一个Sink获得一个BufferedSink。这个过程很简单，我们调用Okio的buffer方法即可返回我们需要的，如下</p>
<pre><code>Okio.buffer(sink)
Okio.buffer(source)
</code></pre><p>但是上面两个方法需要传递一个Sink或者Source，那么这个Sink和Source又是如何获得的呢。其实方法也在Okio这个类中。我们可以调用sink方法获得一个Sink，调用source方法获得一个Source，而数据的来源或者目的可以是一个File，一个输入或者输出流，一个Socket链接等等。如下</p>
<pre><code>Okio.sink(new File(&quot;***&quot;));
Okio.sink(new FileOutputStream(new File(&quot;***&quot;)));
Okio.sink(new Socket(&quot;***&quot;,8888));

Okio.source(new File(&quot;***&quot;));
Okio.source(new FileInputStream(new File(&quot;***&quot;)));
Okio.source(new Socket(&quot;****&quot;,8888));
</code></pre><p>这样你可能还不过瘾，那么让我们连起来应用一下，现在我们从本地读一个文件，读完后再往另一个文件中写入内容。</p>
<pre><code>public static void main(String[] args) {
        Source source = null;
        BufferedSource bufferedSource = null;

        try {
            File file = new File(&quot;resources/test.txt&quot;);
            source = Okio.source(file);
            bufferedSource = Okio.buffer(source);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }

        Sink sink = null;
        BufferedSink bufferedSink = null;
        try {
            File dest = new File(&quot;resources/dest.txt&quot;);
            sink = Okio.sink(dest);
            bufferedSink = Okio.buffer(sink);
            bufferedSink.writeUtf8(&quot;11111111111&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
</code></pre><p>或许有时候网络请求中，我们需要使用到Gzip的功能，那么，我们可以简单的使用一下gzip的功能</p>
<pre><code>public static void main(String[] args) {
        Sink sink = null;
        BufferedSink bufferedSink = null;
        GzipSink gzipSink=null;

        try {
            File dest = new File(&quot;resources/gzip.txt&quot;);
            sink = Okio.sink(dest);
            gzipSink=new GzipSink(sink);
            bufferedSink = Okio.buffer(gzipSink);
            bufferedSink.writeUtf8(&quot;android vs ios&quot;);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSink);
        }

        Source source = null;
        BufferedSource bufferedSource = null;
        GzipSource gzipSource=null;

        try {
            File file = new File(&quot;resources/gzip.txt&quot;);
            source = Okio.source(file);
            gzipSource=new GzipSource(source);
            bufferedSource = Okio.buffer(gzipSource);
            String content = bufferedSource.readUtf8();
            System.out.println(content);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeQuietly(bufferedSource);
        }
    }

    public static void closeQuietly(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ignored) {
            }
        }
    }
</code></pre><p>验证是否正确的方法便是查看该写入的文件是否是乱码，以及读出来是否是原来的字符串。<br>对比一下原来的gzip压缩与解压缩的方式，你就会发现还是简单了不少的</p>
<pre><code>public class GzipUtil {
        /**
         * GZIP压缩
         *
         * @param data
         * @return
         * @throws Exception
         */
        public static byte[] gzip(byte[] data) throws Exception {
            if (data == null || data.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            GZIPOutputStream zos;
            BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(data));
            byte[] buf = new byte[512];
            int len;

            try {
                zos = new GZIPOutputStream(out);
                while ((len = bis.read(buf)) != -1) {
                    zos.write(buf, 0, len);
                    zos.flush();
                }
                bis.close();
                zos.close();
                return out.toByteArray();
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (Exception e2) {
                    }
                }
            }
        }

        /**
         * Gzip解压缩
         *
         * @param b
         * @return
         */
        public static byte[] unGzip(byte[] b) {
            if (b == null || b.length == 0) {
                return null;
            }
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            ByteArrayInputStream in = new ByteArrayInputStream(b);

            try {
                GZIPInputStream gunzip = new GZIPInputStream(in);
                byte[] buffer = new byte[256];
                int n;
                while ((n = gunzip.read(buffer)) &gt;= 0) {
                    out.write(buffer, 0, n);
                }
                return out.toByteArray();
            } catch (IOException e) {
                Log.e(WDCore.getInstance().getConfiguration().getLogTag(), &quot;uncompress error&quot;, e);
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                } catch (Exception e2) {
                }
            }
            return null;
        }
    }
</code></pre><p>此外还有一个 ByteString 类，这个类可以用来做各种变化，它将 byte 转为 String， 而这个 String 可以是 utft8的值，也可以是 base64后的值，也可以是 md5的值， 也可以是 sha256的值，总是就是各种变化，最后去的你想要的值。</p>
<p>在需要的地方使用 Okio 库，可以极大的提升效率，也会带来很大的便利性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp3 源码分析【缓存策略】]]></title>
      <url>http://gdky005.com/2016/06/20/OkHttp3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E3%80%91/</url>
      <content type="html"><![CDATA[<p>本文专门分析 OkHttp 的缓存策略，是 OkHttp 中最简单的一篇</p>
<h3 id="Http-缓存基础知识"><a href="#Http-缓存基础知识" class="headerlink" title="Http 缓存基础知识"></a>Http 缓存基础知识</h3><p>分析源目前，我们先回顾一下 Http 的缓存 Header 的含义</p>
<ol>
<li><p>Expires<br>表示到期时间，一般用在 response 报文中，当超过此事件后相应将被认为是无效的而需要网络连接，反之而是直接使用缓存<br> Expires: Thu, 12 Jan 2017 11:01:33 GMT</p>
</li>
<li><p>Cache-Control<br>相对值，单位是秒，指定某个文件被续多少秒的时间，从而避免额外的网络请求。比expired更好的选择，它不用要求服务器与客户端的时间同步，也不用服务器时刻同步修改配置Expired中的绝对时间，而且它的优先级比Expires更高。比如简书静态资源有如下的header，表示可以续31536000秒，也就是一年。</p>
<p> Cache-Control: max-age=31536000, public</p>
</li>
<li><p>修订文件名（Reving Filenames）<br>如果我们通过设置 header 保证了客户端可以缓存的，而此时远程服务器更新了文件如何解决呢？这个时候可以通过修改 url 的文件名版本后缀进行缓存，比如下文是又拍云的公共CDN就提供了多个版本的JQuery<br> upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.3.min.js</p>
</li>
<li><p>条件 get 请求 （Conditional GET Requests） 与 304<br>如果缓存过期或者轻质放弃缓存，在此情况下，缓存策略全部交给服务器判断，客户端只用发送 条件 get 请求 即可，如果缓存是有效的， 则返回 304 not Modifiled, 否则直接返回 body.</p>
</li>
</ol>
<p>请求的方式有两种：</p>
<ul>
<li>Last-Modified-Date:<br>  Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT</li>
</ul>
<p>客户端再次发送时，通过发送<br>    If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT</p>
<p>交给服务器进行判断，如果任然可以缓存使用，服务器就返回 304.</p>
<ul>
<li>ETag<br>ETag 是对资源文件的一种摘要，客户端并不需要了解实现细节。当客户端第一次请求，服务器返回了<br>  ETag: “5694c7ef-24dc”</li>
</ul>
<p>客户端再次请求时，通过发送<br>    If-None-Match:”5694c7ef-24dc”</p>
<p>交给服务器进行判断，如果还能使用缓存，服务器就返回 304</p>
<blockquote>
<p>如果 ETag 和 Last-Modified 都有，则必须一次性都发给服务器，它们没有优先级之分，反正这里客户端没有任何判断的逻辑。</p>
</blockquote>
<ul>
<li>其他标签<ul>
<li>no-cache/no-store: 不使用缓存<ul>
<li>only-if-cached: 只使用缓存</li>
<li>Date:The date and time that the message was sent</li>
<li>Age： CDN 反代服务器 到原始服务器获取数据延迟的缓存时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>“only-if-cached”标签非常具有诱导性，它只在请求中使用，表示无论是否有网完全只使用缓存（如果命中还好说，否则返回503错误/网络错误），这个标签比较危险。<br>全部的标签，可以到<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_blank" rel="external">这里看</a></p>
</blockquote>
<p>以上内容是作为一个服务器开发或者客户端的常识。下图是网上找的总结，注意图中的 ETag 和 Last-Modified 可能有优先级的歧义，你只需要记住它们是没有优先级的。</p>
<p><img src="http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_01.png" alt=""></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>OkHttp 中使用了 CacheStrategy 实现了上午的流程图，他根据之前的缓存结果与当前将要发送 Request 的 header 进行策略分析，并得出是否要请求的结论。</p>
<ol>
<li>总体请求流程分析<br>CacheStrategy 类似一个 mapping 操作，将两个值输入，再将两值输出<br>Input（request, cacheCandidate） —-》 CacheStrategy(处理，判断 Header 信息) —-》Output(networkRequest, cacheResponse)</li>
</ol>
<p>Request:<br>开发者手动编写并在 Interceptor 中递归加工而成的对象（需要调试分析的话，可以使用 logging-interceptor进行log操作），我们只需要知道母亲传入的 Request 没有任何关于 缓存的 Header。</p>
<p>cacheCandildate:<br>也就是上次与服务器交互缓存的 Response,可能为 null。 这里的缓存全部是基于文件 系统的 map ,key 是请求中url 的 md5, value 是在文件中查询到的缓存，页面置换基于 LRU 算法，我们现在只需要知道他是一个可以读取 缓存 Header 的 Response.</p>
<p>当 CacheStrategy 加工输出后，输出 networkRequest 与 cacheResponse， 根据是否为空执行不同的请求</p>
<p><img src="http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_02.png" alt=""></p>
<blockquote>
<p>以上是对 networkRequest / cacheResponse进行 find usage 查询获得出的结论</p>
</blockquote>
<p>基本上与上文中的图片完全一致，以上就是 OkHttp 的缓存策略。</p>
<blockquote>
<p>关于此部分的分析，读者可以在HttpEngine对象中通过对userResponse进行findUsage分析得出，源码都是一大堆的if判断</p>
</blockquote>
<ol>
<li>CacheStrategy 的加工过程</li>
</ol>
<p>CacheStrategy 使用 Factory模式进行构造，参数如下</p>
<pre><code>InternalCache responseCache = Internal.instance.internalCache(client);
//cacheCandidate从disklurcache中获取
//request的url被md5序列化为key,进行缓存查询
Response cacheCandidate = responseCache != null ? responseCache.get(request) : null;
//请求与缓存
factory = new CacheStrategy.Factory(now, request, cacheCandidate);
cacheStrategy = factory.get();
//输出结果
networkRequest = cacheStrategy.networkRequest;
cacheResponse = cacheStrategy.cacheResponse;
//进行一大堆的if判断，内容同上表格
.....
</code></pre><p>可以看出Factory.get()是最关键的缓存策略的判断，我们点入get()方法，可以发现是对getCandidate()的一个封装，我们接着点开getCandidate()，全是if与数学计算，详细代码如下</p>
<pre><code>private CacheStrategy getCandidate() {
  //如果缓存没有命中(即null),网络请求也不需要加缓存Header了
  if (cacheResponse == null) {
    //`没有缓存的网络请求,查上文的表可知是直接访问
    return new CacheStrategy(request, null);
  }

  // 如果缓存的TLS握手信息丢失,返回进行直接连接
  if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  //检测response的状态码,Expired时间,是否有no-cache标签
  if (!isCacheable(cacheResponse, request)) {
    //直接访问
    return new CacheStrategy(request, null);
  }

  CacheControl requestCaching = request.cacheControl();
  //如果请求报文使用了`no-cache`标签(这个只可能是开发者故意添加的)
  //或者有ETag/Since标签(也就是条件GET请求)
  if (requestCaching.noCache() || hasConditions(request)) {
    //直接连接,把缓存判断交给服务器
    return new CacheStrategy(request, null);
  }
  //根据RFC协议计算
  //计算当前age的时间戳
  //now - sent + age (s)
  long ageMillis = cacheResponseAge();
  //大部分情况服务器设置为max-age
  long freshMillis = computeFreshnessLifetime();

  if (requestCaching.maxAgeSeconds() != -1) {
    //大部分情况下是取max-age
    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));
  }

  long minFreshMillis = 0;
  if (requestCaching.minFreshSeconds() != -1) {
    //大部分情况下设置是0
    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());
  }

  long maxStaleMillis = 0;
  //ParseHeader中的缓存控制信息
  CacheControl responseCaching = cacheResponse.cacheControl();
  if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) {
    //设置最大过期时间,一般设置为0
    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
  }

  //缓存在过期时间内,可以使用
  //大部分情况下是进行如下判断
  //now - sent + age + 0 &lt; max-age + 0
  if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) {
    //返回上次的缓存
    Response.Builder builder = cacheResponse.newBuilder();
    return new CacheStrategy(null, builder.build());
  }

  //缓存失效, 如果有etag等信息
  //进行发送`conditional`请求,交给服务器处理
  Request.Builder conditionalRequestBuilder = request.newBuilder();

  if (etag != null) {
    conditionalRequestBuilder.header(&quot;If-None-Match&quot;, etag);
  } else if (lastModified != null) {
    conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, lastModifiedString);
  } else if (servedDate != null) {
    conditionalRequestBuilder.header(&quot;If-Modified-Since&quot;, servedDateString);
  }
  //下面请求实质还说网络请求
  Request conditionalRequest = conditionalRequestBuilder.build();
  return hasConditions(conditionalRequest) ? new CacheStrategy(conditionalRequest,
      cacheResponse) : new CacheStrategy(conditionalRequest, null);
}
</code></pre><p>太长不看的话，大多数常见的情况可以用这个估算</p>
<pre><code>now - sent + age &lt; max-age
</code></pre><blockquote>
<p>这里有个技巧，对构造函数进行findUsage查询，就可以看出各个输出是否为空的结果，然后各个击破分析<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_03.png" alt=""></p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>根据上面的分析，我们可以发现，okhttp 实现的缓存策略实质上就是大量的 if 判断集合，这些事根据 RFC 标准文件写死的，并没有相当难的技巧。</p>
<ol>
<li>通过上面的分析，我们可以发现，okhttp实现的缓存策略实质上就是大量的if判断集合，这些是根据RFC标准文档写死的，并没有相当难的技巧。</li>
<li>OkHttp 的缓存是自动完成的，玩去由服务器 Header 决定，自己 <strong>没有必要</strong> 进行控制。网上热传的文件中在 Interceptor 中手动天阿基缓存代码控制，它固然有用，但是属于 Hack 式的利用，违反了 RFC 的文档标准，不建议使用，OkHttp 的官方缓存控制在 <a href="https://github.com/square/okhttp/blob/d662c1a82851800c46ad8ede2d9d10d10427fdad/okhttp/src/main/java/okhttp3/Cache.java#L79" target="_blank" rel="external">注释中</a>。 如果读者的需求是对象持久化，建议使用文件存储或者 数据库即可（比如 realm）.</li>
<li>充分利用 idea 的 findUsage 的功能，源码的各个跳转条件都能很快分析完成</li>
<li>可以使用 alt + space  快速预览某个函数<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/okhttp_cache_04.png" alt=""></li>
</ol>
<p>摘自：<a href="http://www.jianshu.com/p/9cebbbd0eeab" target="_blank" rel="external">http://www.jianshu.com/p/9cebbbd0eeab</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OkHttp3源码分析【任务队列】]]></title>
      <url>http://gdky005.com/2016/06/20/OkHttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E3%80%91/</url>
      <content type="html"><![CDATA[<h3 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h3><ol>
<li>线程池基础</li>
<li>反向代理模块</li>
<li>OkHttp 的任务调度</li>
</ol>
<p>OkHttp拥有两种运行方式，一种是同步阻塞调用并直接返回的形式，另一种是通过内部线程池分发调度实现非阻塞的一步回调。本文主要分析第二种，即 OkHttp 在多并发网络下的分发调度过程。本文主要分析的是 Dispatcher 对象。</p>
<h1 id="线程池基础"><a href="#线程池基础" class="headerlink" title="线程池基础"></a>线程池基础</h1><ol>
<li>线程池好处有哪些<br>线程池的关键在于线程复用以减少非核心任务的损耗。以下参考自 IBM 知识库：</li>
</ol>
<p>多线程技术主要解决 处理器单元时间内多个线程执行的问题，他可以显著减少处理器单元内的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举例：<br>如果一台服务完成一项任务的时间为 T</p>
<pre><code>T1 创建线程的时间
T2 在线程中执行任务的时间，包括线程间同步所需时间
T3 线程销毁的时间
</code></pre><p>显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。</p>
<p>可以看出 T1 T3 是多线程本身带来的开销，我们渴望减少 T1，T3的时间，从而减少 T 的时间。但一些线程的使用者并没有注意到这一点，多余在程序中 频繁的创建或销毁线程，导致 T1 T3 占的比例更高。显然这是突出了线程的弱点（T1，T3），而不是有点（并发性）。</p>
<p>线程池的技术是关注如何缩短或调整 T1，T3 的时间的技术，从而提高服务器程序性能。</p>
<ul>
<li>通过对线程缓存，减少创建和销毁的时间损失<ul>
<li>通过控制线程数据的阈值，减少当线程过少带来的 CPU 闲置（比如说 长时间卡在I/O 上）与线程过多时对 JVM 对对内存与线程切换压力</li>
</ul>
</li>
</ul>
<p>在 Java 中，我们可以通过 线程池工厂 或者 自定义参数 来创建 线程池。这里就不说了</p>
<ol>
<li>OkHttp 配置的线程池</li>
</ol>
<p>在 OkHttp 中，使用如下构造了单例线程池<br>    public synchronized ExecutorService executorService() {<br>      if (executorService == null) {<br>        executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,<br>            new SynchronousQueue<runnable>(), Util.threadFactory(“OkHttp Dispatcher”, false));<br>      }<br>      return executorService;<br>    }</runnable></p>
<p>参数说明：</p>
<ul>
<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</li>
<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃<em>处理机制</em>来处理</li>
<li>long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>
<li>TimeUnit unit: 时间单位，一般用秒</li>
<li>BlockingQueue\<runnable\> workQueue:  工作队列</runnable\></li>
<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等</li>
</ul>
<p>可以看出，在 OkHttp 中，构建了一个阈值为【0， Integer.Max_value】的线程池，她不好留任何最先线程数，随时创建更多的线程数，当线程空闲时只能活 60秒，它使用另一个不存储元素的阻塞工作队列， 一个叫做 “OkHttp Dispatcher” 的线程工厂。</p>
<p>也就是说， 在实际运行中，当收到10个并发请求是，线程池会创建十个线程，当工作完成后，线程池会在60s 后相继关闭所有线程。</p>
<blockquote>
<p>在RxJava的Schedulers.io()中，也有类似的设计，最小的线程数量控制，不设上限的最大线程，以保证I/O任务中高阻塞低占用的过程中，不会长时间卡在阻塞上，有兴趣的可以分析RxJava中4种不同场景的Schedulers</p>
</blockquote>
<h3 id="反向代理模型"><a href="#反向代理模型" class="headerlink" title="反向代理模型"></a>反向代理模型</h3><p>在 OkHttp 中，使用了与 Nginx 类似的反向代理与分发技术，这是典型的 单生产者多消费者的问题。</p>
<p>我们知道在Nginx中，用户通过HTTP(Socket)访问前置的服务器，服务器会自动转发请求给后端，并返回后端数据给用户。通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现<strong>非阻塞、高并发连接</strong>，避免资源全部放到一台服务器而带来的负载，速度，在线率等影响。<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_01.png" alt=""></p>
<p>而在 OkHttp 中，非常类似上面的场景，它使用 Dispatcher 作为任务的转发器，线程池对应多台后置服务器，用 AsyncCall 对应 Socket 请求，用 Deque\<readyasynccalls\>对应 Nginx 的内部缓存</readyasynccalls\></p>
<p><img src="http://7xlcno.com1.z0.glb.clouddn.com/okhttp_task_queue_02.png" alt=""></p>
<p>具体成员如下：</p>
<ul>
<li>maxRequests = 64：最大并发请求数为64</li>
<li>maxRequestsPerHost = 5：每个主机最大请求数为5</li>
<li>Dispatcher：分发者，也就是生产者（默认在主线程）</li>
<li>AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）</li>
<li>ExecutorService：消费者池（也就是线程池）</li>
<li>Deque\<readyasynccalls\>：缓存（用数组实现，可自动扩容，无大小限制）</readyasynccalls\></li>
<li>Deque\<runningasynccalls\>：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</runningasynccalls\></li>
</ul>
<p>通过将请求任务分发给多个线程，可以显著减少 I/O 等待时间</p>
<h3 id="OkHttp-的任务调度"><a href="#OkHttp-的任务调度" class="headerlink" title="OkHttp 的任务调度"></a>OkHttp 的任务调度</h3><p>当我们使用 OkHttp 的异步请求时，一般进行如下构造：<br>    OkHttpClient client = new OkHttpClient.Builder().build();<br>    Request request = new Request.Builder()<br>        .url(“<a href="http://qq.com&quot;).get().build(" target="_blank" rel="external">http://qq.com&quot;).get().build(</a>);<br>    client.newCall(request).enqueue(new Callback() {<br>      @Override public void onFailure(Call call, IOException e) {</p>
<pre><code>  }

  @Override public void onResponse(Call call, Response response) throws IOException {

  }
});
</code></pre><p>当 HttpClient 的请求入队 时，根据代码，我们可以发现实际上是 Dispatcher 进行了 入队 操作</p>
<pre><code>synchronized void enqueue(AsyncCall call) {
  if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) {
      //添加正在运行的请求
    runningAsyncCalls.add(call);
       //线程池执行请求
    executorService().execute(call);
  } else {
      //添加到缓存队列
    readyAsyncCalls.add(call);
  }
}
</code></pre><p>可以发现请求是否进入缓存的条件如下：<br>    (runningRequests&lt;64 &amp;&amp; runningRequestsPerHost&lt;5)</p>
<p>如果满足条件，那么久直接把 AsyncCall 直接加到 runningCalls 的队列中，并在现场中执行（线程池会根据当前负载自动创建，销毁，缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。</p>
<p>我们再分析请求元素AsyncCall（本质是实现了Runnable接口），它内部的 execute方法是：<br>    @Override protected void execute() {<br>      boolean signalledCallback = false;<br>      try {<br>          //执行耗时IO任务<br>        Response response = getResponseWithInterceptorChain(forWebSocket);<br>        if (canceled) {<br>          signalledCallback = true;<br>          //回调，注意这里回调是在线程池中，而不是想当然的主线程回调<br>          responseCallback.onFailure(RealCall.this, new IOException(“Canceled”));<br>        } else {<br>          signalledCallback = true;<br>          //回调，同上<br>          responseCallback.onResponse(RealCall.this, response);<br>        }<br>      } catch (IOException e) {<br>        if (signalledCallback) {<br>          // Do not signal the callback twice!<br>          logger.log(Level.INFO, “Callback failure for “ + toLoggableString(), e);<br>        } else {<br>          responseCallback.onFailure(RealCall.this, e);<br>        }<br>      } finally {<br>          //最关键的代码<br>        client.dispatcher().finished(this);<br>      }<br>    }</p>
<p>当任务执行完成后，无是否有 异常，finally 代码段总会被执行，也就是会调用 Dispatcher 的 finished 函数，打开源码，就能发现它将正在运行的任务 Call从 队列 runningAsyncCalls 中移除后，执行 promoteCalls()函数<br>    private void promoteCalls() {<br>        //如果目前是最大负荷运转，接着等<br>      if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity.<br>      //如果缓存等待区是空的，接着等<br>      if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote.</p>
<pre><code>  for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) {
    AsyncCall call = i.next();

    if (runningCallsForHost(call) &lt; maxRequestsPerHost) {
        //将缓存等待区最后一个移动到运行区中，并执行
      i.remove();
      runningAsyncCalls.add(call);
      executorService().execute(call);
    }

    if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity.
  }
}
</code></pre><p>这样，就主动的把缓存队列向前走了一步，而没有使用锁等复杂编码</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>通过上述的分析，我们知道了：</p>
<ol>
<li>OkHttp 采用 Dispatcher 技术，类似于 Nginx, 与线程池配合实现高并发，低阻塞的运行</li>
<li>OkHttp 采用 Deque 作为缓存，按照入队的顺序先进先出</li>
<li>OkHttp 最出彩的地方就是在 try/finally 中调用了 finished 函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂度</li>
</ol>
<p>摘自：<a href="http://www.jianshu.com/p/6637369d02e7" target="_blank" rel="external">http://www.jianshu.com/p/6637369d02e7</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Okhttp3源码分析【DiskLruCache】]]></title>
      <url>http://gdky005.com/2016/06/20/Okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%90DiskLruCache%E3%80%91/</url>
      <content type="html"><![CDATA[<h3 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h3><ul>
<li>Cache 的简介</li>
<li>LinkedHashMap 原理</li>
<li>OkHttp 的文件系统</li>
</ul>
<p>本文对 put/get 过程进行分析，注意缓存的判断依据不是本文， 而是 <strong>缓存策略</strong></p>
<h3 id="1-Cache-的简介"><a href="#1-Cache-的简介" class="headerlink" title="1.Cache 的简介"></a>1.Cache 的简介</h3><p>缓存，顾名思义，也就是方便用户快速的获取值的一种储存方式。小到与CPU同频的昂贵的缓存颗粒，内存，硬盘，网络，CDN反代缓存，DNS递归查询，OS页面置换，都可以看作缓存。它有如下的特点：</p>
<ol>
<li>缓存载体与持久载体总是相对的，容量远远小于持久容量，成本高于持久容量，速度高于持久容量。比如硬盘与网络，目前主流的SSD硬盘可以达到500MB/S，而很多地区网速却只有4M，将网络中的文件存到硬盘中，硬盘就相当于缓存；再比如内存与硬盘，主流的DDR3内存的速度可以达到10GB/S，而硬盘相对的慢了很多数量级别，将硬盘的游戏加载到内存，内存就相对于硬盘是一种缓存。</li>
<li>需要实现 <em>排序依据</em>， 子啊 java 中，可以使用 Comparable\<t\>作为排序的接口。</t\></li>
<li>需要一种 <em>页面置换算法</em> 将旧页面取代去掉 换成新页面，如 最久未使用算法（LRU）、先进先出（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等</li>
<li>如果缓存中没有，就需要从原始地址获取，这个步骤叫做『回源』，CDN厂商会标注“回源率”作为卖点</li>
</ol>
<p>在 OkHttp 中，使用 FileSystem 作为缓存载体（磁盘相对于网络的缓存），使用 LRU 作为 页面置换算法 （封装了 LinkedHashMap）。</p>
<blockquote>
<p>1.Comparable\<t\>是java用来排序的接口，推荐参考阅读《Java Software Structures Designing and Using Data Structures》<br>2.页面置换算法可以参考阅读《现代操作系统》的中译本</t\></p>
</blockquote>
<h3 id="2-LinkedHashMap-原理"><a href="#2-LinkedHashMap-原理" class="headerlink" title="2.LinkedHashMap 原理"></a>2.LinkedHashMap 原理</h3><ol>
<li>源码概述分析<br>在学之前，应该先了解下 LinkedHashMap。 LinkedHashMap 继承于 HashMap.</li>
</ol>
<p>在 HashMap 中，维护了一个 Node\<k,v\>[] table,当 put操作时，将元素按照计算后的 hash 值 放入到 数组相应位置 table[has] 中，最后迭代式，从 table[0] 开始向后迭代，具体的顺序取决于元素的 HashCode, 所以我们常说 HashMap 的元素迭代是不可预测的。</k,v\></p>
<p>而在 LinkedHashMap 中，除了 Node\<k,v\><a href="#"></a> table， 还维护着 Entry\<k,v\> head,tail。 当 put 元素后，调用以下回调函数 对链表 将元素移动到链尾 已经清理旧元素<br>    // move node to last<br>    void afterNodeAccess(Node<k,v> e)<br>    // possibly remove eldest<br>    void afterNodeInsertion(boolean evict)</k,v></k,v\></k,v\></p>
<p>当 get 元素时，如果设置 accessOrder 为 true 时，通过调用如下回调 元素到链尾， 这里强调 移动，如果元素本身已经在 链表中，那它只会移动，而不是新建<br>    // move node to last<br>    void afterNodeAccess(Node<k,v> e)</k,v></p>
<p>综上，当你返回对元素进行 get/put 操作时，经常使用的元素会被移动到 tail 中，而长期不用的元素 会被移动到 head</p>
<p>最后 迭代时，迭代是从旧元素 迭代到新元素，这就是 LRU 的实现<br>    head &lt;–&gt; …. &lt;–&gt; tail</p>
<pre><code>旧元素 &lt;-----------&gt; 反复使用的新元素
</code></pre><p>在 Okhttp 中，使用了 DiskLruCache 对 LinkedHashMap 进行封装实现了 LRU， 如图进行初始化<br>    //按照访问顺序排序的Map，设置accessOrder为true<br>    map = new LinkedHashMap&lt;&gt;(0, 0.75f, true);</p>
<h3 id="3-OkHttp-的文件系统"><a href="#3-OkHttp-的文件系统" class="headerlink" title="3.OkHttp 的文件系统"></a>3.OkHttp 的文件系统</h3><p>OkHttp 中的关键对象如下：</p>
<ul>
<li>FileSystem: 使用 Okio 对 File 的封装，简化了 IO 操作</li>
<li>DiskLruCache.Editor: 添加了同步锁，并对 FileSystem 进行高度封装</li>
<li>DiskLruCache.Entry: 维护着 key 对应的多个文件</li>
<li>Cache.Entry: Response java 对象 与 Okio 流 的序列化/反序列化类</li>
<li>DiskLruCache: 维护着文件的创建， 清理，读取。 内部有线程池，LinkedHashMap（也是 LruCache）</li>
<li>Cache: 被上级代码调用，提供透明的 put/get 操作，封装了缓存检查条件与 DiskLruCache, 开发者只用配置大小即可，不需要手动管理</li>
<li>Response/Request: OkHttp 的请求与回应</li>
</ul>
<ol>
<li>文件初级封装（FileSystem）<br>众所周知，文件读写是流操作，是一堆 try catch 操作，在 OkHttp 中设计了 FileSystem.SYSTEM 作为文件层的管理。通过用 Okio 库中的 source/sink对 File 进行包装，而不用更为头痛 的 Inputstream 这类东西，使用上层调用与管道操作一样简单。<br> File(低级操作，步骤繁琐) -&gt; Okio(封装) －&gt; FileSystem(友好工具类)</li>
</ol>
<p>Okio 很不错，可以去<a href="https://github.com/square/okio" target="_blank" rel="external">这里</a>查看。</p>
<ol>
<li>文件高级封装（DiskLruCache.Entry/Editor/Snapshot）<br>本部分进行了如下操作，进行了实际的 put/get 操作<br> FileSystem &lt;– DiskLruCache.Entry/Editor –&gt; source/sink(更少参数)</li>
</ol>
<p>DiskLruCache.Entry 针对每个请求的 url 对应文件进行维护（而没有进行创建/读取等操作）， 它内部维护了2个 File数组，一般来说 每个 url 对应对应2~4个文件。 文件名的规则是{md5(url) + {0,1}}, 后面的 0 或者 1 ，分别表示 ENTRY_METADATA 与 ENTRY_BODY。</p>
<p>比如在缓存的路径下执行 ls,结果如下：<br>    $ ls<br>    5716ab0f06c49bc7cf602397c51d5677.0<br>    5716ab0f06c49bc7cf602397c51d5677.1<br>    5b2f52377611dc6201a1871bdb997466.0<br>    5b2f52377611dc6201a1871bdb997466.1<br>    journal<br>    …..</p>
<p>DiskLruCache.Editor 对工具类 FileSystem 进行进一步的封装， 它以 DiskLruCache.Entry 作为构造参数，通过操控 Entry 中 维护的数组，对外暴露 source/sink ,为上层 的 java对象与文件的转换提供基于 okio 的流操作，我们可以通过对它 的两个方法进行 FindUsage 查询获得 OkHttp 关于文件读写的全部场景</p>
<ul>
<li>写入场景：第一个位置是写入元信息，也就是写入末尾是0的文件中，是序列化的过程；第二个位置是写入 body,也就是写入末位是1的文件中，是存二进制的过程。<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/0khttp_02.png" alt=""></li>
<li>读取场景：读取时，需要获取快照，通过调用链分析<br><img src="http://7xlcno.com1.z0.glb.clouddn.com/0khttp_01.png" alt=""></li>
</ul>
<ol>
<li>序列化与反序列化（Cache.Entry）<br>文本的存储本质上也是序列化与反序列化的过程。本部分提供了下图的转变<blockquote>
<p>Resonse(java对象) \&lt;— Cache.Entry —> source/sink(文件io)</p>
</blockquote>
</li>
</ol>
<p>可以通过 find usage 位置相同，概括如下：<br>如果信息本身是二进制，就直接写入到文件中；如果文本是信息，就按照预设的格式写入即可。<br>    至于序列化后的东西到底是什么，可以直接在shell下运行cat命令或者打开文本编辑器进行输出查看。</p>
<pre><code>注意这里的Cache.Entry与上面的DiskLruCache.Entry是两个完全不同的对象
</code></pre><ol>
<li><p>缓存的自动清理<br>在 DiskLruCache 初始化时，将简历线程池，最少0个线程池，最大一个线程，线程空闲可活60s, 线程名叫做【OkHttp DiskLruCache】,当 JVM 退出时，线程自动结束。</p>
<p> new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,</p>
<pre><code>new LinkedBlockingQueue&lt;Runnable&gt;(), Util.threadFactory(&quot;OkHttp DiskLruCache&quot;, true))
</code></pre></li>
</ol>
<p>当需要清理时，执行清理任务，它将在每次 get/set 后调用</p>
<pre><code>private final Runnable cleanupRunnable = new Runnable() {
  public void run() {
    synchronized (DiskLruCache.this) {
      if (!initialized | closed) {
        return; // Nothing to do
      }
      try {
        //遍历LRU缓存(从旧到新进行遍历map),并删除文件
        //直到小于MaxSize为止
        trimToSize();
        if (journalRebuildRequired()) {
          rebuildJournal();
          redundantOpCount = 0;
        }
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
};
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>OkHttp 通过对文件进行了多次封装，实现了简单的I/O 操作</li>
<li>OKHttp 通过对请求 url进行 md5 实现了与文件的映射，实现写入，删除的操作</li>
<li>OkHttp 内部维护着清理线程池，实现对缓存文件的自动清理</li>
</ol>
<p>摘自：<a href="http://www.jianshu.com/p/23b8aa490a6b" target="_blank" rel="external">http://www.jianshu.com/p/23b8aa490a6b</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[代码面试最常用的10大算法]]></title>
      <url>http://gdky005.com/2016/03/12/%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8410%E5%A4%A7%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="代码面试最常用的10大算法"><a href="#代码面试最常用的10大算法" class="headerlink" title="代码面试最常用的10大算法"></a>代码面试最常用的10大算法</h3><blockquote>
<p>面试也是一门学问，在面试之前做好充分的准备则是成功的必须条件，而程序员在代码面试时，常会遇到编写算法的相关问题，比如排序、二叉树遍历等等。</p>
</blockquote>
<p>在程序员的职业生涯中，算法亦算是一门基础课程，尤其是在面试的时候，很多公司都会让程序员编写一些算法实例，例如快速排序、二叉树查找等等。<br>本文总结了程序员在代码面试中最常遇到的10大算法类型，想要真正了解这些算法的原理，还需程序员们花些功夫。</p>
<h3 id="1-String-Array-Matrix"><a href="#1-String-Array-Matrix" class="headerlink" title="1. String/Array/Matrix"></a>1. String/Array/Matrix</h3><pre><code>toCharArray() //get char array of a String
Arrays.sort()  //sort an array
Arrays.toString(char[] a) //convert to string
charAt(int x) //get a char at the specific index
length() //string length
length //array size 
substring(int beginIndex) 
substring(int beginIndex, int endIndex)
Integer.valueOf()//string to integer
String.valueOf()/integer to string
</code></pre><p>String/arrays很容易理解，但与它们有关的问题常常需要高级的算法去解决，例如动态编程、递归等。<br>下面列出一些需要高级算法才能解决的经典问题：</p>
<ul>
<li><a href="http://www.programcreek.com/2012/12/leetcode-evaluate-reverse-polish-notation/" target="_blank" rel="external">Evaluate Reverse Polish Notation</a></li>
<li><a href="http://www.programcreek.com/2013/12/leetcode-solution-of-longest-palindromic-substring-java/" target="_blank" rel="external">Longest Palindromic Substring</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-solution-word-break/" target="_blank" rel="external">单词分割</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-word-ladder/" target="_blank" rel="external">字梯</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-median-of-two-sorted-arrays-java/" target="_blank" rel="external">Median of Two Sorted Arrays</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-regular-expression-matching-in-java/" target="_blank" rel="external">正则表达式匹配￼Java</a></li>
<li><a href="http://merge%20intervals/" target="_blank" rel="external">合并间隔</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-insert-interval/" target="_blank" rel="external">插入间隔</a></li>
<li><a href="http://www.programcreek.com/2012/12/leetcode-solution-of-two-sum-in-java/" target="_blank" rel="external">Two Sum</a></li>
<li>3Sum</li>
<li>4Sum</li>
<li>3Sum Closest</li>
<li>String to Integer</li>
<li>合并排序数组</li>
<li>Valid Parentheses</li>
<li>实现strStr()</li>
<li>Set Matrix Zeroes</li>
<li>搜索插入位置</li>
<li>Longest Consecutive Sequence</li>
<li>Valid Palindrome</li>
<li>螺旋矩阵</li>
<li>搜索一个二维矩阵</li>
<li>旋转图像</li>
<li>三角形</li>
<li>Distinct Subsequences Total</li>
<li>Maximum Subarray</li>
<li>删除重复的排序数组</li>
<li>删除重复的排序数组2</li>
<li>查找没有重复的最长子串</li>
<li>包含两个独特字符的最长子串</li>
<li>Palindrome Partitioning</li>
</ul>
<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><p>在Java中实现链表是非常简单的，每个节点都有一个值，然后把它链接到下一个节点。   </p>
<pre><code>class Node {
    int val;
    Node next;

    Node(int x) {
        val = x;
        next = null;
    }
}
</code></pre><p>比较流行的两个链表例子就是栈和队列。</p>
<h4 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h4><pre><code>class Stack{
    Node top; 

    public Node peek(){
        if(top != null){
            return top;
        }

        return null;
    }

    public Node pop(){
        if(top == null){
            return null;
        }else{
            Node temp = new Node(top.val);
            top = top.next;
            return temp;    
        }
    }

    public void push(Node n){
        if(n != null){
            n.next = top;
            top = n;
        }
    }
}
</code></pre><h4 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h4><pre><code>class Queue{
    Node first, last;
&amp;nbsp;
    public void enqueue(Node n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }
&amp;nbsp;
    public Node dequeue(){
        if(first == null){
            return null;
        }else{
            Node temp = new Node(first.val);
            first = first.next;
            return temp;
        }   
    }
}
</code></pre><p>值得一提的是，Java标准库中已经包含一个叫做Stack的类，链表也可以作为一个队列使用（add()和remove()）。（链表实现队列接口）如果你在面试过程中，需要用到栈或队列解决问题时，你可以直接使用它们。<br>在实际中，需要用到链表的算法有：</p>
<ul>
<li>插入两个数字</li>
<li>重新排序列表</li>
<li>链表周期</li>
<li>Copy List with Random Pointer</li>
<li>合并两个有序列表</li>
<li>合并多个排序列表</li>
<li>从排序列表中删除重复的</li>
<li>分区列表</li>
<li>LRU缓存</li>
</ul>
<h3 id="3-树-amp-堆"><a href="#3-树-amp-堆" class="headerlink" title="3. 树&amp;堆"></a>3. 树&amp;堆</h3><p>这里的树通常是指二叉树。</p>
<pre><code>class TreeNode{
    int value;
    TreeNode left;
    TreeNode right;
} 
</code></pre><p>下面是一些与二叉树有关的概念：</p>
<ul>
<li>二叉树搜索：对于所有节点，顺序是：left children \&lt;= current node \&lt;= right children；</li>
<li>平衡vs.非平衡：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树；</li>
<li>满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；</li>
<li>完美二叉树（Perfect Binary Tree）：一个满二叉树，所有叶子都在同一个深度或同一级，并且每个父节点都有两个子节点；</li>
<li>完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</li>
</ul>
<p>堆（Heap）是一个基于树的数据结构，也可以称为优先队列（ PriorityQueue），在队列中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>
<p>下面列出一些基于二叉树和堆的算法：</p>
<ul>
<li>二叉树前序遍历</li>
<li>二叉树中序遍历</li>
<li>二叉树后序遍历</li>
<li>字梯</li>
<li>验证二叉查找树</li>
<li>把二叉树变平放到链表里</li>
<li>二叉树路径和</li>
<li>从前序和后序构建二叉树</li>
<li>把有序数组转换为二叉查找树</li>
<li>把有序列表转为二叉查找树</li>
<li>最小深度二叉树</li>
<li>二叉树最大路径和</li>
<li>平衡二叉树</li>
</ul>
<h3 id="4-Graph"><a href="#4-Graph" class="headerlink" title="4. Graph"></a>4. Graph</h3><p>与Graph相关的问题主要集中在深度优先搜索和宽度优先搜索。深度优先搜索非常简单，你可以从根节点开始循环整个邻居节点。下面是一个非常简单的宽度优先搜索例子，核心是用队列去存储节点。</p>
<p><img src="http://cms.csdnimg.cn/article/201404/10/534655cfcf7a0.jpg" alt=""></p>
<h4 id="第一步，定义一个GraphNode"><a href="#第一步，定义一个GraphNode" class="headerlink" title="第一步，定义一个GraphNode"></a>第一步，定义一个GraphNode</h4><pre><code>class GraphNode{ 
    int val;
    GraphNode next;
    GraphNode[] neighbors;
    boolean visited;

    GraphNode(int x) {
        val = x;
    }

    GraphNode(int x, GraphNode[] n){
        val = x;
        neighbors = n;
    }

    public String toString(){
        return &quot;value: &quot;+ this.val; 
    }
}
</code></pre><h4 id="第二步，定义一个队列"><a href="#第二步，定义一个队列" class="headerlink" title="第二步，定义一个队列"></a>第二步，定义一个队列</h4><pre><code>class Queue{
    GraphNode first, last;

    public void enqueue(GraphNode n){
        if(first == null){
            first = n;
            last = first;
        }else{
            last.next = n;
            last = n;
        }
    }

    public GraphNode dequeue(){
        if(first == null){
            return null;
        }else{
            GraphNode temp = new GraphNode(first.val, first.neighbors);
            first = first.next;
            return temp;
        }   
    }
}
</code></pre><h4 id="第三步，使用队列进行宽度优先搜索"><a href="#第三步，使用队列进行宽度优先搜索" class="headerlink" title="第三步，使用队列进行宽度优先搜索"></a>第三步，使用队列进行宽度优先搜索</h4><pre><code>public class GraphTest {

    public static void main(String[] args) {
        GraphNode n1 = new GraphNode(1); 
        GraphNode n2 = new GraphNode(2); 
        GraphNode n3 = new GraphNode(3); 
        GraphNode n4 = new GraphNode(4); 
        GraphNode n5 = new GraphNode(5); 

        n1.neighbors = new GraphNode[]{n2,n3,n5};
        n2.neighbors = new GraphNode[]{n1,n4};
        n3.neighbors = new GraphNode[]{n1,n4,n5};
        n4.neighbors = new GraphNode[]{n2,n3,n5};
        n5.neighbors = new GraphNode[]{n1,n3,n4};

        breathFirstSearch(n1, 5);
    }

    public static void breathFirstSearch(GraphNode root, int x){
        if(root.val == x)
            System.out.println(&quot;find in root&quot;);

        Queue queue = new Queue();
        root.visited = true;
        queue.enqueue(root);

        while(queue.first != null){
            GraphNode c = (GraphNode) queue.dequeue();
            for(GraphNode n: c.neighbors){

                if(!n.visited){
                    System.out.print(n + &quot; &quot;);
                    n.visited = true;
                    if(n.val == x)
                        System.out.println(&quot;Find &quot;+n);
                    queue.enqueue(n);
                }
            }
        }
    }
}
</code></pre><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><pre><code>value: 2 value: 3 value: 5 Find value: 5 
value: 4
</code></pre><p>实际中，基于Graph需要经常用到的算法：</p>
<ul>
<li>克隆Graph</li>
</ul>
<h3 id="5-排序"><a href="#5-排序" class="headerlink" title="5. 排序"></a>5. 排序</h3><p>不同排序算法的时间复杂度，大家可以到wiki上查看它们的基本思想。</p>
<p><img src="http://cms.csdnimg.cn/article/201404/10/53465710a87e6.jpg" alt=""></p>
<p>BinSort、Radix Sort和CountSort使用了不同的假设，所有，它们不是一般的排序方法。   </p>
<p>下面是这些算法的具体实例，另外，你还可以阅读： <a href="http://www.programcreek.com/2014/03/how-developers-sort-in-java/" target="_blank" rel="external">Java开发者在实际操作中是如何排序的</a>。</p>
<ul>
<li>归并排序</li>
<li>快速排序</li>
<li>插入排序</li>
</ul>
<h3 id="6-递归和迭代"><a href="#6-递归和迭代" class="headerlink" title="6. 递归和迭代"></a>6. 递归和迭代</h3><p>下面通过一个例子来说明什么是递归。</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><blockquote>
<p>这里有n个台阶，每次能爬1或2节，请问有多少种爬法？</p>
</blockquote>
<h4 id="步骤1：查找n和n-1之间的关系"><a href="#步骤1：查找n和n-1之间的关系" class="headerlink" title="步骤1：查找n和n-1之间的关系"></a>步骤1：查找n和n-1之间的关系</h4><p>为了获得n，这里有两种方法：一个是从第一节台阶到n-1或者从2到n-2。如果f(n)种爬法刚好是爬到n节，那么f(n)=f(n-1)+f(n-2)。   </p>
<h4 id="步骤2：确保开始条件是正确的"><a href="#步骤2：确保开始条件是正确的" class="headerlink" title="步骤2：确保开始条件是正确的"></a>步骤2：确保开始条件是正确的</h4><p>f(0) = 0;<br>f(1) = 1; </p>
<pre><code>public static int f(int n){
    if(n &lt;= 2) return n;
    int x = f(n-1) + f(n-2);
    return x;
}
</code></pre><p>递归方法的时间复杂度指数为n，这里会有很多冗余计算。<br>    f(5)<br>    f(4) + f(3)<br>    f(3) + f(2) + f(2) + f(1)<br>    f(2) + f(1) + f(2) + f(2) + f(1)</p>
<p>该递归可以很简单地转换为迭代。<br>    public static int f(int n) {</p>
<pre><code>    if (n &lt;= 2){
        return n;
    }

    int first = 1, second = 2;
    int third = 0;

    for (int i = 3; i &lt;= n; i++) {
        third = first + second;
        first = second;
        second = third;
    }

    return third;
}
</code></pre><p>在这个例子中，迭代花费的时间要少些。关于迭代和递归，你可以去 <a href="http://www.programcreek.com/2012/10/iteration-vs-recursion-in-java/" target="_blank" rel="external">这里</a>看看。</p>
<h3 id="7-动态规划"><a href="#7-动态规划" class="headerlink" title="7. 动态规划"></a>7. 动态规划</h3><p>动态规划主要用来解决如下技术问题：</p>
<ul>
<li>通过较小的子例来解决一个实例；</li>
<li>对于一个较小的实例，可能需要许多个解决方案；</li>
<li>把较小实例的解决方案存储在一个表中，一旦遇上，就很容易解决；</li>
<li><p>附加空间用来节省时间。<br>上面所列的爬台阶问题完全符合这四个属性，因此，可以使用动态规划来解决：<br>  public static int[] A = new int[100];</p>
<p>  public static int f3(int n) {</p>
<pre><code>if (n &lt;= 2)
    A[n]= n;

if(A[n] &gt; 0)
    return A[n];
else
    A[n] = f3(n-1) + f3(n-2);//store results so only calculate once!
return A[n];
</code></pre><p>  }</p>
</li>
</ul>
<p>一些基于动态规划的算法：</p>
<ul>
<li>编辑距离</li>
<li>最长回文子串</li>
<li>单词分割</li>
<li>最大的子数组</li>
</ul>
<h3 id="8-位操作"><a href="#8-位操作" class="headerlink" title="8. 位操作"></a>8. 位操作</h3><p>位操作符：<br><img src="http://cms.csdnimg.cn/article/201404/10/53465e7bc51e0.jpg" alt=""></p>
<p>从一个给定的数n中找位i（i从0开始，然后向右开始）</p>
<pre><code>public static boolean getBit(int num, int i){
    int result = num &amp; (1&lt;&lt;i);

    if(result == 0){
        return false;
    }else{
        return true;
    }
}
</code></pre><p>例如，获取10的第二位：<br>    i=1, n=10<br>    1&lt;&lt;1= 10<br>    1010&amp;10=10<br>    10 is not 0, so return true;</p>
<p>典型的位算法：</p>
<ul>
<li>Find Single Number</li>
<li>Maximum Binary Gap</li>
</ul>
<h3 id="9-概率"><a href="#9-概率" class="headerlink" title="9. 概率"></a>9. 概率</h3><p>通常要解决概率相关问题，都需要很好地格式化问题，下面提供一个简单的例子： </p>
<blockquote>
<p>有50个人在一个房间，那么有两个人是同一天生日的可能性有多大？（忽略闰年，即一年有365天）</p>
</blockquote>
<pre><code>public static double caculateProbability(int n){
    double x = 1; 

    for(int i=0; i&lt;n; i++){
        x *=  (365.0-i)/365.0;
    }

    double pro = Math.round((1-x) * 100);
    return pro/100;
}I
</code></pre><p>结果：</p>
<blockquote>
<p>calculateProbability(50) = 0.97</p>
<h3 id="10-组合和排列"><a href="#10-组合和排列" class="headerlink" title="10. 组合和排列"></a>10. 组合和排列</h3></blockquote>
<p>组合和排列的主要差别在于顺序是否重要。<br>例1：</p>
<blockquote>
<p>1、2、3、4、5这5个数字，输出不同的顺序，其中4不可以排在第三位，3和5不能相邻，请问有多少种组合？<br>例2：<br>有5个香蕉、4个梨、3个苹果，假设每种水果都是一样的，请问有多少种不同的组合？</p>
</blockquote>
<p>基于它们的一些常见算法</p>
<ul>
<li>排列</li>
<li>排列2</li>
<li>排列顺序</li>
</ul>
<p>来自：<a href="http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview" target="_blank" rel="external">http://www.csdn.net/article/2014-04-10/2819237-Top-10-Algorithms-for-Coding-Interview</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[推荐processon 让流程图也可以共享]]></title>
      <url>http://gdky005.com/2016/02/25/%E6%8E%A8%E8%8D%90processon-%E8%AE%A9%E6%B5%81%E7%A8%8B%E5%9B%BE%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>推荐一个流程图共享的网站：<br><a href="https://www.processon.com/popular" target="_blank" rel="external">https://www.processon.com/popular</a></p>
<p>一次偶然的机会在微博里面看到 一图学git 的时候，发现这个图很实用</p>
<p><img src="http://ww2.sinaimg.cn/bmiddle/c5131475jw1f1batea592j21kw0fy0wn.jpg" alt="https://www.processon.com/view/56ca927ce4b0362f22d848b5"><br><a href="https://www.processon.com/view/56ca927ce4b0362f22d848b5" title="原样图" target="_blank" rel="external">原样图</a></p>
<p>然后在里面可以看出常用的流程，对于某些方面的需求还是很有必要的。</p>
<h3 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h3><ul>
<li><a href="https://www.processon.com/view/557051bee4b0d6a77d619124" target="_blank" rel="external">IOS开发</a></li>
<li><a href="https://www.processon.com/view/55783184e4b0d6a77d9f9560" target="_blank" rel="external">前端技能树</a></li>
<li><a href="https://www.processon.com/view/555097e7e4b09739f4652bf3" target="_blank" rel="external">Android Service总结1</a></li>
<li><a href="https://www.processon.com/view/5550a05ee4b09739f46585b0" target="_blank" rel="external">Android Service总结2</a></li>
<li><a href="https://www.processon.com/view/55b4e86ce4b0d2cdb5356e08" target="_blank" rel="external">Android测试工具</a></li>
<li><a href="https://www.processon.com/view/55f69023e4b0a8c6fae84984" target="_blank" rel="external">Android中主要类的关系图 Activity Class</a></li>
<li><a href="https://www.processon.com/view/55110a6ee4b00af64b0c3cba" target="_blank" rel="external">APP开发人员技能树</a></li>
<li><a href="https://www.processon.com/view/568bc9eae4b002e52c0fb427" target="_blank" rel="external">EventBus源码分析简要图</a></li>
<li><a href="https://www.processon.com/view/561ccd9de4b07efc017ca19b" target="_blank" rel="external">Android小说阅读器部分计划及流程</a></li>
<li><a href="https://www.processon.com/view/562847b4e4b04931dccccbfe" target="_blank" rel="external">View绘制流程</a></li>
<li><a href="https://www.processon.com/view/550cf083e4b0b74dae7c2c7d" target="_blank" rel="external">Android Drawable分类汇总</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JADX反编译源码更easy]]></title>
      <url>http://gdky005.com/2016/02/24/APK%E5%8F%8D%E7%BC%96%E8%AF%91Jadx/</url>
      <content type="html"><![CDATA[<h3 id="JADX反编译源码更easy"><a href="#JADX反编译源码更easy" class="headerlink" title="JADX反编译源码更easy"></a>JADX反编译源码更easy</h3><blockquote>
<p>一个Android反编译神器,不同于常见的 dex2jar,这个反编译器生成代码的 try/catch 次数更少, View也不再是数字id了,可读性更高</p>
</blockquote>
<p>Command line and GUI tools for produce Java source code from Android Dex and Apk files</p>
<p><img src="https://camo.githubusercontent.com/bd3c0ea851c23c4535e43590a86c940a0786faa6/687474703a2f2f736b796c6f742e6769746875622e696f2f6a6164782f6a6164782d6775692e706e67" alt=""></p>
<p>Downloads</p>
<ul>
<li><a href="https://drone.io/github.com/skylot/jadx/files" target="_blank" rel="external">unstable</a></li>
<li>from <a href="https://github.com/skylot/jadx/releases" target="_blank" rel="external">github</a></li>
<li>from <a href="http://sourceforge.net/projects/jadx/files/" target="_blank" rel="external">sourceforge</a></li>
</ul>
<p>参考地址：<a href="#"> https://github.com/skylot/jadx </a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android开发者提升技能水平的大招]]></title>
      <url>http://gdky005.com/2016/02/19/Android%E5%BC%80%E5%8F%91%E8%80%85%E6%8F%90%E5%8D%87%E6%8A%80%E8%83%BD%E6%B0%B4%E5%B9%B3%E7%9A%84%E5%A4%A7%E6%8B%9B/</url>
      <content type="html"><![CDATA[<p><br><br>国外的技术佬们是怎么提升技能的？我翻了翻，发现跟国内的同学差不多。</p>
<blockquote>
<p>本文是Denis Gobo做的一个调查表，调查程序员/开发者一般都是通过哪些途径来提升自己在技术领域的技能水平的《How Did You Improve Your Tech Skills》，文中给出了一些对程序员有用的方式方法，但是每个人的喜好不一样，所以各有偏重。不过，要是真的能按照所列出的这些方式方法去做，提升效果一定很大。</p>
</blockquote>
<h3 id="参加活动，沙龙，技术聚会："><a href="#参加活动，沙龙，技术聚会：" class="headerlink" title="参加活动，沙龙，技术聚会："></a>参加活动，沙龙，技术聚会：</h3><p>参加一些高质量的沙龙，总是有一些专家出席做相关演讲，比如最近的Node.js线下沙龙。</p>
<h3 id="参加培训："><a href="#参加培训：" class="headerlink" title="参加培训："></a>参加培训：</h3><p>公司总会为员工的科技技术做一些培训，有兴趣的可以参加提升自己的技能。培训就是一个最快的入门途径。</p>
<h3 id="参加讨论会："><a href="#参加讨论会：" class="headerlink" title="参加讨论会："></a>参加讨论会：</h3><p>参加一些类似于Google IO、Build、JavaWorld、WWDC、SQLPass等等，去接触一下你所使用的产品的真正的创造者。</p>
<h3 id="回答问题："><a href="#回答问题：" class="headerlink" title="回答问题："></a>回答问题：</h3><p>个人举得最有效的提升办法就是回答别人的问题，就像QA网站StackOverflow。</p>
<h3 id="边吃边学："><a href="#边吃边学：" class="headerlink" title="边吃边学："></a>边吃边学：</h3><p>如果你有吃饭的时间，那你就有学习的时间；如果你有和团队成员编写代码的时间，那你就有开发设计的时间。同理，蹲坑的时候也可以翻翻osc和eoe的客户端，想了解一些运营知识的，还可以关注知乎的运营问题。</p>
<h3 id="加入一个开源项目："><a href="#加入一个开源项目：" class="headerlink" title="加入一个开源项目："></a>加入一个开源项目：</h3><p>开源项目是最能锻炼人的一个途径，在这个过程里，你可以思考很多东西，比如说这个代码为什么要这样写？为什么要用这样的方式？使用了多少个设计模板等等，github账号你得有一个。</p>
<h3 id="读书，读代码，读博客："><a href="#读书，读代码，读博客：" class="headerlink" title="读书，读代码，读博客："></a>读书，读代码，读博客：</h3><p>可供程序员阅读的书可以说是汗牛充栋，这里就不列举了。阅读代码可以让你见识到更多的框架；可以让你发掘出更多的API。阅读你所关心的专家的博客，可以 帮助你学习到更多的代码组合和技巧，同时遇到不解的问题还可以留言提问，何乐而不为呢？。</p>
<h3 id="发表博客："><a href="#发表博客：" class="headerlink" title="发表博客："></a>发表博客：</h3><p>编写博客也可以让人保持清醒、更有斗志。在发表博客之后，读者会就你的错误提出指正，为了避免这样的情况，在发表之前会通读好多遍，并做一些研究，以防出现问题，这也是技能的一种进步和拓展。</p>
<h3 id="通过做Kata来实践："><a href="#通过做Kata来实践：" class="headerlink" title="通过做Kata来实践："></a>通过做Kata来实践：</h3><p>Kata是空手道里的招式，也可以用在编程技术里。可以阅读这篇博文加以理解，Using Code Katas to Improve Programming Skills。这个事情，臣妾搞不懂啊。</p>
<h3 id="写书："><a href="#写书：" class="headerlink" title="写书："></a>写书：</h3><p>在技术领域的大多数人都会写一本书，因为写一本书需要花很多时间去做调查和研究，除了要确保你的代码是正确的之外，你还要做很多其他的事情，在这之前你可 能只是个码农，但是一旦你出版了这本书之后你就是这方面的专家了。当然，写书最糟糕的地方就是最初的反馈信息里有很多别人指出的错误，如果脸皮不够厚的话 可能是一个棘手的问题。</p>
<p>这是一个伟大的事情。Android开发入门与实战（第2版）就是由eoe社区数十名版主和会员共同编著而成。</p>
<h3 id="看视频教程，听播客，看在线研讨会："><a href="#看视频教程，听播客，看在线研讨会：" class="headerlink" title="看视频教程，听播客，看在线研讨会："></a>看视频教程，听播客，看在线研讨会：</h3><p>从播客和在线研讨会上也能学到很多东西，关键是在自己的电脑上将播客和研讨会力学来的知识进行代码验证是最好的进步环节。</p>
<p>在给出这个调查表之后有很多程序员/开发者给出了回复和选择，一起来看看他们平时都是怎么来提高自己的技术水平的：</p>
<p><img src="http://s9.51cto.com/wyfs01/M01/32/AB/wKioJlKK1tLCQHKLAABzCAW0Jwk321.jpg" alt=""></p>
<p><strong>很明显，大多数人喜欢把阅读书本、代码和博客作为一种提高技能的手段。同时也有让人惊讶的现象：那就是通过做Kata来实践、参与开源项目、订阅科 技读物的比例实在是太低了，因为这三项在大部分人看来是最容易的，而且效率也是最显著的。另外，写一本书的竟然占到了8%，也很让人吃惊。除了这些，你觉 得还有哪些方式是可以提高你的技术水平的呢？</strong></p>
<p><br></p>
<p>来自：<a href="#"> http://mobile.51cto.com/anews-417838.htm </a></p>
<p>参考：<a href="#"> https://www.zhihu.com/question/20217218 </a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fragment not attached to Activity 异常]]></title>
      <url>http://gdky005.com/2015/11/27/Fragment-not-attached-to-Activity-%E5%BC%82%E5%B8%B8/</url>
      <content type="html"><![CDATA[<h3 id="关于Fragment（XXFragment）-not-attached-to-Activity-异常"><a href="#关于Fragment（XXFragment）-not-attached-to-Activity-异常" class="headerlink" title="关于Fragment（XXFragment） not attached to Activity 异常"></a>关于Fragment（XXFragment） not attached to Activity 异常</h3><p>出现该异常，是因为Fragment的还没有Attach到Activity时，调用了如getResource()等，需要上下文Content的函数。解决方法，就是等将调用的代码写在OnStart（）中。网上还有几处这样的参考：<a href="http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity%C2%A0" target="_blank" rel="external">http://stackoverflow.com/questions/10919240/fragment-myfragment-not-attached-to-activity </a> 回答的主要是在调用</p>
<pre><code>getResources().getString(R.string.app_name); 
</code></pre><p>之前增加一个判断isAdded(),两外说这个异常解决办法的有<br><a href="http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity" target="_blank" rel="external">http://stackoverflow.com/questions/6870325/android-compatibility-package-fragment-not-attached-to-activity</a></p>
<p>这个是针对另外一种情况下的解决方式。</p>
<h3 id="在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常"><a href="#在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常" class="headerlink" title="在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常"></a>在使用Fragment保存参数的时候，可能是因为需要保存的参数比较大或者比较多，这种情况下页会引起异常</h3><pre><code>Bundle b = new Bundle(); 
b.putParcelable(&quot;bitmap&quot;, bitmap2); 
imageRecognitionFragment.setArguments(b); 
</code></pre><p>设置好参数，并且添加hide(),add(),方法之后，需要commit()，来实现两个Fragment跳转的时候，这种情形下参数需要进行系统保存，但是这个时候你已经实现了跳转，系统参数却没有保存。此时就会报异常:</p>
<pre><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
</code></pre><h3 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h3><p>你并不需要系统保存的参数，只要你自己设置的参数能够传递过去，在另外一个Fragment里能够顺利接受就行了，现在android里提供了另外一种形式的提交方式commitAllowingStateLoss()，从名字上就能看出，这种提交是允许状态值丢失的。到此问题得到完美解决，值的传递是你自己控制的。</p>
<p>这里也说一下另外一个问题，bitmap 也可以通过Bundle传递的，使用putParacelable就可以了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Bug小记(**贵金属)]]></title>
      <url>http://gdky005.com/2015/11/20/Bug%E5%B0%8F%E8%AE%B0-%E8%B4%B5%E9%87%91%E5%B1%9E/</url>
      <content type="html"><![CDATA[<h1 id="Bug-小记（-贵金属）"><a href="#Bug-小记（-贵金属）" class="headerlink" title="Bug 小记（**贵金属）"></a>Bug 小记（**贵金属）</h1><p><strong>作者：球儿</strong></p>
<p>最近在修复 APP 的 Bug，遇到了几个因对 SDK 不熟 造成的 Bug。如下：</p>
<p>####Bug1：点击获取验证码后，没有进行倒计时，且不能再次点击</p>
<p>使用 GCD 写的倒计时，源代码：</p>
<pre><code>_isCountDown = YES;
__block int timeout=kCountdownTime; //倒计时时间
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,queue);
dispatch_source_set_timer(_timer,dispatch_walltime(NULL, 0),1.0*NSEC_PER_SEC, 0); //每秒执行
dispatch_source_set_event_handler(_timer, ^{
    if(timeout&lt;=0){ //倒计时结束，关闭
        dispatch_source_cancel(_timer);
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateNormal];
            [self.getSmsCodeBtn setTitle:@&quot;重新获取&quot; forState:UIControlStateDisabled];

            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_LOGINBTN_AVAILABLE_NORMAL) forState:UIControlStateNormal];

            [self.getSmsCodeBtn setEnabled:YES];
            _isCountDown = NO;
        });
    }else{
        NSString *strTime = [NSString stringWithFormat:@&quot;%ds后重发&quot;,timeout];
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateNormal];
            [self.getSmsCodeBtn setTitle:strTime forState:UIControlStateDisabled];

            [self.getSmsCodeBtn setTitleColor:ColorWithHexString(GJS_COLOR_GETCODEBTN_UNAVAILABLE) forState:UIControlStateNormal];
        });
        timeout--;

    }
});
dispatch_resume(_timer);
</code></pre><p>如上所示的源码，在 iOS7 上倒计时按钮上的文字不会变化，在 iOS 8,iOS9 上都是没问题的，我也郁闷了很久。各种百度未果后转向 Google,也有人遇到这样的问题，但是只搜索到一篇真正能解决这个问题的文章 <a href="http://blog.csdn.net/zhangyanshen/article/details/46910515" title="http://blog.csdn.net/zhangyanshen/article/details/46910515" target="_blank" rel="external">http://blog.csdn.net/zhangyanshen/article/details/46910515</a></p>
<font color="green"><strong>解决方案：</strong></font>

<p><code>[sendAuthCodeBtn setTitle:@&quot;发送验证码&quot; forState:UIControlStateDisabled];</code> </p>
<p>关键在于这行代码。设置了禁用状态下的文字。顺利解决了 这个 Bug。</p>
<p><br></p>
<h4 id="Bug1：倒计时-UIButton-上的文字变更会有闪烁效果"><a href="#Bug1：倒计时-UIButton-上的文字变更会有闪烁效果" class="headerlink" title="Bug1：倒计时 UIButton 上的文字变更会有闪烁效果"></a>Bug1：倒计时 UIButton 上的文字变更会有闪烁效果</h4><p><br><br>UIButton 设置 title时会闪烁。</p>
<p><font color="brown"><strong>原因：</strong></font>UIButton 的 buttonType 是 System 类型时会出现该种问题</p>
<p><font color="green"><strong>解决方案：</strong></font>UIButton 的 buttonType 设置为 Custom 类型时不会出现闪烁。</p>
<p><br></p>
<h4 id="Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变"><a href="#Bug2：在工程中添加plist-文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变" class="headerlink" title="Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变"></a>Bug2：在工程中添加plist 文件，用代码对其进行写入操作，在模拟器中按代码执行，但在真机上plist中内容未改变</h4><p><br><br>plist 文件中是一个数组，元素是多个字典，在模拟器上运行一切正常，但测试人员用真机测试时发现问题，无法写入到 plist 文件中。</p>
<p><font color="brown"><strong>原因：</strong></font> 打包在 ipa 的文件是无法更改的。一句话：无权限修改（知道真相的我眼泪掉下来~)，只可进行读取操作。</p>
<p><font color="green"><strong>解决方案：</strong></font>在 app 启动的时候判断是否在 Document 文件夹下存在相同的 plsit 文件。 不存在，获取沙盒下 plist 文件中的内容，并写入Document 文件夹下的 plsit 文件。存在则不做任何处理。（之所以选择这种方式而不选择直接将内容用代码写入 Document 文件夹下来解决这个问题，是因为个人认为在开发时方便对工程中plsit 文件内容的更改）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用groovy读取excel里面内容]]></title>
      <url>http://gdky005.com/2015/11/20/%E4%BD%BF%E7%94%A8groovy%E8%AF%BB%E5%8F%96excel%E9%87%8C%E9%9D%A2%E5%86%85%E5%AE%B9/</url>
      <content type="html"><![CDATA[<h1 id="使用groovy读取excel里面内容"><a href="#使用groovy读取excel里面内容" class="headerlink" title="使用groovy读取excel里面内容"></a>使用groovy读取excel里面内容</h1><h3 id="需要依赖"><a href="#需要依赖" class="headerlink" title="需要依赖"></a>需要依赖</h3><p><a href="http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip" target="_blank" rel="external">apache.org/poi</a></p>
<h3 id="项目目录结构："><a href="#项目目录结构：" class="headerlink" title="项目目录结构："></a>项目目录结构：</h3><p><img src="http://m1.yea.im/43k.jpg" alt=""></p>
<p>项目 assets 下面放了一个people.xlsx文件</p>
<p><img src="http://m1.yea.im/43i.jpg" alt=""></p>
<h3 id="PS："><a href="#PS：" class="headerlink" title="PS："></a><strong>PS</strong>：</h3><ul>
<li>本文依赖 <a href="http://blog.csdn.net/andyxuq/article/details/7916098" target="_blank" rel="external">Groovy读取excel文件</a> 尝试读取后，发现不能运行</li>
<li>下载 Apache的POI组建 遇到问题</li>
</ul>
<h3 id="项目的源码："><a href="#项目的源码：" class="headerlink" title="项目的源码："></a>项目的源码：</h3><pre><code>import org.apache.poi.ss.usermodel.Row
import org.apache.poi.xssf.usermodel.XSSFCell
import org.apache.poi.xssf.usermodel.XSSFRow
import org.apache.poi.xssf.usermodel.XSSFSheet
import org.apache.poi.xssf.usermodel.XSSFWorkbook
/**
 * Created by WangQing on 15/11/20.
 */
class TestGroovy {



    void updateResourceDate(){
        def filePath = &quot;./assets/people.xlsx&quot;


        File file = new File(filePath)

        FileInputStream is = new FileInputStream(file);

        XSSFWorkbook workbook = new XSSFWorkbook(is);
        workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);

        //循环sheet
        (0..&lt;workbook.sheetIterator().collect {return it}.@size).each {s-&gt;
            XSSFSheet sheet = workbook.getSheetAt(s);
            int rows = sheet.physicalNumberOfRows;

            //忽略第一行,标题行
            (1..&lt;rows).each{r-&gt;
                XSSFRow row = sheet.getRow(r);
                def cells = row.physicalNumberOfCells;

                (0..&lt;cells).each{c-&gt;
                    XSSFCell cell = row.getCell(c);

                    def name = &quot;&quot;;

                    switch (c) {
                        case 0:
                            name = &quot;A:&quot;
                            break;
                        case 1:
                            name = &quot;B:&quot;
                            break
                        case 2:
                            name = &quot;C:&quot;
                            break
                        case 3:
                            name = &quot;D:&quot;
                            break
                    }
                    print name + &quot;  &quot;+cell+ &quot;, &quot;;


                }
                println &quot;&quot;;
            }
        }
    }

    static main(args) {
        TestGroovy a = new TestGroovy();
        a.updateResourceDate();
    }
}
</code></pre><p>项目运行结果：<br><img src="http://m1.yea.im/43n.jpg" alt=""></p>
<h3 id="Apache的POI组建-遇到问题"><a href="#Apache的POI组建-遇到问题" class="headerlink" title="Apache的POI组建 遇到问题"></a>Apache的POI组建 遇到问题</h3><p>首先进入网址：<a href="http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip" target="_blank" rel="external">http://www.apache.org/dyn/closer.lua/poi/release/bin/poi-bin-3.13-20150929.zip</a></p>
<p>下载文件的时候，一般在工程里面依赖的是 jar,但是下面的是 .zip 很是疑惑,这个文件 26.4M，虽然不相信，但是下载下来后解压开，才明白：<br><img src="http://m1.yea.im/43l.jpg" alt=""></p>
<p>其中该项目中使用了<br><img src="http://m1.yea.im/43j.jpg" alt=""><br>xmlbeans-2.6.0.jar</p>
<p>这个文件在上面的 lib 下面。</p>
<p>因为我使用的mac 2010 office， 所以文件保存的是：.xlsx。开始使用的 </p>
<p><em>HSSFRow</em>  ，发现报错：<br>    Request processing failed; nested exception is org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. POI only supports OLE2 Office documents</p>
<pre><code>POIFSFileSystem excelFile = new POIFSFileSystem(new FileInputStream(&quot;xxx.xlsx&quot;));
HSSFWorkbook wb = new HSSFWorkbook(excelFile);
</code></pre><p>原因是：<br>HSSFWorkbook:是操作Excel2003以前（包括2003）的版本，扩展名是.xls<br>XSSFWorkbook:是操作Excel2007的版本，扩展名是.xlsx</p>
<p>所以，你在使用的时候，如果是2003版的，将项目的中  XSS 替换成 HSS。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[凯哥高质量文章系列]]></title>
      <url>http://gdky005.com/2015/11/20/%E5%87%AF%E5%93%A5%E9%AB%98%E8%B4%A8%E9%87%8F%E6%96%87%E7%AB%A0%E7%B3%BB%E5%88%97/</url>
      <content type="html"><![CDATA[<p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
<h1 id="凯哥系列："><a href="#凯哥系列：" class="headerlink" title="凯哥系列："></a>凯哥系列：</h1><h2 id="1-Activity启动过程全解析"><a href="#1-Activity启动过程全解析" class="headerlink" title="1. Activity启动过程全解析"></a>1. <a href="http://www.devtf.cn/?p=1101" target="_blank" rel="external">Activity启动过程全解析</a></h2><h2 id="2-framework-Activity界面显示全解析"><a href="#2-framework-Activity界面显示全解析" class="headerlink" title="2. framework-Activity界面显示全解析"></a>2. <a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="external">framework-Activity界面显示全解析</a></h2><p>注：该文是我看着凯哥的文章手打的，可能有很多错误的地方，可以直接看凯哥的博客。手打的目的是为了让自己更加准确的理解里面的一些概念</p>
<h3 id="看文章的记录："><a href="#看文章的记录：" class="headerlink" title="看文章的记录："></a>看文章的记录：</h3><p>1.App启动<br>2.App入口<br>3.Launcher?<br>4.AMS??<br>5.Binder是神马？怎么进行IPC通信？<br>6.Activity生命周期是被谁 什么时候调用的？</p>
<h3 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h3><p>1.开机第一个zygote（受精卵的意思） 进程创建 —》点击桌面图标 —》进入App的流程，从源码的角度<br>2.ActivityManagerServices(即：AMS)， ActivityStack, ActivityThread, Instrumentation等 framework 基础类的作用和相互关系</p>
<p>3.AMS和ActivityThread 利用Binder 进行IPC通信， AMS和ActivityThread控制Activity生命周期的作用于配合</p>
<p>4.Activity相关的framework问题</p>
<h3 id="主要对象功能介绍："><a href="#主要对象功能介绍：" class="headerlink" title="主要对象功能介绍："></a>主要对象功能介绍：</h3><p>1.ActivityManagerServices（AMS):服务对象，负责所有的Activity的生命周期；<br>2.ActivityThread:App的真正入口。打开App->main(),开始消息队列循环，传说中的UI线程或者是主线程，与AMS配合，一起完成Activity的管理工作；<br>3.ApplicationThread: 实现AMS和ActivityThread交互，在AMS需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通信。<br>4.ApplicationThreadProxy: 是ApplicationThread 在服务器端的代理，负责和客户端中的ApplicationThread通信，AMS就是通过该代理与ActivityThread进行通信。<br>5.Instrumentation: 每个应用只有一个对象，每个Activity都有一个该对象的引用，它可以理解为 应用进程管家 ，ActivityThread 要创建或暂停某个Activity时，都需要通过Instrumentation进行操作。<br>6.ActivityStack： Activity在AMS中的栈管理，用来记录启动的Activity的先后关系，状态信息。通过ActivityStack决定是否需要启动新的进程。<br>7.ActivityRecord: ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，记录Activity的状态和其他管理信息，其实就是服务器端的Activity对象的映像。<br>8.TaskRecord: AMS 抽象出来的一个 『任务』概念，是记录ActivityRecord的栈，一个『Task』 包含若干个 ActivityRecord，AMS用TaskRecord确保Activity启动和退出的顺序，如果你清楚 Activity的4中launchMode,那么对这个概念就不会太陌生。</p>
<h3 id="主要流程介绍"><a href="#主要流程介绍" class="headerlink" title="主要流程介绍"></a>主要流程介绍</h3><ul>
<li>zygote 是神马？<br>程序 Crash 的时候，打印红色的log通常带有这个<br>Android基于Linux系统，在linux中，所以的进程都是init进行直接或是间接fork出来的，zygote进行也是！</li>
</ul>
<p>Android 是基于Linux System的，当我们的手机 开机的时候，Linux,内核加载成功后 就会启动一个 『init』进程</p>
<p>我们都知道，每一个App其实都是：</p>
<ul>
<li>一个单独的dalvik 虚拟机<ul>
<li>单独的进程</li>
</ul>
</li>
</ul>
<p>当前系统 里面的第一个 zygote 进程 运行后，再开 App, 就相当于 开启了一个新的进程。而为了实现资源共用 和 更快 启动速度，Android系统开启新进程方式，通过fork第一个zygote进程实现。所以说，除了第一个zygote进程，其他应用所在的进程都是 zygote 的子进程。 这下就明白为什么这个进程叫做 『受精卵』了，一万年就像受精卵一样，它快速分裂，并且产生遗传物质一样的细胞！</p>
<h3 id="SystemServer是什么？-作用？它与zygote有什么样的一重关系？"><a href="#SystemServer是什么？-作用？它与zygote有什么样的一重关系？" class="headerlink" title="SystemServer是什么？ 作用？它与zygote有什么样的一重关系？"></a>SystemServer是什么？ 作用？它与zygote有什么样的一重关系？</h3><p>首先，要告诉你的是 SystemServer 也是一个进程，而且是由zygote进程fork出来的！</p>
<p>这个进程是 Android Framework 里面两个非常重要的进程之一 ——- 另外一个就是 上面的 zygote 进程。</p>
<p>为什么说 SystemServer 非常重要？因为系统 里面的重要服务器都在这个进程里面开启，比如： ActivityManagerService、 PackageManagerService, WindowManagerService 等等，看着是不是都很眼熟？</p>
<p>那么这些服务是怎么开启起来的呢?</p>
<p>在zygote 开启的时候，会调用 ZygoteInit.main初始化</p>
<pre><code>public static void main(String argv[]) {

     ...ignore some code...

    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true
     boolean startSystemServer = false;
     for (int i = 1; i &lt; argv.length; i++) {
                if (&quot;start-system-server&quot;.equals(argv[i])) {
                    startSystemServer = true;
                } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                    abiList = argv[i].substring(ABI_LIST_ARG.length());
                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());
                } else {
                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);
                }
            }

            ...ignore some code...

         //开始fork我们的SystemServer进程
     if (startSystemServer) {
                startSystemServer(abiList, socketName);
         }

     ...ignore some code...

}
</code></pre><p>关键代码：<br>    if (“start-system-server”.equals(argv[i])) {<br>                        startSystemServer = true;<br>    }<br>    ~~~<br>    //开始fork我们的SystemServer进程<br>    if (startSystemServer) {<br>           startSystemServer(abiList, socketName);<br>    }</p>
<p>我们看下startSystemServer()做了些什么:</p>
<pre><code>public static void main(String argv[]) {

     ...ignore some code...

    //在加载首个zygote的时候，会传入初始化参数，使得startSystemServer = true
     boolean startSystemServer = false;
     for (int i = 1; i &lt; argv.length; i++) {
                if (&quot;start-system-server&quot;.equals(argv[i])) {
                    startSystemServer = true;
                } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                    abiList = argv[i].substring(ABI_LIST_ARG.length());
                } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                    socketName = argv[i].substring(SOCKET_NAME_ARG.length());
                } else {
                    throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]);
                }
            }

            ...ignore some code...

         //开始fork我们的SystemServer进程
     if (startSystemServer) {
                startSystemServer(abiList, socketName);
         }

     ...ignore some code...

}
</code></pre><p>我们看下startSystemServer()做了些什么</p>
<pre><code>/**留着这个注释，就是为了说明SystemServer确实是被fork出来的
 * Prepare the arguments and fork for the system server process.
 */
private static boolean startSystemServer(String abiList, String socketName)
        throws MethodAndArgsCaller, RuntimeException {

     ...ignore some code...

    //留着这段注释，就是为了说明上面ZygoteInit.main(String argv[])里面的argv就是通过这种方式传递进来的
    /* Hardcoded command line to start the system server */
    String args[] = {
        &quot;--setuid=1000&quot;,
        &quot;--setgid=1000&quot;,
        &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1032,3001,3002,3003,3006,3007&quot;,
        &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities,
        &quot;--runtime-init&quot;,
        &quot;--nice-name=system_server&quot;,
        &quot;com.android.server.SystemServer&quot;,
    };

    int pid;
    try {
        parsedArgs = new ZygoteConnection.Arguments(args);
        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);

    //确实是fuck出来的吧，我没骗你吧~不对，是fork出来的 -_-|||
        /* Request to fork the system server process */
        pid = Zygote.forkSystemServer(
                parsedArgs.uid, parsedArgs.gid,
                parsedArgs.gids,
                parsedArgs.debugFlags,
                null,
                parsedArgs.permittedCapabilities,
                parsedArgs.effectiveCapabilities);
    } catch (IllegalArgumentException ex) {
        throw new RuntimeException(ex);
    }

    /* For child process */
    if (pid == 0) {
        if (hasSecondZygote(abiList)) {
            waitForSecondaryZygote(socketName);
        }

        handleSystemServerProcess(parsedArgs);
    }

    return true;
}
</code></pre><h3 id="ActivityManagerService是什么？什么时候创建？作用"><a href="#ActivityManagerService是什么？什么时候创建？作用" class="headerlink" title="ActivityManagerService是什么？什么时候创建？作用?"></a>ActivityManagerService是什么？什么时候创建？作用?</h3><p>ActivityManagerService,简称 AMS，服务器端对象，负责系统中所有Activity的生命周期。</p>
<p>AMS 进行初始化的时机很明确，就是 SystemServer 进程开启的时候，就会初始化 ActivityManagerService </p>
<pre><code>public final class SystemServer {

    //zygote的主入口
    public static void main(String[] args) {
        new SystemServer().run();
    }

    public SystemServer() {
        // Check for factory test mode.
        mFactoryTestMode = FactoryTest.getMode();
    }

    private void run() {

        ...ignore some code...

        //加载本地系统服务库，并进行初始化 
        System.loadLibrary(&quot;android_servers&quot;);
        nativeInit();

        // 创建系统上下文
        createSystemContext();

        //初始化SystemServiceManager对象，下面的系统服务开启都需要调用SystemServiceManager.startService(Class&lt;T&gt;)，这个方法通过反射来启动对应的服务
        mSystemServiceManager = new SystemServiceManager(mSystemContext);

        //开启服务
        try {
            startBootstrapServices();
            startCoreServices();
            startOtherServices();
        } catch (Throwable ex) {
            Slog.e(&quot;System&quot;, &quot;******************************************&quot;);
            Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);
            throw ex;
        }

        ...ignore some code...

    }

    //初始化系统上下文对象mSystemContext，并设置默认的主题,mSystemContext实际上是一个ContextImpl对象。调用ActivityThread.systemMain()的时候，会调用ActivityThread.attach(true)，而在attach()里面，则创建了Application对象，并调用了Application.onCreate()。
    private void createSystemContext() {
        ActivityThread activityThread = ActivityThread.systemMain();
        mSystemContext = activityThread.getSystemContext();
        mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);
    }

    //在这里开启了几个核心的服务，因为这些服务之间相互依赖，所以都放在了这个方法里面。
    private void startBootstrapServices() {

        ...ignore some code...

        //初始化ActivityManagerService
        mActivityManagerService = mSystemServiceManager.startService(
                ActivityManagerService.Lifecycle.class).getService();
        mActivityManagerService.setSystemServiceManager(mSystemServiceManager);

        //初始化PowerManagerService，因为其他服务需要依赖这个Service，因此需要尽快的初始化
        mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);

        // 现在电源管理已经开启，ActivityManagerService负责电源管理功能
        mActivityManagerService.initPowerManagement();

        // 初始化DisplayManagerService
        mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);

    //初始化PackageManagerService
    mPackageManagerService = PackageManagerService.main(mSystemContext, mInstaller,
       mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);

    ...ignore some code...

    }

}
</code></pre><p>经过以上， ActivityManagerService对象已经创建好了，并且完成了成员变量初始化，在这之前，调用createSystemContext()创建系统上下文，也完成 mSystemContext 和 ActivityThread 的创建，注意，这是系统开启的流程，在这之后，会开启系统的Launcher 程序，完成系统界面的加载和显示。</p>
<p>你可能会好奇，为什么上文说 AMS是服务端对象? 下面给你介绍 Android 系统里面的服务器 和 客户端的概念。</p>
<p>其实B/S 不仅存在 web开发中，也存在 Android的框架设计里面。服务器端指的是所有App公用的系统服务，比如给提到的 ActivityManagerService， 和前面提到的 PackageManagerService、WindowManagerService等等，这些基础的系统服务 是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你打开一个App， 那么我们知道了 包名和 MainActivity类名 之后就可以打开</p>
<pre><code>Intent intent = new Intent(Intent.ACTION_MAIN);  
intent.addCategory(Intent.CATEGORY_LAUNCHER);              
ComponentName cn = new ComponentName(packageName, className);              
intent.setComponent(cn);  
startActivity(intent); 
</code></pre><p>但是，我们的app通过调用startActivity() 并不能直接打开另外一个App, 这个方法会通过一系列的调用，最后还告诉AMS ”我要打开这个App, 我知道他们的住址和名字，你帮我打开吧！” 所以 AMS来通知 zygote 进程来fork一个新进程，来开启我们的目标App。这就像是浏览器要打开一个超链接一样，浏览器把网址发送到服务器，然后服务器吧需要的资源文件发送到客户端。</p>
<p>知道了 Android Framework的客户端服务器架构之后，我们还需要了解一件事，那就是我们的App 和 AMS（SystemServer进行） 还有zygote 进程分贝属于三个进程，他们怎么通信呢？</p>
<p>App与AMS 通过binder进行IPC通信，AMS（进程） 与 zygote通过 Socket 进行IPC通信。</p>
<p>那么AMS有什么用呢？  前面我们知道， 如果打开一个app, 需要AMS通知 zygote 进程，除此之后，其实所有的Activity 的开启、暂停、关闭 都需要 AMS来控制，所有我们说，ASM负责系统中所有的Activity的生命周期。</p>
<p>在Android系统中，任何一个Activity 的启动都是由AMS和应用程序进程（主要是ActivityThread） 相互配合来完成的。 AMS服务统一调度系统中的所有进程的Activity启动，而每个Activity 的启动过程则由其所属的进程具体来完成。</p>
<p>这样说可能比较抽象，没关系，下面专门来介绍 ASM和ActivityThread如果一起合作控制Activity 的生命周期。</p>
<h3 id="Launche是什么？-什么时候启动？"><a href="#Launche是什么？-什么时候启动？" class="headerlink" title="Launche是什么？ 什么时候启动？"></a>Launche是什么？ 什么时候启动？</h3><p>当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。 但是，你有没有思考过 Launcher 到底一个什么东西呢？</p>
<p>Launcher 本质也是一个应用程序，和我们的App一样，也是继承自Activity。</p>
<p>packages/apps/Launcher2/src/com/android/launcher2/Launcher.java<br>    public final class Launcher extends Activity<br>            implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks,<br>                       View.OnTouchListener {<br>                       }</p>
<p>Launcher 实现了点击，长按等回到接口，来接受用户的输入。其实本质和我们的App一样，点击图标 然后 startActivity（） 发送到对应的Intent 请求呗！就是如此的简单。</p>
<p><img src="DraggedImage.png" alt=""></p>
<p>程序列表里面：<br><img src="DraggedImage-1.png" alt=""></p>
<p>可以看到的是，调用的是：<br>    mLauncher.startActivitySafely(v, appInfo.intent, appInfo);</p>
<p>和上面的一样，这叫什么？ 这叫殊途同归！</p>
<p>所以现在我们明白了一件事：不管从哪里点击图标，调用的都是<br>    Launcher.startActivitySafely()</p>
<p>下面来看看 Launcher.startActivitySafely()到底做了什么事情<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>
<p>调用了startAcitivity(v,intent,tag)<br>    boolean startActivitySafely(View v, Intent intent, Object tag) {<br>            boolean success = false;<br>            try {<br>                success = startActivity(v, intent, tag);<br>            } catch (ActivityNotFoundException e) {<br>                Toast.makeText(this, R.string.activity_not_found, Toast.LENGTH_SHORT).show();<br>                Log.e(TAG, “Unable to launch. tag=” + tag + “ intent=” + intent, e);<br>            }<br>            return success;<br>        }</p>
<p>这里会调用Activity.startActivity(intent, ops.toBundle()) ,这个方法熟悉吗？ 这就是我们常用到的 Activity.startActivity(Intent)的重载函数，而且设置了：<br>    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</p>
<h3 id="Instrumentation是什么？和ActivityThread-是什么关系？"><a href="#Instrumentation是什么？和ActivityThread-是什么关系？" class="headerlink" title="Instrumentation是什么？和ActivityThread 是什么关系？"></a>Instrumentation是什么？和ActivityThread 是什么关系？</h3><p>每个 Activity 都持有Instrumentation 对象的引用，但是整个进程 都只会存在一个Instrumentation 对象。 当 startActivityForResult()调用之后，时间还调用了 mInstrumentation.execStartActivity()</p>
<pre><code>boolean startActivity(View v, Intent intent, Object tag) {

        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        try {
            boolean useLaunchAnimation = (v != null) &amp;&amp;
                    !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION);

            if (useLaunchAnimation) {
                if (user == null || user.equals(android.os.Process.myUserHandle())) {
                    startActivity(intent, opts.toBundle());
                } else {
                    launcherApps.startMainActivity(intent.getComponent(), user,
                            intent.getSourceBounds(),
                            opts.toBundle());
                }
            } else {
                if (user == null || user.equals(android.os.Process.myUserHandle())) {
                    startActivity(intent);
                } else {
                    launcherApps.startMainActivity(intent.getComponent(), user,
                            intent.getSourceBounds(), null);
                }
            }
            return true;
        } catch (SecurityException e) {
        ...
        }
        return false;
    }
</code></pre><p>有一件事情必须说清楚，那就是 Instrumentation类这么重要，为啥我的开发过程中，没有发现他的踪迹呢？</p>
<p>是的，Instrumentation 非常重要，对Activity 生命周期方法的调用根本就离不开他，他可以说是一个大管家，但是，这个大管家比较害羞，是一个女的，管内不管外，是老板娘！！</p>
<p>那你可能要问老板是who?<br>老板当然是 大名鼎鼎的 ActivityThread了</p>
<p>ActivityThread 就是传说中的 UI线程，前面提到， App和AMS是通过Binder 传递信息的，那么ActivityThread 就是专门与AMS 的外交工作。</p>
<p>ASM说：『ActivityThread， 你给我暂停一个Activity！』</p>
<p>ActivityThread 说:”没问题！” 然后转身 和 Instrumentation 说：『老婆，AMS 让暂停一个Activity ，我这里忙着呢，你快去帮我把这事办了吧』</p>
<p>于是，Instrumentation 就去把事儿搞定了。<br>所以说，AMS是董事会， 负责 指挥和调度， Activity 是老板，虽然说家里的事情自己说了算，但是需要听ASM的指挥，而Instrumentation 则是老板娘，负责家里的大事小事，但是一般不抛头露面，听一家之主 ActivityThread 的安排。</p>
<h3 id="如何理解-AMS-和-ActivityThread-之间的-Binder-通信？"><a href="#如何理解-AMS-和-ActivityThread-之间的-Binder-通信？" class="headerlink" title="如何理解 AMS 和 ActivityThread 之间的 Binder 通信？"></a>如何理解 AMS 和 ActivityThread 之间的 Binder 通信？</h3><p>前面提到 调用 startActivity()的时候，时间调用了<br>    mInstrumentation.execStartActivity()</p>
<p>里面又调用了：<br>    ActivityManagerNative.getDefault()<br>                    .startActivity</p>
<p>这里的ActivityManagerNative.getDefault返回的就是ActivityManagerService的远程接口，即ActivityManagerProxy。</p>
<p>Binder 本质只是一种底层通信方式，和具体的服务没有关系。为了提供具体服务，Server 必须提供一套 接口函数，以便client 通过远程访问使用 各种服务。这时通常采用 Proxy 模式；将接口函数定义在一个 首先类中，Server 和 client 都会以抽象类为基准 实现所有 接口函数， 所不同的是Server 端 是真正 的功能实现，而Client 是对 这些 函数 远程调用请求的包装。</p>
<p>为了更明白的说明 客户端 和 服务器端 之间的 Binder 通信，看下面的 ActivityManagerService 和他在 客户端的代理类  ActivityManagerProxy：</p>
<p>AMS， 和 AMP 都实现利率同一个接口： IActivityManager。<br>    class ActivityManagerProxy implements IActivityManager{}</p>
<pre><code>public final class ActivityManagerService extends ActivityManagerNative{}

public abstract class ActivityManagerNative extends Binder implements IActivityManager{}
</code></pre><p>虽然都实现了同一个接口，但是代理对象 ActivityManagerProxy 并不会对这些方法真正意义上的实现， ActivityManagerProxy 只是通过这种方式对方法的参数进行打包（因为都实现了相同的接口，所有可以保证 同一个方法有相同有相同的参数，即对要传输给服务器的数据进行打包），真正实现的是 ActivityManagerService。</p>
<p>但是这个地方并不是直接由 客户端 传递给 服务器，而是通过Binder 驱动进行中转。其实对 Binder 驱动不了解，我们可以把它当做一个中转站， 客户端调用 ActivityManagerProxy接口里面的方法，把数据传递给 Binder驱动，然后Binder驱动就会把这些东西转发给 服务器的ActivityManagerService， 由AMS去真正 的是是具体的操作。</p>
<p>但是 Binder 只能传递数据，并不知道 要调用AMS 哪个方法，所以在数据中会添加 方法的唯一标码，比如<br>    public int startActivity(IApplicationThread caller, String callingPackage, Intent intent,<br>                String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException {<br>            Parcel data = Parcel.obtain();<br>            Parcel reply = Parcel.obtain();</p>
<pre><code>    ...ignore some code...

    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0);
    reply.readException();
    int result = reply.readInt();
    reply.recycle();
    data.recycle();
    return result;
}
</code></pre><p>上面的 START_ACTIVITY_TRANSACTION 就是方法的标示，data 是要传输给 Binder 驱动的数据，reply 是接受操作的返回值。</p>
<p>即：<br>客户度：ActivityManagerProxy ====> Binder驱动 ====》ActivityManagerService：服务器</p>
<p>而且由于继承了同样的公共接口类， ActivityManagerProxy 提供了 与 ActivityMangerService 一样的函数原型，使用户感觉不出 Server 是允许在本地还是原厂，从而可以更方便 的调用这些红药的服务器系统。</p>
<p>但是！ 这里 Binder通信是单向的，即：ActivityManagerProxy 指向ActivityManagerService ，如果 AMS要通知 ActivityThread 做一些事情，应该怎么办呢？ </p>
<p>还是通过 Binder 通信， 不过是换了 另外一对，换成了 ApplicationThread 和 ApplicationThreadProxy。</p>
<p>客户端：ApplicationThread \&lt;=== Binder驱动 \&lt;=== ApplicationThreadProxy：服务器</p>
<p>他们也实现了相同的接口 IApplicationThread:<br>    private class ApplicationThread extends ApplicationThreadNative {}</p>
<pre><code>public abstract class ApplicationThreadNative extends Binder implements IApplicationThread{}

class ApplicationThreadProxy implements IApplicationThread {}
</code></pre><h3 id="AMS-接收到-客户端的请求后，如果开启一个Activity？"><a href="#AMS-接收到-客户端的请求后，如果开启一个Activity？" class="headerlink" title="AMS 接收到 客户端的请求后，如果开启一个Activity？"></a>AMS 接收到 客户端的请求后，如果开启一个Activity？</h3><p>OK，点击桌面图标调用 startActivity(), 终于把数据和要开启的Activity 请求发送到了AMS。说了这么多，其实这些都是在一瞬间完成，下面看看ASM到底做了什么？</p>
<p>注：前方高能，方法调用链接很强！</p>
<p>调用startActivity（）<br>    @Override<br>        public final int startActivity(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options) {<br>            return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,<br>                resultWho, requestCode, startFlags, profilerInfo, options,<br>                UserHandle.getCallingUserId());<br>        }</p>
<p>调用startActivityAsUser（）<br>    @Override<br>        public final int startActivityAsUser(IApplicationThread caller, String callingPackage,<br>                Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,<br>                int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {</p>
<pre><code>        ...ignore some code...

    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,
            resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
            profilerInfo, null, null, options, userId, null, null);
}
</code></pre><p>这里出现了一个 新对象ActivityStackSupervisor,通过这个类可以实现对 ActivityStack的部分操作<br>     final int startActivityMayWait(IApplicationThread caller, int callingUid,<br>                String callingPackage, Intent intent, String resolvedType,<br>                IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,<br>                IBinder resultTo, String resultWho, int requestCode, int startFlags,<br>                ProfilerInfo profilerInfo, WaitResult outResult, Configuration config,<br>                Bundle options, int userId, IActivityContainer iContainer, TaskRecord inTask) {</p>
<pre><code>...ignore some code...

  int res = startActivityLocked(caller, intent, resolvedType, aInfo,
        voiceSession, voiceInteractor, resultTo, resultWho,
        requestCode, callingPid, callingUid, callingPackage,
        realCallingPid, realCallingUid, startFlags, options,
        componentSpecified, null, container, inTask);

...ignore some code...

}
</code></pre><p>继续调用 startActivityLocked()</p>
<pre><code>final int startActivityLocked(IApplicationThread caller,
            Intent intent, String resolvedType, ActivityInfo aInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode,
            int callingPid, int callingUid, String callingPackage,
            int realCallingPid, int realCallingUid, int startFlags, Bundle options,
            boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container,
            TaskRecord inTask) {

              err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor,
              startFlags, true, options, inTask);
        if (err &lt; 0) {
            notifyActivityDrawnForKeyguard();
        }
        return err;
    }
</code></pre><p>调用startActivityUncheckedLocked(),此时要启动的Activity已经通过检查，被认为是一个正常的请求。</p>
<p>终于调用到 ActivityStack的 startActivityLocked(ActivityRecord r, boolean newTask,boolean doResume, boolean keepCurTransition, Bundle options)</p>
<p>ActivityRecord代表的就是要开启的Activity对象， 里面分装了很多信息，比如所在 ActivityTask等，如果是首次打开应用，那么 这个Activity 会放到Activity Task 的栈顶，</p>
<pre><code>final int startActivityUncheckedLocked(ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags,
            boolean doResume, Bundle options, TaskRecord inTask) {

            ...ignore some code...

            targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options);

            ...ignore some code...

             return ActivityManager.START_SUCCESS;
            }
</code></pre><p>调用 ActivityStack.startActivityLocked()</p>
<pre><code>final void startActivityLocked(ActivityRecord r, boolean newTask,
            boolean doResume, boolean keepCurTransition, Bundle options) {

        //ActivityRecord中存储的TaskRecord信息
        TaskRecord rTask = r.task;

         ...ignore some code...

        //如果不是在新的ActivityTask(也就是TaskRecord)中的话，就找出要运行在的TaskRecord对象
     TaskRecord task = null;
        if (!newTask) {
            boolean startIt = true;
            for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) {
                task = mTaskHistory.get(taskNdx);
                if (task.getTopActivity() == null) {
                    // task中的所有Activity都结束了
                    continue;
                }
                if (task == r.task) {
                    // 找到了
                    if (!startIt) {
                        task.addActivityToTop(r);
                        r.putInHistory();
                        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,
                                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,
                                (r.info.flags &amp; ActivityInfo.FLAG_SHOW_ON_LOCK_SCREEN) != 0,
                                r.userId, r.info.configChanges, task.voiceSession != null,
                                r.mLaunchTaskBehind);
                        if (VALIDATE_TOKENS) {
                            validateAppTokensLocked();
                        }
                        ActivityOptions.abort(options);
                        return;
                    }
                    break;
                } else if (task.numFullscreen &gt; 0) {
                    startIt = false;
                }
            }
        }

      ...ignore some code...

        // Place a new activity at top of stack, so it is next to interact
        // with the user.
        task = r.task;
        task.addActivityToTop(r);
        task.setFrontOfTask();

        ...ignore some code...

         if (doResume) {
            mStackSupervisor.resumeTopActivitiesLocked(this, r, options);
        }
    }
</code></pre><p>折腾不休！从 ActivityStackSupervisor 到 ActivityStack， 又调回 ActivityStackSupervisor </p>
<p>淡定，淡定， 好奇！转了一圈又回来了，世界如此美妙，你却如此暴躁，这样不好，不好。。。</p>
<p>一起看下StackSupervisor.resumeTopActivitiesLocked(this, r, options)：<br>    boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target,<br>                Bundle targetOptions) {<br>            if (targetStack == null) {<br>                targetStack = getFocusedStack();<br>            }<br>            // Do targetStack first.<br>            boolean result = false;<br>            if (isFrontStack(targetStack)) {<br>                result = targetStack.resumeTopActivityLocked(target, targetOptions);<br>            }</p>
<pre><code>      ...ignore some code...

    return result;
}
</code></pre><p>又回到 ActivityStack了。。。</p>
<p>ActivityStack.resumeTopActivityLocked()<br>    final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) {<br>            if (inResumeTopActivity) {<br>                // Don’t even start recursing.<br>                return false;<br>            }</p>
<pre><code>    boolean result = false;
    try {
        // Protect against recursion.
        inResumeTopActivity = true;
        result = resumeTopActivityInnerLocked(prev, options);
    } finally {
        inResumeTopActivity = false;
    }
    return result;
}
</code></pre><p>坚持住，看下 ActivityStack.resumeTopActivityInnerLocked() 到底执行了什么？</p>
<pre><code>final boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) {

          ...ignore some code...
      //找出还没结束的首个ActivityRecord
     ActivityRecord next = topRunningActivityLocked(null);

    //如果一个没结束的Activity都没有，就开启Launcher程序
    if (next == null) {
            ActivityOptions.abort(options);
            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: No more activities go home&quot;);
            if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
            // Only resume home if on home display
            final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ?
                    HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo();
            return isOnHomeDisplay() &amp;&amp;
                    mStackSupervisor.resumeHomeStackTask(returnTaskType, prev);
        }

        //先需要暂停当前的Activity。因为我们是在Lancher中启动mainActivity，所以当前mResumedActivity！=null，调用startPausingLocked()使得Launcher进入Pausing状态
          if (mResumedActivity != null) {
            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);
            if (DEBUG_STATES) Slog.d(TAG, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity);
        }

  }
</code></pre><p>在Launcher 进程中消息传递， 调用 ActivityThread.handlePauseActivity()， 最终调用  ActivityThread.performPauseActivity() 暂停 指定 Activity，接着通过签名所说的 Binder 通信，通知AMS 已经完成暂停的操作。<br>    ActivityManagerNative.getDefault().activityPaused(token).</p>
<p>上面的调用关系复杂，源码的判断条件很多，没记住没关系，但是要记住流程，理解了 Android 控制 Activity 的生命周期 是如何操作的，以及通过那几个关键的类进行就可以了。后续遇到问题 明白从什么地方处理就可以了。</p>
<p>最后 来一张高清五码的大图，方便记忆</p>
<p><img src="Activity%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%85%A8%E8%A7%A3%E6%9E%90.png" alt=""></p>
<h3 id="一个App的程序入口是什么？"><a href="#一个App的程序入口是什么？" class="headerlink" title="一个App的程序入口是什么？"></a>一个App的程序入口是什么？</h3><p>是ActivityThread.main()</p>
<h3 id="整个App的主线程的消息循环是在哪里创建的"><a href="#整个App的主线程的消息循环是在哪里创建的" class="headerlink" title="整个App的主线程的消息循环是在哪里创建的?"></a>整个App的主线程的消息循环是在哪里创建的?</h3><p>是在ActivityThread初始化的时候，就已经创建消息循环了，所以在主线程里面创建Hander不需要指定Looper,而如果在其他线程 使用 Handler ，则需要单独使用Looper.prepare() 和 Looper.loop()出埃及消息循环。</p>
<pre><code>public static void main(String[] args) {

          ...ignore some code...    

      Looper.prepareMainLooper();

        ActivityThread thread = new ActivityThread();
        thread.attach(false);

        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        AsyncTask.init();

        if (false) {
            Looper.myLooper().setMessageLogging(new
                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));
        }

        Looper.loop();

          ...ignore some code...    

 }
</code></pre><p>Looper.prepareMainLooper();<br>准备完成后：</p>
<p>Looper.loop()</p>
<h3 id="Application-是在什么时候创建的？onCreate-什么时候调用的？"><a href="#Application-是在什么时候创建的？onCreate-什么时候调用的？" class="headerlink" title="Application 是在什么时候创建的？onCreate()什么时候调用的？"></a>Application 是在什么时候创建的？onCreate()什么时候调用的？</h3><p>也是在ActivityThread.main()的时候，再具体点就是 thread.attach(fase)的时候。</p>
<p>不相信，一起看看去!</p>
<p>先看下ActivityThead.attach()<br>    private void attach(boolean system) {<br>            sCurrentActivityThread = this;<br>            mSystemThread = system;<br>            //普通App进这里<br>            if (!system) {</p>
<pre><code>        ...ignore some code...    

        RuntimeInit.setApplicationObject(mAppThread.asBinder());
        final IActivityManager mgr = ActivityManagerNative.getDefault();
        try {
            mgr.attachApplication(mAppThread);
        } catch (RemoteException ex) {
            // Ignore
        }
       } else {
         //这个分支在SystemServer加载的时候会进入，通过调用
         // private void createSystemContext() {
         //    ActivityThread activityThread = ActivityThread.systemMain()；
         //} 

         // public static ActivityThread systemMain() {
    //        if (!ActivityManager.isHighEndGfx()) {
    //            HardwareRenderer.disable(true);
    //        } else {
    //            HardwareRenderer.enableForegroundTrimming();
    //        }
    //        ActivityThread thread = new ActivityThread();
    //        thread.attach(true);
    //        return thread;
    //    }       
       }
}
</code></pre><p>这里需要关注的是：mag.attachApplication(mAppThread),这个就会通过Binder 调用 AMS 里面对应的方法</p>
<pre><code>@Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }
</code></pre><p>然后：</p>
<pre><code>private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {


             thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat, getCommonServicesLocked(),
                    mCoreSettingsObserver.getCoreSettingsLocked());


            }
</code></pre><p>thread 就是 IApplicationThread ，实际上就是 ApplicationThead 在服务器的代理类，ApplicationThreadProxy,然后又通过IPC 就会调用到ApplicationThread的对应方法<br>    public final void bindApplication(String processName, ApplicationInfo appInfo,<br>                    List<providerinfo> providers, ComponentName instrumentationName,<br>                    ProfilerInfo profilerInfo, Bundle instrumentationArgs,<br>                    IInstrumentationWatcher instrumentationWatcher,<br>                    IUiAutomationConnection instrumentationUiConnection, int debugMode,<br>                    boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent,<br>                    Configuration config, CompatibilityInfo compatInfo, Map<string, ibinder=""> services,<br>                    Bundle coreSettings) {</string,></providerinfo></p>
<pre><code>                 ...ignore some code...    

             AppBindData data = new AppBindData();
            data.processName = processName;
            data.appInfo = appInfo;
            data.providers = providers;
            data.instrumentationName = instrumentationName;
            data.instrumentationArgs = instrumentationArgs;
            data.instrumentationWatcher = instrumentationWatcher;
            data.instrumentationUiAutomationConnection = instrumentationUiConnection;
            data.debugMode = debugMode;
            data.enableOpenGlTrace = enableOpenGlTrace;
            data.restrictedBackupMode = isRestrictedBackupMode;
            data.persistent = persistent;
            data.config = config;
            data.compatInfo = compatInfo;
            data.initProfilerInfo = profilerInfo;
            sendMessage(H.BIND_APPLICATION, data);

           }

}
</code></pre><p>其实我们最关注的就是sendMessage(),里面有函数的编号H.BIND_APPLICATION， 然后这个Message 会被H这个Handler处理<br>    private class H extends Handler {</p>
<pre><code>     ...ignore some code... 

    public static final int BIND_APPLICATION        = 110;

   ...ignore some code... 

    public void handleMessage(Message msg) {
         switch (msg.what) {
       ...ignore some code... 
        case BIND_APPLICATION:
                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);
                   AppBindData data = (AppBindData)msg.obj;
                   handleBindApplication(data);
                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                   break;
       ...ignore some code... 
       }
}
</code></pre><p>最后通过下面的方法，完成实例化，通过mInstrumentation.callApplicationOnCreate实现了onCreate()的调用。</p>
<pre><code>private void handleBindApplication(AppBindData data) {

 try {

           ...ignore some code... 

            Application app = data.info.makeApplication(data.restrictedBackupMode, null);
            mInitialApplication = app;

           ...ignore some code... 

            try {
                mInstrumentation.onCreate(data.instrumentationArgs);
            }
            catch (Exception e) {
            }
            try {
                mInstrumentation.callApplicationOnCreate(app);
            } catch (Exception e) {            }
        } finally {
            StrictMode.setThreadPolicy(savedPolicy);
        }
 }
</code></pre><p>data.info 是一个LoadeApk 对象</p>
<p>LoadeApk.data.info.makeApplication()</p>
<pre><code>public Application makeApplication(boolean forceDefaultAppClass,
            Instrumentation instrumentation) {
        if (mApplication != null) {
            return mApplication;
        }

        Application app = null;

        String appClass = mApplicationInfo.className;
        if (forceDefaultAppClass || (appClass == null)) {
            appClass = &quot;android.app.Application&quot;;
        }

        try {
            java.lang.ClassLoader cl = getClassLoader();
            if (!mPackageName.equals(&quot;android&quot;)) {
                initializeJavaContextClassLoader();
            }
            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
            app = mActivityThread.mInstrumentation.newApplication(
                    cl, appClass, appContext);
            appContext.setOuterContext(app);
        } catch (Exception e) {        }
        mActivityThread.mAllApplications.add(app);
        mApplication = app;

    //传进来的是null，所以这里不会执行，onCreate在上一层执行
        if (instrumentation != null) {
            try {
                instrumentation.callApplicationOnCreate(app);
            } catch (Exception e) {

            }
        }
        ...ignore some code... 

       }

        return app;
    }
</code></pre><p>最后还是通过 Instrumentation.makeApplication（）实例化，这个老板娘真的很厉害！</p>
<pre><code>static public Application newApplication(Class&lt;?&gt; clazz, Context context)
            throws InstantiationException, IllegalAccessException, 
            ClassNotFoundException {
        Application app = (Application)clazz.newInstance();
        app.attach(context);
        return app;
    }
</code></pre><p>而且通过反射拿到Application 对象之后，直接调用 attach(),所以attache调用就在onCreate之前。</p>
<p>参考文章</p>
<p>下面的文章都是这方面的精品，希望你抽出实际研究下，这可能需要花费很长的时间，但是如果你想晋级成为中高级开发者，这一步是必须的。</p>
<p>Binder:</p>
<ul>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Bander设计与实现 - 设计篇</a></li>
</ul>
<p>zygote<br>•    <a href="http://blog.csdn.net/luoshengyang/article/details/6768304" target="_blank" rel="external">Android系统进程Zygote启动过程的源代码分析</a><br>•    <a href="http://blog.csdn.net/xieqibao/article/details/6581975" target="_blank" rel="external">Android 之 zygote 与进程创建</a><br>•    <a href="http://www.th7.cn/Program/Android/201404/187670.shtml" target="_blank" rel="external">Zygote浅谈</a><br>ActivityThread、Instrumentation、AMS<br>•    <a href="http://blog.csdn.net/myarrow/article/details/14224273" target="_blank" rel="external">Android Activity.startActivity流程简介</a><br>•    <a href="http://blog.csdn.net/luoshengyang/article/details/6747696#comments" target="_blank" rel="external">Android应用程序进程启动过程的源代码分析</a><br>•    <a href="http://laokaddk.blog.51cto.com/368606/1206840" target="_blank" rel="external">框架层理解Activity生命周期(APP启动过程)</a><br>•    <a href="http://blog.csdn.net/yangwen123/article/details/35987609" target="_blank" rel="external">Android应用程序窗口设计框架介绍</a><br>•    <a href="http://www.xuebuyuan.com/2172927.html" target="_blank" rel="external">ActivityManagerService分析一：AMS的启动</a><br>•    <a href="http://blog.csdn.net/yangwen123/article/details/35987609" target="_blank" rel="external">Android应用程序窗口设计框架介绍</a><br>Launcher<br>•    <a href="http://mobile.51cto.com/hot-312129.htm" target="_blank" rel="external">Android 4.0 Launcher源码分析系列(一)</a><br>•    <a href="http://www.cnblogs.com/mythou/p/3187881.html" target="_blank" rel="external">Android Launcher分析和修改9——Launcher启动APP流程</a></p>
<p>结束语：<br>到了这里，我们回来看下开头的几个问题：</p>
<ul>
<li>ActivityManagerService：简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>
<li>ActivityThread:App正在的入口。 当开启App之后，会调用main()开始运行，开启消息循环队列，这就是我们所说的UI线程或者主线程，与ActivityManagerService配合，一起完成Activity的管理工作</li>
<li>ApplicationThread:用来实现ActivityManagerService 与 ActivityThread 直接的交互，在iActivityManagerService 需要管理相关的Activity的生命周期，通过ApplicationThreadProxy的代理对象与ActivityThread通讯。</li>
<li>ApplicationThreadProxy： 是ApplicationThread 在服务器端的代理，负责和客户端的ApplicationThreadProxy通讯，AMS就是通过该代理与ActivityThread通讯的</li>
<li>Instrumentation： 每一个应用程序只有一个Instrumentation 对象，每个Activity 内都有一个该对象的引用。Instrumentation 可以理解为应用进程的管家，ActivityThread要创建或者暂停某个Activity时，都需要通过Instrumentation来进行具体操作</li>
<li>ActivityStack, Activity在AMS的栈管理对象，每个Activity在AMS对应个ActivityRecord,来记录Activity的状态已经管理其他的信息。其实就是服务器端的Activity对象映射</li>
<li>TaskRecord：AMS抽象出来一个『任务』对象的概念，是记录ActivityRecord的栈，一个『task』 包含若干个ActivityRecord。AMS用taskRecrod确保Activity启动和退出的顺序。如果清楚 Activity的4种launchMode，就不会陌生了。</li>
</ul>
<p>如果还是迷茫，就把这个篇文章多读几遍。信息量比较多，需要慢慢消化。 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[RecyclerView的基类写法]]></title>
      <url>http://gdky005.com/2015/11/17/RecyclerView%E7%9A%84%E5%9F%BA%E7%B1%BB%E5%86%99%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="RecyclerView的基类写法"><a href="#RecyclerView的基类写法" class="headerlink" title="RecyclerView的基类写法"></a>RecyclerView的基类写法</h1><h3 id="KLBaseRecyclerAdapter"><a href="#KLBaseRecyclerAdapter" class="headerlink" title="KLBaseRecyclerAdapter\"></a>KLBaseRecyclerAdapter\<t\></t\></h3><pre><code>package com.xxx.recyclerviewdemo.adapter;

import android.content.Context;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by WangQing on 15/11/16.
 */
public abstract class KLBaseRecyclerAdapter&lt;T&gt; extends RecyclerView.Adapter {

    protected Context mContext;
    protected LayoutInflater mInflater;
    protected List&lt;T&gt; datas = new ArrayList&lt;T&gt;();

    private View.OnClickListener onClickListener ;

    public KLBaseRecyclerAdapter(Context context) {
        super();
        this.mContext = context;
        this.datas = new ArrayList&lt;T&gt;();
        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public KLBaseRecyclerAdapter(Context context, List&lt;T&gt; datas) {
        super();
        this.mContext = context;
        this.datas.addAll(datas);
        this.mInflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public void setOnClickListener(View.OnClickListener onClickListener) {
        this.onClickListener = onClickListener;
    }

    /**
     * 加载数据
     *
     * @param datas
     */
    public void setData(List&lt;T&gt; datas) {
        if (null != datas) {
//            if (this.datas.size() &gt; 0) {
//                this.datas.clear();
//            }
            this.datas.addAll(datas);
            notifyDataSetChanged();
        }
    }

    public List&lt;T&gt; getData() {
        return this.datas;
    }

    public T getOneData(int potion) {
        return datas.get(potion);
    }

    /**
     * 上拉加载数据
     *
     * @param datas
     */
    public void addData(List&lt;T&gt; datas) {
        if (null != datas) {
            this.datas.addAll(datas);
            notifyDataSetChanged();
        }
    }

    /**
     * 清除数据源
     */
    public void clearData() {
        if (datas != null) {
            datas.clear();
            notifyDataSetChanged();
        }
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public int getItemCount() {
        return datas != null ? datas.size() : 0;
    }

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = mInflater.inflate(setConvertView(), parent, false);
        return setViewHolder(view);
    }

    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        onBindViewHolder((KLViewHolder)holder, position);
    }

    public abstract int setConvertView();

    public abstract RecyclerView.ViewHolder setViewHolder(View view);

    public abstract void onBindViewHolder(KLViewHolder holder, int position);

    abstract class KLViewHolder extends RecyclerView.ViewHolder {

        public KLViewHolder(View convertView) {
            super(convertView);

            initView(convertView);

            if (onClickListener != null)
                convertView.setOnClickListener(onClickListener);
        }

        abstract void initView(View convertView);
    }
}
</code></pre><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><pre><code>package com.xxx.recyclerviewdemo.adapter;

import android.content.Context;
import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.widget.TextView;

import com.zhuyongit.recyclerviewdemo.R;
import com.zhuyongit.recyclerviewdemo.bean.NewsBean;

import java.util.List;

/**
 * Created by WangQing on 15/11/17.
 */
public class TestAdapter extends KLBaseRecyclerAdapter&lt;NewsBean&gt; {

    public TestAdapter(Context context) {
        super(context);
    }

    public TestAdapter(Context context, List&lt;NewsBean&gt; datas) {
        super(context, datas);
    }

    @Override
    public int setConvertView() {
        return R.layout.grid_recycler_item_layout;
    }

    @Override
    public RecyclerView.ViewHolder setViewHolder(View view) {
        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(KLViewHolder holder, int position) {
        ViewHolder _viewHolder = (ViewHolder) holder;
        NewsBean  _newsBean = getData().get(position);
        _viewHolder.tvTitle.setText(_newsBean.getTitle());
        _viewHolder.tvContent.setText(_newsBean.getContent());
    }

    class ViewHolder extends KLViewHolder{

        private TextView tvTitle ;
        private TextView tvContent ;

        public ViewHolder(View convertView) {
            super(convertView);
        }

        @Override
        void initView(View convertView) {
            tvTitle = (TextView) convertView.findViewById(R.id.tvTitle);
            tvContent = (TextView) convertView.findViewById(R.id.tvContent);
        }
    }
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析]]></title>
      <url>http://gdky005.com/2015/11/12/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%B4%A9%E6%BA%83%E6%8F%90%E7%A4%BA-Adapter%E7%9A%84The-content-of-the-adapter-has-changed%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析"><a href="#程序运行崩溃提示-Adapter的The-content-of-the-adapter-has-changed问题分析" class="headerlink" title="程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析"></a>程序运行崩溃提示 Adapter的The content of the adapter has changed问题分析</h3><p><br></p>
<p>遇到该问题，程序会直接崩溃</p>
<p>1.具体问题：</p>
<pre><code>java.lang.IllegalStateException: The content of the adapter has changed but ListView did not receive a notification. Make sure the content of your adapter is not modified from a background thread, but only from the UI thread. Make sure your adapter calls notifyDataSetChanged() when its content changes. [in ListView(2131493253, class android.widget.ListView) with Adapter(class com.kaolafm.a.f)]
at android.widget.ListView.layoutChildren(ListView.java:1562)
at android.widget.AbsListView$CheckForTap.run(AbsListView.java:3281)
at android.os.Handler.handleCallback(Handler.java:739)
at android.os.Handler.dispatchMessage(Handler.java:95)
at android.os.Looper.loop(Looper.java:135)
at android.app.ActivityThread.main(ActivityThread.java:5254)
at java.lang.reflect.Method.invoke(Native Method)
at java.lang.reflect.Method.invoke(Method.java:372)
at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:903)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:698)
</code></pre><p>2.出现的过程：</p>
<p>程序中聊天功能，当人数太多的时候，聊天室界面会非常的卡顿。做了一次优化：来一条消息后并不会立刻更新 listview 的adapter的数据源 ,而且将数据缓存起来，从第一个消息过来后，等待一秒钟，再去更新adapter的数据源。</p>
<p>具体源码是：<br>    while (mDataList != null &amp;&amp; mDataList.size() &gt; MAX_MESSAGE_NUM) {<br>                            mDataList.remove(0);<br>                        }<br>                        MessageBean data = (MessageBean) msg.obj;<br>                        if (!ChatManager.getInstance(getActivity()).handleMessageSended(data)) {<br>                            messageBeanList.add(data);<br>                        }</p>
<pre><code>//调整 在线人数很多，发消息很频繁的bug.
isOnlinePeopleLock = true;
if (isOnlinePeopleLock) {
    mHandler.postDelayed(new Runnable() {
        @Override
        public void run() {
            mDataList.addAll(messageBeanList);
            messageBeanList.clear();
            isOnlinePeopleLock = false;
            listViewSelectEnd(mListView, isTouchListView);
        }
    }, ONE_SECOND);
}
</code></pre><p>当人数很多的时候会偶然出现：<br>    java.lang.IllegalStateException</p>
<p>3.分析问题:</p>
<p><strong>Exception解读：</strong><br><strong>        Adapter的数据内容已经改变，但是ListView却未接收到通知。要确保不在后台线程中修改Adapter的数据内容，而要在UI Thread中修改。确保Adapter的数据内容改变时一定要调用notifyDataSetChanged()方法。</strong></p>
<p><br><br>从Android源码上看看：</p>
<pre><code>// Handle the empty set by removing all views that are visible
// and calling it a day
if (mItemCount == 0) {
    resetList();
    invokeOnItemScrollListener();
    return;
} else if (mItemCount != mAdapter.getCount()) {
    throw new IllegalStateException(&quot;The content of the adapter has changed but &quot;
            + &quot;ListView did not receive a notification. Make sure the content of &quot;
            + &quot;your adapter is not modified from a background thread, but only &quot;
            + &quot;from the UI thread. [in ListView(&quot; + getId() + &quot;, &quot; + getClass()
            + &quot;) with Adapter(&quot; + mAdapter.getClass() + &quot;)]&quot;);
}
</code></pre><h4 id="当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。"><a href="#当ListView缓存的数据Count和ListView中Adapter-getCount-不等时，会抛出该异常。" class="headerlink" title="当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。"></a><strong>当ListView缓存的数据Count和ListView中Adapter.getCount()不等时，会抛出该异常。</strong></h4><p><br><br>可以分析出来的是：</p>
<p>当人数过多的时候，可能先走了 mDataList.remove(0); 还没执行 listViewSelectEnd方法 （方法里面包含了 notifyDataSetChanged()）, 并不能保证Adapter的数据更新时，立马调用notifyDataSetChanged()通知ListView，这两个线程之间的时间差引起的数据不同步，导致ListView的layoutChildren()中访问Adapter的getCount()方法时，Adapter内已经是最新数据源，而ListView内的缓存数据Count仍是旧数据的Count，该问题最终原因终于浮出水面。</p>
<p>4.解决办法：</p>
<p><strong>把addData(List)方法内更新数据的代码挪出来，和notifyDataSetChanged()方法一同放在Handler里，保证数据更新时及时通知ListView。</strong></p>
<p>5.注意事项：</p>
<p>为了尽量避免该问题，以后编程尽量从如下几个方面检查自己的代码：</p>
<ul>
<li>确保Adapter的数据更新后一定要调用notifyDataSetChanged()方法通知ListView</li>
<li>数据更新和notifyDataSetChanged()放在UI线程内，且必须同步顺序执行，不可异步</li>
<li>仔细检查确认getCount()方法返回值是否正确</li>
</ul>
<p>参考：<br><a href="http://www.cnblogs.com/monodin/p/3874147.html" target="_blank" rel="external">http://www.cnblogs.com/monodin/p/3874147.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[圆角图片处理]]></title>
      <url>http://gdky005.com/2015/10/10/%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<pre><code>//图片圆角处理
public Bitmap getRoundedBitmap(Bitmap mBitmap) {
    //创建新的位图
    Bitmap bgBitmap = Bitmap.createBitmap(mBitmap.getWidth(), mBitmap.getHeight(), Bitmap.Config.ARGB_8888);
    //把创建的位图作为画板
    Canvas mCanvas = new Canvas(bgBitmap);

    Paint mPaint = new Paint();
    Rect mRect = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());
    RectF mRectF = new RectF(mRect);
    //设置圆角半径为20
    float roundPx = 10;
    mPaint.setAntiAlias(true);
    //先绘制圆角矩形
    mCanvas.drawRoundRect(mRectF, roundPx, roundPx, mPaint);

    //设置图像的叠加模式
    mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
    //绘制图像
    mCanvas.drawBitmap(mBitmap, mRect, mRect, mPaint);

    return bgBitmap;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android在图形界面UI方面的工具]]></title>
      <url>http://gdky005.com/2015/10/09/Android%E5%9C%A8%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2UI%E6%96%B9%E9%9D%A2%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a><a href="http://www.crifan.com/android_ui_related_tools/?utm_source=tuicool" target="_blank" rel="external">来源</a></h4><p>之前折腾过一些Android的UI，比如：</p>
<h3 id="9patch方面的："><a href="#9patch方面的：" class="headerlink" title="9patch方面的："></a>9patch方面的：</h3><p><a href="http://www.crifan.com/android_make_9_patch_for_edittext/" target="_blank" rel="external">【记录】继续为Android的EditText制作9 patch图片</a></p>
<p>其中用到了，无意间发现的，用于专门制作9 patch的在线工具：</p>
<p><a href="http://android-holo-colors.com/" target="_blank" rel="external">Android Holo Colors</a></p>
<p>然后才发现，原来除此之外，别人还同时提供了更多的，关于Android的UI方面的工具：</p>
<p><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html" target="_blank" rel="external">Android Asset Studio</a></p>
<p>其中包含与UI有关的，很多方面的工具：</p>
<h3 id="图标有关的"><a href="#图标有关的" class="headerlink" title="图标有关的"></a>图标有关的</h3><ul>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-launcher.html" target="_blank" rel="external">Launcher icons</a> ：制作启动界面的图片的？</li>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-actionbar.html" target="_blank" rel="external">Action bar and tab icons</a> ：工具栏的图片</li>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-notification.html" target="_blank" rel="external">Notification icons </a>：通知栏图片</li>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-nav-drawer-indicator.html" target="_blank" rel="external">Navigation drawer indicator</a> ：导航栏图片</li>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-generic.html" target="_blank" rel="external">Generic icons</a> ：通用的图片</li>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-tab.html" target="_blank" rel="external">Tab icons (pre-Android 3.0)</a> ：旧的Tab的图片</li>
<li><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/icons-menu.html" target="_blank" rel="external">Menu icons (pre-Android 3.0) </a>：旧的菜单的图片</li>
</ul>
<h3 id="其他的生成器"><a href="#其他的生成器" class="headerlink" title="其他的生成器"></a>其他的生成器</h3><p><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/device-frames.html" target="_blank" rel="external">Device frame generator</a> (or see the <a href="http://developer.android.com/distribute/promote/device-art.html" target="_blank" rel="external">official version for Nexus devices</a> ) ：设备帧？<br><a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/nine-patches.html" target="_blank" rel="external">Simple nine-patch generator</a> ：简单的9 patch图片生成器<br>社区提供的工具</p>
<p><a href="http://jgilfelt.github.com/android-actionbarstylegenerator/" target="_blank" rel="external">Android Action Bar Style Generator</a> by Jeff Gilfelt ：我也用过这个，用于生成ActionBar相关的一系列的相关图片<br><a href="http://android-holo-colors.com/" target="_blank" rel="external">Android Holo Colors Generator</a> by Jérôme Van Der Linden ：我就是用这个来生成Holo主题相关的9 patch图片的。比如EditText的9 patch图片。<br>总之：</p>
<p>这些工具，都还是很好用的。</p>
<p>当需要的时候，好好去利用，即可极大地提高（更换主题时所需要）制图的效率了。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android录音使用 byte 类型获取分贝或声音振幅]]></title>
      <url>http://gdky005.com/2015/10/08/Android%E5%BD%95%E9%9F%B3%E4%BD%BF%E7%94%A8-byte-%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%88%86%E8%B4%9D%E6%88%96%E5%A3%B0%E9%9F%B3%E6%8C%AF%E5%B9%85/</url>
      <content type="html"><![CDATA[<p>以下是获取声音振幅的代码：</p>
<pre><code>try {
        while (isRecording) {
            read = audioRecord.read(data, 0, recBufSize);
//                L.i(context, &quot;开始获取音频TTT：&quot; + data.length);
            if (AudioRecord.ERROR_INVALID_OPERATION != read &amp;&amp; retry &lt;= 3) {
//                    L.i(context, &quot;发出的音频TTT：&quot; + data.length);
                //录音成功，重置录音失败的次数
                retry = 0;
                int up = kaoLaRecordCore.upload(data, data.length); //TODO  算长度

                long v = 0;
                long tv = 0;
                // 将 data 内容取出，进行平方和运算
                for (int i = 0; i &lt; data.length; i+=2) {
                    tv = data[i+1] * 128 + data[i];
                    tv *= tv;
                    v += tv;
                }
                // 平方和除以数据总长度，得到音量大小。
                double mean = v / (double) read;
                double volume = 10 * Math.log10(mean * 2);
                KL.d(AudioThread.class, &quot;分贝值:&quot; + volume);

                EventBus.getDefault().post((int)volume, ChatManager.TAG_VOICE_DB);

                KL.d(AudioThread.class, &quot;分贝值: {}，v = {}， read  = {}， mean = {}  &quot;, volume, v,
                        read, mean);

//                    L.i(context, &quot;上传录音状态TTT：&quot; + up);
//                    if (isTest) {
//                        try {
//                            os.write(data);
//                        } catch (Exception e) {
//                            e.printStackTrace();
//                        }
//                    }
            } else {
                L.i(AudioThread.class, &quot;TTT录音权限可能有问题，暂时不能录音: read={}, retry:{}&quot;, read, retry);
                if (retry &lt;= 3) {
                    retry++;
                } else {
                    isRecording = false;
                    EventBus.getDefault().post(context.getString(R.string.podcast_record_permission), TAG_MIC_FORBID_STATE);
                    break;
                }

            }
//                L.i(context, &quot;上次音频TTT：&quot; + data.length);

            Thread.sleep(10);

            if (isRecording())
                pauseThread();
        }

//            if (isTest) {
//                try {
//                    os.close();
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//            }

    } catch (Exception e) {
        e.printStackTrace();
        L.i(AudioThread.class, &quot;上传出现异常&quot;);

    }
</code></pre><p>效果是：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">15</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">41</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">42</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">43</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">44</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">48</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">47</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">47</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">50</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">50</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">49</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">48</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">50</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">50</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">48</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">47</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">48</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">44</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">46</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">44</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">44</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">44</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">45</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">64</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">65</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">65</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">57</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">60</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">58</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">55</span></span><br><span class="line">当前接受到的分贝值: <span class="built_in">%s</span>，v =<span class="number">55</span></span><br></pre></td></tr></table></figure>
<p>声音在0-100以内，基本声音维持在 40-60之间</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 和 IOS 应用查找bug 利器]]></title>
      <url>http://gdky005.com/2015/09/26/Android-%E5%92%8C-IOS-%E5%BA%94%E7%94%A8%E6%9F%A5%E6%89%BEbug-%E5%88%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384040fd32a20a0f93b7082eb623889c7a2011c660a4a0d9f50a45893beadd645cda8dba79b97cead62&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">来源: Trinea codeKK</a></p>
<p>查找bug 的神器： <a href="https://bugtags.com" target="_blank" rel="external">bugtags</a></p>
<p>快速反馈 App Bug 的工具 Bugtags，任何人随时随地一键提交 Bug。<br><br><br></p>
<pre><code>Bugtags是国内首款为改善移动产品质量而专门打造的测试平台产品。使用Bugtags平台可以随时随地对移动产品提出准确的改善意见，使得测试更简单，修复问题更轻松，产品用户满意度更高。
</code></pre><p><img src="http://mmbiz.qpic.cn/mmbiz/KfDGLcEiauQjMjV5yhOicj2pQm6m7nJsiarkheNAVo58icUrJzj3y1CojAocibU7jXe0xxlhck079iarhYrZ7Iqg2v7Q/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p>
<h3 id="它在移动端是的主要功能包括："><a href="#它在移动端是的主要功能包括：" class="headerlink" title="它在移动端是的主要功能包括："></a>它在移动端是的主要功能包括：</h3><ol>
<li><p>任何地方快速标记 Bug，分配给对应开发<br>跟他们官网说的一样，测试从未如此简单！</p>
</li>
<li><p>自动记录 App Crash Bug<br>App Crash 时会自动提交日志到后台，这个原理也是大家熟知的 Thread.UncaughtExceptionHandler。</p>
</li>
<li><p>无网下次重传</p>
</li>
<li><p>摇一摇作为彩蛋<br>Bugtags 启动模式有三种，除了截图中的悬浮球，还有摇一摇提交 Bug，可以作为 Release 版的彩蛋。</p>
</li>
</ol>
<h3 id="传统的-App-Bug-发现过程是这样的："><a href="#传统的-App-Bug-发现过程是这样的：" class="headerlink" title="传统的 App Bug 发现过程是这样的："></a>传统的 App Bug 发现过程是这样的：</h3><blockquote>
<p>测试的妹子们截图传到 PC，再上传到 Bug 管理系统，添加具体描述，分配给相应开发</p>
<p>产品经理跑过来“这个这个地方有问题，你改下”</p>
<p>老板拿着手机过来，直接扔给你，立即调试这个“老板级”Bug</p>
</blockquote>
<h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><ol>
<li>在 <a href="https://bugtags.com" target="_blank" rel="external">bugtags</a> 里面集成开发对应的SDK，</li>
<li>添加依赖<br> <code>compile &#39;com.bugtags.library:bugtags-lib:latest.integration&#39;</code></li>
<li>在 Application 初始化</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">　<span class="meta">@Override</span></span><br><span class="line">　public void onCreate() &#123;</span><br><span class="line">　　<span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">　　<span class="comment">// 在这里初始化</span></span><br><span class="line">　　<span class="type">Bugtags</span>.start(<span class="string">"App key"</span>, <span class="keyword">this</span>, <span class="type">Bugtags</span>.<span class="type">BTGInvocationEventBubble</span>);</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加回调"><a href="#添加回调" class="headerlink" title="添加回调"></a>添加回调</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">BaseActivity</span> <span class="selector-tag">extends</span> <span class="selector-tag">Activity</span>&#123;</span><br><span class="line">　<span class="variable">@Override</span></span><br><span class="line">　protected void onResume() &#123;</span><br><span class="line">　　super<span class="selector-class">.onResume</span>();</span><br><span class="line">　　<span class="comment">// 注：回调 1</span></span><br><span class="line">　　Bugtags<span class="selector-class">.onResume</span>(this);</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="variable">@Override</span></span><br><span class="line">　protected void onPause() &#123;</span><br><span class="line">　　super<span class="selector-class">.onPause</span>();</span><br><span class="line">　　<span class="comment">// 注：回调 2</span></span><br><span class="line">　　Bugtags<span class="selector-class">.onPause</span>(this);</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="variable">@Override</span></span><br><span class="line">　public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">　　<span class="comment">// 注：回调 3</span></span><br><span class="line">　　Bugtags<span class="selector-class">.onDispatchTouchEvent</span>(this, event);</span><br><span class="line">　　return super<span class="selector-class">.dispatchTouchEvent</span>(event);</span><br><span class="line">　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有 BaseActivity，可新建此类作为所有 Activity 的基类，统一的 BaseActivity 在开发中还是很有必要的。</p>
<p>PS：MIUI 需要手动打开悬浮窗的显示，打开方式：安全中心-&gt; 授权管理-&gt;应用权限管理，点击选择应用，勾选“显示悬浮窗”开关。</p>
<p><br></p>
<p><br></p>
<p><br></p>
<h6 id="目前他们也在计划开放-API，方便其他系统接入。"><a href="#目前他们也在计划开放-API，方便其他系统接入。" class="headerlink" title="目前他们也在计划开放 API，方便其他系统接入。"></a>目前他们也在计划开放 API，方便其他系统接入。</h6><hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[比较好的Android网站]]></title>
      <url>http://gdky005.com/2015/09/26/%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9A%84Android%E7%BD%91%E7%AB%99/</url>
      <content type="html"><![CDATA[<p>这是分享一些比较靠谱的干货，可以参考下面的链接：<br></p>
<ul>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=1&amp;sn=4102a3f1d369ba79abeb85e77e4c380d&amp;scene=1&amp;srcid=0926h7Wvn1gzNIiKmoZAutR7&amp;key=2877d24f51fa53849e88d66a9ce9a449de0155a91172f2a5651c1f2ac390e16557f401453ad7bde87faa0d3cea54edd5&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">12大Android开发资源，你有几种会用？</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=208024947&amp;idx=2&amp;sn=e6bf1c5afb0e09147484a61c68583b3e&amp;scene=1&amp;srcid=0926n9p8bsx5NQNAg274lTGy&amp;key=2877d24f51fa53849e59745839e77136216893f3c5ca91bf1643cac1ee58f0273dc7c25e2ccc7e5a106d67b1f6ae0e35&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">快速提高Android开发效率的Web工具</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207916695&amp;idx=4&amp;sn=69a69ba7986eeb9fda0054354db828a4&amp;scene=1&amp;srcid=0926JcG6UjZuN7LEu7giAoR9&amp;key=2877d24f51fa5384d6ea3cacc96f2528b69686dc8361b29874eeb4222c2e834b41848230fe4fac051415bf5da2397b5c&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">Android酷炫实用的开源框架（UI框架）</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MTM2MjE2MA==&amp;mid=207581833&amp;idx=3&amp;sn=97bfca775b657f19f990a80fa401392e&amp;scene=1&amp;srcid=09265F2U0UdTJJXCpg11k4ll&amp;key=2877d24f51fa5384dc8ed7b7573bddb2d5833b9e68fffbc5daf583cdfd9fca708ff7204b977b535b22b1aa38ed000d0b&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">Android开发六个建议（经验之谈）</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208540095&amp;idx=1&amp;sn=8a4c7e4d5d9a64839992462f27b4bb95&amp;scene=1&amp;srcid=09266oDuhW22HgxDuGmM0WYC&amp;key=2877d24f51fa538442a9029d560dd31f7b485dbafe774de9fcf0bf9b1ddf126068ca03ffe066d71f88efbf2ebed6fb1d&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">Android Studio常用插件</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208525243&amp;idx=1&amp;sn=8afc00211b37af68f1995a3e8ad45111&amp;scene=1&amp;srcid=0926NrC0khf5Fa9fJEwRfRPY&amp;key=2877d24f51fa5384e71a8cf8116e305d18e01bd016dee5916dd2026497b682ffefe46d56bb71bd0a9fd74991acc84e3e&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">Android App 性能优化实践</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208510253&amp;idx=2&amp;sn=28598cc02ad39b73ca615e886c8eb24c&amp;scene=1&amp;srcid=0926DwVYFw4g4Od2AAnu6iHa&amp;key=2877d24f51fa538406d88df4db226b76df6775aab891b2af8b585d7de15b6d2145a0e5fa22b51441da14cd57f418cb93&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">Android Support 库百分比布局</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NDAxNTY4MA==&amp;mid=208554056&amp;idx=1&amp;sn=b98bfef690e316fa5dc0fccef8dae198&amp;scene=1&amp;srcid=0926PFrnACpa0rgVOJL2BLlc&amp;key=2877d24f51fa5384648c85ac5ce9f46629ad54f9691ab6d6dd0e1f2b8ef87a9427beb751553d9f28d1c245b1cd5b2efd&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">Android 项目部署之Nexus私服搭建和应用</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=207368806&amp;idx=1&amp;sn=ab1203e49d15b5a81a30d3c199fdc80d&amp;scene=1&amp;srcid=0926RMXXJe3DfggnLTgzVz8M&amp;key=2877d24f51fa5384ca0148e1fa1a60810f32d881772f440d182f540f603f059bae8bb10be1d320ea1db238b465c4a0f2&amp;ascene=0&amp;uin=MTA5NTgyNjA0MA%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020012&amp;pass_ticket=DiIrR6XymKM2K2hxm76gAWEBFZQ9pdsonmtfjw3IgzG9PNaJi00dUtdbVQgTUwir" target="_blank" rel="external">移动应用 Bug 快速反馈利器</a> </p>
</li>
</ul>
<p>后续将整理一些比较又实用价值的文章分享给大家</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[monkey 测试命令，保存到SD，遇到崩溃继续]]></title>
      <url>http://gdky005.com/2015/09/19/android-monkey/</url>
      <content type="html"><![CDATA[<h3 id="开始测试："><a href="#开始测试：" class="headerlink" title="开始测试："></a>开始测试：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monkey -<span class="selector-tag">p</span> com<span class="selector-class">.itings</span><span class="selector-class">.myradio</span> -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> -s <span class="number">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class="number">50</span> -v -v <span class="number">600000</span>&gt;/mnt/sdcard/monkey1<span class="selector-class">.txt</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="保存monkey-和-logcat-的日志"><a href="#保存monkey-和-logcat-的日志" class="headerlink" title="保存monkey 和 logcat 的日志"></a>保存monkey 和 logcat 的日志</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monkey -<span class="selector-tag">p</span> com<span class="selector-class">.itings</span><span class="selector-class">.myradio</span> -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> -s <span class="number">500</span> --hprof --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --throttle <span class="number">50</span> -v -v -v <span class="number">15000000</span>&gt;&gt;/mnt/sdcard/monkey_kaola<span class="selector-class">.txt</span> &amp; logcat  -v <span class="selector-tag">time</span> &gt;&gt;/mnt/sdcard/logcat.txt</span><br></pre></td></tr></table></figure>
<h3 id="终止："><a href="#终止：" class="headerlink" title="终止："></a>终止：</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span></span><br><span class="line"><span class="keyword">ps</span>|<span class="keyword">grep</span> monkey</span><br><span class="line">kill id</span><br></pre></td></tr></table></figure>
<h6 id="adb-logcat-s-com-xx-xx"><a href="#adb-logcat-s-com-xx-xx" class="headerlink" title="adb logcat -s com.xx.xx"></a>adb logcat -s com.xx.xx</h6>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio]]></title>
      <url>http://gdky005.com/2015/09/19/AndroidStudio/</url>
      <content type="html"><![CDATA[<p>Android Studio 是可以在线增量更新的，但是可能连不上服务器更新，解决办法如下：</p>
<ul>
<li><p>1.修改系统hosts文件，添加如下2行</p>
<pre><code>203.208.46.146   dl-ssl.google.com
203.208.46.146   dl.google.com
</code></pre></li>
<li><p>2.修改Android Studio\bin目录下的studio.vmoptions (32位系统) 或者 studio64.vmoptions (64位系统)文件，添加如下3行</p>
<pre><code>-Djava.net.preferIPv4Stack=true  
-Didea.updates.url=http://dl.google.com/android/studio/patches/updates.xml  
-Didea.patches.url=http://dl.google.com/android/studio/patches/
</code></pre><p>  <strong>重启Android Studio应该就可以更新了，更新时应使用管理员权限打开Android Studio。
</strong></p>
</li>
<li><p>3.如果仍然无效，将url里的修改http为https，然后重启点击Check Update试试。</p>
</li>
<li><p>4.android studio首次安装运行时卡在更新处理方法</p>
<p>  01.这是在检查你的 Android SDK 。有人会在这里卡上很长时间，很大的原因就是：网络连接有问题。可以通过配置hosts 的方式来解决。如果检查需要更新，则需要你进行安装 。</p>
<p>  02.如果想跳过这一步，可以进行如下操作：在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件，在文件最后追加</p>
<pre><code>disable.android.first.run=true 
</code></pre></li>
</ul>
<p>本方法适用于在某些网络下无法直接更新的问题</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android_gradle工作原理]]></title>
      <url>http://gdky005.com/2015/09/13/Android-gradle%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>在最新的Android Studio 里面，Android 的标准工作方式是使用 gradle 构建的，目前也是非常流行的（<em>不过也存在一些 eclipse 目录方式的，不太好，能用gradle 构建最好，可以使用依赖等快速开发模式</em>）。</p>
<h3 id="gradle-构建流程："><a href="#gradle-构建流程：" class="headerlink" title="gradle 构建流程："></a>gradle 构建流程：</h3><p>下图是google官方的构建流程图</p>
<p><img src="http://i1.tietuku.com/4fa0701d09e5704a.png" alt="andoroid gradle工作原理图"></p>
<h3 id="简单可以分为以下几类："><a href="#简单可以分为以下几类：" class="headerlink" title="简单可以分为以下几类："></a>简单可以分为以下几类：</h3><ol>
<li>AndroidManifest.xml 合并</li>
<li>Resource (包含应用的 string, style, drawable, .png, .jpg, .xml)合并</li>
<li>Asserts 合并</li>
</ol>
<p><strong>以上是常用的，当然还有其他合并，不过对于一般用户都没有问题。剩下的，基本和 Android 的构建基本一致。</strong></p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[是什么使你无法完成工作？——番茄告诉你]]></title>
      <url>http://gdky005.com/2015/09/13/%E6%98%AF%E4%BB%80%E4%B9%88%E4%BD%BF%E4%BD%A0%E6%97%A0%E6%B3%95%E5%AE%8C%E6%88%90%E5%B7%A5%E4%BD%9C%EF%BC%9F%E2%80%94%E2%80%94%E7%95%AA%E8%8C%84%E5%91%8A%E8%AF%89%E4%BD%A0/</url>
      <content type="html"><![CDATA[<h1 id="是什么让你无法完成胜任的工作呢？"><a href="#是什么让你无法完成胜任的工作呢？" class="headerlink" title="是什么让你无法完成胜任的工作呢？"></a>是什么让你无法完成胜任的工作呢？</h1><ul>
<li>面对复杂，望而却步</li>
<li>无聊琐事，越拖越久</li>
<li>小事忙活一天，大事一样没办</li>
<li>最后期限，步步紧逼</li>
<li>从休息回到工作，心智调整不过来</li>
<li>一错再错，不长记性</li>
<li>没想到一件事越做越复杂</li>
<li>头脑被各种想法占据</li>
<li>时间都用来学习适应复杂的工作了</li>
<li>只顾埋头工作，忘了抬头看路</li>
<li>把预估当做承诺</li>
<li>流程管理，纸上谈兵</li>
<li>牵着不走，打着倒退</li>
<li>完美主义，碍手碍脚</li>
<li>前怕虎，后怕狼，害怕失败和评论</li>
</ul>
<p>如有以上烦恼，请看下图：</p>
<h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><pre><code>番茄工作法是简单易行的时间管理方法，是由弗朗西斯科·西里洛于1992年创立的一种相对于GTD更微观的时间管理方法。
使用番茄工作法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后在纸上画一个X短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿
</code></pre><p>如有以上烦恼，没事多看看 下图：</p>
<p><img src="http://i3.tietuku.com/ab907523c2054c41.png" alt="番茄工作法"></p>
<p>必要的时候请使用 戴明循环（PDCA）工作法。</p>
<hr>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[日志指南]]></title>
      <url>http://gdky005.com/2015/09/11/%E6%97%A5%E5%BF%97%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>参考：<a href="http://www.bitstech.net/2014/01/07/log-best-practice/" target="_blank" rel="external">最佳日志实践</a></p>
<p><br></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><br></p>
<pre><code>几乎所有的应用开发者都知道“用户体验”的重要性，要提升用户体验就离不开一个完备的监控和上报系统，这其中日志（包括Crash上报）是最基本的问题跟踪和解决手段。

日志用来记录用户操作、系统运行状态等，是一个系统的重要组成部分。然而由于日志并非系统核心功能，通常情况下并不受团队的重视。在出现问题需要通过日志来定位时，才发现日志还存在很多问题。

日志作用：
- 好的日志记录系统出现问题时能快速定位
- 可以通过对日志的观察和分析
- 提前发现系统可能的风险
- 避免线上事故的发生
</code></pre><p><br></p>
<h2 id="一、日志级别"><a href="#一、日志级别" class="headerlink" title="一、日志级别"></a>一、日志级别</h2><p><br></p>
<h6 id="通常使用的日志库（如log4j-logback-等）"><a href="#通常使用的日志库（如log4j-logback-等）" class="headerlink" title="通常使用的日志库（如log4j, logback 等）"></a>通常使用的日志库（如<strong>log4j</strong>, <strong>logback</strong> 等）</h6><p><strong>日志基本分为以下几类（从低到高）：</strong></p>
<p><strong>VERBOSE</strong> – <em>The VERBOSE Level designates finer-grained informational events than the DEBUG</em></p>
<p><strong>DEBUG</strong> – <em>The DEBUG Level designates fine-grained informational events that are most useful to debug an application.</em></p>
<p><strong>INFO</strong> – <em>The INFO level designates informational messages that highlight the progress of the application at coarse-grained level.</em></p>
<p><strong>WARN</strong> – <em>The WARN level designates potentially harmful situations.</em></p>
<p><strong>ERROR</strong> – <em>The ERROR level designates error events that might still allow the application to continue running.</em></p>
<p><strong>FATAL</strong> – <em>The FATAL level designates very severe error events that will presumably lead the application to abort.</em></p>
<ul>
<li>一个项目各个log级别的定义应该是清楚明确的，是每个开发人员所遵循的；</li>
<li>即使是TRACE或者DEBUG级别的日志，也应该有一定的规范，要保证除了开发人员自己以外，包括测试人员和运维人员都可以方便地通过日志定位问题;</li>
<li>对于日志级别的分类，有以下参考：</li>
</ul>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FATAL — 表示需要立即被处理的系统级错误。当该错误发生时，表示服务已经出现了某种程度的不可用，系统管理员需要立即介入。这属于最严重的日志级别，因此该日志级别必须慎用，如果这种级别的日志经常出现，则该日志也失去了意义。通常情况下，一个进程的生命周期中应该只记录一次FATAL级别的日志，即该进程遇到无法恢复的错误而退出时。当然，如果某个系统的子系统遇到了不可恢复的错误，那该子系统的调用方也可以记入FATAL级别日志，以便通过日志报警提醒系统管理员修复；</span><br><span class="line"></span><br><span class="line"><span class="built_in">ERROR</span> — 该级别的错误也需要马上被处理，但是紧急程度要低于FATAL级别。当<span class="built_in">ERROR</span>错误发生时，已经影响了用户的正常访问。从该意义上来说，实际上<span class="built_in">ERROR</span>错误和FATAL错误对用户的影响是相当的。FATAL相当于服务已经挂了，而<span class="built_in">ERROR</span>相当于好死不如赖活着，然而活着却无法提供正常的服务，只能不断地打印<span class="built_in">ERROR</span>日志。特别需要注意的是，<span class="built_in">ERROR</span>和FATAL都属于服务器自己的异常，是需要马上得到人工介入并处理的。而对于用户自己操作不当，如请求参数错误等等，是绝对不应该记为<span class="built_in">ERROR</span>日志的；</span><br><span class="line"></span><br><span class="line">WARN — 该日志表示系统可能出现问题，也可能没有，这种情况如网络的波动等。对于那些目前还不是错误，然而不及时处理也会变为错误的情况，也可以记为WARN日志，例如一个存储系统的磁盘使用量超过阀值，或者系统中某个用户的存储配额快用完等等。对于WARN级别的日志，虽然不需要系统管理员马上处理，也是需要即使查看并处理的。因此此种级别的日志也不应太多，能不打WARN级别的日志，就尽量不要打；</span><br><span class="line"></span><br><span class="line">INFO — 该种日志记录系统的正常运行状态，例如某个子系统的初始化，某个请求的成功执行等等。通过查看INFO级别的日志，可以很快地对系统中出现的WARN,<span class="built_in">ERROR</span>,FATAL错误进行定位。INFO日志不宜过多，通常情况下，INFO级别的日志应该不大于<span class="keyword">TRACE</span>日志的<span class="number">10</span>%；</span><br><span class="line"></span><br><span class="line"><span class="keyword">DEBUG</span> <span class="keyword">or</span> <span class="keyword">TRACE</span> — 这两种日志具体的规范应该由项目组自己定义，该级别日志的主要作用是对系统每一步的运行状态进行精确的记录。通过该种日志，可以查看某一个操作每一步的执行过程，可以准确定位是何种操作，何种参数，何种顺序导致了某种错误的发生。可以保证在不重现错误的情况下，也可以通过<span class="keyword">DEBUG</span>（或<span class="keyword">TRACE</span>）级别的日志对问题进行诊断。需要注意的是，<span class="keyword">DEBUG</span>日志也需要规范日志格式，应该保证除了记录日志的开发人员自己外，其他的如运维，测试人员等也可以通过<span class="keyword">DEBUG</span>（或<span class="keyword">TRACE</span>）日志来定位问题；</span><br></pre></td></tr></table></figure>
<p><strong>Rule 1</strong>：整个团队（包括运维人员）需要对日志级别有明确的规定，什么日志记入什么级别的日志，什么级别的错误出现要如何处理等</p>
<p><br></p>
<h2 id="二、对记录的日志要进行更新维护"><a href="#二、对记录的日志要进行更新维护" class="headerlink" title="二、对记录的日志要进行更新维护"></a>二、对记录的日志要进行更新维护</h2><p><br></p>
<p>由于DEBUG（或TRACE）级别的日志对于定位问题至关重要，因此该种日志记录是否完备且不冗余、格式是否规范等也需要花费大量精力来优化。此处有以下几个比较好的实践：</p>
<ul>
<li>定义好整个团队记录DEBUG（或TRACE）日志的规范，保证每个开发记录的日志格式统一；</li>
<li>整个团队（包括开发，运维和测试）定期对记录的日志内容进行Review；</li>
</ul>
<p><strong>Rule 2</strong>：需要定期对日志内容进行优化更新，目的就是通过日志快速准确的定位问题</p>
<p><br></p>
<h2 id="三、关于日志分类"><a href="#三、关于日志分类" class="headerlink" title="三、关于日志分类"></a>三、关于日志分类</h2><p><br></p>
<p>日志从功能来说，可分为诊断日志、统计日志、审计日志。</p>
<p>诊断日志， 典型的有：</p>
<ul>
<li>请求入口和出口</li>
<li>外部服务调用和返回</li>
<li>资源消耗操作: 打开文件等</li>
<li>容错行为： 譬如云硬盘的副本修复操作</li>
<li>程序异常： 譬如数据库无法连接</li>
<li>后台操作：清理程序</li>
<li>启动、关闭、配置加载</li>
<li>抛出异常时，不记录日志</li>
</ul>
<p>统计日志：</p>
<ul>
<li>用户访问统计</li>
<li>计费日志（如记录用户使用的网络资源或磁盘占用，格式较为严格，便于统计）</li>
</ul>
<p>审计日志：</p>
<ul>
<li><p>管理操作</p>
<p>  将不同需求的日志记入到不同的日志文件中，可以方便相关问题（管理平台操作审计，用户操作计费等）的处理。针对每一种需求，需要对日志的格式，日志记录的内容等进行特别的记录。</p>
</li>
</ul>
<p><strong>Rule 3</strong>：要明确不同日志的用途，对日志内容进行分类</p>
<p><br></p>
<h2 id="四、日志中不要记录无用信息"><a href="#四、日志中不要记录无用信息" class="headerlink" title="四、日志中不要记录无用信息"></a>四、日志中不要记录无用信息</h2><p><br></p>
<p>例如一些测试的log: log.i(“tag”, “数据加载成功”)，可以打印一些比较有实用价值的Log， 例如：<br>log.i(“tag”, “数据加载成功，数据是：{}”， “XXXX”)</p>
<p><strong>Rule 4</strong>: 绝不要打印没有用的日志，防止无用日志淹没重要信息</p>
<p><br></p>
<h2 id="五、5-日志记录信息要完整"><a href="#五、5-日志记录信息要完整" class="headerlink" title="五、5. 日志记录信息要完整"></a>五、5. 日志记录信息要完整</h2><p><br></p>
<p>问题描述：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NOS提供分块上传的接口，用户可以通过以下的调用序列，来实现一次分块上传的流程：</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> InitMultiUpload（生成一个UploadID）</span><br><span class="line"></span>-<span class="ruby"> UploadPart</span><br><span class="line"></span>-<span class="ruby"> UploadPart</span><br><span class="line"></span>-<span class="ruby">  ……</span><br><span class="line"></span>-<span class="ruby"> UploadPart</span><br><span class="line"></span>-<span class="ruby"> CompleteMultiUpload（AbortMultiUpload）</span><br><span class="line"></span></span><br><span class="line">之前在某个产品上线初期，由于其开发人员对NOS的熟悉程度不够等原因。出现过如下问题：客户端常常会收到NoSuchUpload的错误。该错误出现的原因是，用户在未调用InitMultiUpload之前，或者在调用了CompleteMultiUpload（AbortMultiUpload）之后再次调用UploadPart。</span><br><span class="line"></span><br><span class="line">然而当我们查日志，希望可以看到该UploadPart请求对哪个UploadID进行操作，该UploadID又对应哪些操作时，却发现我们的日志中没有记录UploadPart请求对应的UploadID。</span><br><span class="line"></span><br><span class="line">类似的问题还有很多，很多针对特定请求的日志缺失，导致很多问题无法定位。</span><br><span class="line"></span><br><span class="line">因此，需要进一步对日志中需要记录哪些内容进行规定，此处推荐的需要在日志中记录的内容有：</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> 在系统启动或初始化时记录重要的系统初始化参数</span><br><span class="line"></span>-<span class="ruby"> 记录系统运行过程中的所有的错误</span><br><span class="line"></span>-<span class="ruby"> 记录系统运行过程中的所有的警告</span><br><span class="line"></span>-<span class="ruby"> 在持久化数据修改时记录修改前和修改后的值</span><br><span class="line"></span>-<span class="ruby"> 记录系统各主要模块之间的请求和响应（如在NOS中的视频处理模块在接收到请求和发送应答时，或者向客户端发送回调请求时）</span><br><span class="line"></span>-<span class="ruby"> 重要的状态变化（如NOS中对系统白名单的修改等）</span><br><span class="line"></span>-<span class="ruby"> 系统中一些长期执行的任务的执行进度</span></span><br></pre></td></tr></table></figure>
<p><strong>不推荐记录日志的内容有：</strong></p>
<ul>
<li>函数入口信息 —— 除非该函数入口表示了一个重要事件的开始，或者将该信息记入DEBUG级别日志</li>
<li>文件内容或者一大段消息的内容 —— 如果实在需要记录，则可以截取其中一些重要的信息来记入日志</li>
<li>“良性”错误 —— 有时候虽然出现了错误，然而错误处理的流程可以正确解决这种情况，例如插入数据库时有重复的记录，尽管是个错误，然而错误处理流程可以对这种情况进行处理</li>
</ul>
<p><strong>Rule 5</strong>：日志信息要准确全面，能做到仅凭日志就可以定位问题</p>
<p><em>解决办法：整理所有的请求处理流程，针对每一个操作（去重，分块上传……）打印特定的日志。</em></p>
<p><br></p>
<h2 id="六、测试的日志"><a href="#六、测试的日志" class="headerlink" title="六、测试的日志"></a>六、测试的日志</h2><p><br></p>
<p>测试代码（单元测试，接口测试……）的日志同样重要。特别是，当一个测试失败时，可以通过日志很快确定是测试代码有问题，还是系统出现了故障，如果做不到这一点，那就需要优化测试的日志了。</p>
<p>测试日志应该包含以下内容：</p>
<ul>
<li>测试执行的环境</li>
<li>测试执行前的初始状态</li>
<li>测试的详细步骤</li>
<li>测试和系统的交互信息</li>
<li>测试期望的返回结果</li>
<li>测试实际的返回结果</li>
</ul>
<p><strong>Rule 6</strong>：要以同样严格的要求对待测试程序的日志</p>
<p><br></p>
<h2 id="七、从问题中完善日志"><a href="#七、从问题中完善日志" class="headerlink" title="七、从问题中完善日志"></a>七、从问题中完善日志</h2><p><br></p>
<p>在线上出现问题的时候，需要尽快发现问题并解决，而同时，需要借此机会好好思考一下当前系统的日志是否合理。需要考虑以下问题：</p>
<ul>
<li>如果定位问题花费了很长时间，那就说明系统日志还存在问题，需要进一步完善和优化</li>
<li>需要思考是否可以通过优化日志，来提前预判该问题是否可能发生（如某种资源耗尽而导致的错误，可以对资源的使用情况进行记录）</li>
</ul>
<p>通过系统出现的问题来优化日志，应该是一项长期的实践，不断地从日志发现系统的问题，不断地从系统异常发现日志的问题。</p>
<p><strong>Rule 7</strong>：日志的优化是一件持续不断需要投入精力的事，需要不断从错误中学习</p>
<p><br></p>
<h2 id="八、对日志进行监控报警，比客户先发现系统问题"><a href="#八、对日志进行监控报警，比客户先发现系统问题" class="headerlink" title="八、对日志进行监控报警，比客户先发现系统问题"></a>八、对日志进行监控报警，比客户先发现系统问题</h2><p><br></p>
<p>crash关键字报警：</p>
<p>程序崩溃的时候，会出现crash 字样，可以获取到相关日志，会严重影响用户的实用，可以动态获取崩溃日志</p>
<p>类似的关键字报警还有很多：如对空指针， 数组越界，内存溢出 等等。</p>
<p><strong>Rule 8</strong>：对日志进行监控报警，比客户先发现系统问题</p>
<p><br></p>
<h2 id="九、关于日志格式"><a href="#九、关于日志格式" class="headerlink" title="九、关于日志格式"></a>九、关于日志格式</h2><p><br></p>
<p>日志格式一定要统一，不能任由开发人员的喜好来。举例来说，对于NOS视频截图超时的ERROR日志，有以下几种方式打印：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">logger<span class="selector-class">.error</span>(“Gearman timeout exception for request ” + getRequestID() + ” <span class="attribute">value</span>: ” + value, e);</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">logger<span class="selector-class">.error</span>(“<span class="attribute">RequestID</span>: ” + getRequestID() + “, Error <span class="attribute">Message</span>: Gearman timeout <span class="attribute">exception</span>: ” + e);</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">logger<span class="selector-class">.error</span>(getErrorMessage(getRequestID(), getErrorMessage(), e));</span><br></pre></td></tr></table></figure>
<p>第一种方式打印日志即是开发人员按照自己的喜好来的，这种方法带来的问题是：</p>
<ul>
<li>系统中日志格式不统一，不利于自动化处理</li>
<li>有些日志可能只有开发人员自己才能看懂</li>
<li>代码规范性不好</li>
</ul>
<p>而第三种方式，通过一个函数来规范日志格式，所有开发人员便可以通过该接口实现统一的日志。</p>
<p><strong>Rule 9</strong>：日志格式要统一规范</p>
<p><br></p>
<h2 id="十、错误日志输出到不同文件"><a href="#十、错误日志输出到不同文件" class="headerlink" title="十、错误日志输出到不同文件"></a>十、错误日志输出到不同文件</h2><p><br></p>
<p>在性能测试中遇到的另一个问题是，当并发量很大时，可能会有一些请求处理失败（如0.5%），为了对这些错误进行分析，需要去查这些错误请求的日志。而由于这种情况下并发量很大，使得对错误日志的分析变得困难。</p>
<p>这种情况下可以将所有的错误日志同时输出到一个单独的文件之中。</p>
<p><strong>Rule 10</strong>：将错误日志输出到一个单独的文件中进行分析</p>
<p><br></p>
<h2 id="十一、关于日志文件大小"><a href="#十一、关于日志文件大小" class="headerlink" title="十一、关于日志文件大小"></a>十一、关于日志文件大小</h2><p><br></p>
<p>日志文件不宜过大，过大的日志文件对于日志监控，问题定位等都会带来不便。因此需要进行日志文件的切分，日志文件的切分可以通过log4j等日志工具来配置，日志文件应该按天来分割，还是按照小时来分割，应该根据日志量来决定，原则就是方便开发或运维人员能快速查找日志。</p>
<p>为了防止日志文件将整个磁盘空间占满，需要定期对日志文件进行删除。例如，在收到磁盘报警时，可以将两个月以前的日志文件删除。此处比较好的实践是：</p>
<ul>
<li>将所有日志文件收集起来，这样即使在记录日志的机器上删除，也可以通过收集的日志对之前的问题进行定位；</li>
<li>每天通过定时任务来删除过期日志，如每天在凌晨4点删除60天前的日志</li>
</ul>
<p><strong>Rule 11</strong>：要把日志的大小，如何切分，如何删除等作为规范建立起来</p>
<!--###参考示例

![示例图][1]


1. 封装控制系统原生Log，然后根据不同的级别分别输出到Logcat和文件中，主要有类LogcatLog和FileLog实现
2. 收集手机其他信息，在将log上报到服务器时一同上报，这些信息包括Settings信息、DropBox打印的log、应用的SharedPreference、设备分辨率信息等。所有这些被时限为XXColector类，可以根据需要（后台配置控制）进行上传。
3. 将FileLog信息、Crash信息、以及Collector收集的手机信息上报到服务器。上报的方式主要分为：通过Email发送和通过HTTP（以及后台CGI）发送，当然你也可以选择发送到Google Form等。
4. Crash异常捕获处理（即：继承实现UncaughtExceptionHandler），有LogCenter中实现。
5. 良好的可配置信息，即：系统中所有的日志收集、发送方式都是后台可配置的。-->
<hr>
]]></content>
    </entry>
    
  
  
</search>
